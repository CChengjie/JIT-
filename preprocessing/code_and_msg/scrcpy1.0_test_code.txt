    private static MediaCodec createCodec(String encoderName) throws IOException {        if (encoderName != null) {            Ln.d("Creating encoder by name: '" + encoderName + "'");            return MediaCodec.createByCodecName(encoderName);        }        MediaCodec codec = MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_VIDEO_AVC);        Ln.d("Using encoder: '" + codec.getName() + "'");        return codec;    }
    private static MediaCodec createCodec(String encoderName) throws IOException {        if (encoderName != null) {            Ln.d("Creating encoder by name: '" + encoderName + "'");            return MediaCodec.createByCodecName(encoderName);        }        MediaCodec codec = MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_VIDEO_AVC);        Ln.d("Using encoder: '" + codec.getName() + "'");        return codec;    }
    private static MediaCodec createCodec(String encoderName) throws IOException {        if (encoderName != null) {            Ln.d("Creating encoder by name: '" + encoderName + "'");            try {                return MediaCodec.createByCodecName(encoderName);            } catch (IllegalArgumentException e) {                MediaCodecInfo[] encoders = listEncoders();                throw new InvalidEncoderException(encoderName, encoders);            }        }        MediaCodec codec = MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_VIDEO_AVC);        Ln.d("Using encoder: '" + codec.getName() + "'");        return codec;    }
    private static MediaCodecInfo[] listEncoders() {        List<MediaCodecInfo> result = new ArrayList<>();        MediaCodecList list = new MediaCodecList(MediaCodecList.REGULAR_CODECS);        for (MediaCodecInfo codecInfo : list.getCodecInfos()) {            if (codecInfo.isEncoder() && Arrays.asList(codecInfo.getSupportedTypes()).contains(MediaFormat.MIMETYPE_VIDEO_AVC)) {                result.add(codecInfo);            }        }        return result.toArray(new MediaCodecInfo[result.size()]);    }
    private static void suggestFix(Throwable e) {        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {            if (e instanceof MediaCodec.CodecException) {                MediaCodec.CodecException mce = (MediaCodec.CodecException) e;                if (mce.getErrorCode() == 0xfffffc0e) {                    Ln.e("The hardware encoder is not able to encode at the given definition.");                    Ln.e("Try with a lower definition:");                    Ln.e("    scrcpy -m 1024");                }            }        }        if (e instanceof InvalidDisplayIdException) {            InvalidDisplayIdException idie = (InvalidDisplayIdException) e;            int[] displayIds = idie.getAvailableDisplayIds();            if (displayIds != null && displayIds.length > 0) {                Ln.e("Try to use one of the available display ids:");                for (int id : displayIds) {                    Ln.e("    scrcpy --display " + id);                }            }        }    }
    private static void suggestFix(Throwable e) {        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {            if (e instanceof MediaCodec.CodecException) {                MediaCodec.CodecException mce = (MediaCodec.CodecException) e;                if (mce.getErrorCode() == 0xfffffc0e) {                    Ln.e("The hardware encoder is not able to encode at the given definition.");                    Ln.e("Try with a lower definition:");                    Ln.e("    scrcpy -m 1024");                }            }        }        if (e instanceof InvalidDisplayIdException) {            InvalidDisplayIdException idie = (InvalidDisplayIdException) e;            int[] displayIds = idie.getAvailableDisplayIds();            if (displayIds != null && displayIds.length > 0) {                Ln.e("Try to use one of the available display ids:");                for (int id : displayIds) {                    Ln.e("    scrcpy --display " + id);                }            }        } else if (e instanceof InvalidEncoderException) {            InvalidEncoderException iee = (InvalidEncoderException) e;            MediaCodecInfo[] encoders = iee.getAvailableEncoders();            if (encoders != null && encoders.length > 0) {                Ln.e("Try to use one of the available encoders:");                for (MediaCodecInfo encoder : encoders) {                    Ln.e("    scrcpy --encoder-name '" + encoder.getName() + "'");                }            }        }    }
                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard                        set_device_clipboard(controller);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && cmd && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:
convert_mouse_button(const SDL_MouseButtonEvent *from, struct screen *screen,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_mouse_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen->frame_size;    to->inject_touch_event.position.point.x = from->x;    to->inject_touch_event.position.point.y = from->y;    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons =        convert_mouse_buttons(SDL_BUTTON(from->button));    return true;}
convert_mouse_motion(const SDL_MouseMotionEvent *from, struct screen *screen,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    to->inject_touch_event.action = AMOTION_EVENT_ACTION_MOVE;    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen->frame_size;    to->inject_touch_event.position.point.x = from->x;    to->inject_touch_event.position.point.y = from->y;    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons = convert_mouse_buttons(from->state);    return true;}
convert_touch(const SDL_TouchFingerEvent *from, struct screen *screen,              struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_touch_action(from->type, &to->inject_touch_event.action)) {        return false;    }    struct size frame_size = screen->frame_size;    to->inject_touch_event.pointer_id = from->fingerId;    to->inject_touch_event.position.screen_size = frame_size;    // SDL touch event coordinates are normalized in the range [0; 1]    to->inject_touch_event.position.point.x = from->x * frame_size.width;    to->inject_touch_event.position.point.y = from->y * frame_size.height;    to->inject_touch_event.pressure = from->pressure;    to->inject_touch_event.buttons = 0;    return true;}
rotate_position(struct screen *screen, int32_t x, int32_t y) {    unsigned rotation = screen->rotation;    assert(rotation < 4);    int32_t w = screen->content_size.width;    int32_t h = screen->content_size.height;    struct point result;    switch (rotation) {        case 0:            result.x = x;            result.y = y;            break;        case 1:            result.x = h - y;            result.y = x;            break;        case 2:            result.x = w - x;            result.y = h - y;            break;        case 3:            result.x = y;            result.y = w - x;            break;        default:            assert(!"Unreachable");    }    return result;}
convert_mouse_button(const SDL_MouseButtonEvent *from, struct screen *screen,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_mouse_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen->frame_size;    to->inject_touch_event.position.point =        rotate_position(screen, from->x, from->y);    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons =        convert_mouse_buttons(SDL_BUTTON(from->button));    return true;}
convert_mouse_motion(const SDL_MouseMotionEvent *from, struct screen *screen,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    to->inject_touch_event.action = AMOTION_EVENT_ACTION_MOVE;    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen->frame_size;    to->inject_touch_event.position.point =        rotate_position(screen, from->x, from->y);    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons = convert_mouse_buttons(from->state);    return true;}
convert_touch(const SDL_TouchFingerEvent *from, struct screen *screen,              struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_touch_action(from->type, &to->inject_touch_event.action)) {        return false;    }    struct size frame_size = screen->frame_size;    to->inject_touch_event.pointer_id = from->fingerId;    to->inject_touch_event.position.screen_size = frame_size;    // SDL touch event coordinates are normalized in the range [0; 1]    float x = from->x * frame_size.width;    float y = from->y * frame_size.height;    to->inject_touch_event.position.point = rotate_position(screen, x, y);    to->inject_touch_event.pressure = from->pressure;    to->inject_touch_event.buttons = 0;    return true;}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device (and paste if the device\n"        "        runs Android >= 7)\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        Switch fullscreen mode\n"        "\n"        "    Ctrl+Left\n"        "        Rotate display left\n"        "\n"        "    Ctrl+Right\n"        "        Rotate display right\n"        "\n"        "    Ctrl+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    Ctrl+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    Ctrl+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    Ctrl+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    Ctrl+r\n"        "        Rotate device screen\n"        "\n"        "    Ctrl+n\n"        "        Expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    Ctrl+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    Ctrl+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    Ctrl+Shift+v\n"        "        Copy computer clipboard to device (and paste if the device\n"        "        runs Android >= 7)\n"        "\n"        "    Ctrl+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = im->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (cmd && !shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (cmd && !shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (cmd && !shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (cmd && !shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (cmd && !shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (cmd && !shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && cmd && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    if (alt || meta) {        // no shortcuts involve Alt or Meta, and they must not be forwarded to        // the device        return;    }    struct controller *controller = im->controller;    // capture all Ctrl events    if (ctrl) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                if (control && ctrl && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && ctrl && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && ctrl && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                if (control && ctrl && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && ctrl && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && ctrl && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && ctrl && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && ctrl && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (ctrl && !shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (ctrl && !shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && ctrl && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && ctrl && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (ctrl && !shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (ctrl && !shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (ctrl && !shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (ctrl && !shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && ctrl && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && ctrl && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
screen_switch_fullscreen(struct screen *screen) {    if (!screen->fullscreen) {        // going to fullscreen, store the current windowed window size        screen->windowed_window_size = get_native_window_size(screen->window);    }    uint32_t new_mode = screen->fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;    if (SDL_SetWindowFullscreen(screen->window, new_mode)) {        LOGW("Could not switch fullscreen mode: %s", SDL_GetError());        return;    }    screen->fullscreen = !screen->fullscreen;    if (!screen->fullscreen) {        // fullscreen disabled, restore expected windowed window size        SDL_SetWindowSize(screen->window, screen->windowed_window_size.width,                          screen->windowed_window_size.height);    }    LOGD("Switched to %s mode", screen->fullscreen ? "fullscreen" : "windowed");    screen_render(screen);}
get_native_window_size(SDL_Window *window) {    int width;    int height;    SDL_GetWindowSize(window, &width, &height);    struct size size;    size.width = width;    size.height = height;    return size;}
get_window_size(const struct screen *screen) {    if (screen->fullscreen) {        return screen->windowed_window_size;    }    return get_native_window_size(screen->window);}
get_window_size(const struct screen *screen) {    if (screen->fullscreen) {        return screen->windowed_window_size;    }    return get_native_window_size(screen->window);}
get_window_size(const struct screen *screen) {    if (screen->fullscreen) {        return screen->windowed_window_size;    }    return get_native_window_size(screen->window);}
prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width            || screen->frame_size.height != new_frame_size.height) {        if (SDL_RenderSetLogicalSize(screen->renderer, new_frame_size.width,                                     new_frame_size.height)) {            LOGE("Could not set renderer logical size: %s", SDL_GetError());            return false;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        struct size current_size = get_window_size(screen);        struct size target_size = {            (uint32_t) current_size.width * new_frame_size.width                    / screen->frame_size.width,            (uint32_t) current_size.height * new_frame_size.height                    / screen->frame_size.height,        };        target_size = get_optimal_size(target_size, new_frame_size);        set_window_size(screen, target_size);        screen->frame_size = new_frame_size;        LOGI("New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = create_texture(screen->renderer, new_frame_size);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return false;        }    }    return true;}
get_optimal_window_size(const struct screen *screen, struct size frame_size) {    struct size current_size = get_window_size(screen);    return get_optimal_size(current_size, frame_size);}
screen_switch_fullscreen(struct screen *screen) {    if (!screen->fullscreen) {        // going to fullscreen, store the current windowed window size        screen->windowed_window_size = get_window_size(screen->window);    }    uint32_t new_mode = screen->fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;    if (SDL_SetWindowFullscreen(screen->window, new_mode)) {        LOGW("Could not switch fullscreen mode: %s", SDL_GetError());        return;    }    screen->fullscreen = !screen->fullscreen;    if (!screen->fullscreen) {        // fullscreen disabled, restore expected windowed window size        SDL_SetWindowSize(screen->window, screen->windowed_window_size.width,                          screen->windowed_window_size.height);    }    LOGD("Switched to %s mode", screen->fullscreen ? "fullscreen" : "windowed");    screen_render(screen);}
get_window_size(SDL_Window *window) {    int width;    int height;    SDL_GetWindowSize(window, &width, &height);    struct size size;    size.width = width;    size.height = height;    return size;}
get_window_size(SDL_Window *window) {    int width;    int height;    SDL_GetWindowSize(window, &width, &height);    struct size size;    size.width = width;    size.height = height;    return size;}
get_windowed_window_size(const struct screen *screen) {    if (screen->fullscreen) {        return screen->windowed_window_size;    }    return get_window_size(screen->window);}
get_windowed_window_size(const struct screen *screen) {    if (screen->fullscreen) {        return screen->windowed_window_size;    }    return get_window_size(screen->window);}
prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width            || screen->frame_size.height != new_frame_size.height) {        if (SDL_RenderSetLogicalSize(screen->renderer, new_frame_size.width,                                     new_frame_size.height)) {            LOGE("Could not set renderer logical size: %s", SDL_GetError());            return false;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        struct size windowed_size = get_windowed_window_size(screen);        struct size target_size = {            (uint32_t) windowed_size.width * new_frame_size.width                    / screen->frame_size.width,            (uint32_t) windowed_size.height * new_frame_size.height                    / screen->frame_size.height,        };        target_size = get_optimal_size(target_size, new_frame_size);        set_window_size(screen, target_size);        screen->frame_size = new_frame_size;        LOGI("New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = create_texture(screen->renderer, new_frame_size);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return false;        }    }    return true;}
get_optimal_window_size(const struct screen *screen, struct size frame_size) {    struct size windowed_size = get_windowed_window_size(screen);    return get_optimal_size(windowed_size, frame_size);}
    private boolean injectTouch(int action, long pointerId, Position position, float pressure, int buttons) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        int pointerIndex = pointersState.getPointerIndex(pointerId);        if (pointerIndex == -1) {            Ln.w("Too many pointers for touch event");            return false;        }        Pointer pointer = pointersState.get(pointerIndex);        pointer.setPoint(point);        pointer.setPressure(pressure);        pointer.setUp(action == MotionEvent.ACTION_UP);        int pointerCount = pointersState.update(pointerProperties, pointerCoords);        if (pointerCount == 1) {            if (action == MotionEvent.ACTION_DOWN) {                lastTouchDown = now;            }        } else {            // secondary pointers must use ACTION_POINTER_* ORed with the pointerIndex            if (action == MotionEvent.ACTION_UP) {                action = MotionEvent.ACTION_POINTER_UP | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            } else if (action == MotionEvent.ACTION_DOWN) {                action = MotionEvent.ACTION_POINTER_DOWN | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            }        }        MotionEvent event = MotionEvent                .obtain(lastTouchDown, now, action, pointerCount, pointerProperties, pointerCoords, 0, buttons, 1f, 1f, DEVICE_ID_VIRTUAL, 0,                        InputDevice.SOURCE_TOUCHSCREEN, 0);        return device.injectEvent(event);    }
    private boolean injectTouch(int action, long pointerId, Position position, float pressure, int buttons) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            Ln.w("Ignore touch event, it was generated for a different device size");            return false;        }        int pointerIndex = pointersState.getPointerIndex(pointerId);        if (pointerIndex == -1) {            Ln.w("Too many pointers for touch event");            return false;        }        Pointer pointer = pointersState.get(pointerIndex);        pointer.setPoint(point);        pointer.setPressure(pressure);        pointer.setUp(action == MotionEvent.ACTION_UP);        int pointerCount = pointersState.update(pointerProperties, pointerCoords);        if (pointerCount == 1) {            if (action == MotionEvent.ACTION_DOWN) {                lastTouchDown = now;            }        } else {            // secondary pointers must use ACTION_POINTER_* ORed with the pointerIndex            if (action == MotionEvent.ACTION_UP) {                action = MotionEvent.ACTION_POINTER_UP | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            } else if (action == MotionEvent.ACTION_DOWN) {                action = MotionEvent.ACTION_POINTER_DOWN | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            }        }        MotionEvent event = MotionEvent                .obtain(lastTouchDown, now, action, pointerCount, pointerProperties, pointerCoords, 0, buttons, 1f, 1f, DEVICE_ID_VIRTUAL, 0,                        InputDevice.SOURCE_TOUCHSCREEN, 0);        return device.injectEvent(event);    }
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };#ifndef NDEBUG    args.opts.log_level = SC_LOG_LEVEL_DEBUG;#endif    if (!scrcpy_parse_args(&args, argc, argv)) {        return 1;    }    SDL_LogPriority sdl_log = convert_log_level_to_sdl(args.opts.log_level);    SDL_LogSetPriority(SDL_LOG_CATEGORY_APPLICATION, sdl_log);    if (args.help) {        scrcpy_print_usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    LOGI("scrcpy " SCRCPY_VERSION " <https://github.com/Genymobile/scrcpy>");#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }    int res = scrcpy(&args.opts) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press Enter to continue...\n");        getchar();    }#endif    return res;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };#ifndef NDEBUG    args.opts.log_level = SC_LOG_LEVEL_DEBUG;#endif    if (!scrcpy_parse_args(&args, argc, argv)) {        return 1;    }    SDL_LogPriority sdl_log = convert_log_level_to_sdl(args.opts.log_level);    SDL_LogSetPriority(SDL_LOG_CATEGORY_APPLICATION, sdl_log);    if (args.help) {        scrcpy_print_usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    LOGI("scrcpy " SCRCPY_VERSION " <https://github.com/Genymobile/scrcpy>");#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }    int res = scrcpy(&args.opts) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"codec-options",          required_argument, NULL, OPT_CODEC_OPTIONS},        {"crop",                   required_argument, NULL, OPT_CROP},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"force-adb-forward",      no_argument,       NULL,                                                  OPT_FORCE_ADB_FORWARD},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"port",                   required_argument, NULL, 'p'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"stay-awake",             no_argument,       NULL, 'w'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"verbosity",              required_argument, NULL, 'V'},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTvV:w",                            long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case 'V':                if (!parse_log_level(optarg, &opts->log_level)) {                    return false;                }                break;            case 'w':                opts->stay_awake = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            case OPT_CODEC_OPTIONS:                opts->codec_options = optarg;                break;            case OPT_FORCE_ADB_FORWARD:                opts->force_adb_forward = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    if (!opts->control && opts->stay_awake) {        LOGE("Could not request to stay awake if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device (and paste if the device\n"        "        runs Android >= 7)\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"codec-options",          required_argument, NULL, OPT_CODEC_OPTIONS},        {"crop",                   required_argument, NULL, OPT_CROP},        {"disable-screensaver",    no_argument,       NULL,                                                  OPT_DISABLE_SCREENSAVER},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"force-adb-forward",      no_argument,       NULL,                                                  OPT_FORCE_ADB_FORWARD},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"port",                   required_argument, NULL, 'p'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"stay-awake",             no_argument,       NULL, 'w'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"verbosity",              required_argument, NULL, 'V'},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTvV:w",                            long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case 'V':                if (!parse_log_level(optarg, &opts->log_level)) {                    return false;                }                break;            case 'w':                opts->stay_awake = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            case OPT_CODEC_OPTIONS:                opts->codec_options = optarg;                break;            case OPT_FORCE_ADB_FORWARD:                opts->force_adb_forward = true;                break;            case OPT_DISABLE_SCREENSAVER:                opts->disable_screensaver = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    if (!opts->control && opts->stay_awake) {        LOGE("Could not request to stay awake if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device (and paste if the device\n"        "        runs Android >= 7)\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
sdl_init_and_configure(bool display, const char *render_driver) {    uint32_t flags = display ? SDL_INIT_VIDEO : SDL_INIT_EVENTS;    if (SDL_Init(flags)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return false;    }    atexit(SDL_Quit);#ifdef _WIN32    // Clean up properly on Ctrl+C on Windows    bool ok = SetConsoleCtrlHandler(windows_ctrl_handler, TRUE);    if (!ok) {        LOGW("Could not set Ctrl+C handler");    }#endif // _WIN32    if (!display) {        return true;    }    if (render_driver && !SDL_SetHint(SDL_HINT_RENDER_DRIVER, render_driver)) {        LOGW("Could not set render driver");    }    // Linear filtering    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        LOGW("Could not enable linear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif#ifdef SCRCPY_SDL_HAS_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR    // Disable compositor bypassing on X11    if (!SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, "0")) {        LOGW("Could not disable X11 compositor bypass");    }#endif    // Do not minimize on focus loss    if (!SDL_SetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, "0")) {        LOGW("Could not disable minimize on focus loss");    }    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return true;}
sdl_init_and_configure(bool display, const char *render_driver) {    uint32_t flags = display ? SDL_INIT_VIDEO : SDL_INIT_EVENTS;    if (SDL_Init(flags)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return false;    }    atexit(SDL_Quit);#ifdef _WIN32    // Clean up properly on Ctrl+C on Windows    bool ok = SetConsoleCtrlHandler(windows_ctrl_handler, TRUE);    if (!ok) {        LOGW("Could not set Ctrl+C handler");    }#endif // _WIN32    if (!display) {        return true;    }    if (render_driver && !SDL_SetHint(SDL_HINT_RENDER_DRIVER, render_driver)) {        LOGW("Could not set render driver");    }    // Linear filtering    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        LOGW("Could not enable linear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif#ifdef SCRCPY_SDL_HAS_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR    // Disable compositor bypassing on X11    if (!SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, "0")) {        LOGW("Could not disable X11 compositor bypass");    }#endif    // Do not minimize on focus loss    if (!SDL_SetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, "0")) {        LOGW("Could not disable minimize on focus loss");    }    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return true;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .log_level = options->log_level,        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,        .show_touches = options->show_touches,        .stay_awake = options->stay_awake,        .codec_options = options->codec_options,        .force_adb_forward = options->force_adb_forward,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options-> mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    server_destroy(&server);    return ret;}
sdl_init_and_configure(bool display, const char *render_driver,                       bool disable_screensaver) {    uint32_t flags = display ? SDL_INIT_VIDEO : SDL_INIT_EVENTS;    if (SDL_Init(flags)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return false;    }    atexit(SDL_Quit);#ifdef _WIN32    // Clean up properly on Ctrl+C on Windows    bool ok = SetConsoleCtrlHandler(windows_ctrl_handler, TRUE);    if (!ok) {        LOGW("Could not set Ctrl+C handler");    }#endif // _WIN32    if (!display) {        return true;    }    if (render_driver && !SDL_SetHint(SDL_HINT_RENDER_DRIVER, render_driver)) {        LOGW("Could not set render driver");    }    // Linear filtering    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        LOGW("Could not enable linear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif#ifdef SCRCPY_SDL_HAS_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR    // Disable compositor bypassing on X11    if (!SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, "0")) {        LOGW("Could not disable X11 compositor bypass");    }#endif    // Do not minimize on focus loss    if (!SDL_SetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, "0")) {        LOGW("Could not disable minimize on focus loss");    }    if (disable_screensaver) {        LOGD("Screensaver disabled");        SDL_DisableScreenSaver();    } else {        LOGD("Screensaver enabled");
sdl_init_and_configure(bool display, const char *render_driver,                       bool disable_screensaver) {    uint32_t flags = display ? SDL_INIT_VIDEO : SDL_INIT_EVENTS;    if (SDL_Init(flags)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return false;    }    atexit(SDL_Quit);#ifdef _WIN32    // Clean up properly on Ctrl+C on Windows    bool ok = SetConsoleCtrlHandler(windows_ctrl_handler, TRUE);    if (!ok) {        LOGW("Could not set Ctrl+C handler");    }#endif // _WIN32    if (!display) {        return true;    }    if (render_driver && !SDL_SetHint(SDL_HINT_RENDER_DRIVER, render_driver)) {        LOGW("Could not set render driver");    }    // Linear filtering    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        LOGW("Could not enable linear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif#ifdef SCRCPY_SDL_HAS_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR    // Disable compositor bypassing on X11    if (!SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, "0")) {        LOGW("Could not disable X11 compositor bypass");    }#endif    // Do not minimize on focus loss    if (!SDL_SetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, "0")) {        LOGW("Could not disable minimize on focus loss");    }    if (disable_screensaver) {        LOGD("Screensaver disabled");        SDL_DisableScreenSaver();    } else {        LOGD("Screensaver enabled");        SDL_EnableScreenSaver();    }    return true;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .log_level = options->log_level,        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,        .show_touches = options->show_touches,        .stay_awake = options->stay_awake,        .codec_options = options->codec_options,        .force_adb_forward = options->force_adb_forward,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver,                                options->disable_screensaver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options-> mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    server_destroy(&server);    return ret;}
int main(void) {    test_deserialize_clipboard();    return 0;}
int main(void) {    test_deserialize_clipboard();    test_deserialize_clipboard_big();    return 0;}
    private static MediaCodec createCodec() throws IOException {        return MediaCodec.createEncoderByType("video/avc");    }
    private static MediaFormat createFormat(int bitRate, int maxFps, int iFrameInterval) {        MediaFormat format = new MediaFormat();        format.setString(MediaFormat.KEY_MIME, "video/avc");        format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);        // must be present to configure the encoder, but does not impact the actual frame rate, which is variable        format.setInteger(MediaFormat.KEY_FRAME_RATE, 60);        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iFrameInterval);        // display the very first frame, and recover from bad quality when no new frames        format.setLong(MediaFormat.KEY_REPEAT_PREVIOUS_FRAME_AFTER, REPEAT_FRAME_DELAY_US); // µs        if (maxFps > 0) {            // The key existed privately before Android 10:            // <https://android.googlesource.com/platform/frameworks/base/+/625f0aad9f7a259b6881006ad8710adce57d1384%5E%21/>            // <https://github.com/Genymobile/scrcpy/issues/488#issuecomment-567321437>            format.setFloat(KEY_MAX_FPS_TO_ENCODER, maxFps);        }        return format;    }
    private static MediaCodec createCodec() throws IOException {        return MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_VIDEO_AVC);    }
    private static MediaFormat createFormat(int bitRate, int maxFps, int iFrameInterval) {        MediaFormat format = new MediaFormat();        format.setString(MediaFormat.KEY_MIME, MediaFormat.MIMETYPE_VIDEO_AVC);        format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);        // must be present to configure the encoder, but does not impact the actual frame rate, which is variable        format.setInteger(MediaFormat.KEY_FRAME_RATE, 60);        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iFrameInterval);        // display the very first frame, and recover from bad quality when no new frames        format.setLong(MediaFormat.KEY_REPEAT_PREVIOUS_FRAME_AFTER, REPEAT_FRAME_DELAY_US); // µs        if (maxFps > 0) {            // The key existed privately before Android 10:            // <https://android.googlesource.com/platform/frameworks/base/+/625f0aad9f7a259b6881006ad8710adce57d1384%5E%21/>            // <https://github.com/Genymobile/scrcpy/issues/488#issuecomment-567321437>            format.setFloat(KEY_MAX_FPS_TO_ENCODER, maxFps);        }        return format;    }
    public Device(Options options) {        displayId = options.getDisplayId();        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo(displayId);        if (displayInfo == null) {            int[] displayIds = serviceManager.getDisplayManager().getDisplayIds();            throw new InvalidDisplayIdException(displayId, displayIds);        }        int displayInfoFlags = displayInfo.getFlags();        screenInfo = ScreenInfo.computeScreenInfo(displayInfo, options.getCrop(), options.getMaxSize(), options.getLockedVideoOrientation());        layerStack = displayInfo.getLayerStack();        serviceManager.getWindowManager().registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) {                synchronized (Device.this) {                    screenInfo = screenInfo.withDeviceRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        }, displayId);        if (options.getControl()) {            // If control is enabled, synchronize Android clipboard to the computer automatically            serviceManager.getClipboardManager().addPrimaryClipChangedListener(new IOnPrimaryClipChangedListener.Stub() {                @Override                public void dispatchPrimaryClipChanged() {                    if (isSettingClipboard.get()) {                        // This is a notification for the change we are currently applying, ignore it                        return;                    }                    synchronized (Device.this) {                        if (clipboardListener != null) {                            String text = getClipboardText();                            if (text != null) {                                clipboardListener.onClipboardTextChanged(text);                            }                        }                    }                }            });        }        if ((displayInfoFlags & DisplayInfo.FLAG_SUPPORTS_PROTECTED_BUFFERS) == 0) {            Ln.w("Display doesn't have FLAG_SUPPORTS_PROTECTED_BUFFERS flag, mirroring can be restricted");        }        // main display or any display on Android >= Q        supportsInputEvents = displayId == 0 || Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q;        if (!supportsInputEvents) {            Ln.w("Input events are not supported for secondary displays before Android 10");        }    }
    public String getClipboardText() {        CharSequence s = serviceManager.getClipboardManager().getText();        if (s == null) {            return null;        }        return s.toString();    }
    public boolean setClipboardText(String text) {        isSettingClipboard.set(true);        boolean ok = serviceManager.getClipboardManager().setText(text);        isSettingClipboard.set(false);        return ok;    }
    public Device(Options options) {        displayId = options.getDisplayId();        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo(displayId);        if (displayInfo == null) {            int[] displayIds = serviceManager.getDisplayManager().getDisplayIds();            throw new InvalidDisplayIdException(displayId, displayIds);        }        int displayInfoFlags = displayInfo.getFlags();        screenInfo = ScreenInfo.computeScreenInfo(displayInfo, options.getCrop(), options.getMaxSize(), options.getLockedVideoOrientation());        layerStack = displayInfo.getLayerStack();        serviceManager.getWindowManager().registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) {                synchronized (Device.this) {                    screenInfo = screenInfo.withDeviceRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        }, displayId);        if (options.getControl()) {            // If control is enabled, synchronize Android clipboard to the computer automatically            ClipboardManager clipboardManager = serviceManager.getClipboardManager();            if (clipboardManager != null) {                clipboardManager.addPrimaryClipChangedListener(new IOnPrimaryClipChangedListener.Stub() {                    @Override                    public void dispatchPrimaryClipChanged() {                        if (isSettingClipboard.get()) {                            // This is a notification for the change we are currently applying, ignore it                            return;                        }                        synchronized (Device.this) {                            if (clipboardListener != null) {                                String text = getClipboardText();                                if (text != null) {                                    clipboardListener.onClipboardTextChanged(text);                                }                            }                        }                    }                });            } else {                Ln.w("No clipboard manager, copy-paste between device and computer will not work");            }        }        if ((displayInfoFlags & DisplayInfo.FLAG_SUPPORTS_PROTECTED_BUFFERS) == 0) {            Ln.w("Display doesn't have FLAG_SUPPORTS_PROTECTED_BUFFERS flag, mirroring can be restricted");        }        // main display or any display on Android >= Q        supportsInputEvents = displayId == 0 || Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q;        if (!supportsInputEvents) {            Ln.w("Input events are not supported for secondary displays before Android 10");        }    }
    public String getClipboardText() {        ClipboardManager clipboardManager = serviceManager.getClipboardManager();        if (clipboardManager == null) {            return null;        }        CharSequence s = clipboardManager.getText();        if (s == null) {            return null;        }        return s.toString();    }
    public boolean setClipboardText(String text) {        ClipboardManager clipboardManager = serviceManager.getClipboardManager();        if (clipboardManager == null) {            return false;        }        isSettingClipboard.set(true);        boolean ok = clipboardManager.setText(text);        isSettingClipboard.set(false);        return ok;    }
    public ClipboardManager getClipboardManager() {        if (clipboardManager == null) {            clipboardManager = new ClipboardManager(getService("clipboard", "android.content.IClipboard"));        }        return clipboardManager;    }
    public ClipboardManager getClipboardManager() {        if (clipboardManager == null) {            IInterface clipboard = getService("clipboard", "android.content.IClipboard");            if (clipboard == null) {                // Some devices have no clipboard manager                // <https://github.com/Genymobile/scrcpy/issues/1440>                // <https://github.com/Genymobile/scrcpy/issues/1556>                return null;            }            clipboardManager = new ClipboardManager(clipboard);        }        return clipboardManager;    }
get_server_path(void) {    const char *server_path_env = getenv("SCRCPY_SERVER_PATH");    if (server_path_env) {        // if the envvar is set, use it        char *server_path = SDL_strdup(server_path_env);        if (!server_path) {            LOGE("Could not allocate memory");            return NULL;        }        LOGD("Using SCRCPY_SERVER_PATH: %s", server_path);        return server_path;    }#ifndef PORTABLE    LOGD("Using server: " DEFAULT_SERVER_PATH);    char *server_path = SDL_strdup(DEFAULT_SERVER_PATH);    if (!server_path) {        LOGE("Could not allocate memory");        return NULL;    }    // the absolute path is hardcoded    return server_path;#else    // use scrcpy-server in the same directory as the executable    char *executable_path = get_executable_path();    if (!executable_path) {        LOGE("Could not get executable path, "             "using " SERVER_FILENAME " from current directory");        // not found, use current directory        return SERVER_FILENAME;    }    char *dir = dirname(executable_path);    size_t dirlen = strlen(dir);    // sizeof(SERVER_FILENAME) gives statically the size including the null byte    size_t len = dirlen + 1 + sizeof(SERVER_FILENAME);    char *server_path = SDL_malloc(len);    if (!server_path) {        LOGE("Could not alloc server path string, "             "using " SERVER_FILENAME " from current directory");        SDL_free(executable_path);        return SERVER_FILENAME;    }    memcpy(server_path, dir, dirlen);    server_path[dirlen] = PATH_SEPARATOR;    memcpy(&server_path[dirlen + 1], SERVER_FILENAME, sizeof(SERVER_FILENAME));    // the final null byte has been copied with SERVER_FILENAME    SDL_free(executable_path);    LOGD("Using server (portable): %s", server_path);    return server_path;#endif}
get_server_path(void) {#ifdef __WINDOWS__    const wchar_t *server_path_env = _wgetenv(L"SCRCPY_SERVER_PATH");#else    const char *server_path_env = getenv("SCRCPY_SERVER_PATH");#endif    if (server_path_env) {        // if the envvar is set, use it#ifdef __WINDOWS__        char *server_path = utf8_from_wide_char(server_path_env);#else        char *server_path = SDL_strdup(server_path_env);#endif        if (!server_path) {            LOGE("Could not allocate memory");            return NULL;        }        LOGD("Using SCRCPY_SERVER_PATH: %s", server_path);        return server_path;    }#ifndef PORTABLE    LOGD("Using server: " DEFAULT_SERVER_PATH);    char *server_path = SDL_strdup(DEFAULT_SERVER_PATH);    if (!server_path) {        LOGE("Could not allocate memory");        return NULL;    }    // the absolute path is hardcoded    return server_path;#else    // use scrcpy-server in the same directory as the executable    char *executable_path = get_executable_path();    if (!executable_path) {        LOGE("Could not get executable path, "             "using " SERVER_FILENAME " from current directory");        // not found, use current directory        return SERVER_FILENAME;    }    char *dir = dirname(executable_path);    size_t dirlen = strlen(dir);    // sizeof(SERVER_FILENAME) gives statically the size including the null byte    size_t len = dirlen + 1 + sizeof(SERVER_FILENAME);    char *server_path = SDL_malloc(len);    if (!server_path) {        LOGE("Could not alloc server path string, "             "using " SERVER_FILENAME " from current directory");        SDL_free(executable_path);        return SERVER_FILENAME;    }    memcpy(server_path, dir, dirlen);    server_path[dirlen] = PATH_SEPARATOR;    memcpy(&server_path[dirlen + 1], SERVER_FILENAME, sizeof(SERVER_FILENAME));    // the final null byte has been copied with SERVER_FILENAME    SDL_free(executable_path);    LOGD("Using server (portable): %s", server_path);    return server_path;#endif}
process_msg(struct controller *controller,              const struct control_msg *msg) {    unsigned char serialized_msg[CONTROL_MSG_MAX_SIZE];    int length = control_msg_serialize(msg, serialized_msg);    if (!length) {        return false;    }    int w = net_send_all(controller->control_socket, serialized_msg, length);    return w == length;}
process_msg(struct controller *controller,              const struct control_msg *msg) {    static unsigned char serialized_msg[CONTROL_MSG_MAX_SIZE];    int length = control_msg_serialize(msg, serialized_msg);    if (!length) {        return false;    }    int w = net_send_all(controller->control_socket, serialized_msg, length);    return w == length;}
run_receiver(void *data) {    struct receiver *receiver = data;    unsigned char buf[DEVICE_MSG_MAX_SIZE];    size_t head = 0;    for (;;) {        assert(head < DEVICE_MSG_MAX_SIZE);        ssize_t r = net_recv(receiver->control_socket, buf + head,                             DEVICE_MSG_MAX_SIZE - head);        if (r <= 0) {            LOGD("Receiver stopped");            break;        }        head += r;        ssize_t consumed = process_msgs(buf, head);        if (consumed == -1) {            // an error occurred            break;        }        if (consumed) {            head -= consumed;            // shift the remaining data in the buffer            memmove(buf, &buf[consumed], head);        }    }    return 0;}
run_receiver(void *data) {    struct receiver *receiver = data;    static unsigned char buf[DEVICE_MSG_MAX_SIZE];    size_t head = 0;    for (;;) {        assert(head < DEVICE_MSG_MAX_SIZE);        ssize_t r = net_recv(receiver->control_socket, buf + head,                             DEVICE_MSG_MAX_SIZE - head);        if (r <= 0) {            LOGD("Receiver stopped");            break;        }        head += r;        ssize_t consumed = process_msgs(buf, head);        if (consumed == -1) {            // an error occurred            break;        }        if (consumed) {            head -= consumed;            // shift the remaining data in the buffer            memmove(buf, &buf[consumed], head);        }    }    return 0;}
fps_counter_add_skipped_frame(struct fps_counter *counter) {    if (!SDL_AtomicGet(&counter->started)) {        return;    }    mutex_lock(counter->mutex);    uint32_t now = SDL_GetTicks();    check_interval_expired(counter, now);    ++counter->nr_skipped;    mutex_unlock(counter->mutex);}
fps_counter_init(struct fps_counter *counter) {    counter->mutex = SDL_CreateMutex();    if (!counter->mutex) {        return false;    }    counter->state_cond = SDL_CreateCond();    if (!counter->state_cond) {        SDL_DestroyMutex(counter->mutex);        return false;    }    counter->thread = NULL;    SDL_AtomicSet(&counter->started, 0);    // no need to initialize the other fields, they are unused until started    return true;}
fps_counter_stop(struct fps_counter *counter) {    SDL_AtomicSet(&counter->started, 0);    cond_signal(counter->state_cond);}
fps_counter_stop(struct fps_counter *counter) {    SDL_AtomicSet(&counter->started, 0);    cond_signal(counter->state_cond);}
fps_counter_add_rendered_frame(struct fps_counter *counter) {    if (!SDL_AtomicGet(&counter->started)) {        return;    }    mutex_lock(counter->mutex);    uint32_t now = SDL_GetTicks();    check_interval_expired(counter, now);    ++counter->nr_rendered;    mutex_unlock(counter->mutex);}
fps_counter_is_started(struct fps_counter *counter) {    return SDL_AtomicGet(&counter->started);}
fps_counter_start(struct fps_counter *counter) {    mutex_lock(counter->mutex);    counter->next_timestamp = SDL_GetTicks() + FPS_COUNTER_INTERVAL_MS;    counter->nr_rendered = 0;    counter->nr_skipped = 0;    mutex_unlock(counter->mutex);    SDL_AtomicSet(&counter->started, 1);    cond_signal(counter->state_cond);    // counter->thread is always accessed from the same thread, no need to lock    if (!counter->thread) {        counter->thread =            SDL_CreateThread(run_fps_counter, "fps counter", counter);        if (!counter->thread) {            LOGE("Could not start FPS counter thread");            return false;        }    }    return true;}
fps_counter_start(struct fps_counter *counter) {    mutex_lock(counter->mutex);    counter->next_timestamp = SDL_GetTicks() + FPS_COUNTER_INTERVAL_MS;    counter->nr_rendered = 0;    counter->nr_skipped = 0;    mutex_unlock(counter->mutex);    SDL_AtomicSet(&counter->started, 1);    cond_signal(counter->state_cond);    // counter->thread is always accessed from the same thread, no need to lock    if (!counter->thread) {        counter->thread =            SDL_CreateThread(run_fps_counter, "fps counter", counter);        if (!counter->thread) {            LOGE("Could not start FPS counter thread");            return false;        }    }    return true;}
run_fps_counter(void *data) {    struct fps_counter *counter = data;    mutex_lock(counter->mutex);    while (!counter->interrupted) {        while (!counter->interrupted && !SDL_AtomicGet(&counter->started)) {            cond_wait(counter->state_cond, counter->mutex);        }        while (!counter->interrupted && SDL_AtomicGet(&counter->started)) {            uint32_t now = SDL_GetTicks();            check_interval_expired(counter, now);            assert(counter->next_timestamp > now);            uint32_t remaining = counter->next_timestamp - now;            // ignore the reason (timeout or signaled), we just loop anyway            cond_wait_timeout(counter->state_cond, counter->mutex, remaining);        }    }    mutex_unlock(counter->mutex);    return 0;}
fps_counter_add_skipped_frame(struct fps_counter *counter) {    if (!is_started(counter)) {        return;    }    mutex_lock(counter->mutex);    uint32_t now = SDL_GetTicks();    check_interval_expired(counter, now);    ++counter->nr_skipped;    mutex_unlock(counter->mutex);}
fps_counter_init(struct fps_counter *counter) {    counter->mutex = SDL_CreateMutex();    if (!counter->mutex) {        return false;    }    counter->state_cond = SDL_CreateCond();    if (!counter->state_cond) {        SDL_DestroyMutex(counter->mutex);        return false;    }    counter->thread = NULL;    atomic_init(&counter->started, 0);    // no need to initialize the other fields, they are unused until started    return true;}
fps_counter_stop(struct fps_counter *counter) {    set_started(counter, false);    cond_signal(counter->state_cond);}
set_started(struct fps_counter *counter, bool started) {    atomic_store_explicit(&counter->started, started, memory_order_release);}
fps_counter_add_rendered_frame(struct fps_counter *counter) {    if (!is_started(counter)) {        return;    }    mutex_lock(counter->mutex);    uint32_t now = SDL_GetTicks();    check_interval_expired(counter, now);    ++counter->nr_rendered;    mutex_unlock(counter->mutex);}
fps_counter_is_started(struct fps_counter *counter) {    return is_started(counter);}
fps_counter_start(struct fps_counter *counter) {    mutex_lock(counter->mutex);    counter->next_timestamp = SDL_GetTicks() + FPS_COUNTER_INTERVAL_MS;    counter->nr_rendered = 0;    counter->nr_skipped = 0;    mutex_unlock(counter->mutex);    set_started(counter, true);    cond_signal(counter->state_cond);    // counter->thread is always accessed from the same thread, no need to lock    if (!counter->thread) {        counter->thread =            SDL_CreateThread(run_fps_counter, "fps counter", counter);        if (!counter->thread) {            LOGE("Could not start FPS counter thread");            return false;        }    }    return true;}
is_started(struct fps_counter *counter) {    return atomic_load_explicit(&counter->started, memory_order_acquire);}
run_fps_counter(void *data) {    struct fps_counter *counter = data;    mutex_lock(counter->mutex);    while (!counter->interrupted) {        while (!counter->interrupted && !is_started(counter)) {            cond_wait(counter->state_cond, counter->mutex);        }        while (!counter->interrupted && is_started(counter)) {            uint32_t now = SDL_GetTicks();            check_interval_expired(counter, now);            assert(counter->next_timestamp > now);            uint32_t remaining = counter->next_timestamp - now;            // ignore the reason (timeout or signaled), we just loop anyway            cond_wait_timeout(counter->state_cond, counter->mutex, remaining);        }    }    mutex_unlock(counter->mutex);    return 0;}
run_wait_server(void *data) {    struct server *server = data;    cmd_simple_wait(server->process, NULL); // ignore exit code    // no need for synchronization, server_socket is initialized before this    // thread was created    if (server->server_socket != INVALID_SOCKET            && SDL_AtomicCAS(&server->server_socket_closed, 0, 1)) {        // On Linux, accept() is unblocked by shutdown(), but on Windows, it is        // unblocked by closesocket(). Therefore, call both (close_socket()).        close_socket(server->server_socket);    }    LOGD("Server terminated");    return 0;}
server_start(struct server *server, const char *serial,             const struct server_params *params) {    server->port_range = params->port_range;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        goto error1;    }    if (!enable_tunnel_any_port(server, params->port_range)) {        goto error1;    }    // server will connect to our server socket    server->process = execute_server(server, params);    if (server->process == PROCESS_NONE) {        goto error2;    }    // If the server process dies before connecting to the server socket, then    // the client will be stuck forever on accept(). To avoid the problem, we    // must be able to wake up the accept() call when the server dies. To keep    // things simple and multiplatform, just spawn a new thread waiting for the    // server process and calling shutdown()/close() on the server socket if    // necessary to wake up any accept() blocking call.    server->wait_server_thread =        SDL_CreateThread(run_wait_server, "wait-server", server);    if (!server->wait_server_thread) {        cmd_terminate(server->process);        cmd_simple_wait(server->process, NULL); // ignore exit code        goto error2;    }    server->tunnel_enabled = true;    return true;error2:    if (!server->tunnel_forward) {        // the wait server thread is not started, SDL_AtomicSet() is sufficient        SDL_AtomicSet(&server->server_socket_closed, 1);        close_socket(server->server_socket);    }    disable_tunnel(server);error1:    SDL_free(server->serial);    return false;}
server_connect_to(struct server *server) {    if (!server->tunnel_forward) {        server->video_socket = net_accept(server->server_socket);        if (server->video_socket == INVALID_SOCKET) {            return false;        }        server->control_socket = net_accept(server->server_socket);        if (server->control_socket == INVALID_SOCKET) {            // the video_socket will be cleaned up on destroy            return false;        }        // we don't need the server socket anymore        if (SDL_AtomicCAS(&server->server_socket_closed, 0, 1)) {            // close it from here            close_socket(server->server_socket);            // otherwise, it is closed by run_wait_server()        }    } else {        uint32_t attempts = 100;        uint32_t delay = 100; // ms        server->video_socket =            connect_to_server(server->local_port, attempts, delay);        if (server->video_socket == INVALID_SOCKET) {            return false;        }        // we know that the device is listening, we don't need several attempts        server->control_socket =            net_connect(IPV4_LOCALHOST, server->local_port);        if (server->control_socket == INVALID_SOCKET) {            return false;        }    }    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = false;    return true;}
server_stop(struct server *server) {    if (server->server_socket != INVALID_SOCKET            && SDL_AtomicCAS(&server->server_socket_closed, 0, 1)) {        close_socket(server->server_socket);    }    if (server->video_socket != INVALID_SOCKET) {        close_socket(server->video_socket);    }    if (server->control_socket != INVALID_SOCKET) {        close_socket(server->control_socket);    }    assert(server->process != PROCESS_NONE);    cmd_terminate(server->process);    if (server->tunnel_enabled) {        // ignore failure        disable_tunnel(server);    }    SDL_WaitThread(server->wait_server_thread, NULL);}
run_wait_server(void *data) {    struct server *server = data;    cmd_simple_wait(server->process, NULL); // ignore exit code    // no need for synchronization, server_socket is initialized before this    // thread was created    if (server->server_socket != INVALID_SOCKET            && !atomic_flag_test_and_set(&server->server_socket_closed)) {        // On Linux, accept() is unblocked by shutdown(), but on Windows, it is        // unblocked by closesocket(). Therefore, call both (close_socket()).        close_socket(server->server_socket);    }    LOGD("Server terminated");    return 0;}
server_start(struct server *server, const char *serial,             const struct server_params *params) {    server->port_range = params->port_range;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        goto error1;    }    if (!enable_tunnel_any_port(server, params->port_range)) {        goto error1;    }    // server will connect to our server socket    server->process = execute_server(server, params);    if (server->process == PROCESS_NONE) {        goto error2;    }    // If the server process dies before connecting to the server socket, then    // the client will be stuck forever on accept(). To avoid the problem, we    // must be able to wake up the accept() call when the server dies. To keep    // things simple and multiplatform, just spawn a new thread waiting for the    // server process and calling shutdown()/close() on the server socket if    // necessary to wake up any accept() blocking call.    server->wait_server_thread =        SDL_CreateThread(run_wait_server, "wait-server", server);    if (!server->wait_server_thread) {        cmd_terminate(server->process);        cmd_simple_wait(server->process, NULL); // ignore exit code        goto error2;    }    server->tunnel_enabled = true;    return true;error2:    if (!server->tunnel_forward) {        bool was_closed =            atomic_flag_test_and_set(&server->server_socket_closed);        // the thread is not started, the flag could not be already set        assert(!was_closed);        (void) was_closed;        close_socket(server->server_socket);    }    disable_tunnel(server);error1:    SDL_free(server->serial);    return false;}
server_connect_to(struct server *server) {    if (!server->tunnel_forward) {        server->video_socket = net_accept(server->server_socket);        if (server->video_socket == INVALID_SOCKET) {            return false;        }        server->control_socket = net_accept(server->server_socket);        if (server->control_socket == INVALID_SOCKET) {            // the video_socket will be cleaned up on destroy            return false;        }        // we don't need the server socket anymore        if (!atomic_flag_test_and_set(&server->server_socket_closed)) {            // close it from here            close_socket(server->server_socket);            // otherwise, it is closed by run_wait_server()        }    } else {        uint32_t attempts = 100;        uint32_t delay = 100; // ms        server->video_socket =            connect_to_server(server->local_port, attempts, delay);        if (server->video_socket == INVALID_SOCKET) {            return false;        }        // we know that the device is listening, we don't need several attempts        server->control_socket =            net_connect(IPV4_LOCALHOST, server->local_port);        if (server->control_socket == INVALID_SOCKET) {            return false;        }    }    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = false;    return true;}
server_stop(struct server *server) {    if (server->server_socket != INVALID_SOCKET            && !atomic_flag_test_and_set(&server->server_socket_closed)) {        close_socket(server->server_socket);    }    if (server->video_socket != INVALID_SOCKET) {        close_socket(server->video_socket);    }    if (server->control_socket != INVALID_SOCKET) {        close_socket(server->control_socket);    }    assert(server->process != PROCESS_NONE);    cmd_terminate(server->process);    if (server->tunnel_enabled) {        // ignore failure        disable_tunnel(server);    }    SDL_WaitThread(server->wait_server_thread, NULL);}
int main(void) {    test_buffer_write16be();    test_buffer_write32be();    test_buffer_write64be();    test_buffer_read16be();    test_buffer_read32be();    test_buffer_read64be();    return 0;}
int main(void) {    test_buffer_write16be();    test_buffer_write32be();    test_buffer_write64be();    test_buffer_read16be();    test_buffer_read32be();    test_buffer_read64be();    return 0;}
int main(int argc, char *argv[]) {    (void) argc;    (void) argv;    test_buffer_write16be();    test_buffer_write32be();    test_buffer_write64be();    test_buffer_read16be();    test_buffer_read32be();    test_buffer_read64be();    return 0;}
int main(int argc, char *argv[]) {    (void) argc;    (void) argv;    test_buffer_write16be();    test_buffer_write32be();    test_buffer_write64be();    test_buffer_read16be();    test_buffer_read32be();    test_buffer_read64be();
int main(void) {    test_cbuf_empty();    test_cbuf_full();    test_cbuf_push_take();    return 0;}
int main(void) {    test_cbuf_empty();    test_cbuf_full();    test_cbuf_push_take();    return 0;}
int main(int argc, char *argv[]) {    (void) argc;    (void) argv;    test_cbuf_empty();    test_cbuf_full();    test_cbuf_push_take();    return 0;}
int main(int argc, char *argv[]) {    (void) argc;    (void) argv;    test_cbuf_empty();    test_cbuf_full();    test_cbuf_push_take();
int main(void) {    test_flag_version();    test_flag_help();    test_options();    test_options2();    return 0;};
int main(void) {    test_flag_version();    test_flag_help();    test_options();    test_options2();    return 0;};
int main(int argc, char *argv[]) {    (void) argc;    (void) argv;    test_flag_version();    test_flag_help();    test_options();    test_options2();    return 0;};
int main(int argc, char *argv[]) {    (void) argc;    (void) argv;    test_flag_version();    test_flag_help();    test_options();    test_options2();
int main(void) {    test_serialize_inject_keycode();    test_serialize_inject_text();    test_serialize_inject_text_long();    test_serialize_inject_touch_event();    test_serialize_inject_scroll_event();    test_serialize_back_or_screen_on();    test_serialize_expand_notification_panel();    test_serialize_collapse_notification_panel();    test_serialize_get_clipboard();    test_serialize_set_clipboard();    test_serialize_set_screen_power_mode();    test_serialize_rotate_device();    return 0;}
int main(void) {    test_serialize_inject_keycode();    test_serialize_inject_text();    test_serialize_inject_text_long();    test_serialize_inject_touch_event();    test_serialize_inject_scroll_event();    test_serialize_back_or_screen_on();    test_serialize_expand_notification_panel();    test_serialize_collapse_notification_panel();    test_serialize_get_clipboard();    test_serialize_set_clipboard();    test_serialize_set_screen_power_mode();    test_serialize_rotate_device();    return 0;}
int main(int argc, char *argv[]) {    (void) argc;    (void) argv;    test_serialize_inject_keycode();    test_serialize_inject_text();    test_serialize_inject_text_long();    test_serialize_inject_touch_event();    test_serialize_inject_scroll_event();    test_serialize_back_or_screen_on();    test_serialize_expand_notification_panel();    test_serialize_collapse_notification_panel();    test_serialize_get_clipboard();    test_serialize_set_clipboard();    test_serialize_set_screen_power_mode();    test_serialize_rotate_device();    return 0;}
int main(int argc, char *argv[]) {    (void) argc;    (void) argv;    test_serialize_inject_keycode();    test_serialize_inject_text();    test_serialize_inject_text_long();    test_serialize_inject_touch_event();    test_serialize_inject_scroll_event();    test_serialize_back_or_screen_on();    test_serialize_expand_notification_panel();    test_serialize_collapse_notification_panel();    test_serialize_get_clipboard();    test_serialize_set_clipboard();    test_serialize_set_screen_power_mode();    test_serialize_rotate_device();
int main(void) {    test_deserialize_clipboard();    test_deserialize_clipboard_big();    return 0;}
int main(void) {    test_deserialize_clipboard();    test_deserialize_clipboard_big();    return 0;}
int main(int argc, char *argv[]) {    (void) argc;    (void) argv;    test_deserialize_clipboard();    test_deserialize_clipboard_big();    return 0;}
int main(int argc, char *argv[]) {    (void) argc;    (void) argv;    test_deserialize_clipboard();    test_deserialize_clipboard_big();
int main(void) {    test_queue();    return 0;}
int main(void) {    test_queue();    return 0;}
int main(int argc, char *argv[]) {    (void) argc;    (void) argv;    test_queue();    return 0;}
int main(int argc, char *argv[]) {    (void) argc;    (void) argv;    test_queue();
int main(void) {    test_xstrncpy_simple();    test_xstrncpy_just_fit();    test_xstrncpy_truncated();    test_xstrjoin_simple();    test_xstrjoin_just_fit();    test_xstrjoin_truncated_in_token();    test_xstrjoin_truncated_before_sep();    test_xstrjoin_truncated_after_sep();    test_strquote();    test_utf8_truncate();    test_parse_integer();    test_parse_integers();    test_parse_integer_with_suffix();    return 0;}
int main(void) {    test_xstrncpy_simple();    test_xstrncpy_just_fit();    test_xstrncpy_truncated();    test_xstrjoin_simple();    test_xstrjoin_just_fit();    test_xstrjoin_truncated_in_token();    test_xstrjoin_truncated_before_sep();    test_xstrjoin_truncated_after_sep();    test_strquote();    test_utf8_truncate();    test_parse_integer();    test_parse_integers();    test_parse_integer_with_suffix();    return 0;}
int main(int argc, char *argv[]) {    (void) argc;    (void) argv;    test_xstrncpy_simple();    test_xstrncpy_just_fit();    test_xstrncpy_truncated();    test_xstrjoin_simple();    test_xstrjoin_just_fit();    test_xstrjoin_truncated_in_token();    test_xstrjoin_truncated_before_sep();    test_xstrjoin_truncated_after_sep();    test_strquote();    test_utf8_truncate();    test_parse_integer();    test_parse_integers();    test_parse_integer_with_suffix();    return 0;}
int main(int argc, char *argv[]) {    (void) argc;    (void) argv;    test_xstrncpy_simple();    test_xstrncpy_just_fit();    test_xstrncpy_truncated();    test_xstrjoin_simple();    test_xstrjoin_just_fit();    test_xstrjoin_truncated_in_token();    test_xstrjoin_truncated_before_sep();    test_xstrjoin_truncated_after_sep();    test_strquote();    test_utf8_truncate();    test_parse_integer();    test_parse_integers();    test_parse_integer_with_suffix();
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device (and paste if the device\n"        "        runs Android >= 7)\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device (and paste if the device\n"        "        runs Android >= 7)\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
convert_keycode(SDL_Keycode from, enum android_keycode *to, uint16_t mod) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_HOME,         AKEYCODE_MOVE_HOME);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);    }    if (mod & (KMOD_LALT | KMOD_RALT | KMOD_LGUI | KMOD_RGUI)) {        return false;    }    // if ALT and META are not pressed, also handle letters and space    switch (from) {        MAP(SDLK_a,            AKEYCODE_A);        MAP(SDLK_b,            AKEYCODE_B);        MAP(SDLK_c,            AKEYCODE_C);        MAP(SDLK_d,            AKEYCODE_D);        MAP(SDLK_e,            AKEYCODE_E);        MAP(SDLK_f,            AKEYCODE_F);        MAP(SDLK_g,            AKEYCODE_G);        MAP(SDLK_h,            AKEYCODE_H);        MAP(SDLK_i,            AKEYCODE_I);        MAP(SDLK_j,            AKEYCODE_J);        MAP(SDLK_k,            AKEYCODE_K);        MAP(SDLK_l,            AKEYCODE_L);        MAP(SDLK_m,            AKEYCODE_M);        MAP(SDLK_n,            AKEYCODE_N);        MAP(SDLK_o,            AKEYCODE_O);        MAP(SDLK_p,            AKEYCODE_P);        MAP(SDLK_q,            AKEYCODE_Q);        MAP(SDLK_r,            AKEYCODE_R);        MAP(SDLK_s,            AKEYCODE_S);        MAP(SDLK_t,            AKEYCODE_T);        MAP(SDLK_u,            AKEYCODE_U);        MAP(SDLK_v,            AKEYCODE_V);        MAP(SDLK_w,            AKEYCODE_W);        MAP(SDLK_x,            AKEYCODE_X);        MAP(SDLK_y,            AKEYCODE_Y);        MAP(SDLK_z,            AKEYCODE_Z);        MAP(SDLK_SPACE,        AKEYCODE_SPACE);        FAIL;    }}
convert_keycode(SDL_Keycode from, enum android_keycode *to, uint16_t mod) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_HOME,         AKEYCODE_MOVE_HOME);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);    }    if (mod & (KMOD_LALT | KMOD_RALT | KMOD_LGUI | KMOD_RGUI)) {        return false;    }    // if ALT and META are not pressed, also handle letters and space    switch (from) {        MAP(SDLK_a,            AKEYCODE_A);        MAP(SDLK_b,            AKEYCODE_B);        MAP(SDLK_c,            AKEYCODE_C);        MAP(SDLK_d,            AKEYCODE_D);        MAP(SDLK_e,            AKEYCODE_E);        MAP(SDLK_f,            AKEYCODE_F);        MAP(SDLK_g,            AKEYCODE_G);        MAP(SDLK_h,            AKEYCODE_H);        MAP(SDLK_i,            AKEYCODE_I);        MAP(SDLK_j,            AKEYCODE_J);        MAP(SDLK_k,            AKEYCODE_K);        MAP(SDLK_l,            AKEYCODE_L);        MAP(SDLK_m,            AKEYCODE_M);        MAP(SDLK_n,            AKEYCODE_N);        MAP(SDLK_o,            AKEYCODE_O);        MAP(SDLK_p,            AKEYCODE_P);        MAP(SDLK_q,            AKEYCODE_Q);        MAP(SDLK_r,            AKEYCODE_R);        MAP(SDLK_s,            AKEYCODE_S);        MAP(SDLK_t,            AKEYCODE_T);        MAP(SDLK_u,            AKEYCODE_U);        MAP(SDLK_v,            AKEYCODE_V);        MAP(SDLK_w,            AKEYCODE_W);        MAP(SDLK_x,            AKEYCODE_X);        MAP(SDLK_y,            AKEYCODE_Y);        MAP(SDLK_z,            AKEYCODE_Z);        MAP(SDLK_SPACE,        AKEYCODE_SPACE);        FAIL;    }}
convert_keycode(SDL_Keycode from, enum android_keycode *to, uint16_t mod,                bool prefer_text) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_HOME,         AKEYCODE_MOVE_HOME);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);    }    if (prefer_text) {        // do not forward alpha and space key events        return false;    }    if (mod & (KMOD_LALT | KMOD_RALT | KMOD_LGUI | KMOD_RGUI)) {        return false;    }    // if ALT and META are not pressed, also handle letters and space    switch (from) {        MAP(SDLK_a,            AKEYCODE_A);        MAP(SDLK_b,            AKEYCODE_B);        MAP(SDLK_c,            AKEYCODE_C);        MAP(SDLK_d,            AKEYCODE_D);        MAP(SDLK_e,            AKEYCODE_E);        MAP(SDLK_f,            AKEYCODE_F);        MAP(SDLK_g,            AKEYCODE_G);        MAP(SDLK_h,            AKEYCODE_H);        MAP(SDLK_i,            AKEYCODE_I);        MAP(SDLK_j,            AKEYCODE_J);        MAP(SDLK_k,            AKEYCODE_K);        MAP(SDLK_l,            AKEYCODE_L);        MAP(SDLK_m,            AKEYCODE_M);        MAP(SDLK_n,            AKEYCODE_N);        MAP(SDLK_o,            AKEYCODE_O);        MAP(SDLK_p,            AKEYCODE_P);        MAP(SDLK_q,            AKEYCODE_Q);        MAP(SDLK_r,            AKEYCODE_R);        MAP(SDLK_s,            AKEYCODE_S);        MAP(SDLK_t,            AKEYCODE_T);        MAP(SDLK_u,            AKEYCODE_U);        MAP(SDLK_v,            AKEYCODE_V);        MAP(SDLK_w,            AKEYCODE_W);        MAP(SDLK_x,            AKEYCODE_X);        MAP(SDLK_y,            AKEYCODE_Y);        MAP(SDLK_z,            AKEYCODE_Z);        MAP(SDLK_SPACE,        AKEYCODE_SPACE);        FAIL;    }}
convert_keycode(SDL_Keycode from, enum android_keycode *to, uint16_t mod,                bool prefer_text) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_HOME,         AKEYCODE_MOVE_HOME);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);    }    if (prefer_text) {        // do not forward alpha and space key events        return false;    }    if (mod & (KMOD_LALT | KMOD_RALT | KMOD_LGUI | KMOD_RGUI)) {        return false;    }    // if ALT and META are not pressed, also handle letters and space    switch (from) {        MAP(SDLK_a,            AKEYCODE_A);        MAP(SDLK_b,            AKEYCODE_B);        MAP(SDLK_c,            AKEYCODE_C);        MAP(SDLK_d,            AKEYCODE_D);        MAP(SDLK_e,            AKEYCODE_E);        MAP(SDLK_f,            AKEYCODE_F);        MAP(SDLK_g,            AKEYCODE_G);        MAP(SDLK_h,            AKEYCODE_H);        MAP(SDLK_i,            AKEYCODE_I);        MAP(SDLK_j,            AKEYCODE_J);        MAP(SDLK_k,            AKEYCODE_K);        MAP(SDLK_l,            AKEYCODE_L);        MAP(SDLK_m,            AKEYCODE_M);        MAP(SDLK_n,            AKEYCODE_N);        MAP(SDLK_o,            AKEYCODE_O);        MAP(SDLK_p,            AKEYCODE_P);        MAP(SDLK_q,            AKEYCODE_Q);        MAP(SDLK_r,            AKEYCODE_R);        MAP(SDLK_s,            AKEYCODE_S);        MAP(SDLK_t,            AKEYCODE_T);        MAP(SDLK_u,            AKEYCODE_U);        MAP(SDLK_v,            AKEYCODE_V);        MAP(SDLK_w,            AKEYCODE_W);        MAP(SDLK_x,            AKEYCODE_X);
input_manager_process_text_input(struct input_manager *im,                                 const SDL_TextInputEvent *event) {    char c = event->text[0];    if (isalpha(c) || c == ' ') {        SDL_assert(event->text[1] == '\0');        // letters and space are handled as raw key event        return;    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    msg.inject_text.text = SDL_strdup(event->text);    if (!msg.inject_text.text) {        LOGW("Could not strdup input text");        return;    }    if (!controller_push_msg(im->controller, &msg)) {        SDL_free(msg.inject_text.text);        LOGW("Could not request 'inject text'");    }}
convert_input_key(const SDL_KeyboardEvent *from, struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_KEYCODE;    if (!convert_keycode_action(from->type, &to->inject_keycode.action)) {        return false;    }    uint16_t mod = from->keysym.mod;    if (!convert_keycode(from->keysym.sym, &to->inject_keycode.keycode, mod)) {        return false;    }    to->inject_keycode.metastate = convert_meta_state(mod);    return true;}
convert_input_key(const SDL_KeyboardEvent *from, struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_KEYCODE;    if (!convert_keycode_action(from->type, &to->inject_keycode.action)) {        return false;    }    uint16_t mod = from->keysym.mod;    if (!convert_keycode(from->keysym.sym, &to->inject_keycode.keycode, mod)) {        return false;    }    to->inject_keycode.metastate = convert_meta_state(mod);    return true;}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = im->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && !shift && down) {                    set_screen_power_mode(controller, SCREEN_POWER_MODE_OFF);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard                        set_device_clipboard(controller);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && cmd && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && cmd && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;        }        return;    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_input_key(event, &msg)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_process_text_input(struct input_manager *im,                                 const SDL_TextInputEvent *event) {    if (!im->prefer_text) {        char c = event->text[0];        if (isalpha(c) || c == ' ') {            SDL_assert(event->text[1] == '\0');            // letters and space are handled as raw key event            return;        }    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    msg.inject_text.text = SDL_strdup(event->text);    if (!msg.inject_text.text) {        LOGW("Could not strdup input text");        return;    }    if (!controller_push_msg(im->controller, &msg)) {        SDL_free(msg.inject_text.text);        LOGW("Could not request 'inject text'");    }}
}static boolconvert_input_key(const SDL_KeyboardEvent *from, struct control_msg *to,                  bool prefer_text) {    to->type = CONTROL_MSG_TYPE_INJECT_KEYCODE;    if (!convert_keycode_action(from->type, &to->inject_keycode.action)) {        return false;    }    uint16_t mod = from->keysym.mod;    if (!convert_keycode(from->keysym.sym, &to->inject_keycode.keycode, mod,                         prefer_text)) {        return false;    }
convert_input_key(const SDL_KeyboardEvent *from, struct control_msg *to,                  bool prefer_text) {    to->type = CONTROL_MSG_TYPE_INJECT_KEYCODE;    if (!convert_keycode_action(from->type, &to->inject_keycode.action)) {        return false;    }    uint16_t mod = from->keysym.mod;    if (!convert_keycode(from->keysym.sym, &to->inject_keycode.keycode, mod,                         prefer_text)) {        return false;    }    to->inject_keycode.metastate = convert_meta_state(mod);    return true;}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = im->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && !shift && down) {                    set_screen_power_mode(controller, SCREEN_POWER_MODE_OFF);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard                        set_device_clipboard(controller);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && cmd && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && cmd && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;        }        return;    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
static void usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, OPT_CROP},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"push-target",           required_argument, NULL, OPT_PUSH_TARGET},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, OPT_RECORD_FORMAT},        {"render-expired-frames", no_argument,       NULL,                                                     OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL,                                                     OPT_WINDOW_TITLE},        {NULL,                    0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port(optarg, &opts->port)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
static void usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, OPT_CROP},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"push-target",           required_argument, NULL, OPT_PUSH_TARGET},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, OPT_RECORD_FORMAT},        {"render-expired-frames", no_argument,       NULL,                                                     OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"prefer-text",           no_argument,       NULL, OPT_PREFER_TEXT},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL,                                                     OPT_WINDOW_TITLE},        {NULL,                    0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port(optarg, &opts->port)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF, "max size");    if (!ok) {        return false;    }    *max_size = (uint16_t) value;    return true;}static boolparse_max_fps(const char *s, uint16_t *max_fps) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 1000, "max fps");    if (!ok) {        return false;
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
parse_port(const char *s, uint16_t *port) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF, "port");    if (!ok) {        return false;    }    *port = (uint16_t) value;    return true;}
parse_port(const char *s, uint16_t *port) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF, "port");    if (!ok) {        return false;    }    *port = (uint16_t) value;    return true;}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, OPT_CROP},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-fps",               required_argument, NULL, OPT_MAX_FPS},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"push-target",           required_argument, NULL, OPT_PUSH_TARGET},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, OPT_RECORD_FORMAT},        {"render-expired-frames", no_argument,       NULL,                                                     OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"prefer-text",           no_argument,       NULL, OPT_PREFER_TEXT},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",              required_argument, NULL, OPT_WINDOW_X},        {"window-y",              required_argument, NULL, OPT_WINDOW_Y},        {"window-width",          required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",         required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",     no_argument,       NULL,                                                     OPT_WINDOW_BORDERLESS},        {NULL,                    0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port(optarg, &opts->port)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
parse_integers_arg(const char *s, size_t max_items, long *out, long min,                   long max, const char *name) {    size_t count = parse_integers(s, ':', max_items, out);    if (!count) {        LOGE("Could not parse %s: %s", name, s);        return 0;    }    for (size_t i = 0; i < count; ++i) {        long value = out[i];        if (value < min || value > max) {            LOGE("Could not parse %s: value (%ld) out-of-range (%ld; %ld)",                 name, value, min, max);            return 0;        }    }    return count;}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
        return false;    }    *position = (int16_t) value;    return true;}static boolparse_window_dimension(const char *s, uint16_t *dimension) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF,
parse_port_range(const char *s, struct port_range *port_range) {    long values[2];    size_t count = parse_integers_arg(s, 2, values, 0, 0xFFFF, "port");    if (!count) {        return false;    }    uint16_t v0 = (uint16_t) values[0];    if (count == 1) {        port_range->first = v0;        port_range->last = v0;        return true;    }    assert(count == 2);    uint16_t v1 = (uint16_t) values[1];    if (v0 < v1) {        port_range->first = v0;        port_range->last = v1;    } else {        port_range->first = v1;        port_range->last = v0;    }    return true;}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, OPT_CROP},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-fps",               required_argument, NULL, OPT_MAX_FPS},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"push-target",           required_argument, NULL, OPT_PUSH_TARGET},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, OPT_RECORD_FORMAT},        {"render-expired-frames", no_argument,       NULL,                                                     OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"prefer-text",           no_argument,       NULL, OPT_PREFER_TEXT},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",              required_argument, NULL, OPT_WINDOW_X},        {"window-y",              required_argument, NULL, OPT_WINDOW_Y},        {"window-width",          required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",         required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",     no_argument,       NULL,                                                     OPT_WINDOW_BORDERLESS},        {NULL,                    0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
        SDL_free(server->serial);        return false;    }    // server will connect to our server socket    server->process = execute_server(server, params);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free(server->serial);        return false;    }    server->tunnel_enabled = true;    return true;}boolserver_connect_to(struct server *server) {    if (!server->tunnel_forward) {        server->video_socket = net_accept(server->server_socket);        if (server->video_socket == INVALID_SOCKET) {            return false;        }        server->control_socket = net_accept(server->server_socket);        if (server->control_socket == INVALID_SOCKET) {            // the video_socket will be cleaned up on destroy            return false;        }        // we don't need the server socket anymore        close_socket(&server->server_socket);    } else {        uint32_t attempts = 100;        uint32_t delay = 100; // ms        server->video_socket =            connect_to_server(server->local_port, attempts, delay);        if (server->video_socket == INVALID_SOCKET) {            return false;        }        // we know that the device is listening, we don't need several attempts        server->control_socket =            net_connect(IPV4_LOCALHOST, server->local_port);        if (server->control_socket == INVALID_SOCKET) {            return false;        }    }    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = false;    return true;}voidserver_stop(struct server *server) {    if (server->server_socket != INVALID_SOCKET) {        close_socket(&server->server_socket);    }    if (server->video_socket != INVALID_SOCKET) {        close_socket(&server->video_socket);    }    if (server->control_socket != INVALID_SOCKET) {        close_socket(&server->control_socket);    }    assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Could not terminate server");    }    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->tunnel_enabled) {        // ignore failure        disable_tunnel(server);    }}voidserver_destroy(struct server *server) {    SDL_free(server->serial);}
enable_tunnel(struct server *server) {    if (enable_tunnel_reverse(server->serial, server->local_port)) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(server->local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, server->local_port);            disable_tunnel(server);            return false;        }        return true;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    LOGW("'adb reverse' failed, fallback to 'adb forward'");    server->tunnel_forward = true;    return enable_tunnel_forward(server->serial, server->local_port);}
enable_tunnel(struct server *server) {    if (enable_tunnel_reverse(server->serial, server->local_port)) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(server->local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, server->local_port);            disable_tunnel(server);            return false;        }        return true;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    LOGW("'adb reverse' failed, fallback to 'adb forward'");    server->tunnel_forward = true;    return enable_tunnel_forward(server->serial, server->local_port);}
enable_tunnel(struct server *server) {    if (enable_tunnel_reverse(server->serial, server->local_port)) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(server->local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, server->local_port);            disable_tunnel(server);            return false;        }        return true;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    LOGW("'adb reverse' failed, fallback to 'adb forward'");    server->tunnel_forward = true;    return enable_tunnel_forward(server->serial, server->local_port);}
server_start(struct server *server, const char *serial,             const struct server_params *params) {    server->local_port = params->local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        SDL_free(server->serial);        return false;    }    if (!enable_tunnel(server)) {        SDL_free(server->serial);        return false;    }    // server will connect to our server socket    server->process = execute_server(server, params);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free(server->serial);        return false;    }    server->tunnel_enabled = true;    return true;}
enable_tunnel_reverse_any_port(struct server *server,                               struct port_range port_range) {    uint16_t port = port_range.first;    for (;;) {        if (!enable_tunnel_reverse(server->serial, port)) {            // the command itself failed, it will fail on any port            return false;        }        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(port);        if (server->server_socket != INVALID_SOCKET) {            // success            server->local_port = port;            return true;        }        // failure, disable tunnel and try another port        if (!disable_tunnel_reverse(server->serial)) {            LOGW("Could not remove reverse tunnel on port %" PRIu16, port);        }        // check before incrementing to avoid overflow on port 65535        if (port < port_range.last) {            LOGW("Could not listen on port %" PRIu16", retrying on %" PRIu16,                 port, port + 1);            port++;            continue;        }        if (port_range.first == port_range.last) {            LOGE("Could not listen on port %" PRIu16, port_range.first);        } else {            LOGE("Could not listen on any port in range %" PRIu16 ":%" PRIu16,                 port_range.first, port_range.last);        }        return false;    }}
enable_tunnel_reverse_any_port(struct server *server,                               struct port_range port_range) {    uint16_t port = port_range.first;    for (;;) {        if (!enable_tunnel_reverse(server->serial, port)) {            // the command itself failed, it will fail on any port            return false;        }        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(port);        if (server->server_socket != INVALID_SOCKET) {            // success            server->local_port = port;            return true;        }        // failure, disable tunnel and try another port        if (!disable_tunnel_reverse(server->serial)) {            LOGW("Could not remove reverse tunnel on port %" PRIu16, port);
enable_tunnel_any_port(struct server *server, struct port_range port_range) {    if (enable_tunnel_reverse_any_port(server, port_range)) {        return true;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    LOGW("'adb reverse' failed, fallback to 'adb forward'");    return enable_tunnel_forward_any_port(server, port_range);}
enable_tunnel_forward_any_port(struct server *server,                               struct port_range port_range) {    server->tunnel_forward = true;    uint16_t port = port_range.first;    for (;;) {        if (enable_tunnel_forward(server->serial, port)) {            // success            server->local_port = port;            return true;        }        if (port < port_range.last) {            LOGW("Could not forward port %" PRIu16", retrying on %" PRIu16,                 port, port + 1);            port++;            continue;        }        if (port_range.first == port_range.last) {            LOGE("Could not forward port %" PRIu16, port_range.first);        } else {            LOGE("Could not forward any port in range %" PRIu16 ":%" PRIu16,                 port_range.first, port_range.last);        }        return false;    }}
server_start(struct server *server, const char *serial,             const struct server_params *params) {    server->port_range = params->port_range;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        SDL_free(server->serial);        return false;    }    if (!enable_tunnel_any_port(server, params->port_range)) {        SDL_free(server->serial);        return false;    }    // server will connect to our server socket    server->process = execute_server(server, params);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free(server->serial);        return false;    }    server->tunnel_enabled = true;    return true;}
static void test_options(void) {    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    char *argv[] = {        "scrcpy",        "--always-on-top",        "--bit-rate", "5M",        "--crop", "100:200:300:400",        "--fullscreen",        "--max-fps", "30",        "--max-size", "1024",        // "--no-control" is not compatible with "--turn-screen-off"        // "--no-display" is not compatible with "--fulscreen"        "--port", "1234",        "--push-target", "/sdcard/Movies",        "--record", "file",        "--record-format", "mkv",        "--render-expired-frames",        "--serial", "0123456789abcdef",        "--show-touches",        "--turn-screen-off",        "--prefer-text",        "--window-title", "my device",        "--window-x", "100",        "--window-y", "-1",        "--window-width", "600",        "--window-height", "0",        "--window-borderless",    };    bool ok = scrcpy_parse_args(&args, ARRAY_LEN(argv), argv);    assert(ok);    const struct scrcpy_options *opts = &args.opts;    assert(opts->always_on_top);    fprintf(stderr, "%d\n", (int) opts->bit_rate);    assert(opts->bit_rate == 5000000);    assert(!strcmp(opts->crop, "100:200:300:400"));    assert(opts->fullscreen);    assert(opts->max_fps == 30);    assert(opts->max_size == 1024);    assert(opts->port == 1234);    assert(!strcmp(opts->push_target, "/sdcard/Movies"));    assert(!strcmp(opts->record_filename, "file"));    assert(opts->record_format == RECORDER_FORMAT_MKV);    assert(opts->render_expired_frames);    assert(!strcmp(opts->serial, "0123456789abcdef"));    assert(opts->show_touches);    assert(opts->turn_screen_off);    assert(opts->prefer_text);    assert(!strcmp(opts->window_title, "my device"));    assert(opts->window_x == 100);    assert(opts->window_y == -1);    assert(opts->window_width == 600);    assert(opts->window_height == 0);    assert(opts->window_borderless);}
static void test_options(void) {    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    char *argv[] = {        "scrcpy",        "--always-on-top",        "--bit-rate", "5M",        "--crop", "100:200:300:400",        "--fullscreen",        "--max-fps", "30",        "--max-size", "1024",        // "--no-control" is not compatible with "--turn-screen-off"        // "--no-display" is not compatible with "--fulscreen"        "--port", "1234:1236",        "--push-target", "/sdcard/Movies",        "--record", "file",        "--record-format", "mkv",        "--render-expired-frames",        "--serial", "0123456789abcdef",        "--show-touches",        "--turn-screen-off",        "--prefer-text",        "--window-title", "my device",        "--window-x", "100",        "--window-y", "-1",        "--window-width", "600",        "--window-height", "0",        "--window-borderless",    };    bool ok = scrcpy_parse_args(&args, ARRAY_LEN(argv), argv);    assert(ok);    const struct scrcpy_options *opts = &args.opts;    assert(opts->always_on_top);    fprintf(stderr, "%d\n", (int) opts->bit_rate);    assert(opts->bit_rate == 5000000);    assert(!strcmp(opts->crop, "100:200:300:400"));    assert(opts->fullscreen);    assert(opts->max_fps == 30);    assert(opts->max_size == 1024);    assert(opts->port_range.first == 1234);    assert(opts->port_range.last == 1236);    assert(!strcmp(opts->push_target, "/sdcard/Movies"));    assert(!strcmp(opts->record_filename, "file"));    assert(opts->record_format == RECORDER_FORMAT_MKV);    assert(opts->render_expired_frames);    assert(!strcmp(opts->serial, "0123456789abcdef"));    assert(opts->show_touches);    assert(opts->turn_screen_off);    assert(opts->prefer_text);    assert(!strcmp(opts->window_title, "my device"));    assert(opts->window_x == 100);    assert(opts->window_y == -1);    assert(opts->window_width == 600);    assert(opts->window_height == 0);    assert(opts->window_borderless);}
    private boolean injectScroll(Position position, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        MotionEvent.PointerProperties props = pointerProperties[0];        props.id = 0;        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.x = point.getX();        coords.y = point.getY();        coords.setAxisValue(MotionEvent.AXIS_HSCROLL, hScroll);        coords.setAxisValue(MotionEvent.AXIS_VSCROLL, vScroll);        MotionEvent event = MotionEvent                .obtain(lastTouchDown, now, MotionEvent.ACTION_SCROLL, 1, pointerProperties, pointerCoords, 0, 0, 1f, 1f, DEVICE_ID_VIRTUAL, 0,                        InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
    private boolean injectScroll(Position position, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        MotionEvent.PointerProperties props = pointerProperties[0];        props.id = 0;        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.x = point.getX();        coords.y = point.getY();        coords.setAxisValue(MotionEvent.AXIS_HSCROLL, hScroll);        coords.setAxisValue(MotionEvent.AXIS_VSCROLL, vScroll);        MotionEvent event = MotionEvent                .obtain(lastTouchDown, now, MotionEvent.ACTION_SCROLL, 1, pointerProperties, pointerCoords, 0, 0, 1f, 1f, DEVICE_ID_VIRTUAL, 0,                        InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
parse_shortcut_mods_item(const char *item, size_t len) {    unsigned mod = 0;    for (;;) {        char *plus = strchr(item, '+');        // strchr() does not consider the "len" parameter, to it could find an        // occurrence too far in the string (there is no strnchr())        bool has_plus = plus && plus < item + len;        assert(!has_plus || plus > item);        size_t key_len = has_plus ? (size_t) (plus - item) : len;#define STREQ(literal, s, len) \    ((sizeof(literal)-1 == len) && !memcmp(literal, s, len))        if (STREQ("lctrl", item, key_len)) {            mod |= SC_MOD_LCTRL;        } else if (STREQ("rctrl", item, key_len)) {            mod |= SC_MOD_RCTRL;        } else if (STREQ("lalt", item, key_len)) {            mod |= SC_MOD_LALT;        } else if (STREQ("ralt", item, key_len)) {            mod |= SC_MOD_RALT;        } else if (STREQ("lsuper", item, key_len)) {            mod |= SC_MOD_LSUPER;        } else if (STREQ("rsuper", item, key_len)) {            mod |= SC_MOD_RSUPER;        } else {            LOGW("Unknown modifier key: %.*s", (int) key_len, item);            return 0;        }#undef STREQ        if (!has_plus) {            break;        }        item = plus + 1;        assert(len >= key_len + 1);        len -= key_len + 1;    }    return mod;}
parse_shortcut_mods_item(const char *item, size_t len) {    unsigned mod = 0;    for (;;) {        char *plus = strchr(item, '+');        // strchr() does not consider the "len" parameter, to it could find an        // occurrence too far in the string (there is no strnchr())        bool has_plus = plus && plus < item + len;        assert(!has_plus || plus > item);        size_t key_len = has_plus ? (size_t) (plus - item) : len;#define STREQ(literal, s, len) \    ((sizeof(literal)-1 == len) && !memcmp(literal, s, len))        if (STREQ("lctrl", item, key_len)) {            mod |= SC_MOD_LCTRL;        } else if (STREQ("rctrl", item, key_len)) {            mod |= SC_MOD_RCTRL;        } else if (STREQ("lalt", item, key_len)) {            mod |= SC_MOD_LALT;        } else if (STREQ("ralt", item, key_len)) {            mod |= SC_MOD_RALT;        } else if (STREQ("lsuper", item, key_len)) {            mod |= SC_MOD_LSUPER;        } else if (STREQ("rsuper", item, key_len)) {            mod |= SC_MOD_RSUPER;        } else {            LOGE("Unknown modifier key: %.*s "                 "(must be one of: lctrl, rctrl, lalt, ralt, lsuper, rsuper)",                 (int) key_len, item);            return 0;        }#undef STREQ        if (!has_plus) {            break;        }        item = plus + 1;        assert(len >= key_len + 1);        len -= key_len + 1;    }    return mod;}
is_outside_device_screen(struct input_manager *im, int x, int y){    return x < 0 || x >= im->screen->frame_size.width ||           y < 0 || y >= im->screen->frame_size.height;}
is_outside_device_screen(struct input_manager *im, int x, int y){    return x < 0 || x >= im->screen->content_size.width ||           y < 0 || y >= im->screen->content_size.height;}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"crop",                   required_argument, NULL, OPT_CROP},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"port",                   required_argument, NULL, 'p'},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"crop",                   required_argument, NULL, OPT_CROP},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"port",                   required_argument, NULL, 'p'},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
    private Bundle call(String callMethod, String arg, Bundle extras) {        try {            Method method = getCallMethod();            Object[] args;            if (!callMethodLegacy) {                args = new Object[]{ServiceManager.PACKAGE_NAME, "settings", callMethod, arg, extras};            } else {                args = new Object[]{ServiceManager.PACKAGE_NAME, callMethod, arg, extras};            }            return (Bundle) method.invoke(provider, args);        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            Ln.e("Could not invoke method", e);            return null;        }    }
    private Method getCallMethod() throws NoSuchMethodException {        if (callMethod == null) {            try {                callMethod = provider.getClass().getMethod("call", String.class, String.class, String.class, String.class, Bundle.class);            } catch (NoSuchMethodException e) {                // old version                callMethod = provider.getClass().getMethod("call", String.class, String.class, String.class, Bundle.class);                callMethodLegacy = true;            }        }        return callMethod;    }
    private Bundle call(String callMethod, String arg, Bundle extras) {        try {            Method method = getCallMethod();            Object[] args;            switch (callMethodVersion) {                case 0:                    args = new Object[]{ServiceManager.PACKAGE_NAME, null, "settings", callMethod, arg, extras};                    break;                case 1:                    args = new Object[]{ServiceManager.PACKAGE_NAME, "settings", callMethod, arg, extras};                    break;                default:                    args = new Object[]{ServiceManager.PACKAGE_NAME, callMethod, arg, extras};                    break;            }            return (Bundle) method.invoke(provider, args);        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            Ln.e("Could not invoke method", e);            return null;        }    }
    private Method getCallMethod() throws NoSuchMethodException {        if (callMethod == null) {            try {                callMethod = provider.getClass()                        .getMethod("call", String.class, String.class, String.class, String.class, String.class, Bundle.class);                callMethodVersion = 0;            } catch (NoSuchMethodException e) {                // old versions                try {                    callMethod = provider.getClass().getMethod("call", String.class, String.class, String.class, String.class, Bundle.class);                    callMethodVersion = 1;                } catch (NoSuchMethodException e2) {                    callMethod = provider.getClass().getMethod("call", String.class, String.class, String.class, Bundle.class);                    callMethodVersion = 2;                }            }        }        return callMethod;    }
convert_mouse_button(const SDL_MouseButtonEvent *from, struct screen *screen,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_mouse_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen->frame_size;    to->inject_touch_event.position.point =        screen_convert_window_to_frame_coords(screen, from->x, from->y);    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons =        convert_mouse_buttons(SDL_BUTTON(from->button));    return true;}
convert_mouse_button(const SDL_MouseButtonEvent *from, struct screen *screen,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_mouse_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen->frame_size;    to->inject_touch_event.position.point =        screen_convert_window_to_frame_coords(screen, from->x, from->y);    to->inject_touch_event.pressure =        from->type == SDL_MOUSEBUTTONDOWN ? 1.f : 0.f;    to->inject_touch_event.buttons =        convert_mouse_buttons(SDL_BUTTON(from->button));    return true;}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = im->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (cmd && !shift && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (cmd && !shift && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && cmd && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && cmd && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && cmd && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = im->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (cmd && !shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (cmd && !shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && cmd && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && cmd && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && cmd && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
convert_touch(const SDL_TouchFingerEvent *from, struct screen *screen,              struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_touch_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = from->fingerId;    to->inject_touch_event.position.screen_size = screen->frame_size;    // SDL touch event coordinates are normalized in the range [0; 1]    float x = from->x * screen->content_size.width;    float y = from->y * screen->content_size.height;    to->inject_touch_event.position.point =        screen_convert_to_frame_coords(screen, x, y);    to->inject_touch_event.pressure = from->pressure;    to->inject_touch_event.buttons = 0;    return true;}
is_outside_device_screen(struct input_manager *im, int x, int y){    return x < 0 || x >= im->screen->content_size.width ||           y < 0 || y >= im->screen->content_size.height;}
input_manager_process_mouse_button(struct input_manager *im,                                   const SDL_MouseButtonEvent *event,                                   bool control) {    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (control && event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(im->controller);            return;        }        if (control && event->button == SDL_BUTTON_MIDDLE) {            action_home(im->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            bool outside =                is_outside_device_screen(im, event->x, event->y);            if (outside) {                screen_resize_to_fit(im->screen);                return;            }        }        // otherwise, send the click event to the device    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_mouse_button(event, im->screen, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject mouse button event'");        }    }}
convert_to_renderer_coordinates(SDL_Renderer *renderer, int *x, int *y) {    SDL_Rect viewport;    float scale_x, scale_y;    SDL_RenderGetViewport(renderer, &viewport);    SDL_RenderGetScale(renderer, &scale_x, &scale_y);    *x = (int) (*x / scale_x) - viewport.x;    *y = (int) (*y / scale_y) - viewport.y;}
get_mouse_point(struct screen *screen) {    int x;    int y;    SDL_GetMouseState(&x, &y);    convert_to_renderer_coordinates(screen->renderer, &x, &y);    return (struct point) {        .x = x,        .y = y,    };}
convert_mouse_wheel(const SDL_MouseWheelEvent *from, struct screen *screen,                    struct control_msg *to) {    struct position position = {        .screen_size = screen->frame_size,        .point = get_mouse_point(screen),    };    to->type = CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT;    to->inject_scroll_event.position = position;    to->inject_scroll_event.hscroll = from->x;    to->inject_scroll_event.vscroll = from->y;    return true;}
convert_touch(const SDL_TouchFingerEvent *from, struct screen *screen,              struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_touch_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = from->fingerId;    to->inject_touch_event.position.screen_size = screen->frame_size;    int ww;    int wh;    SDL_GL_GetDrawableSize(screen->window, &ww, &wh);    // SDL touch event coordinates are normalized in the range [0; 1]    int32_t x = from->x * ww;    int32_t y = from->y * wh;    to->inject_touch_event.position.point =        screen_convert_to_frame_coords(screen, x, y);    to->inject_touch_event.pressure = from->pressure;    to->inject_touch_event.buttons = 0;    return true;}
                                   const SDL_MouseButtonEvent *event,                                   bool control) {    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }
input_manager_process_mouse_button(struct input_manager *im,                                   const SDL_MouseButtonEvent *event,                                   bool control) {    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (control && event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(im->controller);            return;        }        if (control && event->button == SDL_BUTTON_MIDDLE) {            action_home(im->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            int32_t x = event->x;            int32_t y = event->y;            screen_hidpi_scale_coords(im->screen, &x, &y);            SDL_Rect *r = &im->screen->rect;            bool outside = x < r->x || x >= r->x + r->w                        || y < r->y || y >= r->y + r->h;            if (outside) {                screen_resize_to_fit(im->screen);                return;            }        }        // otherwise, send the click event to the device    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_mouse_button(event, im->screen, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject mouse button event'");        }    }}
    // send DOWN event    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_KEYCODE;    msg.inject_keycode.keycode = keycode;    msg.inject_keycode.metastate = 0;    if (actions & ACTION_DOWN) {        msg.inject_keycode.action = AKEY_EVENT_ACTION_DOWN;        if (!controller_push_msg(controller, &msg)) {
            return;        }    }    if (actions & ACTION_UP) {        msg.inject_keycode.action = AKEY_EVENT_ACTION_UP;        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject %s (UP)'", name);        }    }}
convert_mouse_wheel(const SDL_MouseWheelEvent *from, struct screen *screen,                    struct control_msg *to) {    // mouse_x and mouse_y are expressed in pixels relative to the window    int mouse_x;    int mouse_y;    SDL_GetMouseState(&mouse_x, &mouse_y);    struct position position = {        .screen_size = screen->frame_size,        .point = screen_convert_to_frame_coords(screen, mouse_x, mouse_y),    };    to->type = CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT;    to->inject_scroll_event.position = position;    to->inject_scroll_event.hscroll = from->x;    to->inject_scroll_event.vscroll = from->y;    return true;}
event_watcher(void *data, SDL_Event *event) {    (void) data;    if (event->type == SDL_WINDOWEVENT            && event->window.event == SDL_WINDOWEVENT_RESIZED) {        // In practice, it seems to always be called from the same thread in        // that specific case. Anyway, it's just a workaround.        screen_render(&screen);    }    return 0;}#endif
event_watcher(void *data, SDL_Event *event) {    (void) data;    if (event->type == SDL_WINDOWEVENT            && event->window.event == SDL_WINDOWEVENT_RESIZED) {        // In practice, it seems to always be called from the same thread in        // that specific case. Anyway, it's just a workaround.        screen_render(&screen, true);    }    return 0;}#endif
screen_handle_window_event(struct screen *screen,                           const SDL_WindowEvent *event) {    switch (event->event) {        case SDL_WINDOWEVENT_EXPOSED:            screen_render(screen);            break;        case SDL_WINDOWEVENT_SIZE_CHANGED:            screen_render(screen);            break;        case SDL_WINDOWEVENT_MAXIMIZED:            screen->maximized = true;            break;        case SDL_WINDOWEVENT_RESTORED:            if (screen->fullscreen) {                // On Windows, in maximized+fullscreen, disabling fullscreen                // mode unexpectedly triggers the "restored" then "maximized"                // events, leaving the window in a weird state (maximized                // according to the events, but not maximized visually).                break;            }            screen->maximized = false;            apply_pending_resize(screen);            break;    }}
screen_set_rotation(struct screen *screen, unsigned rotation) {    assert(rotation < 4);    if (rotation == screen->rotation) {        return;    }    struct size new_content_size =        get_rotated_size(screen->frame_size, rotation);    if (SDL_RenderSetLogicalSize(screen->renderer,                                 new_content_size.width,                                 new_content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        return;    }    set_content_size(screen, new_content_size);    screen->rotation = rotation;    LOGI("Display rotation set to %u", rotation);    screen_render(screen);}
screen_render(struct screen *screen) {    SDL_RenderClear(screen->renderer);    if (screen->rotation == 0) {        SDL_RenderCopy(screen->renderer, screen->texture, NULL, NULL);    } else {        // rotation in RenderCopyEx() is clockwise, while screen->rotation is        // counterclockwise (to be consistent with --lock-video-orientation)        int cw_rotation = (4 - screen->rotation) % 4;        double angle = 90 * cw_rotation;        SDL_Rect *dstrect = NULL;        SDL_Rect rect;        if (screen->rotation & 1) {            struct size size = screen->content_size;            rect.x = (size.width - size.height) / 2;            rect.y = (size.height - size.width) / 2;            rect.w = size.height;            rect.h = size.width;            dstrect = &rect;        }        SDL_RenderCopyEx(screen->renderer, screen->texture, NULL, dstrect,                         angle, NULL, 0);    }    SDL_RenderPresent(screen->renderer);}
screen_update_frame(struct screen *screen, struct video_buffer *vb) {    mutex_lock(vb->mutex);    const AVFrame *frame = video_buffer_consume_rendered_frame(vb);    struct size new_frame_size = {frame->width, frame->height};    if (!prepare_for_frame(screen, new_frame_size)) {        mutex_unlock(vb->mutex);        return false;    }    update_texture(screen, frame);    mutex_unlock(vb->mutex);    screen_render(screen);    return true;}
prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width            || screen->frame_size.height != new_frame_size.height) {        struct size new_content_size =            get_rotated_size(new_frame_size, screen->rotation);        if (SDL_RenderSetLogicalSize(screen->renderer,                                     new_content_size.width,                                     new_content_size.height)) {            LOGE("Could not set renderer logical size: %s", SDL_GetError());            return false;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        set_content_size(screen, new_content_size);        screen->frame_size = new_frame_size;        LOGI("New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = create_texture(screen);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return false;        }    }    return true;}
prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width            || screen->frame_size.height != new_frame_size.height) {        struct size new_content_size =            get_rotated_size(new_frame_size, screen->rotation);        if (SDL_RenderSetLogicalSize(screen->renderer,                                     new_content_size.width,                                     new_content_size.height)) {            LOGE("Could not set renderer logical size: %s", SDL_GetError());            return false;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        set_content_size(screen, new_content_size);        screen->frame_size = new_frame_size;        LOGI("New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = create_texture(screen);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return false;        }    }    return true;}
screen_switch_fullscreen(struct screen *screen) {    uint32_t new_mode = screen->fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;    if (SDL_SetWindowFullscreen(screen->window, new_mode)) {        LOGW("Could not switch fullscreen mode: %s", SDL_GetError());        return;    }    screen->fullscreen = !screen->fullscreen;    if (!screen->fullscreen && !screen->maximized) {        apply_pending_resize(screen);    }    LOGD("Switched to %s mode", screen->fullscreen ? "fullscreen" : "windowed");    screen_render(screen);}
screen_render(struct screen *screen) {    SDL_RenderClear(screen->renderer);    if (screen->rotation == 0) {        SDL_RenderCopy(screen->renderer, screen->texture, NULL, NULL);    } else {        // rotation in RenderCopyEx() is clockwise, while screen->rotation is        // counterclockwise (to be consistent with --lock-video-orientation)        int cw_rotation = (4 - screen->rotation) % 4;        double angle = 90 * cw_rotation;        SDL_Rect *dstrect = NULL;        SDL_Rect rect;        if (screen->rotation & 1) {            struct size size = screen->content_size;            rect.x = (size.width - size.height) / 2;            rect.y = (size.height - size.width) / 2;            rect.w = size.height;            rect.h = size.width;            dstrect = &rect;        }        SDL_RenderCopyEx(screen->renderer, screen->texture, NULL, dstrect,                         angle, NULL, 0);    }    SDL_RenderPresent(screen->renderer);}
screen_convert_to_frame_coords(struct screen *screen, int32_t x, int32_t y) {    unsigned rotation = screen->rotation;    assert(rotation < 4);    int32_t w = screen->content_size.width;    int32_t h = screen->content_size.height;    struct point result;    switch (rotation) {        case 0:            result.x = x;            result.y = y;            break;        case 1:            result.x = h - y;            result.y = x;            break;        case 2:            result.x = w - x;            result.y = h - y;            break;        default:            assert(rotation == 3);            result.x = y;            result.y = w - x;            break;    }    return result;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation, bool mipmaps) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size = get_rotated_size(frame_size, screen->rotation);    screen->content_size = content_size;    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_RendererInfo renderer_info;    int r = SDL_GetRendererInfo(screen->renderer, &renderer_info);    const char *renderer_name = r ? NULL : renderer_info.name;    LOGI("Renderer: %s", renderer_name ? renderer_name : "(unknown)");    if (SDL_RenderSetLogicalSize(screen->renderer, content_size.width,                                 content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    // starts with "opengl"    screen->use_opengl = renderer_name && !strncmp(renderer_name, "opengl", 6);    if (screen->use_opengl) {        struct sc_opengl *gl = &screen->gl;        sc_opengl_init(gl);        LOGI("OpenGL version: %s", gl->version);        if (mipmaps) {            bool supports_mipmaps =                sc_opengl_version_at_least(gl, 3, 0, /* OpenGL 3.0+ */                                               2, 0  /* OpenGL ES 2.0+ */);            if (supports_mipmaps) {                LOGI("Trilinear filtering enabled");                screen->mipmaps = true;            } else {                LOGW("Trilinear filtering disabled "                     "(OpenGL 3.0+ or ES 2.0+ required)");            }        } else {            LOGI("Trilinear filtering disabled");        }    } else {        LOGW("Trilinear filtering disabled (not an OpenGL renderer)");    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    return true;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation, bool mipmaps) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size = get_rotated_size(frame_size, screen->rotation);    screen->content_size = content_size;    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_RendererInfo renderer_info;    int r = SDL_GetRendererInfo(screen->renderer, &renderer_info);    const char *renderer_name = r ? NULL : renderer_info.name;    LOGI("Renderer: %s", renderer_name ? renderer_name : "(unknown)");    if (SDL_RenderSetLogicalSize(screen->renderer, content_size.width,                                 content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    // starts with "opengl"    screen->use_opengl = renderer_name && !strncmp(renderer_name, "opengl", 6);    if (screen->use_opengl) {        struct sc_opengl *gl = &screen->gl;        sc_opengl_init(gl);        LOGI("OpenGL version: %s", gl->version);        if (mipmaps) {            bool supports_mipmaps =                sc_opengl_version_at_least(gl, 3, 0, /* OpenGL 3.0+ */                                               2, 0  /* OpenGL ES 2.0+ */);            if (supports_mipmaps) {                LOGI("Trilinear filtering enabled");                screen->mipmaps = true;            } else {                LOGW("Trilinear filtering disabled "                     "(OpenGL 3.0+ or ES 2.0+ required)");            }        } else {            LOGI("Trilinear filtering disabled");        }    } else {        LOGW("Trilinear filtering disabled (not an OpenGL renderer)");    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    return true;}
screen_handle_window_event(struct screen *screen,                           const SDL_WindowEvent *event) {    switch (event->event) {        case SDL_WINDOWEVENT_EXPOSED:            screen_render(screen, true);            break;        case SDL_WINDOWEVENT_SIZE_CHANGED:            screen_render(screen, true);            break;        case SDL_WINDOWEVENT_MAXIMIZED:            screen->maximized = true;            break;        case SDL_WINDOWEVENT_RESTORED:            if (screen->fullscreen) {                // On Windows, in maximized+fullscreen, disabling fullscreen                // mode unexpectedly triggers the "restored" then "maximized"                // events, leaving the window in a weird state (maximized                // according to the events, but not maximized visually).                break;            }            screen->maximized = false;            apply_pending_resize(screen);            break;    }}
screen_set_rotation(struct screen *screen, unsigned rotation) {    assert(rotation < 4);    if (rotation == screen->rotation) {        return;    }    struct size new_content_size =        get_rotated_size(screen->frame_size, rotation);    set_content_size(screen, new_content_size);    screen->rotation = rotation;    LOGI("Display rotation set to %u", rotation);    screen_render(screen, true);}
screen_render(struct screen *screen, bool update_content_rect) {    if (update_content_rect) {        screen_update_content_rect(screen);    }    SDL_RenderClear(screen->renderer);    if (screen->rotation == 0) {        SDL_RenderCopy(screen->renderer, screen->texture, NULL, &screen->rect);    } else {        // rotation in RenderCopyEx() is clockwise, while screen->rotation is        // counterclockwise (to be consistent with --lock-video-orientation)        int cw_rotation = (4 - screen->rotation) % 4;        double angle = 90 * cw_rotation;        SDL_Rect *dstrect = NULL;        SDL_Rect rect;        if (screen->rotation & 1) {            rect.x = screen->rect.x + (screen->rect.w - screen->rect.h) / 2;            rect.y = screen->rect.y + (screen->rect.h - screen->rect.w) / 2;            rect.w = screen->rect.h;            rect.h = screen->rect.w;            dstrect = &rect;        } else {            assert(screen->rotation == 2);            dstrect = &screen->rect;        }        SDL_RenderCopyEx(screen->renderer, screen->texture, NULL, dstrect,                         angle, NULL, 0);    }    SDL_RenderPresent(screen->renderer);}
screen_update_frame(struct screen *screen, struct video_buffer *vb) {    mutex_lock(vb->mutex);    const AVFrame *frame = video_buffer_consume_rendered_frame(vb);    struct size new_frame_size = {frame->width, frame->height};    if (!prepare_for_frame(screen, new_frame_size)) {        mutex_unlock(vb->mutex);        return false;    }    update_texture(screen, frame);    mutex_unlock(vb->mutex);    screen_render(screen, false);    return true;}
prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width            || screen->frame_size.height != new_frame_size.height) {        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        screen->frame_size = new_frame_size;        struct size new_content_size =            get_rotated_size(new_frame_size, screen->rotation);        set_content_size(screen, new_content_size);        screen_update_content_rect(screen);        LOGI("New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = create_texture(screen);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return false;        }    }    return true;}
screen_hidpi_scale_coords(struct screen *screen, int32_t *x, int32_t *y) {    // take the HiDPI scaling (dw/ww and dh/wh) into account    int ww, wh, dw, dh;    SDL_GetWindowSize(screen->window, &ww, &wh);    SDL_GL_GetDrawableSize(screen->window, &dw, &dh);    // scale for HiDPI (64 bits for intermediate multiplications)    *x = (int64_t) *x * dw / ww;    *y = (int64_t) *y * dh / wh;}
screen_switch_fullscreen(struct screen *screen) {    uint32_t new_mode = screen->fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;    if (SDL_SetWindowFullscreen(screen->window, new_mode)) {        LOGW("Could not switch fullscreen mode: %s", SDL_GetError());        return;    }    screen->fullscreen = !screen->fullscreen;    if (!screen->fullscreen && !screen->maximized) {        apply_pending_resize(screen);    }    LOGD("Switched to %s mode", screen->fullscreen ? "fullscreen" : "windowed");    screen_render(screen, true);}
        screen->gl.GenerateMipmap(GL_TEXTURE_2D);        SDL_GL_UnbindTexture(screen->texture);    }}boolscreen_update_frame(struct screen *screen, struct video_buffer *vb) {    mutex_lock(vb->mutex);    const AVFrame *frame = video_buffer_consume_rendered_frame(vb);    struct size new_frame_size = {frame->width, frame->height};    if (!prepare_for_frame(screen, new_frame_size)) {        mutex_unlock(vb->mutex);        return false;    }    update_texture(screen, frame);    mutex_unlock(vb->mutex);    screen_render(screen, false);    return true;}voidscreen_render(struct screen *screen, bool update_content_rect) {    if (update_content_rect) {        screen_update_content_rect(screen);    }
screen_convert_to_frame_coords(struct screen *screen, int32_t x, int32_t y) {    unsigned rotation = screen->rotation;    assert(rotation < 4);    int32_t w = screen->content_size.width;    int32_t h = screen->content_size.height;    screen_hidpi_scale_coords(screen, &x, &y);    x = (int64_t) (x - screen->rect.x) * w / screen->rect.w;    y = (int64_t) (y - screen->rect.y) * h / screen->rect.h;    // rotate    struct point result;    switch (rotation) {        case 0:            result.x = x;            result.y = y;            break;        case 1:            result.x = h - y;            result.y = x;            break;        case 2:            result.x = w - x;            result.y = h - y;            break;        default:            assert(rotation == 3);            result.x = y;            result.y = w - x;            break;    }    return result;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation, bool mipmaps) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size = get_rotated_size(frame_size, screen->rotation);    screen->content_size = content_size;    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_RendererInfo renderer_info;    int r = SDL_GetRendererInfo(screen->renderer, &renderer_info);    const char *renderer_name = r ? NULL : renderer_info.name;    LOGI("Renderer: %s", renderer_name ? renderer_name : "(unknown)");    // starts with "opengl"    screen->use_opengl = renderer_name && !strncmp(renderer_name, "opengl", 6);    if (screen->use_opengl) {        struct sc_opengl *gl = &screen->gl;        sc_opengl_init(gl);        LOGI("OpenGL version: %s", gl->version);        if (mipmaps) {            bool supports_mipmaps =                sc_opengl_version_at_least(gl, 3, 0, /* OpenGL 3.0+ */                                               2, 0  /* OpenGL ES 2.0+ */);            if (supports_mipmaps) {                LOGI("Trilinear filtering enabled");                screen->mipmaps = true;            } else {                LOGW("Trilinear filtering disabled "                     "(OpenGL 3.0+ or ES 2.0+ required)");            }        } else {            LOGI("Trilinear filtering disabled");        }    } else {        LOGW("Trilinear filtering disabled (not an OpenGL renderer)");    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen_update_content_rect(screen);    return true;}
screen_update_content_rect(struct screen *screen) {    int dw;    int dh;    SDL_GL_GetDrawableSize(screen->window, &dw, &dh);    struct size content_size = screen->content_size;    // The drawable size is the window size * the HiDPI scale    struct size drawable_size = {dw, dh};    SDL_Rect *rect = &screen->rect;    if (is_optimal_size(drawable_size, content_size)) {        rect->x = 0;        rect->y = 0;        rect->w = drawable_size.width;        rect->h = drawable_size.height;        return;    }    bool keep_width = content_size.width * drawable_size.height                    > content_size.height * drawable_size.width;    if (keep_width) {        rect->x = 0;        rect->w = drawable_size.width;        rect->h = drawable_size.width * content_size.height                                      / content_size.width;        rect->y = (drawable_size.height - rect->h) / 2;    } else {        rect->y = 0;        rect->h = drawable_size.height;        rect->w = drawable_size.height * content_size.width                                       / content_size.height;        rect->x = (drawable_size.width - rect->w) / 2;    }}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation, bool mipmaps) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size = get_rotated_size(frame_size, screen->rotation);    screen->content_size = content_size;    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_RendererInfo renderer_info;    int r = SDL_GetRendererInfo(screen->renderer, &renderer_info);    const char *renderer_name = r ? NULL : renderer_info.name;    LOGI("Renderer: %s", renderer_name ? renderer_name : "(unknown)");    // starts with "opengl"    screen->use_opengl = renderer_name && !strncmp(renderer_name, "opengl", 6);    if (screen->use_opengl) {        struct sc_opengl *gl = &screen->gl;        sc_opengl_init(gl);        LOGI("OpenGL version: %s", gl->version);        if (mipmaps) {            bool supports_mipmaps =                sc_opengl_version_at_least(gl, 3, 0, /* OpenGL 3.0+ */                                               2, 0  /* OpenGL ES 2.0+ */);            if (supports_mipmaps) {                LOGI("Trilinear filtering enabled");                screen->mipmaps = true;            } else {                LOGW("Trilinear filtering disabled "                     "(OpenGL 3.0+ or ES 2.0+ required)");            }        } else {            LOGI("Trilinear filtering disabled");        }    } else {        LOGW("Trilinear filtering disabled (not an OpenGL renderer)");    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    // Reset the window size to trigger a SIZE_CHANGED event, to workaround    // HiDPI issues with some SDL renderers when several displays having    // different HiDPI scaling are connected    SDL_SetWindowSize(screen->window, window_size.width, window_size.height);    screen_update_content_rect(screen);    return true;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation, bool mipmaps) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size = get_rotated_size(frame_size, screen->rotation);    screen->content_size = content_size;    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_RendererInfo renderer_info;    int r = SDL_GetRendererInfo(screen->renderer, &renderer_info);    const char *renderer_name = r ? NULL : renderer_info.name;    LOGI("Renderer: %s", renderer_name ? renderer_name : "(unknown)");    // starts with "opengl"    screen->use_opengl = renderer_name && !strncmp(renderer_name, "opengl", 6);    if (screen->use_opengl) {        struct sc_opengl *gl = &screen->gl;        sc_opengl_init(gl);        LOGI("OpenGL version: %s", gl->version);        if (mipmaps) {            bool supports_mipmaps =                sc_opengl_version_at_least(gl, 3, 0, /* OpenGL 3.0+ */                                               2, 0  /* OpenGL ES 2.0+ */);            if (supports_mipmaps) {                LOGI("Trilinear filtering enabled");                screen->mipmaps = true;            } else {                LOGW("Trilinear filtering disabled "                     "(OpenGL 3.0+ or ES 2.0+ required)");            }        } else {            LOGI("Trilinear filtering disabled");        }    } else {        LOGD("Trilinear filtering disabled (not an OpenGL renderer)");    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    // Reset the window size to trigger a SIZE_CHANGED event, to workaround    // HiDPI issues with some SDL renderers when several displays having    // different HiDPI scaling are connected    SDL_SetWindowSize(screen->window, window_size.width, window_size.height);    screen_update_content_rect(screen);    return true;}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"codec-options",          required_argument, NULL, OPT_CODEC_OPTIONS},        {"crop",                   required_argument, NULL, OPT_CROP},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"port",                   required_argument, NULL, 'p'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"stay-awake",             no_argument,       NULL, 'w'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTvw", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case 'w':                opts->stay_awake = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            case OPT_CODEC_OPTIONS:                opts->codec_options = optarg;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    if (!opts->control && opts->stay_awake) {        LOGE("Could not request to stay awake if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"codec-options",          required_argument, NULL, OPT_CODEC_OPTIONS},        {"crop",                   required_argument, NULL, OPT_CROP},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"port",                   required_argument, NULL, 'p'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"stay-awake",             no_argument,       NULL, 'w'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"verbosity",              required_argument, NULL, 'V'},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTvV:w",                            long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case 'V':                if (!parse_log_level(optarg, &opts->log_level)) {                    return false;                }                break;            case 'w':                opts->stay_awake = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            case OPT_CODEC_OPTIONS:                opts->codec_options = optarg;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    if (!opts->control && opts->stay_awake) {        LOGE("Could not request to stay awake if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
parse_log_level(const char *s, enum sc_log_level *log_level) {    if (!strcmp(s, "debug")) {        *log_level = SC_LOG_LEVEL_DEBUG;        return true;    }    if (!strcmp(s, "info")) {        *log_level = SC_LOG_LEVEL_INFO;        return true;    }    if (!strcmp(s, "warn")) {        *log_level = SC_LOG_LEVEL_WARN;        return true;    }    if (!strcmp(s, "error")) {        *log_level = SC_LOG_LEVEL_ERROR;        return true;    }    LOGE("Could not parse log level: %s", s);    return false;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif#ifndef NDEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    if (!scrcpy_parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        scrcpy_print_usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    LOGI("scrcpy " SCRCPY_VERSION " <https://github.com/Genymobile/scrcpy>");#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }    int res = scrcpy(&args.opts) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif#ifndef NDEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    if (!scrcpy_parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        scrcpy_print_usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    LOGI("scrcpy " SCRCPY_VERSION " <https://github.com/Genymobile/scrcpy>");#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }    int res = scrcpy(&args.opts) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };#ifndef NDEBUG    args.opts.log_level = SC_LOG_LEVEL_DEBUG;#endif    if (!scrcpy_parse_args(&args, argc, argv)) {        return 1;    }    SDL_LogPriority sdl_log = convert_log_level_to_sdl(args.opts.log_level);    SDL_LogSetAllPriority(sdl_log);    if (args.help) {        scrcpy_print_usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    LOGI("scrcpy " SCRCPY_VERSION " <https://github.com/Genymobile/scrcpy>");#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }    int res = scrcpy(&args.opts) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
convert_log_level_to_sdl(enum sc_log_level level) {    switch (level) {        case SC_LOG_LEVEL_DEBUG:            return SDL_LOG_PRIORITY_DEBUG;        case SC_LOG_LEVEL_INFO:            return SDL_LOG_PRIORITY_INFO;        case SC_LOG_LEVEL_WARN:            return SDL_LOG_PRIORITY_WARN;        case SC_LOG_LEVEL_ERROR:            return SDL_LOG_PRIORITY_ERROR;        default:            assert(!"unexpected log level");            return SC_LOG_LEVEL_INFO;    }}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,        .show_touches = options->show_touches,        .stay_awake = options->stay_awake,        .codec_options = options->codec_options,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options-> mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .log_level = options->log_level,        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,        .show_touches = options->show_touches,        .stay_awake = options->stay_awake,        .codec_options = options->codec_options,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options-> mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    server_destroy(&server);    return ret;}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    char max_fps_string[6];    char lock_video_orientation_string[5];    char display_id_string[6];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    sprintf(max_fps_string, "%"PRIu16, params->max_fps);    sprintf(lock_video_orientation_string, "%"PRIi8, params->lock_video_orientation);    sprintf(display_id_string, "%"PRIu16, params->display_id);    const char *const cmd[] = {        "shell",        "CLASSPATH=" DEVICE_SERVER_PATH,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"# ifdef SERVER_DEBUGGER_METHOD_NEW        /* Android 9 and above */        "-XjdwpProvider:internal -XjdwpOptions:transport=dt_socket,suspend=y,server=y,address="# else        /* Android 8 and below */        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="# endif            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,#ifndef NDEBUG        "debug",#else        "info",#endif        max_size_string,        bit_rate_string,        max_fps_string,        lock_video_orientation_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",        display_id_string,        params->show_touches ? "true" : "false",        params->stay_awake ? "true" : "false",        params->codec_options ? params->codec_options : "-",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    char max_fps_string[6];    char lock_video_orientation_string[5];    char display_id_string[6];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    sprintf(max_fps_string, "%"PRIu16, params->max_fps);    sprintf(lock_video_orientation_string, "%"PRIi8, params->lock_video_orientation);    sprintf(display_id_string, "%"PRIu16, params->display_id);    const char *const cmd[] = {        "shell",        "CLASSPATH=" DEVICE_SERVER_PATH,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"# ifdef SERVER_DEBUGGER_METHOD_NEW        /* Android 9 and above */        "-XjdwpProvider:internal -XjdwpOptions:transport=dt_socket,suspend=y,server=y,address="# else        /* Android 8 and below */        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="# endif            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,#ifndef NDEBUG        "debug",#else        "info",#endif        max_size_string,        bit_rate_string,        max_fps_string,        lock_video_orientation_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",        display_id_string,        params->show_touches ? "true" : "false",        params->stay_awake ? "true" : "false",        params->codec_options ? params->codec_options : "-",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    char max_fps_string[6];    char lock_video_orientation_string[5];    char display_id_string[6];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    sprintf(max_fps_string, "%"PRIu16, params->max_fps);    sprintf(lock_video_orientation_string, "%"PRIi8, params->lock_video_orientation);    sprintf(display_id_string, "%"PRIu16, params->display_id);    const char *const cmd[] = {        "shell",        "CLASSPATH=" DEVICE_SERVER_PATH,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"# ifdef SERVER_DEBUGGER_METHOD_NEW        /* Android 9 and above */        "-XjdwpProvider:internal -XjdwpOptions:transport=dt_socket,suspend=y,server=y,address="# else        /* Android 8 and below */        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="# endif            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,        log_level_to_server_string(params->log_level),        max_size_string,        bit_rate_string,        max_fps_string,        lock_video_orientation_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",        display_id_string,        params->show_touches ? "true" : "false",        params->stay_awake ? "true" : "false",        params->codec_options ? params->codec_options : "-",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
log_level_to_server_string(enum sc_log_level level) {    switch (level) {        case SC_LOG_LEVEL_DEBUG:            return "debug";        case SC_LOG_LEVEL_INFO:            return "info";        case SC_LOG_LEVEL_WARN:            return "warn";        case SC_LOG_LEVEL_ERROR:            return "error";        default:            assert(!"unexpected log level");            return "(unknown)";    }}
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    --shortcut-mod key[+...]][,...]\n"        "        Specify the modifiers to use for scrcpy shortcuts.\n"        "        Possible keys are \"lctrl\", \"rctrl\", \"lalt\", \"ralt\",\n"        "        \"lsuper\" and \"rsuper\".\n"        "\n"        "        A shortcut can consist in several keys, separated by '+'.\n"        "        Several shortcuts can be specified, separated by ','.\n"        "\n"        "        For example, to use either LCtrl+LAlt or LSuper for scrcpy\n"        "        shortcuts, pass \"lctrl+lalt,lsuper\".\n"        "\n"        "        Default is \"lalt,lsuper\" (left-Alt or left-Super).\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    In the following list, MOD is the shortcut modifier. By default,\n"        "    it's (left) Alt or (left) Super, but it can be configured by\n"        "    --shortcut-mod.\n"        "\n"        "    MOD+f\n"        "        Switch fullscreen mode\n"        "\n"        "    MOD+Left\n"        "        Rotate display left\n"        "\n"        "    MOD+Right\n"        "        Rotate display right\n"        "\n"        "    MOD+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    MOD+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    MOD+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    MOD+b\n"        "    MOD+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    MOD+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    MOD+m\n"        "        Click on MENU\n"        "\n"        "    MOD+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    MOD+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    MOD+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    MOD+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    MOD+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    MOD+r\n"        "        Rotate device screen\n"        "\n"        "    MOD+n\n"        "        Expand notification panel\n"        "\n"        "    MOD+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    MOD+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    MOD+Shift+v\n"        "        Copy computer clipboard to device (and paste if the device\n"        "        runs Android >= 7)\n"        "\n"        "    MOD+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    --shortcut-mod key[+...]][,...]\n"        "        Specify the modifiers to use for scrcpy shortcuts.\n"        "        Possible keys are \"lctrl\", \"rctrl\", \"lalt\", \"ralt\",\n"        "        \"lsuper\" and \"rsuper\".\n"        "\n"        "        A shortcut can consist in several keys, separated by '+'.\n"        "        Several shortcuts can be specified, separated by ','.\n"        "\n"        "        For example, to use either LCtrl+LAlt or LSuper for scrcpy\n"        "        shortcuts, pass \"lctrl+lalt,lsuper\".\n"        "\n"        "        Default is \"lalt,lsuper\" (left-Alt or left-Super).\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    In the following list, MOD is the shortcut modifier. By default,\n"        "    it's (left) Alt or (left) Super, but it can be configured by\n"        "    --shortcut-mod.\n"        "\n"        "    MOD+f\n"        "        Switch fullscreen mode\n"        "\n"        "    MOD+Left\n"        "        Rotate display left\n"        "\n"        "    MOD+Right\n"        "        Rotate display right\n"        "\n"        "    MOD+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    MOD+w\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    MOD+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    MOD+b\n"        "    MOD+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    MOD+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    MOD+m\n"        "        Click on MENU\n"        "\n"        "    MOD+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    MOD+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    MOD+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    MOD+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    MOD+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    MOD+r\n"        "        Rotate device screen\n"        "\n"        "    MOD+n\n"        "        Expand notification panel\n"        "\n"        "    MOD+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    MOD+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    MOD+Shift+v\n"        "        Copy computer clipboard to device (and paste if the device\n"        "        runs Android >= 7)\n"        "\n"        "    MOD+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    bool smod = is_shortcut_mod(im, event->keysym.mod);    struct controller *controller = im->controller;    SDL_Keycode keycode = event->keysym.sym;    bool down = event->type == SDL_KEYDOWN;    bool ctrl = event->keysym.mod & KMOD_CTRL;    bool shift = event->keysym.mod & KMOD_SHIFT;    bool repeat = event->repeat;    // The shortcut modifier is pressed    if (smod) {        int action = down ? ACTION_DOWN : ACTION_UP;        switch (keycode) {            case SDLK_h:                if (control && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                if (control && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (!shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (!shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_v:                if (control && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    if (ctrl && !shift && keycode == SDLK_v && down && !repeat) {        // Synchronize the computer clipboard to the device clipboard before        // sending Ctrl+v, to allow seamless copy-paste.        set_device_clipboard(controller, false);    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    bool smod = is_shortcut_mod(im, event->keysym.mod);    struct controller *controller = im->controller;    SDL_Keycode keycode = event->keysym.sym;    bool down = event->type == SDL_KEYDOWN;    bool ctrl = event->keysym.mod & KMOD_CTRL;    bool shift = event->keysym.mod & KMOD_SHIFT;    bool repeat = event->repeat;    // The shortcut modifier is pressed    if (smod) {        int action = down ? ACTION_DOWN : ACTION_UP;        switch (keycode) {            case SDLK_h:                if (control && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                if (control && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (!shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (!shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_v:                if (control && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_w:                if (!shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    if (ctrl && !shift && keycode == SDLK_v && down && !repeat) {        // Synchronize the computer clipboard to the device clipboard before        // sending Ctrl+v, to allow seamless copy-paste.        set_device_clipboard(controller, false);    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps, int lockedVideoOrientation) {        this(sendFrameMeta, bitRate, maxFps, lockedVideoOrientation, DEFAULT_I_FRAME_INTERVAL);    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps, int lockedVideoOrientation) {        this(sendFrameMeta, bitRate, maxFps, lockedVideoOrientation, DEFAULT_I_FRAME_INTERVAL);    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps, int lockedVideoOrientation, int iFrameInterval) {        this.sendFrameMeta = sendFrameMeta;        this.bitRate = bitRate;        this.maxFps = maxFps;        this.lockedVideoOrientation = lockedVideoOrientation;        this.iFrameInterval = iFrameInterval;    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps, int lockedVideoOrientation) {        this(sendFrameMeta, bitRate, maxFps, lockedVideoOrientation, DEFAULT_I_FRAME_INTERVAL);    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps) {        this(sendFrameMeta, bitRate, maxFps, DEFAULT_I_FRAME_INTERVAL);    }
    }    @Override    public void onRotationChanged(int rotation) {
        this.sendFrameMeta = sendFrameMeta;        this.bitRate = bitRate;        this.maxFps = maxFps;        this.iFrameInterval = iFrameInterval;    }    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps) {        this(sendFrameMeta, bitRate, maxFps, DEFAULT_I_FRAME_INTERVAL);
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps, int iFrameInterval) {        this.sendFrameMeta = sendFrameMeta;        this.bitRate = bitRate;        this.maxFps = maxFps;        this.iFrameInterval = iFrameInterval;    }
    private static void scrcpy(Options options) throws IOException {        Ln.i("Device: " + Build.MANUFACTURER + " " + Build.MODEL + " (Android " + Build.VERSION.RELEASE + ")");        final Device device = new Device(options);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate(), options.getMaxFps(),                    options.getLockedVideoOrientation());            if (options.getControl()) {                Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    private static void scrcpy(Options options) throws IOException {        Ln.i("Device: " + Build.MANUFACTURER + " " + Build.MODEL + " (Android " + Build.VERSION.RELEASE + ")");        final Device device = new Device(options);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate(), options.getMaxFps());            if (options.getControl()) {                Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
run_wait_server(void *data) {    struct server *server = data;    cmd_simple_wait(server->process, NULL); // ignore exit code    // no need for synchronization, server_socket is initialized before this    // thread was created    if (server->server_socket != INVALID_SOCKET            && !atomic_flag_test_and_set(&server->server_socket_closed)) {        // On Linux, accept() is unblocked by shutdown(), but on Windows, it is        // unblocked by closesocket(). Therefore, call both (close_socket()).        close_socket(server->server_socket);    }    LOGD("Server terminated");    return 0;}
server_destroy(struct server *server) {    SDL_free(server->serial);}
server_init(struct server *server) {    server->serial = NULL;    server->process = PROCESS_NONE;    server->wait_server_thread = NULL;    atomic_flag_clear_explicit(&server->server_socket_closed,                               memory_order_relaxed);    server->server_socket = INVALID_SOCKET;    server->video_socket = INVALID_SOCKET;    server->control_socket = INVALID_SOCKET;    server->port_range.first = 0;    server->port_range.last = 0;    server->local_port = 0;    server->tunnel_enabled = false;    server->tunnel_forward = false;    return true;}
server_stop(struct server *server) {    if (server->server_socket != INVALID_SOCKET            && !atomic_flag_test_and_set(&server->server_socket_closed)) {        close_socket(server->server_socket);    }    if (server->video_socket != INVALID_SOCKET) {        close_socket(server->video_socket);    }    if (server->control_socket != INVALID_SOCKET) {        close_socket(server->control_socket);    }    assert(server->process != PROCESS_NONE);    cmd_terminate(server->process);    if (server->tunnel_enabled) {        // ignore failure        disable_tunnel(server);    }    SDL_WaitThread(server->wait_server_thread, NULL);}
run_wait_server(void *data) {    struct server *server = data;    cmd_simple_wait(server->process, NULL); // ignore exit code    mutex_lock(server->mutex);    server->process_terminated = true;    cond_signal(server->process_terminated_cond);    mutex_unlock(server->mutex);    // no need for synchronization, server_socket is initialized before this    // thread was created    if (server->server_socket != INVALID_SOCKET            && !atomic_flag_test_and_set(&server->server_socket_closed)) {        // On Linux, accept() is unblocked by shutdown(), but on Windows, it is        // unblocked by closesocket(). Therefore, call both (close_socket()).        close_socket(server->server_socket);    }    LOGD("Server terminated");    return 0;}
server_destroy(struct server *server) {    SDL_free(server->serial);    SDL_DestroyCond(server->process_terminated_cond);    SDL_DestroyMutex(server->mutex);}
server_init(struct server *server) {    server->serial = NULL;    server->process = PROCESS_NONE;    server->wait_server_thread = NULL;    atomic_flag_clear_explicit(&server->server_socket_closed,                               memory_order_relaxed);    server->mutex = SDL_CreateMutex();    if (!server->mutex) {        return false;    }    server->process_terminated_cond = SDL_CreateCond();    if (!server->process_terminated_cond) {        SDL_DestroyMutex(server->mutex);        return false;    }    server->process_terminated = false;    server->server_socket = INVALID_SOCKET;    server->video_socket = INVALID_SOCKET;    server->control_socket = INVALID_SOCKET;    server->port_range.first = 0;    server->port_range.last = 0;    server->local_port = 0;    server->tunnel_enabled = false;    server->tunnel_forward = false;    return true;}
server_stop(struct server *server) {    if (server->server_socket != INVALID_SOCKET            && !atomic_flag_test_and_set(&server->server_socket_closed)) {        close_socket(server->server_socket);    }    if (server->video_socket != INVALID_SOCKET) {        close_socket(server->video_socket);    }    if (server->control_socket != INVALID_SOCKET) {        close_socket(server->control_socket);    }    assert(server->process != PROCESS_NONE);    if (server->tunnel_enabled) {        // ignore failure        disable_tunnel(server);    }    // Give some delay for the server to terminate properly    mutex_lock(server->mutex);    int r = 0;    if (!server->process_terminated) {#define WATCHDOG_DELAY_MS 1000        r = cond_wait_timeout(server->process_terminated_cond,                              server->mutex,                              WATCHDOG_DELAY_MS);    }    mutex_unlock(server->mutex);    // After this delay, kill the server if it's not dead already.    // On some devices, closing the sockets is not sufficient to wake up the    // blocking calls while the device is asleep.    if (r == SDL_MUTEX_TIMEDOUT) {        // FIXME There is a race condition here: there is a small chance that        // the process is already terminated, and the PID assigned to a new        // process.        LOGW("Killing the server...");        cmd_terminate(server->process);    }    SDL_WaitThread(server->wait_server_thread, NULL);}
    public boolean setClipboardText(String text) {        return serviceManager.getClipboardManager().setText(text);    }
    public Device(Options options) {        displayId = options.getDisplayId();        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo(displayId);        if (displayInfo == null) {            int[] displayIds = serviceManager.getDisplayManager().getDisplayIds();            throw new InvalidDisplayIdException(displayId, displayIds);        }        int displayInfoFlags = displayInfo.getFlags();        screenInfo = ScreenInfo.computeScreenInfo(displayInfo, options.getCrop(), options.getMaxSize(), options.getLockedVideoOrientation());        layerStack = displayInfo.getLayerStack();        serviceManager.getWindowManager().registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) {                synchronized (Device.this) {                    screenInfo = screenInfo.withDeviceRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        }, displayId);        if (options.getControl()) {            // If control is enabled, synchronize Android clipboard to the computer automatically            serviceManager.getClipboardManager().addPrimaryClipChangedListener(new IOnPrimaryClipChangedListener.Stub() {                @Override                public void dispatchPrimaryClipChanged() {                    synchronized (Device.this) {                        if (clipboardListener != null) {                            String text = getClipboardText();                            if (text != null) {                                clipboardListener.onClipboardTextChanged(text);                            }                        }                    }                }            });        }        if ((displayInfoFlags & DisplayInfo.FLAG_SUPPORTS_PROTECTED_BUFFERS) == 0) {            Ln.w("Display doesn't have FLAG_SUPPORTS_PROTECTED_BUFFERS flag, mirroring can be restricted");        }        // main display or any display on Android >= Q        supportsInputEvents = displayId == 0 || Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q;        if (!supportsInputEvents) {            Ln.w("Input events are not supported for secondary displays before Android 10");        }    }
    public boolean setClipboardText(String text) {        isSettingClipboard.set(true);        boolean ok = serviceManager.getClipboardManager().setText(text);        isSettingClipboard.set(false);        return ok;    }
    public Device(Options options) {        displayId = options.getDisplayId();        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo(displayId);        if (displayInfo == null) {            int[] displayIds = serviceManager.getDisplayManager().getDisplayIds();            throw new InvalidDisplayIdException(displayId, displayIds);        }        int displayInfoFlags = displayInfo.getFlags();        screenInfo = ScreenInfo.computeScreenInfo(displayInfo, options.getCrop(), options.getMaxSize(), options.getLockedVideoOrientation());        layerStack = displayInfo.getLayerStack();        serviceManager.getWindowManager().registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) {                synchronized (Device.this) {                    screenInfo = screenInfo.withDeviceRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        }, displayId);        if (options.getControl()) {            // If control is enabled, synchronize Android clipboard to the computer automatically            serviceManager.getClipboardManager().addPrimaryClipChangedListener(new IOnPrimaryClipChangedListener.Stub() {                @Override                public void dispatchPrimaryClipChanged() {                    if (isSettingClipboard.get()) {                        // This is a notification for the change we are currently applying, ignore it                        return;                    }                    synchronized (Device.this) {                        if (clipboardListener != null) {                            String text = getClipboardText();                            if (text != null) {                                clipboardListener.onClipboardTextChanged(text);                            }                        }                    }                }            });        }        if ((displayInfoFlags & DisplayInfo.FLAG_SUPPORTS_PROTECTED_BUFFERS) == 0) {            Ln.w("Display doesn't have FLAG_SUPPORTS_PROTECTED_BUFFERS flag, mirroring can be restricted");        }        // main display or any display on Android >= Q        supportsInputEvents = displayId == 0 || Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q;        if (!supportsInputEvents) {            Ln.w("Input events are not supported for secondary displays before Android 10");        }    }
convert_touch(const SDL_TouchFingerEvent *from, struct screen *screen,              struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_touch_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = from->fingerId;    to->inject_touch_event.position.screen_size = screen->frame_size;    // SDL touch event coordinates are normalized in the range [0; 1]    float x = from->x * screen->content_size.width;    float y = from->y * screen->content_size.height;    to->inject_touch_event.position.point = rotate_position(screen, x, y);    to->inject_touch_event.pressure = from->pressure;    to->inject_touch_event.buttons = 0;    return true;}
rotate_position(struct screen *screen, int32_t x, int32_t y) {    unsigned rotation = screen->rotation;    assert(rotation < 4);    int32_t w = screen->content_size.width;    int32_t h = screen->content_size.height;    struct point result;    switch (rotation) {        case 0:            result.x = x;            result.y = y;            break;        case 1:            result.x = h - y;            result.y = x;            break;        case 2:            result.x = w - x;            result.y = h - y;            break;        default:            assert(rotation == 3);            result.x = y;            result.y = w - x;            break;    }    return result;}
convert_mouse_button(const SDL_MouseButtonEvent *from, struct screen *screen,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_mouse_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen->frame_size;    to->inject_touch_event.position.point =        rotate_position(screen, from->x, from->y);    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons =        convert_mouse_buttons(SDL_BUTTON(from->button));    return true;}
convert_mouse_motion(const SDL_MouseMotionEvent *from, struct screen *screen,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    to->inject_touch_event.action = AMOTION_EVENT_ACTION_MOVE;    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen->frame_size;    to->inject_touch_event.position.point =        rotate_position(screen, from->x, from->y);    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons = convert_mouse_buttons(from->state);    return true;}
convert_touch(const SDL_TouchFingerEvent *from, struct screen *screen,              struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_touch_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = from->fingerId;    to->inject_touch_event.position.screen_size = screen->frame_size;    // SDL touch event coordinates are normalized in the range [0; 1]    float x = from->x * screen->content_size.width;    float y = from->y * screen->content_size.height;    to->inject_touch_event.position.point =        screen_convert_to_frame_coords(screen, x, y);    to->inject_touch_event.pressure = from->pressure;    to->inject_touch_event.buttons = 0;    return true;}
convert_mouse_motion(const SDL_MouseMotionEvent *from, struct screen *screen,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    to->inject_touch_event.action = AMOTION_EVENT_ACTION_MOVE;    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen->frame_size;    to->inject_touch_event.position.point =        screen_convert_to_frame_coords(screen, from->x, from->y);    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons = convert_mouse_buttons(from->state);    return true;}voidinput_manager_process_mouse_motion(struct input_manager *im,                                   const SDL_MouseMotionEvent *event) {    if (!event->state) {        // do not send motion events when no button is pressed        return;    }    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    struct control_msg msg;    if (convert_mouse_motion(event, im->screen, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject mouse motion event'");
convert_mouse_button(const SDL_MouseButtonEvent *from, struct screen *screen,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_mouse_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen->frame_size;    to->inject_touch_event.position.point =        screen_convert_to_frame_coords(screen, from->x, from->y);    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons =        convert_mouse_buttons(SDL_BUTTON(from->button));    return true;}
convert_mouse_motion(const SDL_MouseMotionEvent *from, struct screen *screen,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    to->inject_touch_event.action = AMOTION_EVENT_ACTION_MOVE;    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen->frame_size;    to->inject_touch_event.position.point =        screen_convert_to_frame_coords(screen, from->x, from->y);    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons = convert_mouse_buttons(from->state);    return true;}
    LOGD("Switched to %s mode", screen->fullscreen ? "fullscreen" : "windowed");    screen_render(screen);}voidscreen_resize_to_fit(struct screen *screen) {    if (screen->fullscreen) {        return;    }    if (screen->maximized) {        SDL_RestoreWindow(screen->window);        screen->maximized = false;    }
screen_convert_to_frame_coords(struct screen *screen, int32_t x, int32_t y) {    unsigned rotation = screen->rotation;    assert(rotation < 4);    int32_t w = screen->content_size.width;    int32_t h = screen->content_size.height;    struct point result;    switch (rotation) {        case 0:            result.x = x;            result.y = y;            break;        case 1:            result.x = h - y;            result.y = x;            break;        case 2:            result.x = w - x;            result.y = h - y;            break;        default:            assert(rotation == 3);            result.x = y;            result.y = w - x;            break;    }    return result;}
    private static void unlinkSelf() {        try {            new File(SERVER_PATH).delete();        } catch (Exception e) {            Ln.e("Could not unlink server", e);        }    }
    private static void scrcpy(Options options) throws IOException {        Ln.i("Device: " + Build.MANUFACTURER + " " + Build.MODEL + " (Android " + Build.VERSION.RELEASE + ")");        final Device device = new Device(options);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate(), options.getMaxFps());            if (options.getControl()) {                Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    public static void main(String... args) throws Exception {        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {            @Override            public void uncaughtException(Thread t, Throwable e) {                Ln.e("Exception on thread " + t, e);                suggestFix(e);            }        });        unlinkSelf();        Options options = createOptions(args);        scrcpy(options);    }}
    private static void suggestFix(Throwable e) {        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {            if (e instanceof MediaCodec.CodecException) {                MediaCodec.CodecException mce = (MediaCodec.CodecException) e;                if (mce.getErrorCode() == 0xfffffc0e) {                    Ln.e("The hardware encoder is not able to encode at the given definition.");                    Ln.e("Try with a lower definition:");
    private static void scrcpy(Options options) throws IOException {        Ln.i("Device: " + Build.MANUFACTURER + " " + Build.MODEL + " (Android " + Build.VERSION.RELEASE + ")");        final Device device = new Device(options);        CleanUp.configure();        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate(), options.getMaxFps());            if (options.getControl()) {                Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
        });        Options options = createOptions(args);        scrcpy(options);    }}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device (and paste if the device\n"        "        runs Android >= 7)\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device (and paste if the device\n"        "        runs Android >= 7)\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = im->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && !shift && down) {                    set_screen_power_mode(controller, SCREEN_POWER_MODE_OFF);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (cmd && !shift && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (cmd && !shift && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && cmd && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && cmd && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && cmd && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = im->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (cmd && !shift && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (cmd && !shift && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && cmd && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && cmd && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && cmd && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    --no-key-repeat\n"        "        Do not forward repeated key events when a key is held down.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    --shortcut-mod key[+...]][,...]\n"        "        Specify the modifiers to use for scrcpy shortcuts.\n"        "        Possible keys are \"lctrl\", \"rctrl\", \"lalt\", \"ralt\",\n"        "        \"lsuper\" and \"rsuper\".\n"        "\n"        "        A shortcut can consist in several keys, separated by '+'.\n"        "        Several shortcuts can be specified, separated by ','.\n"        "\n"        "        For example, to use either LCtrl+LAlt or LSuper for scrcpy\n"        "        shortcuts, pass \"lctrl+lalt,lsuper\".\n"        "\n"        "        Default is \"lalt,lsuper\" (left-Alt or left-Super).\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    In the following list, MOD is the shortcut modifier. By default,\n"        "    it's (left) Alt or (left) Super, but it can be configured by\n"        "    --shortcut-mod.\n"        "\n"        "    MOD+f\n"        "        Switch fullscreen mode\n"        "\n"        "    MOD+Left\n"        "        Rotate display left\n"        "\n"        "    MOD+Right\n"        "        Rotate display right\n"        "\n"        "    MOD+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    MOD+w\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    MOD+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    MOD+b\n"        "    MOD+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    MOD+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    MOD+m\n"        "        Click on MENU\n"        "\n"        "    MOD+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    MOD+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    MOD+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    MOD+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    MOD+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    MOD+r\n"        "        Rotate device screen\n"        "\n"        "    MOD+n\n"        "        Expand notification panel\n"        "\n"        "    MOD+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    MOD+c\n"        "        Copy to clipboard (inject COPY keycode, Android >= 7 only)\n"        "\n"        "    MOD+x\n"        "        Cut to clipboard (inject CUT keycode, Android >= 7 only)\n"        "\n"        "    MOD+v\n"        "        Copy computer clipboard to device, then paste (inject PASTE\n"        "        keycode, Android >= 7 only)\n"        "\n"        "    MOD+Shift+v\n"        "        Inject computer clipboard text as a sequence of key events\n"        "\n"        "    MOD+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    --no-key-repeat\n"        "        Do not forward repeated key events when a key is held down.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    --shortcut-mod key[+...]][,...]\n"        "        Specify the modifiers to use for scrcpy shortcuts.\n"        "        Possible keys are \"lctrl\", \"rctrl\", \"lalt\", \"ralt\",\n"        "        \"lsuper\" and \"rsuper\".\n"        "\n"        "        A shortcut can consist in several keys, separated by '+'.\n"        "        Several shortcuts can be specified, separated by ','.\n"        "\n"        "        For example, to use either LCtrl+LAlt or LSuper for scrcpy\n"        "        shortcuts, pass \"lctrl+lalt,lsuper\".\n"        "\n"        "        Default is \"lalt,lsuper\" (left-Alt or left-Super).\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    In the following list, MOD is the shortcut modifier. By default,\n"        "    it's (left) Alt or (left) Super, but it can be configured by\n"        "    --shortcut-mod.\n"        "\n"        "    MOD+f\n"        "        Switch fullscreen mode\n"        "\n"        "    MOD+Left\n"        "        Rotate display left\n"        "\n"        "    MOD+Right\n"        "        Rotate display right\n"        "\n"        "    MOD+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    MOD+w\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    MOD+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    MOD+b\n"        "    MOD+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    MOD+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    MOD+m\n"        "        Click on MENU\n"        "\n"        "    MOD+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    MOD+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    MOD+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    MOD+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    MOD+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    MOD+r\n"        "        Rotate device screen\n"        "\n"        "    MOD+n\n"        "        Expand notification panel\n"        "\n"        "    MOD+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    MOD+c\n"        "        Copy to clipboard (inject COPY keycode, Android >= 7 only)\n"        "\n"        "    MOD+x\n"        "        Cut to clipboard (inject CUT keycode, Android >= 7 only)\n"        "\n"        "    MOD+v\n"        "        Copy computer clipboard to device, then paste (inject PASTE\n"        "        keycode, Android >= 7 only)\n"        "\n"        "    MOD+Shift+v\n"        "        Inject computer clipboard text as a sequence of key events\n"        "\n"        "    MOD+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Ctrl+click-and-move\n"        "        Pinch-to-zoom from the center of the screen\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
input_manager_process_mouse_motion(struct input_manager *im,                                   const SDL_MouseMotionEvent *event) {    if (!event->state) {        // do not send motion events when no button is pressed        return;    }    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    struct control_msg msg;    if (convert_mouse_motion(event, im->screen, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject mouse motion event'");        }    }}
input_manager_process_mouse_motion(struct input_manager *im,                                   const SDL_MouseMotionEvent *event) {    if (!event->state) {        // do not send motion events when no button is pressed        return;    }    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    struct control_msg msg;    if (convert_mouse_motion(event, im->screen, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject mouse motion event'");        }    }}
input_manager_init(struct input_manager *im,                   const struct scrcpy_options *options){    im->control = options->control;    im->forward_key_repeat = options->forward_key_repeat;    im->prefer_text = options->prefer_text;    const struct sc_shortcut_mods *shortcut_mods = &options->shortcut_mods;    assert(shortcut_mods->count);    assert(shortcut_mods->count < SC_MAX_SHORTCUT_MODS);    for (unsigned i = 0; i < shortcut_mods->count; ++i) {        uint16_t sdl_mod = to_sdl_mod(shortcut_mods->data[i]);        assert(sdl_mod);        im->sdl_shortcut_mods.data[i] = sdl_mod;    }    im->sdl_shortcut_mods.count = shortcut_mods->count;}
input_manager_process_mouse_button(struct input_manager *im,                                   const SDL_MouseButtonEvent *event) {    bool control = im->control;    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (control && event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(im->controller);            return;        }        if (control && event->button == SDL_BUTTON_MIDDLE) {            action_home(im->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            int32_t x = event->x;            int32_t y = event->y;            screen_hidpi_scale_coords(im->screen, &x, &y);            SDL_Rect *r = &im->screen->rect;            bool outside = x < r->x || x >= r->x + r->w                        || y < r->y || y >= r->y + r->h;            if (outside) {                screen_resize_to_fit(im->screen);                return;            }        }        // otherwise, send the click event to the device    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_mouse_button(event, im->screen, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject mouse button event'");        }    }}
input_manager_process_mouse_button(struct input_manager *im,                                   const SDL_MouseButtonEvent *event) {    bool control = im->control;    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (control && event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(im->controller);            return;        }        if (control && event->button == SDL_BUTTON_MIDDLE) {            action_home(im->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            int32_t x = event->x;            int32_t y = event->y;            screen_hidpi_scale_coords(im->screen, &x, &y);            SDL_Rect *r = &im->screen->rect;            bool outside = x < r->x || x >= r->x + r->w                        || y < r->y || y >= r->y + r->h;            if (outside) {                screen_resize_to_fit(im->screen);                return;            }        }        // otherwise, send the click event to the device    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_mouse_button(event, im->screen, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject mouse button event'");        }    }}
input_manager_process_mouse_motion(struct input_manager *im,                                   const SDL_MouseMotionEvent *event) {    if (!event->state) {        // do not send motion events when no button is pressed        return;    }    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    struct control_msg msg;    if (!convert_mouse_motion(event, im->screen, &msg)) {        return;    }    if (!controller_push_msg(im->controller, &msg)) {        LOGW("Could not request 'inject mouse motion event'");    }    if (im->vfinger_down) {        struct point mouse = msg.inject_touch_event.position.point;        struct point vfinger = inverse_point(mouse, im->screen->frame_size);        simulate_virtual_finger(im, AMOTION_EVENT_ACTION_MOVE, vfinger);    }}
simulate_virtual_finger(struct input_manager *im,                        enum android_motionevent_action action,                        struct point point) {    bool up = action == AMOTION_EVENT_ACTION_UP;    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    msg.inject_touch_event.action = action;    msg.inject_touch_event.position.screen_size = im->screen->frame_size;    msg.inject_touch_event.position.point = point;    msg.inject_touch_event.pointer_id = POINTER_ID_VIRTUAL_FINGER;    msg.inject_touch_event.pressure = up ? 0.0f : 1.0f;    msg.inject_touch_event.buttons = 0;    if (!controller_push_msg(im->controller, &msg)) {        LOGW("Could not request 'inject virtual finger event'");        return false;    }    return true;}
input_manager_init(struct input_manager *im,                   const struct scrcpy_options *options){    im->control = options->control;    im->forward_key_repeat = options->forward_key_repeat;    im->prefer_text = options->prefer_text;    const struct sc_shortcut_mods *shortcut_mods = &options->shortcut_mods;    assert(shortcut_mods->count);    assert(shortcut_mods->count < SC_MAX_SHORTCUT_MODS);    for (unsigned i = 0; i < shortcut_mods->count; ++i) {        uint16_t sdl_mod = to_sdl_mod(shortcut_mods->data[i]);        assert(sdl_mod);        im->sdl_shortcut_mods.data[i] = sdl_mod;    }    im->sdl_shortcut_mods.count = shortcut_mods->count;    im->vfinger_down = false;}
input_manager_process_mouse_button(struct input_manager *im,                                   const SDL_MouseButtonEvent *event) {    bool control = im->control;    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    bool down = event->type == SDL_MOUSEBUTTONDOWN;    if (down) {        if (control && event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(im->controller);            return;        }        if (control && event->button == SDL_BUTTON_MIDDLE) {            action_home(im->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            int32_t x = event->x;            int32_t y = event->y;            screen_hidpi_scale_coords(im->screen, &x, &y);            SDL_Rect *r = &im->screen->rect;            bool outside = x < r->x || x >= r->x + r->w                        || y < r->y || y >= r->y + r->h;            if (outside) {                screen_resize_to_fit(im->screen);                return;            }        }        // otherwise, send the click event to the device    }    if (!control) {        return;    }    struct control_msg msg;    if (!convert_mouse_button(event, im->screen, &msg)) {        return;    }    if (!controller_push_msg(im->controller, &msg)) {        LOGW("Could not request 'inject mouse button event'");        return;    }    // Pinch-to-zoom simulation.    //    // If Ctrl is hold when the left-click button is pressed, then    // pinch-to-zoom mode is enabled: on every mouse event until the left-click    // button is released, an additional "virtual finger" event is generated,    // having a position inverted through the center of the screen.    //    // In other words, the center of the rotation/scaling is the center of the    // screen.#define CTRL_PRESSED (SDL_GetModState() & (KMOD_LCTRL | KMOD_RCTRL))    if ((down && !im->vfinger_down && CTRL_PRESSED)            || (!down && im->vfinger_down)) {        struct point mouse = msg.inject_touch_event.position.point;        struct point vfinger = inverse_point(mouse, im->screen->frame_size);        enum android_motionevent_action action = down                                               ? AMOTION_EVENT_ACTION_DOWN                                               : AMOTION_EVENT_ACTION_UP;        if (!simulate_virtual_finger(im, action, vfinger)) {            return;        }        im->vfinger_down = down;    }}
inverse_point(struct point point, struct size size) {    point.x = size.width - point.x;    point.y = size.height - point.y;    return point;}
// apply the windowed window size if fullscreen and maximized are disabledstatic voidapply_windowed_size(struct screen *screen) {    if (!screen->fullscreen && !screen->maximized) {        SDL_SetWindowSize(screen->window, screen->windowed_window_size.width,                                          screen->windowed_window_size.height);    }}// set the window size to be applied when fullscreen is disabled
prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width            || screen->frame_size.height != new_frame_size.height) {        struct size new_content_size =            get_rotated_size(new_frame_size, screen->rotation);        if (SDL_RenderSetLogicalSize(screen->renderer,                                     new_content_size.width,                                     new_content_size.height)) {            LOGE("Could not set renderer logical size: %s", SDL_GetError());            return false;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        struct size content_size = screen->content_size;        struct size windowed_size = get_windowed_window_size(screen);        struct size target_size = {            (uint32_t) windowed_size.width * new_content_size.width                    / content_size.width,            (uint32_t) windowed_size.height * new_content_size.height                    / content_size.height,        };        target_size = get_optimal_size(target_size, new_content_size);        set_window_size(screen, target_size);        screen->frame_size = new_frame_size;        screen->content_size = new_content_size;        LOGI("New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = create_texture(screen);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return false;        }    }    return true;}
screen_set_rotation(struct screen *screen, unsigned rotation) {    assert(rotation < 4);    if (rotation == screen->rotation) {        return;    }    struct size old_content_size = screen->content_size;    struct size new_content_size =        get_rotated_size(screen->frame_size, rotation);    if (SDL_RenderSetLogicalSize(screen->renderer,                                 new_content_size.width,                                 new_content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        return;    }    struct size windowed_size = get_windowed_window_size(screen);    struct size target_size = {        .width = (uint32_t) windowed_size.width * new_content_size.width                / old_content_size.width,        .height = (uint32_t) windowed_size.height * new_content_size.height                / old_content_size.height,    };    target_size = get_optimal_size(target_size, new_content_size);    set_window_size(screen, target_size);    screen->content_size = new_content_size;    screen->rotation = rotation;    LOGI("Display rotation set to %u", rotation);    screen_render(screen);}
set_content_size(struct screen *screen, struct size new_content_size) {    struct size old_content_size = screen->content_size;    struct size windowed_size = get_windowed_window_size(screen);    struct size target_size = {        .width = (uint32_t) windowed_size.width * new_content_size.width                / old_content_size.width,        .height = (uint32_t) windowed_size.height * new_content_size.height                / old_content_size.height,    };    target_size = get_optimal_size(target_size, new_content_size);    set_window_size(screen, target_size);    screen->content_size = new_content_size;}
prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width            || screen->frame_size.height != new_frame_size.height) {        struct size new_content_size =            get_rotated_size(new_frame_size, screen->rotation);        if (SDL_RenderSetLogicalSize(screen->renderer,                                     new_content_size.width,                                     new_content_size.height)) {            LOGE("Could not set renderer logical size: %s", SDL_GetError());            return false;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        set_content_size(screen, new_content_size);        screen->frame_size = new_frame_size;        LOGI("New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = create_texture(screen);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return false;        }    }    return true;}
screen_set_rotation(struct screen *screen, unsigned rotation) {    assert(rotation < 4);    if (rotation == screen->rotation) {        return;    }    struct size new_content_size =        get_rotated_size(screen->frame_size, rotation);    if (SDL_RenderSetLogicalSize(screen->renderer,                                 new_content_size.width,                                 new_content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        return;    }    set_content_size(screen, new_content_size);    screen->rotation = rotation;    LOGI("Display rotation set to %u", rotation);    screen_render(screen);}
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps) {        this(sendFrameMeta, bitRate, maxFps, DEFAULT_I_FRAME_INTERVAL);    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps, int iFrameInterval) {        this.sendFrameMeta = sendFrameMeta;        this.bitRate = bitRate;        this.maxFps = maxFps;        this.iFrameInterval = iFrameInterval;    }
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        Workarounds.prepareMainLooper();        Workarounds.fillAppInfo();        MediaFormat format = createFormat(bitRate, maxFps, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                ScreenInfo screenInfo = device.getScreenInfo();                Rect contentRect = screenInfo.getContentRect();                // include the locked video orientation                Rect videoRect = screenInfo.getVideoSize().toRect();                // does not include the locked video orientation                Rect unlockedVideoRect = screenInfo.getUnlockedVideoSize().toRect();                int videoRotation = screenInfo.getVideoRotation();                int layerStack = device.getLayerStack();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, videoRotation, contentRect, unlockedVideoRect, layerStack);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps) {        this.sendFrameMeta = sendFrameMeta;        this.bitRate = bitRate;        this.maxFps = maxFps;    }
        this.sendFrameMeta = sendFrameMeta;        this.bitRate = bitRate;        this.maxFps = maxFps;    }    @Override    public void onRotationChanged(int rotation) {
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        Workarounds.prepareMainLooper();        Workarounds.fillAppInfo();        MediaFormat format = createFormat(bitRate, maxFps, DEFAULT_I_FRAME_INTERVAL);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                ScreenInfo screenInfo = device.getScreenInfo();                Rect contentRect = screenInfo.getContentRect();                // include the locked video orientation                Rect videoRect = screenInfo.getVideoSize().toRect();                // does not include the locked video orientation                Rect unlockedVideoRect = screenInfo.getUnlockedVideoSize().toRect();                int videoRotation = screenInfo.getVideoRotation();                int layerStack = device.getLayerStack();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, videoRotation, contentRect, unlockedVideoRect, layerStack);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
scrcpy(const struct scrcpy_options *options) {    if (!server_init(&server)) {        return false;    }    bool server_started = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    bool record = !!options->record_filename;    struct server_params params = {        .log_level = options->log_level,        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,        .show_touches = options->show_touches,        .stay_awake = options->stay_awake,        .codec_options = options->codec_options,        .encoder_name = options->encoder_name,        .force_adb_forward = options->force_adb_forward,    };    if (!server_start(&server, options->serial, &params)) {        goto end;    }    server_started = true;    if (!sdl_init_and_configure(options->display, options->render_driver,                                options->disable_screensaver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options->mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    input_manager_init(&input_manager, options);    bool ret = event_loop(options);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    if (server_started) {        // shutdown the sockets and kill the server        server_stop(&server);    }    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    if (!server_init(&server)) {        return false;    }    bool ret = false;    bool server_started = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    bool record = !!options->record_filename;    struct server_params params = {        .log_level = options->log_level,        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,        .show_touches = options->show_touches,        .stay_awake = options->stay_awake,        .codec_options = options->codec_options,        .encoder_name = options->encoder_name,        .force_adb_forward = options->force_adb_forward,    };    if (!server_start(&server, options->serial, &params)) {        goto end;    }    server_started = true;    if (!sdl_init_and_configure(options->display, options->render_driver,                                options->disable_screensaver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options->mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    input_manager_init(&input_manager, options);    ret = event_loop(options);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    if (server_started) {        // shutdown the sockets and kill the server        server_stop(&server);    }    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    server_destroy(&server);    return ret;}
control_msg_serialize(const struct control_msg *msg, unsigned char *buf) {    buf[0] = msg->type;    switch (msg->type) {        case CONTROL_MSG_TYPE_INJECT_KEYCODE:            buf[1] = msg->inject_keycode.action;            buffer_write32be(&buf[2], msg->inject_keycode.keycode);            buffer_write32be(&buf[6], msg->inject_keycode.metastate);            return 10;        case CONTROL_MSG_TYPE_INJECT_TEXT: {            size_t len = write_string(msg->inject_text.text,                                      CONTROL_MSG_TEXT_MAX_LENGTH, &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_INJECT_MOUSE_EVENT:            buf[1] = msg->inject_mouse_event.action;            buffer_write32be(&buf[2], msg->inject_mouse_event.buttons);            write_position(&buf[6], &msg->inject_mouse_event.position);            return 18;        case CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT:            write_position(&buf[1], &msg->inject_scroll_event.position);            buffer_write32be(&buf[13],                             (uint32_t) msg->inject_scroll_event.hscroll);            buffer_write32be(&buf[17],                             (uint32_t) msg->inject_scroll_event.vscroll);            return 21;        case CONTROL_MSG_TYPE_SET_CLIPBOARD: {            size_t len = write_string(msg->inject_text.text,                                      CONTROL_MSG_CLIPBOARD_TEXT_MAX_LENGTH,                                      &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE:            buf[1] = msg->set_screen_power_mode.mode;            return 2;        case CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_GET_CLIPBOARD:            // no additional data            return 1;        default:            LOGW("Unknown message type: %u", (unsigned) msg->type);            return 0;    }}
control_msg_serialize(const struct control_msg *msg, unsigned char *buf) {    buf[0] = msg->type;    switch (msg->type) {        case CONTROL_MSG_TYPE_INJECT_KEYCODE:            buf[1] = msg->inject_keycode.action;            buffer_write32be(&buf[2], msg->inject_keycode.keycode);            buffer_write32be(&buf[6], msg->inject_keycode.metastate);            return 10;        case CONTROL_MSG_TYPE_INJECT_TEXT: {            size_t len = write_string(msg->inject_text.text,                                      CONTROL_MSG_TEXT_MAX_LENGTH, &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_INJECT_MOUSE_EVENT:            buf[1] = msg->inject_mouse_event.action;            buffer_write32be(&buf[2], msg->inject_mouse_event.buttons);            write_position(&buf[6], &msg->inject_mouse_event.position);            return 18;        case CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT:            write_position(&buf[1], &msg->inject_scroll_event.position);            buffer_write32be(&buf[13],                             (uint32_t) msg->inject_scroll_event.hscroll);            buffer_write32be(&buf[17],                             (uint32_t) msg->inject_scroll_event.vscroll);            return 21;        case CONTROL_MSG_TYPE_SET_CLIPBOARD: {            size_t len = write_string(msg->inject_text.text,                                      CONTROL_MSG_CLIPBOARD_TEXT_MAX_LENGTH,                                      &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE:            buf[1] = msg->set_screen_power_mode.mode;            return 2;        case CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_GET_CLIPBOARD:            // no additional data            return 1;        default:            LOGW("Unknown message type: %u", (unsigned) msg->type);            return 0;    }}
control_msg_serialize(const struct control_msg *msg, unsigned char *buf) {    buf[0] = msg->type;    switch (msg->type) {        case CONTROL_MSG_TYPE_INJECT_KEYCODE:            buf[1] = msg->inject_keycode.action;            buffer_write32be(&buf[2], msg->inject_keycode.keycode);            buffer_write32be(&buf[6], msg->inject_keycode.metastate);            return 10;        case CONTROL_MSG_TYPE_INJECT_TEXT: {            size_t len = write_string(msg->inject_text.text,                                      CONTROL_MSG_TEXT_MAX_LENGTH, &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_INJECT_MOUSE_EVENT:            buf[1] = msg->inject_mouse_event.action;            buffer_write32be(&buf[2], msg->inject_mouse_event.buttons);            write_position(&buf[6], &msg->inject_mouse_event.position);            return 18;        case CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT:            buf[1] = msg->inject_touch_event.action;            buffer_write64be(&buf[2], msg->inject_touch_event.pointer_id);            write_position(&buf[10], &msg->inject_touch_event.position);            uint16_t pressure =                to_fixed_point_16(msg->inject_touch_event.pressure);            buffer_write16be(&buf[22], pressure);            return 24;        case CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT:            write_position(&buf[1], &msg->inject_scroll_event.position);            buffer_write32be(&buf[13],                             (uint32_t) msg->inject_scroll_event.hscroll);            buffer_write32be(&buf[17],                             (uint32_t) msg->inject_scroll_event.vscroll);            return 21;        case CONTROL_MSG_TYPE_SET_CLIPBOARD: {            size_t len = write_string(msg->inject_text.text,                                      CONTROL_MSG_CLIPBOARD_TEXT_MAX_LENGTH,                                      &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE:            buf[1] = msg->set_screen_power_mode.mode;            return 2;        case CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_GET_CLIPBOARD:            // no additional data            return 1;        default:            LOGW("Unknown message type: %u", (unsigned) msg->type);            return 0;    }}
to_fixed_point_16(float f) {    SDL_assert(f >= 0.0f && f <= 1.0f);    uint32_t u = f * 0x1p16f; // 2^16    if (u >= 0xffff) {        u = 0xffff;    }    return (uint16_t) u;}
int main(void) {    test_serialize_inject_keycode();    test_serialize_inject_text();    test_serialize_inject_text_long();    test_serialize_inject_mouse_event();    test_serialize_inject_scroll_event();    test_serialize_back_or_screen_on();    test_serialize_expand_notification_panel();    test_serialize_collapse_notification_panel();    test_serialize_get_clipboard();    test_serialize_set_clipboard();    test_serialize_set_screen_power_mode();    return 0;}
int main(void) {    test_serialize_inject_keycode();    test_serialize_inject_text();    test_serialize_inject_text_long();    test_serialize_inject_mouse_event();    test_serialize_inject_scroll_event();    test_serialize_back_or_screen_on();    test_serialize_expand_notification_panel();    test_serialize_collapse_notification_panel();    test_serialize_get_clipboard();    test_serialize_set_clipboard();    test_serialize_set_screen_power_mode();    return 0;}
int main(void) {    test_serialize_inject_keycode();    test_serialize_inject_text();    test_serialize_inject_text_long();    test_serialize_inject_mouse_event();    test_serialize_inject_touch_event();    test_serialize_inject_scroll_event();    test_serialize_back_or_screen_on();    test_serialize_expand_notification_panel();    test_serialize_collapse_notification_panel();    test_serialize_get_clipboard();    test_serialize_set_clipboard();    test_serialize_set_screen_power_mode();    return 0;}
static void test_serialize_inject_touch_event(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT,        .inject_touch_event = {            .action = AMOTION_EVENT_ACTION_DOWN,            .pointer_id = 0x1234567887654321L,            .position = {                .point = {                    .x = 100,                    .y = 200,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },            .pressure = 1.0f,        },    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 24);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT,        0x00, // AKEY_EVENT_ACTION_DOWN        0x12, 0x34, 0x56, 0x78, 0x87, 0x65, 0x43, 0x21, // pointer id        0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0xc8, // 100 200        0x04, 0x38, 0x07, 0x80, // 1080 1920        0xff, 0xff, // pressure    };    assert(!memcmp(buf, expected, sizeof(expected)));}
    public ControlMessage next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        ControlMessage msg;        switch (type) {            case ControlMessage.TYPE_INJECT_KEYCODE:                msg = parseInjectKeycode();                break;            case ControlMessage.TYPE_INJECT_TEXT:                msg = parseInjectText();                break;            case ControlMessage.TYPE_INJECT_MOUSE_EVENT:                msg = parseInjectMouseEvent();                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                msg = parseInjectScrollEvent();                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                msg = parseSetClipboard();                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                msg = parseSetScreenPowerMode();                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:            case ControlMessage.TYPE_GET_CLIPBOARD:                msg = ControlMessage.createEmpty(type);                break;            default:                Ln.w("Unknown event type: " + type);                msg = null;                break;        }        if (msg == null) {            // failure, reset savedPosition            buffer.position(savedPosition);        }        return msg;    }
    public ControlMessage next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        ControlMessage msg;        switch (type) {            case ControlMessage.TYPE_INJECT_KEYCODE:                msg = parseInjectKeycode();                break;            case ControlMessage.TYPE_INJECT_TEXT:                msg = parseInjectText();                break;            case ControlMessage.TYPE_INJECT_MOUSE_EVENT:                msg = parseInjectMouseEvent();                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                msg = parseInjectTouchEvent();                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                msg = parseInjectScrollEvent();                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                msg = parseSetClipboard();                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                msg = parseSetScreenPowerMode();                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:            case ControlMessage.TYPE_GET_CLIPBOARD:                msg = ControlMessage.createEmpty(type);                break;            default:                Ln.w("Unknown event type: " + type);                msg = null;                break;        }        if (msg == null) {            // failure, reset savedPosition            buffer.position(savedPosition);        }        return msg;    }
        byte[] text = "testé".getBytes(StandardCharsets.UTF_8);        dos.writeShort(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_TEXT, event.getType());        Assert.assertEquals("testé", event.getText());    }    @Test    public void testParseLongTextEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_TEXT);        byte[] text = new byte[ControlMessageReader.TEXT_MAX_LENGTH];        Arrays.fill(text, (byte) 'a');        dos.writeShort(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_TEXT, event.getType());        Assert.assertEquals(new String(text, StandardCharsets.US_ASCII), event.getText());    }    @Test    @SuppressWarnings("checkstyle:MagicNumber")    public void testParseMouseEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_MOUSE_EVENT);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(100);        dos.writeInt(200);        dos.writeShort(1080);        dos.writeShort(1920);
    public void testParseTouchEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_TOUCH_EVENT);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeLong(-42); // pointerId        dos.writeInt(100);        dos.writeInt(200);        dos.writeShort(1080);        dos.writeShort(1920);        dos.writeShort(0xffff); // pressure        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_TOUCH_EVENT, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(-42, event.getPointerId());        Assert.assertEquals(100, event.getPosition().getPoint().getX());        Assert.assertEquals(200, event.getPosition().getPoint().getY());        Assert.assertEquals(1080, event.getPosition().getScreenSize().getWidth());        Assert.assertEquals(1920, event.getPosition().getScreenSize().getHeight());        Assert.assertEquals(1f, event.getPressure(), 0f); // must be exact    }
    public Device(Options options) {        displayId = options.getDisplayId();        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo(displayId);        if (displayInfo == null) {            int[] displayIds = serviceManager.getDisplayManager().getDisplayIds();            throw new InvalidDisplayIdException(displayId, displayIds);        }        int displayInfoFlags = displayInfo.getFlags();        screenInfo = ScreenInfo.computeScreenInfo(displayInfo, options.getCrop(), options.getMaxSize(), options.getLockedVideoOrientation());        layerStack = displayInfo.getLayerStack();        serviceManager.getWindowManager().registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) {                synchronized (Device.this) {                    screenInfo = screenInfo.withDeviceRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        }, displayId);        if ((displayInfoFlags & DisplayInfo.FLAG_SUPPORTS_PROTECTED_BUFFERS) == 0) {            Ln.w("Display doesn't have FLAG_SUPPORTS_PROTECTED_BUFFERS flag, mirroring can be restricted");        }        // main display or any display on Android >= Q        supportsInputEvents = displayId == 0 || Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q;        if (!supportsInputEvents) {            Ln.w("Input events are not supported for secondary displays before Android 10");        }    }
    public Device(Options options) {        displayId = options.getDisplayId();        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo(displayId);        if (displayInfo == null) {            int[] displayIds = serviceManager.getDisplayManager().getDisplayIds();            throw new InvalidDisplayIdException(displayId, displayIds);        }        int displayInfoFlags = displayInfo.getFlags();        screenInfo = ScreenInfo.computeScreenInfo(displayInfo, options.getCrop(), options.getMaxSize(), options.getLockedVideoOrientation());        layerStack = displayInfo.getLayerStack();        serviceManager.getWindowManager().registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) {                synchronized (Device.this) {                    screenInfo = screenInfo.withDeviceRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        }, displayId);        if ((displayInfoFlags & DisplayInfo.FLAG_SUPPORTS_PROTECTED_BUFFERS) == 0) {            Ln.w("Display doesn't have FLAG_SUPPORTS_PROTECTED_BUFFERS flag, mirroring can be restricted");        }        // main display or any display on Android >= Q        supportsInputEvents = displayId == 0 || Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q;        if (!supportsInputEvents) {            Ln.w("Input events are not supported for secondary displays before Android 10");        }    }
    public synchronized void setClipboardListener(ClipboardListener clipboardListener) {        this.clipboardListener = clipboardListener;    }
    public Device(Options options) {        displayId = options.getDisplayId();        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo(displayId);        if (displayInfo == null) {            int[] displayIds = serviceManager.getDisplayManager().getDisplayIds();            throw new InvalidDisplayIdException(displayId, displayIds);        }        int displayInfoFlags = displayInfo.getFlags();        screenInfo = ScreenInfo.computeScreenInfo(displayInfo, options.getCrop(), options.getMaxSize(), options.getLockedVideoOrientation());        layerStack = displayInfo.getLayerStack();        serviceManager.getWindowManager().registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) {                synchronized (Device.this) {                    screenInfo = screenInfo.withDeviceRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        }, displayId);        if (options.getControl()) {            // If control is enabled, synchronize Android clipboard to the computer automatically            serviceManager.getClipboardManager().addPrimaryClipChangedListener(new IOnPrimaryClipChangedListener.Stub() {                @Override                public void dispatchPrimaryClipChanged() {                    synchronized (Device.this) {                        if (clipboardListener != null) {                            String text = getClipboardText();                            if (text != null) {                                clipboardListener.onClipboardTextChanged(text);                            }                        }                    }                }            });        }        if ((displayInfoFlags & DisplayInfo.FLAG_SUPPORTS_PROTECTED_BUFFERS) == 0) {            Ln.w("Display doesn't have FLAG_SUPPORTS_PROTECTED_BUFFERS flag, mirroring can be restricted");        }        // main display or any display on Android >= Q        supportsInputEvents = displayId == 0 || Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q;        if (!supportsInputEvents) {            Ln.w("Input events are not supported for secondary displays before Android 10");        }    }
    private static void scrcpy(Options options) throws IOException {        Ln.i("Device: " + Build.MANUFACTURER + " " + Build.MODEL + " (Android " + Build.VERSION.RELEASE + ")");        final Device device = new Device(options);        boolean mustDisableShowTouchesOnCleanUp = false;        int restoreStayOn = -1;        if (options.getShowTouches() || options.getStayAwake()) {            try (ContentProvider settings = device.createSettingsProvider()) {                if (options.getShowTouches()) {                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_SYSTEM, "show_touches", "1");                    // If "show touches" was disabled, it must be disabled back on clean up                    mustDisableShowTouchesOnCleanUp = !"1".equals(oldValue);                }                if (options.getStayAwake()) {                    int stayOn = BatteryManager.BATTERY_PLUGGED_AC | BatteryManager.BATTERY_PLUGGED_USB | BatteryManager.BATTERY_PLUGGED_WIRELESS;                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_GLOBAL, "stay_on_while_plugged_in", String.valueOf(stayOn));                    try {                        restoreStayOn = Integer.parseInt(oldValue);                        if (restoreStayOn == stayOn) {                            // No need to restore                            restoreStayOn = -1;                        }                    } catch (NumberFormatException e) {                        restoreStayOn = 0;                    }                }            }        }        CleanUp.configure(mustDisableShowTouchesOnCleanUp, restoreStayOn);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate(), options.getMaxFps());            if (options.getControl()) {                Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    private static void scrcpy(Options options) throws IOException {        Ln.i("Device: " + Build.MANUFACTURER + " " + Build.MODEL + " (Android " + Build.VERSION.RELEASE + ")");        final Device device = new Device(options);        boolean mustDisableShowTouchesOnCleanUp = false;        int restoreStayOn = -1;        if (options.getShowTouches() || options.getStayAwake()) {            try (ContentProvider settings = device.createSettingsProvider()) {                if (options.getShowTouches()) {                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_SYSTEM, "show_touches", "1");                    // If "show touches" was disabled, it must be disabled back on clean up                    mustDisableShowTouchesOnCleanUp = !"1".equals(oldValue);                }                if (options.getStayAwake()) {                    int stayOn = BatteryManager.BATTERY_PLUGGED_AC | BatteryManager.BATTERY_PLUGGED_USB | BatteryManager.BATTERY_PLUGGED_WIRELESS;                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_GLOBAL, "stay_on_while_plugged_in", String.valueOf(stayOn));                    try {                        restoreStayOn = Integer.parseInt(oldValue);                        if (restoreStayOn == stayOn) {                            // No need to restore                            restoreStayOn = -1;                        }                    } catch (NumberFormatException e) {                        restoreStayOn = 0;                    }                }            }        }        CleanUp.configure(mustDisableShowTouchesOnCleanUp, restoreStayOn);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate(), options.getMaxFps());            if (options.getControl()) {                final Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());                device.setClipboardListener(new Device.ClipboardListener() {                    @Override                    public void onClipboardTextChanged(String text) {                        controller.getSender().pushClipboardText(text);                    }                });            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    }    private Method getGetPrimaryClipMethod() throws NoSuchMethodException {        if (getPrimaryClipMethod == null) {            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                getPrimaryClipMethod = manager.getClass().getMethod("getPrimaryClip", String.class);            } else {                getPrimaryClipMethod = manager.getClass().getMethod("getPrimaryClip", String.class, int.class);            }        }        return getPrimaryClipMethod;    }    private Method getSetPrimaryClipMethod() throws NoSuchMethodException {        if (setPrimaryClipMethod == null) {            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                setPrimaryClipMethod = manager.getClass().getMethod("setPrimaryClip", ClipData.class, String.class);            } else {                setPrimaryClipMethod = manager.getClass().getMethod("setPrimaryClip", ClipData.class, String.class, int.class);            }        }        return setPrimaryClipMethod;    }    private static ClipData getPrimaryClip(Method method, IInterface manager) throws InvocationTargetException, IllegalAccessException {        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {            return (ClipData) method.invoke(manager, ServiceManager.PACKAGE_NAME);        }        return (ClipData) method.invoke(manager, ServiceManager.PACKAGE_NAME, ServiceManager.USER_ID);    }    private static void setPrimaryClip(Method method, IInterface manager, ClipData clipData)            throws InvocationTargetException, IllegalAccessException {        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {            method.invoke(manager, clipData, ServiceManager.PACKAGE_NAME);        } else {            method.invoke(manager, clipData, ServiceManager.PACKAGE_NAME, ServiceManager.USER_ID);        }    }    public CharSequence getText() {        try {            Method method = getGetPrimaryClipMethod();            ClipData clipData = getPrimaryClip(method, manager);            if (clipData == null || clipData.getItemCount() == 0) {                return null;            }            return clipData.getItemAt(0).getText();        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            Ln.e("Could not invoke method", e);            return null;        }    }
    }    private Method getGetPrimaryClipMethod() throws NoSuchMethodException {        if (getPrimaryClipMethod == null) {            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                getPrimaryClipMethod = manager.getClass().getMethod("getPrimaryClip", String.class);            } else {                getPrimaryClipMethod = manager.getClass().getMethod("getPrimaryClip", String.class, int.class);            }        }        return getPrimaryClipMethod;    }    private Method getSetPrimaryClipMethod() throws NoSuchMethodException {        if (setPrimaryClipMethod == null) {            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                setPrimaryClipMethod = manager.getClass().getMethod("setPrimaryClip", ClipData.class, String.class);            } else {                setPrimaryClipMethod = manager.getClass().getMethod("setPrimaryClip", ClipData.class, String.class, int.class);            }        }        return setPrimaryClipMethod;    }    private static ClipData getPrimaryClip(Method method, IInterface manager) throws InvocationTargetException, IllegalAccessException {        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {            return (ClipData) method.invoke(manager, ServiceManager.PACKAGE_NAME);        }        return (ClipData) method.invoke(manager, ServiceManager.PACKAGE_NAME, ServiceManager.USER_ID);    }    private static void setPrimaryClip(Method method, IInterface manager, ClipData clipData)            throws InvocationTargetException, IllegalAccessException {        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {            method.invoke(manager, clipData, ServiceManager.PACKAGE_NAME);        } else {            method.invoke(manager, clipData, ServiceManager.PACKAGE_NAME, ServiceManager.USER_ID);        }    }    public CharSequence getText() {        try {            Method method = getGetPrimaryClipMethod();            ClipData clipData = getPrimaryClip(method, manager);            if (clipData == null || clipData.getItemCount() == 0) {                return null;            }            return clipData.getItemAt(0).getText();        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            Ln.e("Could not invoke method", e);            return null;        }    }
    }    private Method getGetPrimaryClipMethod() throws NoSuchMethodException {        if (getPrimaryClipMethod == null) {            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                getPrimaryClipMethod = manager.getClass().getMethod("getPrimaryClip", String.class);            } else {                getPrimaryClipMethod = manager.getClass().getMethod("getPrimaryClip", String.class, int.class);            }        }        return getPrimaryClipMethod;    }    private Method getSetPrimaryClipMethod() throws NoSuchMethodException {        if (setPrimaryClipMethod == null) {            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                setPrimaryClipMethod = manager.getClass().getMethod("setPrimaryClip", ClipData.class, String.class);            } else {                setPrimaryClipMethod = manager.getClass().getMethod("setPrimaryClip", ClipData.class, String.class, int.class);            }        }        return setPrimaryClipMethod;    }    private static ClipData getPrimaryClip(Method method, IInterface manager) throws InvocationTargetException, IllegalAccessException {        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {            return (ClipData) method.invoke(manager, ServiceManager.PACKAGE_NAME);        }        return (ClipData) method.invoke(manager, ServiceManager.PACKAGE_NAME, ServiceManager.USER_ID);    }    private static void setPrimaryClip(Method method, IInterface manager, ClipData clipData)            throws InvocationTargetException, IllegalAccessException {        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {            method.invoke(manager, clipData, ServiceManager.PACKAGE_NAME);        } else {            method.invoke(manager, clipData, ServiceManager.PACKAGE_NAME, ServiceManager.USER_ID);        }    }    public CharSequence getText() {        try {            Method method = getGetPrimaryClipMethod();            ClipData clipData = getPrimaryClip(method, manager);            if (clipData == null || clipData.getItemCount() == 0) {                return null;            }            return clipData.getItemAt(0).getText();        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            Ln.e("Could not invoke method", e);            return null;        }    }
    private static void addPrimaryClipChangedListener(Method method, IInterface manager, IOnPrimaryClipChangedListener listener)            throws InvocationTargetException, IllegalAccessException {        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {            method.invoke(manager, listener, ServiceManager.PACKAGE_NAME);        } else {            method.invoke(manager, listener, ServiceManager.PACKAGE_NAME, ServiceManager.USER_ID);        }    }
    public boolean addPrimaryClipChangedListener(IOnPrimaryClipChangedListener listener) {        try {            Method method = getAddPrimaryClipChangedListener();            addPrimaryClipChangedListener(method, manager, listener);            return true;        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            Ln.e("Could not invoke method", e);            return false;        }    }}
    private Method getAddPrimaryClipChangedListener() throws NoSuchMethodException {        if (addPrimaryClipChangedListener == null) {            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                addPrimaryClipChangedListener = manager.getClass()                        .getMethod("addPrimaryClipChangedListener", IOnPrimaryClipChangedListener.class, String.class);            } else {                addPrimaryClipChangedListener = manager.getClass()                        .getMethod("addPrimaryClipChangedListener", IOnPrimaryClipChangedListener.class, String.class, int.class);            }        }        return addPrimaryClipChangedListener;    }
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, OPT_CROP},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-fps",               required_argument, NULL, OPT_MAX_FPS},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"push-target",           required_argument, NULL, OPT_PUSH_TARGET},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, OPT_RECORD_FORMAT},        {"render-expired-frames", no_argument,       NULL,                                                     OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"prefer-text",           no_argument,       NULL, OPT_PREFER_TEXT},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",              required_argument, NULL, OPT_WINDOW_X},        {"window-y",              required_argument, NULL, OPT_WINDOW_Y},        {"window-width",          required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",         required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",     no_argument,       NULL,                                                     OPT_WINDOW_BORDERLESS},        {NULL,                    0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port(optarg, &opts->port)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, OPT_CROP},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-fps",               required_argument, NULL, OPT_MAX_FPS},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"push-target",           required_argument, NULL, OPT_PUSH_TARGET},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, OPT_RECORD_FORMAT},        {"render-expired-frames", no_argument,       NULL,                                                     OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"prefer-text",           no_argument,       NULL, OPT_PREFER_TEXT},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",              required_argument, NULL, OPT_WINDOW_X},        {"window-y",              required_argument, NULL, OPT_WINDOW_Y},        {"window-width",          required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",         required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",     no_argument,       NULL,                                                     OPT_WINDOW_BORDERLESS},        {NULL,                    0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port(optarg, &opts->port)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
        adb_command = getenv("ADB");        if (!adb_command)            adb_command = "adb";    }    return adb_command;}// serialize argv to string "[arg1], [arg2], [arg3]"static size_targv_to_string(const char *const *argv, char *buf, size_t bufsize) {    size_t idx = 0;    bool first = true;    while (*argv) {        const char *arg = *argv;        size_t len = strlen(arg);        // count space for "[], ...\0"        if (idx + len + 8 >= bufsize) {            // not enough space, truncate            assert(idx < bufsize - 4);            memcpy(&buf[idx], "...", 3);            idx += 3;            break;        }        if (first) {
show_adb_err_msg(enum process_result err, const char *const argv[]) {    char buf[512];    switch (err) {        case PROCESS_ERROR_GENERIC:            argv_to_string(argv, buf, sizeof(buf));            LOGE("Failed to execute: %s", buf);            break;        case PROCESS_ERROR_MISSING_BINARY:            argv_to_string(argv, buf, sizeof(buf));            LOGE("Command not found: %s", buf);            LOGE("(make 'adb' accessible from your PATH or define its full"                 "path in the ADB environment variable)");            break;        case PROCESS_SUCCESS:            // do nothing            break;    }}
show_adb_installation_msg() {#ifndef __WINDOWS__    static const struct {        const char *binary;        const char *command;    } pkg_managers[] = {        {"apt", "apt install adb"},        {"apt-get", "apt-get install adb"},        {"brew", "brew cask install android-platform-tools"},        {"dnf", "dnf install android-tools"},        {"emerge", "emerge dev-util/android-tools"},        {"pacman", "pacman -S android-tools"},    };    for (size_t i = 0; i < ARRAY_LEN(pkg_managers); ++i) {        if (cmd_search(pkg_managers[i].binary)) {            LOGI("You may install 'adb' by \"%s\"", pkg_managers[i].command);            return;        }    }#endif    LOGI("You may download and install 'adb' from "         "https://developer.android.com/studio/releases/platform-tools");}
show_adb_err_msg(enum process_result err, const char *const argv[]) {    char buf[512];    switch (err) {        case PROCESS_ERROR_GENERIC:            argv_to_string(argv, buf, sizeof(buf));            LOGE("Failed to execute: %s", buf);            break;        case PROCESS_ERROR_MISSING_BINARY:            argv_to_string(argv, buf, sizeof(buf));            LOGE("Command not found: %s", buf);            LOGE("(make 'adb' accessible from your PATH or define its full"                 "path in the ADB environment variable)");            show_adb_installation_msg();            break;        case PROCESS_SUCCESS:            // do nothing            break;    }}
            } else {                ret = PROCESS_ERROR_GENERIC;            }            perror("exec");        } else {            perror("fcntl");            ret = PROCESS_ERROR_GENERIC;        }        // send ret to the parent        if (write(fd[1], &ret, sizeof(ret)) == -1) {            perror("write");        }        // close write side before exiting        close(fd[1]);        _exit(1);    }end:    if (fd[0] != -1) {
cmd_search(const char *file) {    char *path = getenv("PATH");    if (!path)        return false;    path = strdup(path);    if (!path)        return false;    bool ret = false;    size_t file_len = strlen(file);    char *saveptr;    for (char *dir = strtok_r(path, ":", &saveptr); dir;            dir = strtok_r(NULL, ":", &saveptr)) {        size_t dir_len = strlen(dir);        char *fullpath = malloc(dir_len + file_len + 2);        if (!fullpath)            continue;        memcpy(fullpath, dir, dir_len);        fullpath[dir_len] = '/';        memcpy(fullpath + dir_len + 1, file, file_len + 1);        struct stat sb;        bool fullpath_executable = stat(fullpath, &sb) == 0 &&            sb.st_mode & S_IXUSR;        free(fullpath);        if (fullpath_executable) {            ret = true;            break;        }    }    free(path);    return ret;}
convert_keycode(SDL_Keycode from, enum android_keycode *to, uint16_t mod,                bool prefer_text) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_HOME,         AKEYCODE_MOVE_HOME);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);    }    if (prefer_text) {        // do not forward alpha and space key events        return false;    }    if (mod & (KMOD_LALT | KMOD_RALT | KMOD_LGUI | KMOD_RGUI)) {        return false;    }    // if ALT and META are not pressed, also handle letters and space    switch (from) {        MAP(SDLK_a,            AKEYCODE_A);        MAP(SDLK_b,            AKEYCODE_B);        MAP(SDLK_c,            AKEYCODE_C);        MAP(SDLK_d,            AKEYCODE_D);        MAP(SDLK_e,            AKEYCODE_E);        MAP(SDLK_f,            AKEYCODE_F);        MAP(SDLK_g,            AKEYCODE_G);        MAP(SDLK_h,            AKEYCODE_H);        MAP(SDLK_i,            AKEYCODE_I);        MAP(SDLK_j,            AKEYCODE_J);        MAP(SDLK_k,            AKEYCODE_K);        MAP(SDLK_l,            AKEYCODE_L);        MAP(SDLK_m,            AKEYCODE_M);        MAP(SDLK_n,            AKEYCODE_N);        MAP(SDLK_o,            AKEYCODE_O);        MAP(SDLK_p,            AKEYCODE_P);        MAP(SDLK_q,            AKEYCODE_Q);        MAP(SDLK_r,            AKEYCODE_R);        MAP(SDLK_s,            AKEYCODE_S);        MAP(SDLK_t,            AKEYCODE_T);        MAP(SDLK_u,            AKEYCODE_U);        MAP(SDLK_v,            AKEYCODE_V);        MAP(SDLK_w,            AKEYCODE_W);        MAP(SDLK_x,            AKEYCODE_X);        MAP(SDLK_y,            AKEYCODE_Y);        MAP(SDLK_z,            AKEYCODE_Z);        MAP(SDLK_SPACE,        AKEYCODE_SPACE);        FAIL;    }}
convert_keycode(SDL_Keycode from, enum android_keycode *to, uint16_t mod,                bool prefer_text) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_HOME,         AKEYCODE_MOVE_HOME);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);    }    if (!(mod & (KMOD_NUM | KMOD_SHIFT))) {        // Handle Numpad events when Num Lock is disabled        // If SHIFT is pressed, a text event will be sent instead        switch(from) {            MAP(SDLK_KP_0,            AKEYCODE_INSERT);            MAP(SDLK_KP_1,            AKEYCODE_MOVE_END);            MAP(SDLK_KP_2,            AKEYCODE_DPAD_DOWN);            MAP(SDLK_KP_3,            AKEYCODE_PAGE_DOWN);            MAP(SDLK_KP_4,            AKEYCODE_DPAD_LEFT);            MAP(SDLK_KP_6,            AKEYCODE_DPAD_RIGHT);            MAP(SDLK_KP_7,            AKEYCODE_MOVE_HOME);            MAP(SDLK_KP_8,            AKEYCODE_DPAD_UP);            MAP(SDLK_KP_9,            AKEYCODE_PAGE_UP);            MAP(SDLK_KP_PERIOD,       AKEYCODE_FORWARD_DEL);        }    }    if (prefer_text) {        // do not forward alpha and space key events        return false;    }    if (mod & (KMOD_LALT | KMOD_RALT | KMOD_LGUI | KMOD_RGUI)) {        return false;    }    // if ALT and META are not pressed, also handle letters and space    switch (from) {        MAP(SDLK_a,            AKEYCODE_A);        MAP(SDLK_b,            AKEYCODE_B);        MAP(SDLK_c,            AKEYCODE_C);        MAP(SDLK_d,            AKEYCODE_D);        MAP(SDLK_e,            AKEYCODE_E);        MAP(SDLK_f,            AKEYCODE_F);        MAP(SDLK_g,            AKEYCODE_G);        MAP(SDLK_h,            AKEYCODE_H);        MAP(SDLK_i,            AKEYCODE_I);        MAP(SDLK_j,            AKEYCODE_J);        MAP(SDLK_k,            AKEYCODE_K);        MAP(SDLK_l,            AKEYCODE_L);        MAP(SDLK_m,            AKEYCODE_M);        MAP(SDLK_n,            AKEYCODE_N);        MAP(SDLK_o,            AKEYCODE_O);        MAP(SDLK_p,            AKEYCODE_P);        MAP(SDLK_q,            AKEYCODE_Q);        MAP(SDLK_r,            AKEYCODE_R);        MAP(SDLK_s,            AKEYCODE_S);        MAP(SDLK_t,            AKEYCODE_T);        MAP(SDLK_u,            AKEYCODE_U);        MAP(SDLK_v,            AKEYCODE_V);        MAP(SDLK_w,            AKEYCODE_W);        MAP(SDLK_x,            AKEYCODE_X);        MAP(SDLK_y,            AKEYCODE_Y);        MAP(SDLK_z,            AKEYCODE_Z);        MAP(SDLK_SPACE,        AKEYCODE_SPACE);        FAIL;    }}
  typedef struct sockaddr SOCKADDR;  typedef struct in_addr IN_ADDR;#endif
  typedef struct sockaddr SOCKADDR;  typedef struct in_addr IN_ADDR;#endif
  typedef struct sockaddr SOCKADDR;  typedef struct in_addr IN_ADDR;#endif
net_init(void) {#ifdef __WINDOWS__    WSADATA wsa;    int res = WSAStartup(MAKEWORD(2, 2), &wsa) < 0;    if (res < 0) {        LOGC("WSAStartup failed with error %d", res);        return false;    }#endif    return true;}
net_cleanup(void) {#ifdef __WINDOWS__    WSACleanup();#endif}
net_close(socket_t socket) {#ifdef __WINDOWS__    return !closesocket(socket);#else    return !close(socket);#endif}
        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, OPT_CROP},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-fps",               required_argument, NULL, OPT_MAX_FPS},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"push-target",           required_argument, NULL, OPT_PUSH_TARGET},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, OPT_RECORD_FORMAT},        {"render-expired-frames", no_argument,       NULL,                                                     OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"prefer-text",           no_argument,       NULL, OPT_PREFER_TEXT},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",              required_argument, NULL, OPT_WINDOW_X},        {"window-y",              required_argument, NULL, OPT_WINDOW_Y},        {"window-width",          required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",         required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",     no_argument,       NULL,                                                     OPT_WINDOW_BORDERLESS},        {NULL,                    0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
parse_lock_video_orientation(const char *s, int8_t *lock_video_orientation) {    long value;    bool ok = parse_integer_arg(s, &value, false, -1, 3,                                "lock video orientation");    if (!ok) {        return false;    }    *lock_video_orientation = (int8_t) value;    return true;}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"crop",                   required_argument, NULL, OPT_CROP},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"port",                   required_argument, NULL, 'p'},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value. Values are integers in the\n"        "        range [-1..3]. Natural device orientation is 0 and each\n"        "        increment adds 90 degrees counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    char max_fps_string[6];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    sprintf(max_fps_string, "%"PRIu16, params->max_fps);    const char *const cmd[] = {        "shell",        "CLASSPATH=" DEVICE_SERVER_PATH,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,        max_size_string,        bit_rate_string,        max_fps_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    char max_fps_string[6];    char lock_video_orientation_string[3];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    sprintf(max_fps_string, "%"PRIu16, params->max_fps);    sprintf(lock_video_orientation_string, "%"PRIi8, params->lock_video_orientation);    const char *const cmd[] = {        "shell",        "CLASSPATH=" DEVICE_SERVER_PATH,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,        max_size_string,        bit_rate_string,        max_fps_string,        lock_video_orientation_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
static void test_options(void) {    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    char *argv[] = {        "scrcpy",        "--always-on-top",        "--bit-rate", "5M",        "--crop", "100:200:300:400",        "--fullscreen",        "--max-fps", "30",        "--max-size", "1024",        // "--no-control" is not compatible with "--turn-screen-off"        // "--no-display" is not compatible with "--fulscreen"        "--port", "1234:1236",        "--push-target", "/sdcard/Movies",        "--record", "file",        "--record-format", "mkv",        "--render-expired-frames",        "--serial", "0123456789abcdef",        "--show-touches",        "--turn-screen-off",        "--prefer-text",        "--window-title", "my device",        "--window-x", "100",        "--window-y", "-1",        "--window-width", "600",        "--window-height", "0",        "--window-borderless",    };    bool ok = scrcpy_parse_args(&args, ARRAY_LEN(argv), argv);    assert(ok);    const struct scrcpy_options *opts = &args.opts;    assert(opts->always_on_top);    fprintf(stderr, "%d\n", (int) opts->bit_rate);    assert(opts->bit_rate == 5000000);    assert(!strcmp(opts->crop, "100:200:300:400"));    assert(opts->fullscreen);    assert(opts->max_fps == 30);    assert(opts->max_size == 1024);    assert(opts->port_range.first == 1234);    assert(opts->port_range.last == 1236);    assert(!strcmp(opts->push_target, "/sdcard/Movies"));    assert(!strcmp(opts->record_filename, "file"));    assert(opts->record_format == RECORDER_FORMAT_MKV);    assert(opts->render_expired_frames);    assert(!strcmp(opts->serial, "0123456789abcdef"));    assert(opts->show_touches);    assert(opts->turn_screen_off);    assert(opts->prefer_text);    assert(!strcmp(opts->window_title, "my device"));    assert(opts->window_x == 100);    assert(opts->window_y == -1);    assert(opts->window_width == 600);    assert(opts->window_height == 0);    assert(opts->window_borderless);}
static void test_options(void) {    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    char *argv[] = {        "scrcpy",        "--always-on-top",        "--bit-rate", "5M",        "--crop", "100:200:300:400",        "--fullscreen",        "--max-fps", "30",        "--max-size", "1024",        "--lock-video-orientation", "2",        // "--no-control" is not compatible with "--turn-screen-off"        // "--no-display" is not compatible with "--fulscreen"        "--port", "1234:1236",        "--push-target", "/sdcard/Movies",        "--record", "file",        "--record-format", "mkv",        "--render-expired-frames",        "--serial", "0123456789abcdef",        "--show-touches",        "--turn-screen-off",        "--prefer-text",        "--window-title", "my device",        "--window-x", "100",        "--window-y", "-1",        "--window-width", "600",        "--window-height", "0",        "--window-borderless",    };    bool ok = scrcpy_parse_args(&args, ARRAY_LEN(argv), argv);    assert(ok);    const struct scrcpy_options *opts = &args.opts;    assert(opts->always_on_top);    fprintf(stderr, "%d\n", (int) opts->bit_rate);    assert(opts->bit_rate == 5000000);    assert(!strcmp(opts->crop, "100:200:300:400"));    assert(opts->fullscreen);    assert(opts->max_fps == 30);    assert(opts->max_size == 1024);    assert(opts->lock_video_orientation == 2);    assert(opts->port_range.first == 1234);    assert(opts->port_range.last == 1236);    assert(!strcmp(opts->push_target, "/sdcard/Movies"));    assert(!strcmp(opts->record_filename, "file"));    assert(opts->record_format == RECORDER_FORMAT_MKV);    assert(opts->render_expired_frames);    assert(!strcmp(opts->serial, "0123456789abcdef"));    assert(opts->show_touches);    assert(opts->turn_screen_off);    assert(opts->prefer_text);    assert(!strcmp(opts->window_title, "my device"));    assert(opts->window_x == 100);    assert(opts->window_y == -1);    assert(opts->window_width == 600);    assert(opts->window_height == 0);    assert(opts->window_borderless);}
    public Point getPhysicalPoint(Position position) {        // it hides the field on purpose, to read it with a lock        @SuppressWarnings("checkstyle:HiddenField")        ScreenInfo screenInfo = getScreenInfo(); // read with synchronization        Size videoSize = screenInfo.getVideoSize();        Size clientVideoSize = position.getScreenSize();        if (!videoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event            return null;        }        Rect contentRect = screenInfo.getContentRect();        Point point = position.getPoint();        int scaledX = contentRect.left + point.getX() * contentRect.width() / videoSize.getWidth();        int scaledY = contentRect.top + point.getY() * contentRect.height() / videoSize.getHeight();        return new Point(scaledX, scaledY);    }
    private ScreenInfo computeScreenInfo(Rect crop, int maxSize) {        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        Rect contentRect = new Rect(0, 0, deviceSize.getWidth(), deviceSize.getHeight());        if (crop != null) {            if (rotated) {                // the crop (provided by the user) is expressed in the natural orientation                crop = flipRect(crop);            }            if (!contentRect.intersect(crop)) {                // intersect() changes contentRect so that it is intersected with crop                Ln.w("Crop rectangle (" + formatCrop(crop) + ") does not intersect device screen (" + formatCrop(deviceSize.toRect()) + ")");                contentRect = new Rect(); // empty            }        }        Size videoSize = computeVideoSize(contentRect.width(), contentRect.height(), maxSize);        return new ScreenInfo(contentRect, videoSize, rotated);    }
    private ScreenInfo computeScreenInfo(Rect crop, int maxSize) {        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        Rect contentRect = new Rect(0, 0, deviceSize.getWidth(), deviceSize.getHeight());        if (crop != null) {            if (rotated) {                // the crop (provided by the user) is expressed in the natural orientation                crop = flipRect(crop);            }            if (!contentRect.intersect(crop)) {                // intersect() changes contentRect so that it is intersected with crop                Ln.w("Crop rectangle (" + formatCrop(crop) + ") does not intersect device screen (" + formatCrop(deviceSize.toRect()) + ")");                contentRect = new Rect(); // empty            }        }        Size videoSize = computeVideoSize(contentRect.width(), contentRect.height(), maxSize);        return new ScreenInfo(contentRect, videoSize, rotated);    }
    public Device(Options options) {        screenInfo = computeScreenInfo(options.getCrop(), options.getMaxSize());        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    screenInfo = screenInfo.withRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        });    }
    public Device(Options options) {        screenInfo = computeScreenInfo(options.getCrop(), options.getMaxSize());        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    screenInfo = screenInfo.withRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        });    }
    public Point getPhysicalPoint(Position position) {        // it hides the field on purpose, to read it with a lock        @SuppressWarnings("checkstyle:HiddenField")        ScreenInfo screenInfo = getScreenInfo(); // read with synchronization        Size videoSize = screenInfo.getVideoSize();        int deviceRotation = screenInfo.getRotation();        int reverseVideoRotation = getReverseVideoRotation(deviceRotation);        // reverse the video rotation to apply the events        Position devicePosition = position.rotate(reverseVideoRotation);        Size clientVideoSize = devicePosition.getScreenSize();        if (!videoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event            return null;        }        Rect contentRect = screenInfo.getContentRect();        Point point = devicePosition.getPoint();        int convertedX = contentRect.left + point.getX() * contentRect.width() / videoSize.getWidth();        int convertedY = contentRect.top + point.getY() * contentRect.height() / videoSize.getHeight();        return new Point(convertedX, convertedY);    }
    private ScreenInfo computeScreenInfo(Rect crop, int maxSize) {        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        int rotation = displayInfo.getRotation();        Size deviceSize = displayInfo.getSize();        Rect contentRect = new Rect(0, 0, deviceSize.getWidth(), deviceSize.getHeight());        if (crop != null) {            if (rotation % 2 != 0) { // 180s preserve dimensions                // the crop (provided by the user) is expressed in the natural orientation                crop = flipRect(crop);            }            if (!contentRect.intersect(crop)) {                // intersect() changes contentRect so that it is intersected with crop                Ln.w("Crop rectangle (" + formatCrop(crop) + ") does not intersect device screen (" + formatCrop(deviceSize.toRect()) + ")");                contentRect = new Rect(); // empty            }        }        Size videoSize = computeVideoSize(contentRect.width(), contentRect.height(), maxSize);        return new ScreenInfo(contentRect, videoSize, rotation);    }
    public int getVideoRotation(int deviceRotation) {        if (lockedVideoOrientation == -1) {            // no offset            return 0;        }        return (deviceRotation + 4 - lockedVideoOrientation) % 4;    }
    public Device(Options options) {        lockedVideoOrientation = options.getLockedVideoOrientation();        screenInfo = computeScreenInfo(options.getCrop(), options.getMaxSize());        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    screenInfo = screenInfo.withRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        });    }
    private int getReverseVideoRotation(int deviceRotation) {        if (lockedVideoOrientation == -1) {            // no offset            return 0;        }        return (lockedVideoOrientation + 4 - deviceRotation) % 4;    }
    }    public int getMaxFps() {        return maxFps;    }    public void setMaxFps(int maxFps) {        this.maxFps = maxFps;    }    public boolean isTunnelForward() {        return tunnelForward;    }    public void setTunnelForward(boolean tunnelForward) {        this.tunnelForward = tunnelForward;    }
    }    public int getMaxFps() {        return maxFps;    }    public void setMaxFps(int maxFps) {        this.maxFps = maxFps;    }    public boolean isTunnelForward() {        return tunnelForward;    }    public void setTunnelForward(boolean tunnelForward) {        this.tunnelForward = tunnelForward;    }
    public int getLockedVideoOrientation() {        return lockedVideoOrientation;    }
    public void setLockedVideoOrientation(int lockedVideoOrientation) {        this.lockedVideoOrientation = lockedVideoOrientation;    }
        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        Position position = (Position) o;        return Objects.equals(point, position.point) && Objects.equals(screenSize, position.screenSize);    }    @Override    public int hashCode() {        return Objects.hash(point, screenSize);    }    @Override    public String toString() {
    public Position rotate(int rotation) {        switch (rotation) {            case 1:                return new Position(new Point(screenSize.getHeight() - point.getY(), point.getX()), screenSize.rotate());            case 2:                return new Position(new Point(screenSize.getWidth() - point.getX(), screenSize.getHeight() - point.getY()), screenSize);            case 3:                return new Position(new Point(point.getY(), screenSize.getWidth() - point.getX()), screenSize.rotate());            default:                return this;        }    }
    private static void setSize(MediaFormat format, int width, int height) {        format.setInteger(MediaFormat.KEY_WIDTH, width);        format.setInteger(MediaFormat.KEY_HEIGHT, height);    }
    private static void setSize(MediaFormat format, int width, int height) {        format.setInteger(MediaFormat.KEY_WIDTH, width);        format.setInteger(MediaFormat.KEY_HEIGHT, height);    }
    private static void setDisplaySurface(IBinder display, Surface surface, Rect deviceRect, Rect displayRect) {        SurfaceControl.openTransaction();        try {            SurfaceControl.setDisplaySurface(display, surface);            SurfaceControl.setDisplayProjection(display, 0, deviceRect, displayRect);            SurfaceControl.setDisplayLayerStack(display, 0);        } finally {            SurfaceControl.closeTransaction();        }    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps, int iFrameInterval) {        this.sendFrameMeta = sendFrameMeta;        this.bitRate = bitRate;        this.maxFps = maxFps;        this.iFrameInterval = iFrameInterval;    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps) {        this(sendFrameMeta, bitRate, maxFps, DEFAULT_I_FRAME_INTERVAL);    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps) {        this(sendFrameMeta, bitRate, maxFps, DEFAULT_I_FRAME_INTERVAL);    }
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        Workarounds.prepareMainLooper();        Workarounds.fillAppInfo();        MediaFormat format = createFormat(bitRate, maxFps, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                ScreenInfo screenInfo = device.getScreenInfo();                Rect contentRect = screenInfo.getContentRect();                Rect videoRect = screenInfo.getVideoSize().toRect();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, contentRect, videoRect);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps) {        this(sendFrameMeta, bitRate, maxFps, DEFAULT_I_FRAME_INTERVAL);    }
    private static void setDisplaySurface(IBinder display, Surface surface, Rect deviceRect, Rect displayRect) {        SurfaceControl.openTransaction();        try {            SurfaceControl.setDisplaySurface(display, surface);            SurfaceControl.setDisplayProjection(display, 0, deviceRect, displayRect);            SurfaceControl.setDisplayLayerStack(display, 0);        } finally {            SurfaceControl.closeTransaction();        }    }
        codec.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);    }    private static void setSize(MediaFormat format, int orientation, int width, int height) {        if (orientation % 2 == 0) {
    private static void setSize(MediaFormat format, int orientation, int width, int height) {        if (orientation % 2 == 0) {            format.setInteger(MediaFormat.KEY_WIDTH, width);            format.setInteger(MediaFormat.KEY_HEIGHT, height);            return;        }        format.setInteger(MediaFormat.KEY_WIDTH, height);        format.setInteger(MediaFormat.KEY_HEIGHT, width);    }
    private static void setDisplaySurface(IBinder display, Surface surface, int orientation, Rect deviceRect, Rect displayRect) {        SurfaceControl.openTransaction();        try {            SurfaceControl.setDisplaySurface(display, surface);            SurfaceControl.setDisplayProjection(display, orientation, deviceRect, displayRect);            SurfaceControl.setDisplayLayerStack(display, 0);        } finally {            SurfaceControl.closeTransaction();        }    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps, int lockedVideoOrientation, int iFrameInterval) {        this.sendFrameMeta = sendFrameMeta;        this.bitRate = bitRate;        this.maxFps = maxFps;        this.lockedVideoOrientation = lockedVideoOrientation;        this.iFrameInterval = iFrameInterval;
    }    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps, int lockedVideoOrientation) {        this(sendFrameMeta, bitRate, maxFps, lockedVideoOrientation, DEFAULT_I_FRAME_INTERVAL);
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps, int lockedVideoOrientation) {        this(sendFrameMeta, bitRate, maxFps, lockedVideoOrientation, DEFAULT_I_FRAME_INTERVAL);    }
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        Workarounds.prepareMainLooper();        Workarounds.fillAppInfo();        MediaFormat format = createFormat(bitRate, maxFps, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                ScreenInfo screenInfo = device.getScreenInfo();                Rect contentRect = screenInfo.getContentRect();                Rect videoRect = screenInfo.getVideoSize().toRect();                int videoRotation = device.getVideoRotation(screenInfo.getRotation());                setSize(format, videoRotation, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, videoRotation, contentRect, videoRect);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps, int lockedVideoOrientation, int iFrameInterval) {        this.sendFrameMeta = sendFrameMeta;        this.bitRate = bitRate;        this.maxFps = maxFps;        this.lockedVideoOrientation = lockedVideoOrientation;        this.iFrameInterval = iFrameInterval;    }
            format.setInteger(MediaFormat.KEY_WIDTH, width);            format.setInteger(MediaFormat.KEY_HEIGHT, height);            return;        }        format.setInteger(MediaFormat.KEY_WIDTH, height);        format.setInteger(MediaFormat.KEY_HEIGHT, width);    }    private static void setDisplaySurface(IBinder display, Surface surface, int orientation, Rect deviceRect, Rect displayRect) {        SurfaceControl.openTransaction();        try {
    public ScreenInfo(Rect contentRect, Size videoSize, boolean rotated) {        this.contentRect = contentRect;        this.videoSize = videoSize;        this.rotated = rotated;    }
    public ScreenInfo(Rect contentRect, Size videoSize, boolean rotated) {        this.contentRect = contentRect;        this.videoSize = videoSize;        this.rotated = rotated;    }
    public ScreenInfo withRotation(int rotation) {        boolean newRotated = (rotation & 1) != 0;        if (rotated == newRotated) {            return this;        }        return new ScreenInfo(Device.flipRect(contentRect), videoSize.rotate(), newRotated);    }}
    public ScreenInfo withRotation(int rotation) {        boolean newRotated = (rotation & 1) != 0;        if (rotated == newRotated) {            return this;        }        return new ScreenInfo(Device.flipRect(contentRect), videoSize.rotate(), newRotated);    }}
    public ScreenInfo(Rect contentRect, Size videoSize, boolean rotated) {        this.contentRect = contentRect;        this.videoSize = videoSize;        this.rotated = rotated;    }
    public ScreenInfo(Rect contentRect, Size videoSize, int rotation) {        this.contentRect = contentRect;        this.videoSize = videoSize;        this.rotation = rotation;    }
    public int getRotation() {        return rotation;    }
    public ScreenInfo withRotation(int newRotation) {        if (newRotation == rotation) {            return this;        }        // true if changed between portrait and landscape        boolean orientationChanged = (rotation + newRotation) % 2 != 0;        Rect newContentRect;        Size newVideoSize;        if (orientationChanged) {            newContentRect = Device.flipRect(contentRect);            newVideoSize = videoSize.rotate();        } else {            newContentRect = contentRect;            newVideoSize = videoSize;        }        return new ScreenInfo(newContentRect, newVideoSize, newRotation);    }}
    public int getRotation() {        return rotation;    }    public ScreenInfo withRotation(int newRotation) {        if (newRotation == rotation) {            return this;        }
    public ScreenInfo(Rect contentRect, Size videoSize, int rotation) {        this.contentRect = contentRect;        this.videoSize = videoSize;        this.rotation = rotation;    }
    private static Options createOptions(String... args) {        if (args.length < 1) {            throw new IllegalArgumentException("Missing client version");        }        String clientVersion = args[0];        if (!clientVersion.equals(BuildConfig.VERSION_NAME)) {            throw new IllegalArgumentException(                    "The server version (" + clientVersion + ") does not match the client " + "(" + BuildConfig.VERSION_NAME + ")");        }        if (args.length != 8) {            throw new IllegalArgumentException("Expecting 8 parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[1]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[2]);        options.setBitRate(bitRate);        int maxFps = Integer.parseInt(args[3]);        options.setMaxFps(maxFps);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[4]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[5]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[6]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[7]);        options.setControl(control);        return options;    }
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate(), options.getMaxFps());            if (options.getControl()) {                Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    private static Options createOptions(String... args) {        if (args.length < 1) {            throw new IllegalArgumentException("Missing client version");        }        String clientVersion = args[0];        if (!clientVersion.equals(BuildConfig.VERSION_NAME)) {            throw new IllegalArgumentException(                    "The server version (" + clientVersion + ") does not match the client " + "(" + BuildConfig.VERSION_NAME + ")");        }        if (args.length != 9) {            throw new IllegalArgumentException("Expecting 9 parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[1]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[2]);        options.setBitRate(bitRate);        int maxFps = Integer.parseInt(args[3]);        options.setMaxFps(maxFps);        int lockedVideoOrientation = Integer.parseInt(args[4]);        options.setLockedVideoOrientation(lockedVideoOrientation);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[5]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[6]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[7]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[8]);        options.setControl(control);        return options;    }
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate(), options.getMaxFps(),                    options.getLockedVideoOrientation());            if (options.getControl()) {                Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation, bool mipmaps) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size = get_rotated_size(frame_size, screen->rotation);    screen->content_size = content_size;    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_RendererInfo renderer_info;    int r = SDL_GetRendererInfo(screen->renderer, &renderer_info);    const char *renderer_name = r ? NULL : renderer_info.name;    LOGI("Renderer: %s", renderer_name ? renderer_name : "(unknown)");    // starts with "opengl"    screen->use_opengl = renderer_name && !strncmp(renderer_name, "opengl", 6);    if (screen->use_opengl) {        struct sc_opengl *gl = &screen->gl;        sc_opengl_init(gl);        LOGI("OpenGL version: %s", gl->version);        if (mipmaps) {            bool supports_mipmaps =                sc_opengl_version_at_least(gl, 3, 0, /* OpenGL 3.0+ */                                               2, 0  /* OpenGL ES 2.0+ */);            if (supports_mipmaps) {                LOGI("Trilinear filtering enabled");                screen->mipmaps = true;            } else {                LOGW("Trilinear filtering disabled "                     "(OpenGL 3.0+ or ES 2.0+ required)");            }        } else {            LOGI("Trilinear filtering disabled");        }    } else {        LOGW("Trilinear filtering disabled (not an OpenGL renderer)");    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen_update_content_rect(screen);    return true;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation, bool mipmaps) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size = get_rotated_size(frame_size, screen->rotation);    screen->content_size = content_size;    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_RendererInfo renderer_info;    int r = SDL_GetRendererInfo(screen->renderer, &renderer_info);    const char *renderer_name = r ? NULL : renderer_info.name;    LOGI("Renderer: %s", renderer_name ? renderer_name : "(unknown)");    // starts with "opengl"    screen->use_opengl = renderer_name && !strncmp(renderer_name, "opengl", 6);    if (screen->use_opengl) {        struct sc_opengl *gl = &screen->gl;        sc_opengl_init(gl);        LOGI("OpenGL version: %s", gl->version);        if (mipmaps) {            bool supports_mipmaps =                sc_opengl_version_at_least(gl, 3, 0, /* OpenGL 3.0+ */                                               2, 0  /* OpenGL ES 2.0+ */);            if (supports_mipmaps) {                LOGI("Trilinear filtering enabled");                screen->mipmaps = true;            } else {                LOGW("Trilinear filtering disabled "                     "(OpenGL 3.0+ or ES 2.0+ required)");            }        } else {            LOGI("Trilinear filtering disabled");        }    } else {        LOGW("Trilinear filtering disabled (not an OpenGL renderer)");    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    // Reset the window size to trigger a SIZE_CHANGED event, to workaround    // HiDPI issues with some SDL renderers when several displays having    // different HiDPI scaling are connected    SDL_SetWindowSize(screen->window, window_size.width, window_size.height);    screen_update_content_rect(screen);    return true;}
sdl_init_and_configure(bool display) {    uint32_t flags = display ? SDL_INIT_VIDEO : SDL_INIT_EVENTS;    if (SDL_Init(flags)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return false;    }    atexit(SDL_Quit);    if (!display) {        return true;    }    // Use the best available scale quality    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "2")) {        LOGW("Could not enable bilinear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif#ifdef SCRCPY_SDL_HAS_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR    // Disable compositor bypassing on X11    if (!SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, "0")) {        LOGW("Could not disable X11 compositor bypass");    }#endif    // Do not minimize on focus loss    if (!SDL_SetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, "0")) {        LOGW("Could not disable minimize on focus loss");    }    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return true;}
sdl_init_and_configure(bool display) {    uint32_t flags = display ? SDL_INIT_VIDEO : SDL_INIT_EVENTS;    if (SDL_Init(flags)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return false;    }    atexit(SDL_Quit);    if (!display) {        return true;    }    // Linear filtering    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        LOGW("Could not enable linear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif#ifdef SCRCPY_SDL_HAS_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR    // Disable compositor bypassing on X11    if (!SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, "0")) {        LOGW("Could not disable X11 compositor bypass");    }#endif    // Do not minimize on focus loss    if (!SDL_SetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, "0")) {        LOGW("Could not disable minimize on focus loss");    }    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return true;}
screen_resize_to_fit(struct screen *screen) {    if (screen->fullscreen || screen->maximized) {        return;    }    struct size optimal_size =        get_optimal_window_size(screen, screen->content_size);    SDL_SetWindowSize(screen->window, optimal_size.width, optimal_size.height);    LOGD("Resized to optimal size: %ux%u", optimal_size.width,                                           optimal_size.height);}voidscreen_resize_to_pixel_perfect(struct screen *screen) {    if (screen->fullscreen) {        return;    }
get_optimal_size(struct size current_size, struct size content_size) {    if (content_size.width == 0 || content_size.height == 0) {        // avoid division by 0        return current_size;    }    struct size display_size;    // 32 bits because we need to multiply two 16 bits values    uint32_t w;    uint32_t h;    if (!get_preferred_display_bounds(&display_size)) {        // could not get display bounds, do not constraint the size        w = current_size.width;        h = current_size.height;    } else {        w = MIN(current_size.width, display_size.width);        h = MIN(current_size.height, display_size.height);    }    if (h == w * content_size.height / content_size.width     || w == h * content_size.width / content_size.height) {        // The size is already optimal, if we ignore rounding errors due to        // integer window dimensions        return (struct size) {w, h};    }    bool keep_width = content_size.width * h > content_size.height * w;    if (keep_width) {        // remove black borders on top and bottom        h = content_size.height * w / content_size.width;    } else {        // remove black borders on left and right (or none at all if it already        // fits)        w = content_size.width * h / content_size.height;    }    // w and h must fit into 16 bits    assert(w < 0x10000 && h < 0x10000);    return (struct size) {w, h};}
is_optimal_size(struct size current_size, struct size content_size) {    // The size is optimal if we can recompute one dimension of the current    // size from the other    return current_size.height == current_size.width * content_size.height                                                     / content_size.width        || current_size.width == current_size.height * content_size.width                                                     / content_size.height;}
get_optimal_size(struct size current_size, struct size content_size) {    if (content_size.width == 0 || content_size.height == 0) {        // avoid division by 0        return current_size;    }    struct size window_size;    struct size display_size;    if (!get_preferred_display_bounds(&display_size)) {        // could not get display bounds, do not constraint the size        window_size.width = current_size.width;        window_size.height = current_size.height;    } else {        window_size.width = MIN(current_size.width, display_size.width);        window_size.height = MIN(current_size.height, display_size.height);    }    if (is_optimal_size(window_size, content_size)) {        return window_size;    }    bool keep_width = content_size.width * window_size.height                    > content_size.height * window_size.width;    if (keep_width) {        // remove black borders on top and bottom        window_size.height = content_size.height * window_size.width                           / content_size.width;    } else {        // remove black borders on left and right (or none at all if it already        // fits)        window_size.width = content_size.width * window_size.height                          / content_size.height;    }    return window_size;}
sdl_init_and_configure(bool display) {    uint32_t flags = display ? SDL_INIT_VIDEO : SDL_INIT_EVENTS;    if (SDL_Init(flags)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return false;    }    atexit(SDL_Quit);    if (!display) {        return true;    }    // Use the best available scale quality    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "2")) {        LOGW("Could not enable bilinear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif#ifdef SCRCPY_SDL_HAS_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR    // Disable compositor bypassing on X11    if (!SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, "0")) {        LOGW("Could not disable X11 compositor bypass");    }#endif    // Do not minimize on focus loss    if (!SDL_SetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, "0")) {        LOGW("Could not disable minimize on focus loss");    }    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return true;}
sdl_init_and_configure(bool display) {    uint32_t flags = display ? SDL_INIT_VIDEO : SDL_INIT_EVENTS;    if (SDL_Init(flags)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return false;    }    atexit(SDL_Quit);    if (!display) {        return true;    }    // Linear filtering    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        LOGW("Could not enable linear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif#ifdef SCRCPY_SDL_HAS_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR    // Disable compositor bypassing on X11    if (!SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, "0")) {        LOGW("Could not disable X11 compositor bypass");    }#endif    // Do not minimize on focus loss    if (!SDL_SetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, "0")) {        LOGW("Could not disable minimize on focus loss");    }    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return true;}
    public void registerRotationWatcher(IRotationWatcher rotationWatcher) {        serviceManager.getWindowManager().registerRotationWatcher(rotationWatcher);    }
    public Device(Options options) {        displayId = options.getDisplayId();        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo(displayId);        if (displayInfo == null) {            int[] displayIds = serviceManager.getDisplayManager().getDisplayIds();            throw new InvalidDisplayIdException(displayId, displayIds);        }        int displayInfoFlags = displayInfo.getFlags();        screenInfo = ScreenInfo.computeScreenInfo(displayInfo, options.getCrop(), options.getMaxSize(), options.getLockedVideoOrientation());        layerStack = displayInfo.getLayerStack();        isPresentationDisplay = (displayInfoFlags & DisplayInfo.FLAG_PRESENTATION) != 0;        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    screenInfo = screenInfo.withDeviceRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        });        if ((displayInfoFlags & DisplayInfo.FLAG_SUPPORTS_PROTECTED_BUFFERS) == 0) {            Ln.w("Display doesn't have FLAG_SUPPORTS_PROTECTED_BUFFERS flag, mirroring can be restricted");        }        if (!supportsInputEvents()) {            Ln.w("Input events are not supported for displays with FLAG_PRESENTATION enabled for devices with API lower than 29");        }    }
    public void registerRotationWatcher(IRotationWatcher rotationWatcher) {        serviceManager.getWindowManager().registerRotationWatcher(rotationWatcher);    }
    public void registerRotationWatcher(IRotationWatcher rotationWatcher, int displayId) {        serviceManager.getWindowManager().registerRotationWatcher(rotationWatcher, displayId);    }
    public Device(Options options) {        displayId = options.getDisplayId();        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo(displayId);        if (displayInfo == null) {            int[] displayIds = serviceManager.getDisplayManager().getDisplayIds();            throw new InvalidDisplayIdException(displayId, displayIds);        }        int displayInfoFlags = displayInfo.getFlags();        screenInfo = ScreenInfo.computeScreenInfo(displayInfo, options.getCrop(), options.getMaxSize(), options.getLockedVideoOrientation());        layerStack = displayInfo.getLayerStack();        isPresentationDisplay = (displayInfoFlags & DisplayInfo.FLAG_PRESENTATION) != 0;        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    screenInfo = screenInfo.withDeviceRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        }, displayId);        if ((displayInfoFlags & DisplayInfo.FLAG_SUPPORTS_PROTECTED_BUFFERS) == 0) {            Ln.w("Display doesn't have FLAG_SUPPORTS_PROTECTED_BUFFERS flag, mirroring can be restricted");        }        if (!supportsInputEvents()) {            Ln.w("Input events are not supported for displays with FLAG_PRESENTATION enabled for devices with API lower than 29");        }    }
    public void registerRotationWatcher(IRotationWatcher rotationWatcher, int displayId) {        serviceManager.getWindowManager().registerRotationWatcher(rotationWatcher, displayId);    }
    public void registerRotationWatcher(IRotationWatcher rotationWatcher) {        try {            Class<?> cls = manager.getClass();            try {                // display parameter added since this commit:                // https://android.googlesource.com/platform/frameworks/base/+/35fa3c26adcb5f6577849fd0df5228b1f67cf2c6%5E%21/#F1                cls.getMethod("watchRotation", IRotationWatcher.class, int.class).invoke(manager, rotationWatcher, 0);            } catch (NoSuchMethodException e) {                // old version                cls.getMethod("watchRotation", IRotationWatcher.class).invoke(manager, rotationWatcher);            }        } catch (Exception e) {            throw new AssertionError(e);        }    }}
    public void registerRotationWatcher(IRotationWatcher rotationWatcher) {        try {            Class<?> cls = manager.getClass();            try {                // display parameter added since this commit:                // https://android.googlesource.com/platform/frameworks/base/+/35fa3c26adcb5f6577849fd0df5228b1f67cf2c6%5E%21/#F1                cls.getMethod("watchRotation", IRotationWatcher.class, int.class).invoke(manager, rotationWatcher, 0);            } catch (NoSuchMethodException e) {                // old version                cls.getMethod("watchRotation", IRotationWatcher.class).invoke(manager, rotationWatcher);            }        } catch (Exception e) {            throw new AssertionError(e);        }    }}
    public void registerRotationWatcher(IRotationWatcher rotationWatcher, int displayId) {        try {            Class<?> cls = manager.getClass();            try {                // display parameter added since this commit:                // https://android.googlesource.com/platform/frameworks/base/+/35fa3c26adcb5f6577849fd0df5228b1f67cf2c6%5E%21/#F1                cls.getMethod("watchRotation", IRotationWatcher.class, int.class).invoke(manager, rotationWatcher, displayId);            } catch (NoSuchMethodException e) {                // old version                cls.getMethod("watchRotation", IRotationWatcher.class).invoke(manager, rotationWatcher);            }        } catch (Exception e) {            throw new AssertionError(e);        }    }}
    public void registerRotationWatcher(IRotationWatcher rotationWatcher, int displayId) {        try {            Class<?> cls = manager.getClass();            try {                // display parameter added since this commit:                // https://android.googlesource.com/platform/frameworks/base/+/35fa3c26adcb5f6577849fd0df5228b1f67cf2c6%5E%21/#F1                cls.getMethod("watchRotation", IRotationWatcher.class, int.class).invoke(manager, rotationWatcher, displayId);            } catch (NoSuchMethodException e) {                // old version                cls.getMethod("watchRotation", IRotationWatcher.class).invoke(manager, rotationWatcher);            }        } catch (Exception e) {            throw new AssertionError(e);        }    }}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value. Values are integers in the\n"        "        range [-1..3]. Natural device orientation is 0 and each\n"        "        increment adds 90 degrees counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value. Values are integers in the\n"        "        range [-1..3]. Natural device orientation is 0 and each\n"        "        increment adds 90 degrees counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = im->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && !shift && down) {                    set_screen_power_mode(controller, SCREEN_POWER_MODE_OFF);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard                        set_device_clipboard(controller);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && cmd && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && cmd && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && cmd && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = im->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && !shift && down) {                    set_screen_power_mode(controller, SCREEN_POWER_MODE_OFF);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard                        set_device_clipboard(controller);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && cmd && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && cmd && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && cmd && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = im->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && !shift && down) {                    set_screen_power_mode(controller, SCREEN_POWER_MODE_OFF);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard                        set_device_clipboard(controller);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && cmd && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && cmd && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && cmd && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = im->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && !shift && down) {                    set_screen_power_mode(controller, SCREEN_POWER_MODE_OFF);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (cmd && !shift && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (cmd && !shift && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard                        set_device_clipboard(controller);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && cmd && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && cmd && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && cmd && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
rotate_client_right(struct screen *screen) {    unsigned new_rotation = (screen->rotation + 3) % 4;    screen_set_rotation(screen, new_rotation);}
rotate_client_left(struct screen *screen) {    unsigned new_rotation = (screen->rotation + 1) % 4;    screen_set_rotation(screen, new_rotation);}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless) {    screen->frame_size = frame_size;    struct size window_size =        get_initial_optimal_size(frame_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width            || screen->frame_size.height != new_frame_size.height) {        if (SDL_RenderSetLogicalSize(screen->renderer, new_frame_size.width,                                     new_frame_size.height)) {            LOGE("Could not set renderer logical size: %s", SDL_GetError());            return false;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        struct size windowed_size = get_windowed_window_size(screen);        struct size target_size = {            (uint32_t) windowed_size.width * new_frame_size.width                    / screen->frame_size.width,            (uint32_t) windowed_size.height * new_frame_size.height                    / screen->frame_size.height,        };        target_size = get_optimal_size(target_size, new_frame_size);        set_window_size(screen, target_size);        screen->frame_size = new_frame_size;        LOGI("New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = create_texture(screen->renderer, new_frame_size);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return false;        }    }    return true;}
get_optimal_window_size(const struct screen *screen, struct size frame_size) {    struct size windowed_size = get_windowed_window_size(screen);    return get_optimal_size(windowed_size, frame_size);}
screen_resize_to_pixel_perfect(struct screen *screen) {    if (screen->fullscreen) {        return;    }    if (screen->maximized) {        SDL_RestoreWindow(screen->window);        screen->maximized = false;    }    SDL_SetWindowSize(screen->window, screen->frame_size.width,                      screen->frame_size.height);    LOGD("Resized to pixel-perfect");}
get_optimal_size(struct size current_size, struct size frame_size) {    if (frame_size.width == 0 || frame_size.height == 0) {        // avoid division by 0        return current_size;    }    struct size display_size;    // 32 bits because we need to multiply two 16 bits values    uint32_t w;    uint32_t h;    if (!get_preferred_display_bounds(&display_size)) {        // could not get display bounds, do not constraint the size        w = current_size.width;        h = current_size.height;    } else {        w = MIN(current_size.width, display_size.width);        h = MIN(current_size.height, display_size.height);    }    bool keep_width = frame_size.width * h > frame_size.height * w;    if (keep_width) {        // remove black borders on top and bottom        h = frame_size.height * w / frame_size.width;    } else {        // remove black borders on left and right (or none at all if it already        // fits)        w = frame_size.width * h / frame_size.height;    }    // w and h must fit into 16 bits    assert(w < 0x10000 && h < 0x10000);    return (struct size) {w, h};}
get_optimal_window_size(const struct screen *screen, struct size frame_size) {    struct size windowed_size = get_windowed_window_size(screen);    return get_optimal_size(windowed_size, frame_size);}
get_initial_optimal_size(struct size frame_size, uint16_t req_width,                         uint16_t req_height) {    struct size window_size;    if (!req_width && !req_height) {        window_size = get_optimal_size(frame_size, frame_size);    } else {        if (req_width) {            window_size.width = req_width;        } else {            // compute from the requested height            window_size.width = (uint32_t) req_height * frame_size.width                              / frame_size.height;        }        if (req_height) {            window_size.height = req_height;        } else {            // compute from the requested width            window_size.height = (uint32_t) req_width * frame_size.height                               / frame_size.width;        }    }    return window_size;}
screen_render(struct screen *screen) {    SDL_RenderClear(screen->renderer);    SDL_RenderCopy(screen->renderer, screen->texture, NULL, NULL);    SDL_RenderPresent(screen->renderer);}
get_initial_optimal_size(struct size frame_size, uint16_t req_width,                         uint16_t req_height) {    struct size window_size;    if (!req_width && !req_height) {        window_size = get_optimal_size(frame_size, frame_size);    } else {        if (req_width) {            window_size.width = req_width;        } else {            // compute from the requested height            window_size.width = (uint32_t) req_height * frame_size.width                              / frame_size.height;        }        if (req_height) {            window_size.height = req_height;        } else {            // compute from the requested width            window_size.height = (uint32_t) req_width * frame_size.height                               / frame_size.width;        }    }    return window_size;}
get_initial_optimal_size(struct size frame_size, uint16_t req_width,                         uint16_t req_height) {    struct size window_size;    if (!req_width && !req_height) {        window_size = get_optimal_size(frame_size, frame_size);    } else {        if (req_width) {            window_size.width = req_width;        } else {            // compute from the requested height            window_size.width = (uint32_t) req_height * frame_size.width                              / frame_size.height;        }        if (req_height) {            window_size.height = req_height;        } else {            // compute from the requested width            window_size.height = (uint32_t) req_width * frame_size.height                               / frame_size.width;        }    }    return window_size;}
get_initial_optimal_size(struct size frame_size, uint16_t req_width,                         uint16_t req_height) {    struct size window_size;    if (!req_width && !req_height) {        window_size = get_optimal_size(frame_size, frame_size);    } else {        if (req_width) {            window_size.width = req_width;        } else {            // compute from the requested height            window_size.width = (uint32_t) req_height * frame_size.width                              / frame_size.height;        }        if (req_height) {            window_size.height = req_height;        } else {            // compute from the requested width            window_size.height = (uint32_t) req_width * frame_size.height                               / frame_size.width;        }    }    return window_size;}
get_optimal_size(struct size current_size, struct size frame_size) {    if (frame_size.width == 0 || frame_size.height == 0) {        // avoid division by 0        return current_size;    }    struct size display_size;    // 32 bits because we need to multiply two 16 bits values    uint32_t w;    uint32_t h;    if (!get_preferred_display_bounds(&display_size)) {        // could not get display bounds, do not constraint the size        w = current_size.width;        h = current_size.height;    } else {        w = MIN(current_size.width, display_size.width);        h = MIN(current_size.height, display_size.height);    }    bool keep_width = frame_size.width * h > frame_size.height * w;    if (keep_width) {        // remove black borders on top and bottom        h = frame_size.height * w / frame_size.width;    } else {        // remove black borders on left and right (or none at all if it already        // fits)        w = frame_size.width * h / frame_size.height;    }    // w and h must fit into 16 bits    assert(w < 0x10000 && h < 0x10000);    return (struct size) {w, h};}
screen_resize_to_fit(struct screen *screen) {    if (screen->fullscreen) {        return;    }    if (screen->maximized) {        SDL_RestoreWindow(screen->window);        screen->maximized = false;    }    struct size optimal_size =        get_optimal_window_size(screen, screen->frame_size);    SDL_SetWindowSize(screen->window, optimal_size.width, optimal_size.height);    LOGD("Resized to optimal size");}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless) {    screen->frame_size = frame_size;    struct size content_size =        get_rotated_size(frame_size, screen->rotation);    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, content_size.width,                                 content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width            || screen->frame_size.height != new_frame_size.height) {        struct size new_content_size =            get_rotated_size(new_frame_size, screen->rotation);        if (SDL_RenderSetLogicalSize(screen->renderer,                                     new_content_size.width,                                     new_content_size.height)) {            LOGE("Could not set renderer logical size: %s", SDL_GetError());            return false;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        struct size content_size =            get_rotated_size(screen->frame_size, screen->rotation);        struct size windowed_size = get_windowed_window_size(screen);        struct size target_size = {            (uint32_t) windowed_size.width * new_content_size.width                    / content_size.width,            (uint32_t) windowed_size.height * new_content_size.height                    / content_size.height,        };        target_size = get_optimal_size(target_size, new_content_size);        set_window_size(screen, target_size);        screen->frame_size = new_frame_size;        LOGI("New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = create_texture(screen->renderer, new_frame_size);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return false;        }    }    return true;}
    } else {        // remove black borders on left and right (or none at all if it already        // fits)        w = content_size.width * h / content_size.height;    }
screen_resize_to_pixel_perfect(struct screen *screen) {    if (screen->fullscreen) {        return;    }    if (screen->maximized) {        SDL_RestoreWindow(screen->window);        screen->maximized = false;    }    struct size content_size =        get_rotated_size(screen->frame_size, screen->rotation);    SDL_SetWindowSize(screen->window, content_size.width, content_size.height);    LOGD("Resized to pixel-perfect");}
get_optimal_size(struct size current_size, struct size content_size) {    if (content_size.width == 0 || content_size.height == 0) {        // avoid division by 0        return current_size;    }    struct size display_size;    // 32 bits because we need to multiply two 16 bits values    uint32_t w;    uint32_t h;    if (!get_preferred_display_bounds(&display_size)) {        // could not get display bounds, do not constraint the size        w = current_size.width;        h = current_size.height;    } else {        w = MIN(current_size.width, display_size.width);        h = MIN(current_size.height, display_size.height);    }    bool keep_width = content_size.width * h > content_size.height * w;    if (keep_width) {        // remove black borders on top and bottom        h = content_size.height * w / content_size.width;    } else {        // remove black borders on left and right (or none at all if it already        // fits)        w = content_size.width * h / content_size.height;    }    // w and h must fit into 16 bits    assert(w < 0x10000 && h < 0x10000);    return (struct size) {w, h};}
get_optimal_window_size(const struct screen *screen, struct size content_size) {    struct size windowed_size = get_windowed_window_size(screen);    return get_optimal_size(windowed_size, content_size);}
get_initial_optimal_size(struct size content_size, uint16_t req_width,                         uint16_t req_height) {    struct size window_size;    if (!req_width && !req_height) {        window_size = get_optimal_size(content_size, content_size);    } else {        if (req_width) {            window_size.width = req_width;        } else {            // compute from the requested height            window_size.width = (uint32_t) req_height * content_size.width                              / content_size.height;        }        if (req_height) {            window_size.height = req_height;        } else {            // compute from the requested width            window_size.height = (uint32_t) req_width * content_size.height                               / content_size.width;        }    }    return window_size;}
screen_render(struct screen *screen) {    SDL_RenderClear(screen->renderer);    if (screen->rotation == 0) {        SDL_RenderCopy(screen->renderer, screen->texture, NULL, NULL);    } else {        // rotation in RenderCopyEx() is clockwise, while screen->rotation is        // counterclockwise (to be consistent with --lock-video-orientation)        int cw_rotation = (4 - screen->rotation) % 4;        double angle = 90 * cw_rotation;        SDL_Rect *dstrect = NULL;        SDL_Rect rect;        if (screen->rotation & 1) {            struct size size =                get_rotated_size(screen->frame_size, screen->rotation);            rect.x = (size.width - size.height) / 2;            rect.y = (size.height - size.width) / 2;            rect.w = size.height;            rect.h = size.width;            dstrect = &rect;        }        SDL_RenderCopyEx(screen->renderer, screen->texture, NULL, dstrect,                         angle, NULL, 0);    }    SDL_RenderPresent(screen->renderer);}
    return (struct size) {w, h};}// same as get_optimal_size(), but read the current size from the windowstatic inline struct sizeget_optimal_window_size(const struct screen *screen, struct size content_size) {    struct size windowed_size = get_windowed_window_size(screen);    return get_optimal_size(windowed_size, content_size);}// initially, there is no current size, so use the frame size as current size// req_width and req_height, if not 0, are the sizes requested by the userstatic inline struct sizeget_initial_optimal_size(struct size content_size, uint16_t req_width,                         uint16_t req_height) {    struct size window_size;    if (!req_width && !req_height) {        window_size = get_optimal_size(content_size, content_size);    } else {        if (req_width) {            window_size.width = req_width;        } else {            // compute from the requested height            window_size.width = (uint32_t) req_height * content_size.width
screen_set_rotation(struct screen *screen, unsigned rotation) {    assert(rotation < 4);    if (rotation == screen->rotation) {        return;    }    struct size old_content_size =        get_rotated_size(screen->frame_size, screen->rotation);    struct size new_content_size =        get_rotated_size(screen->frame_size, rotation);    if (SDL_RenderSetLogicalSize(screen->renderer,                                 new_content_size.width,                                 new_content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        return;    }    struct size windowed_size = get_windowed_window_size(screen);    struct size target_size = {        .width = (uint32_t) windowed_size.width * new_content_size.width                / old_content_size.width,        .height = (uint32_t) windowed_size.height * new_content_size.height                / old_content_size.height,    };    target_size = get_optimal_size(target_size, new_content_size);    set_window_size(screen, target_size);    screen->rotation = rotation;    LOGI("Display rotation set to %u", rotation);    screen_render(screen);}
get_rotated_size(struct size size, int rotation) {    struct size rotated_size;    if (rotation & 1) {        rotated_size.width = size.height;        rotated_size.height = size.width;    } else {        rotated_size.width = size.width;        rotated_size.height = size.height;    }    return rotated_size;}
    }    bounds->width = MAX(0, rect.w - DISPLAY_MARGINS);    bounds->height = MAX(0, rect.h - DISPLAY_MARGINS);    return true;}// return the optimal size of the window, with the following constraints://  - it attempts to keep at least one dimension of the current_size (i.e. it//    crops the black borders)//  - it keeps the aspect ratio//  - it scales down to make it fit in the display_sizestatic struct sizeget_optimal_size(struct size current_size, struct size content_size) {    if (content_size.width == 0 || content_size.height == 0) {        // avoid division by 0        return current_size;    }    struct size display_size;    // 32 bits because we need to multiply two 16 bits values    uint32_t w;    uint32_t h;    if (!get_preferred_display_bounds(&display_size)) {        // could not get display bounds, do not constraint the size        w = current_size.width;        h = current_size.height;    } else {        w = MIN(current_size.width, display_size.width);        h = MIN(current_size.height, display_size.height);    }    bool keep_width = content_size.width * h > content_size.height * w;    if (keep_width) {
screen_resize_to_fit(struct screen *screen) {    if (screen->fullscreen) {        return;    }    if (screen->maximized) {        SDL_RestoreWindow(screen->window);        screen->maximized = false;    }    struct size content_size =        get_rotated_size(screen->frame_size, screen->rotation);    struct size optimal_size =        get_optimal_window_size(screen, content_size);    SDL_SetWindowSize(screen->window, optimal_size.width, optimal_size.height);    LOGD("Resized to optimal size");}
server_start(struct server *server, const char *serial,             const struct server_params *params) {    server->port_range = params->port_range;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        goto error1;    }    if (!enable_tunnel_any_port(server, params->port_range)) {        goto error1;    }    // server will connect to our server socket    server->process = execute_server(server, params);    if (server->process == PROCESS_NONE) {        goto error2;    }    server->wait_server_thread =        SDL_CreateThread(run_wait_server, "wait-server", server);    if (!server->wait_server_thread) {        if (!cmd_terminate(server->process)) {            LOGW("Could not terminate server");        }        cmd_simple_wait(server->process, NULL); // ignore exit code        goto error2;    }    server->tunnel_enabled = true;    return true;error2:    if (!server->tunnel_forward) {        close_socket(&server->server_socket);    }    disable_tunnel(server);error1:    SDL_free(server->serial);    return false;}
server_connect_to(struct server *server) {    if (!server->tunnel_forward) {        server->video_socket = net_accept(server->server_socket);        if (server->video_socket == INVALID_SOCKET) {            return false;        }        server->control_socket = net_accept(server->server_socket);        if (server->control_socket == INVALID_SOCKET) {            // the video_socket will be cleaned up on destroy            return false;        }        // we don't need the server socket anymore        close_socket(&server->server_socket);    } else {        uint32_t attempts = 100;        uint32_t delay = 100; // ms        server->video_socket =            connect_to_server(server->local_port, attempts, delay);        if (server->video_socket == INVALID_SOCKET) {            return false;        }        // we know that the device is listening, we don't need several attempts        server->control_socket =            net_connect(IPV4_LOCALHOST, server->local_port);        if (server->control_socket == INVALID_SOCKET) {            return false;        }    }    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = false;    return true;}
server_stop(struct server *server) {    if (server->server_socket != INVALID_SOCKET) {        close_socket(&server->server_socket);    }    if (server->video_socket != INVALID_SOCKET) {        close_socket(&server->video_socket);    }    if (server->control_socket != INVALID_SOCKET) {        close_socket(&server->control_socket);    }    assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Could not terminate server");    }    if (server->tunnel_enabled) {        // ignore failure        disable_tunnel(server);    }    SDL_WaitThread(server->wait_server_thread, NULL);}
close_socket(socket_t *socket) {    assert(*socket != INVALID_SOCKET);    net_shutdown(*socket, SHUT_RDWR);    if (!net_close(*socket)) {        LOGW("Could not close socket");        return;    }    *socket = INVALID_SOCKET;}
run_wait_server(void *data) {    struct server *server = data;    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    return 0;}
close_socket(socket_t *socket) {    assert(*socket != INVALID_SOCKET);    net_shutdown(*socket, SHUT_RDWR);    if (!net_close(*socket)) {        LOGW("Could not close socket");        return;    }    *socket = INVALID_SOCKET;}
server_start(struct server *server, const char *serial,             const struct server_params *params) {    server->port_range = params->port_range;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        goto error1;    }    if (!enable_tunnel_any_port(server, params->port_range)) {        goto error1;    }    // server will connect to our server socket    server->process = execute_server(server, params);    if (server->process == PROCESS_NONE) {        goto error2;    }    // If the server process dies before connecting to the server socket, then    // the client will be stuck forever on accept(). To avoid the problem, we    // must be able to wake up the accept() call when the server dies. To keep    // things simple and multiplatform, just spawn a new thread waiting for the    // server process and calling shutdown()/close() on the server socket if    // necessary to wake up any accept() blocking call.    server->wait_server_thread =        SDL_CreateThread(run_wait_server, "wait-server", server);    if (!server->wait_server_thread) {        if (!cmd_terminate(server->process)) {            LOGW("Could not terminate server");        }        cmd_simple_wait(server->process, NULL); // ignore exit code        goto error2;    }    server->tunnel_enabled = true;    return true;error2:    if (!server->tunnel_forward) {        // the wait server thread is not started, SDL_AtomicSet() is sufficient        SDL_AtomicSet(&server->server_socket_closed, 1);        close_socket(server->server_socket);    }    disable_tunnel(server);error1:    SDL_free(server->serial);    return false;}
server_connect_to(struct server *server) {    if (!server->tunnel_forward) {        server->video_socket = net_accept(server->server_socket);        if (server->video_socket == INVALID_SOCKET) {            return false;        }        server->control_socket = net_accept(server->server_socket);        if (server->control_socket == INVALID_SOCKET) {            // the video_socket will be cleaned up on destroy            return false;        }        // we don't need the server socket anymore        if (SDL_AtomicCAS(&server->server_socket_closed, 0, 1)) {            // close it from here            close_socket(server->server_socket);            // otherwise, it is closed by run_wait_server()        }    } else {        uint32_t attempts = 100;        uint32_t delay = 100; // ms        server->video_socket =            connect_to_server(server->local_port, attempts, delay);        if (server->video_socket == INVALID_SOCKET) {            return false;        }        // we know that the device is listening, we don't need several attempts        server->control_socket =            net_connect(IPV4_LOCALHOST, server->local_port);        if (server->control_socket == INVALID_SOCKET) {            return false;        }    }    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = false;    return true;}
server_stop(struct server *server) {    if (server->server_socket != INVALID_SOCKET            && SDL_AtomicCAS(&server->server_socket_closed, 0, 1)) {        close_socket(server->server_socket);    }    if (server->video_socket != INVALID_SOCKET) {        close_socket(server->video_socket);    }    if (server->control_socket != INVALID_SOCKET) {        close_socket(server->control_socket);    }    assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Could not terminate server");    }    if (server->tunnel_enabled) {        // ignore failure        disable_tunnel(server);    }    SDL_WaitThread(server->wait_server_thread, NULL);}
close_socket(socket_t socket) {    assert(socket != INVALID_SOCKET);    net_shutdown(socket, SHUT_RDWR);    if (!net_close(socket)) {        LOGW("Could not close socket");    }}
run_wait_server(void *data) {    struct server *server = data;    cmd_simple_wait(server->process, NULL); // ignore exit code    // no need for synchronization, server_socket is initialized before this    // thread was created    if (server->server_socket != INVALID_SOCKET            && SDL_AtomicCAS(&server->server_socket_closed, 0, 1)) {        // On Linux, accept() is unblocked by shutdown(), but on Windows, it is        // unblocked by closesocket(). Therefore, call both (close_socket()).        close_socket(server->server_socket);    }    LOGD("Server terminated");    return 0;}
close_socket(socket_t socket) {    assert(socket != INVALID_SOCKET);    net_shutdown(socket, SHUT_RDWR);    if (!net_close(socket)) {        LOGW("Could not close socket");    }}voidserver_init(struct server *server) {
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"crop",                   required_argument, NULL, OPT_CROP},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"port",                   required_argument, NULL, 'p'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"stay-awake",             no_argument,       NULL, 'w'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTvw", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case 'w':                opts->stay_awake = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    if (!opts->control && opts->stay_awake) {        LOGE("Could not request to stay awake if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"codec-options",          required_argument, NULL, OPT_CODEC_OPTIONS},        {"crop",                   required_argument, NULL, OPT_CROP},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"port",                   required_argument, NULL, 'p'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"stay-awake",             no_argument,       NULL, 'w'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTvw", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case 'w':                opts->stay_awake = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            case OPT_CODEC_OPTIONS:                opts->codec_options = optarg;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    if (!opts->control && opts->stay_awake) {        LOGE("Could not request to stay awake if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,        .show_touches = options->show_touches,        .stay_awake = options->stay_awake,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options-> mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,        .show_touches = options->show_touches,        .stay_awake = options->stay_awake,        .codec_options = options->codec_options,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options-> mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    server_destroy(&server);    return ret;}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    char max_fps_string[6];    char lock_video_orientation_string[3];    char display_id_string[6];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    sprintf(max_fps_string, "%"PRIu16, params->max_fps);    sprintf(lock_video_orientation_string, "%"PRIi8, params->lock_video_orientation);    sprintf(display_id_string, "%"PRIu16, params->display_id);    const char *const cmd[] = {        "shell",        "CLASSPATH=" DEVICE_SERVER_PATH,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"# ifdef SERVER_DEBUGGER_METHOD_NEW        /* Android 9 and above */        "-XjdwpProvider:internal -XjdwpOptions:transport=dt_socket,suspend=y,server=y,address="# else        /* Android 8 and below */        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="# endif            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,        max_size_string,        bit_rate_string,        max_fps_string,        lock_video_orientation_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",        display_id_string,        params->show_touches ? "true" : "false",        params->stay_awake ? "true" : "false",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    char max_fps_string[6];    char lock_video_orientation_string[3];    char display_id_string[6];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    sprintf(max_fps_string, "%"PRIu16, params->max_fps);    sprintf(lock_video_orientation_string, "%"PRIi8, params->lock_video_orientation);    sprintf(display_id_string, "%"PRIu16, params->display_id);    const char *const cmd[] = {        "shell",        "CLASSPATH=" DEVICE_SERVER_PATH,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"# ifdef SERVER_DEBUGGER_METHOD_NEW        /* Android 9 and above */        "-XjdwpProvider:internal -XjdwpOptions:transport=dt_socket,suspend=y,server=y,address="# else        /* Android 8 and below */        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="# endif            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,        max_size_string,        bit_rate_string,        max_fps_string,        lock_video_orientation_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",        display_id_string,        params->show_touches ? "true" : "false",        params->stay_awake ? "true" : "false",        params->codec_options ? params->codec_options : "-",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
    private void internalStreamScreen(Device device, FileDescriptor fd) throws IOException {        MediaFormat format = createFormat(bitRate, maxFps);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                ScreenInfo screenInfo = device.getScreenInfo();                Rect contentRect = screenInfo.getContentRect();                // include the locked video orientation                Rect videoRect = screenInfo.getVideoSize().toRect();                // does not include the locked video orientation                Rect unlockedVideoRect = screenInfo.getUnlockedVideoSize().toRect();                int videoRotation = screenInfo.getVideoRotation();                int layerStack = device.getLayerStack();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, videoRotation, contentRect, unlockedVideoRect, layerStack);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    private static MediaFormat createFormat(int bitRate, int maxFps) {        MediaFormat format = new MediaFormat();        format.setString(MediaFormat.KEY_MIME, MediaFormat.MIMETYPE_VIDEO_AVC);        format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);        // must be present to configure the encoder, but does not impact the actual frame rate, which is variable        format.setInteger(MediaFormat.KEY_FRAME_RATE, 60);        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, DEFAULT_I_FRAME_INTERVAL);        // display the very first frame, and recover from bad quality when no new frames        format.setLong(MediaFormat.KEY_REPEAT_PREVIOUS_FRAME_AFTER, REPEAT_FRAME_DELAY_US); // µs        if (maxFps > 0) {            // The key existed privately before Android 10:            // <https://android.googlesource.com/platform/frameworks/base/+/625f0aad9f7a259b6881006ad8710adce57d1384%5E%21/>            // <https://github.com/Genymobile/scrcpy/issues/488#issuecomment-567321437>            format.setFloat(KEY_MAX_FPS_TO_ENCODER, maxFps);        }        return format;    }
    private static MediaFormat createFormat(int bitRate, int maxFps) {        MediaFormat format = new MediaFormat();        format.setString(MediaFormat.KEY_MIME, MediaFormat.MIMETYPE_VIDEO_AVC);        format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);        // must be present to configure the encoder, but does not impact the actual frame rate, which is variable        format.setInteger(MediaFormat.KEY_FRAME_RATE, 60);        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, DEFAULT_I_FRAME_INTERVAL);        // display the very first frame, and recover from bad quality when no new frames        format.setLong(MediaFormat.KEY_REPEAT_PREVIOUS_FRAME_AFTER, REPEAT_FRAME_DELAY_US); // µs        if (maxFps > 0) {            // The key existed privately before Android 10:            // <https://android.googlesource.com/platform/frameworks/base/+/625f0aad9f7a259b6881006ad8710adce57d1384%5E%21/>            // <https://github.com/Genymobile/scrcpy/issues/488#issuecomment-567321437>            format.setFloat(KEY_MAX_FPS_TO_ENCODER, maxFps);        }        return format;    }
    private static MediaFormat createFormat(int bitRate, int maxFps) {        MediaFormat format = new MediaFormat();        format.setString(MediaFormat.KEY_MIME, MediaFormat.MIMETYPE_VIDEO_AVC);        format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);        // must be present to configure the encoder, but does not impact the actual frame rate, which is variable        format.setInteger(MediaFormat.KEY_FRAME_RATE, 60);        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, DEFAULT_I_FRAME_INTERVAL);        // display the very first frame, and recover from bad quality when no new frames        format.setLong(MediaFormat.KEY_REPEAT_PREVIOUS_FRAME_AFTER, REPEAT_FRAME_DELAY_US); // µs        if (maxFps > 0) {            // The key existed privately before Android 10:            // <https://android.googlesource.com/platform/frameworks/base/+/625f0aad9f7a259b6881006ad8710adce57d1384%5E%21/>            // <https://github.com/Genymobile/scrcpy/issues/488#issuecomment-567321437>            format.setFloat(KEY_MAX_FPS_TO_ENCODER, maxFps);        }        return format;    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps) {        this.sendFrameMeta = sendFrameMeta;        this.bitRate = bitRate;        this.maxFps = maxFps;    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps) {        this.sendFrameMeta = sendFrameMeta;        this.bitRate = bitRate;        this.maxFps = maxFps;    }
    private void internalStreamScreen(Device device, FileDescriptor fd) throws IOException {        MediaFormat format = createFormat(bitRate, maxFps, codecOptions);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                ScreenInfo screenInfo = device.getScreenInfo();                Rect contentRect = screenInfo.getContentRect();                // include the locked video orientation                Rect videoRect = screenInfo.getVideoSize().toRect();                // does not include the locked video orientation                Rect unlockedVideoRect = screenInfo.getUnlockedVideoSize().toRect();                int videoRotation = screenInfo.getVideoRotation();                int layerStack = device.getLayerStack();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, videoRotation, contentRect, unlockedVideoRect, layerStack);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
        return MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_VIDEO_AVC);    }    private static void setCodecOption(MediaFormat format, CodecOption codecOption) {        String key = codecOption.getKey();        Object value = codecOption.getValue();        if (value instanceof Integer) {            format.setInteger(key, (Integer) value);        } else if (value instanceof Long) {            format.setLong(key, (Long) value);        } else if (value instanceof Float) {            format.setFloat(key, (Float) value);        } else if (value instanceof String) {            format.setString(key, (String) value);        }        Ln.d("Codec option set: " + key + " (" + value.getClass().getSimpleName() + ") = " + value);    }
    private static void setCodecOption(MediaFormat format, CodecOption codecOption) {        String key = codecOption.getKey();        Object value = codecOption.getValue();        if (value instanceof Integer) {            format.setInteger(key, (Integer) value);        } else if (value instanceof Long) {            format.setLong(key, (Long) value);        } else if (value instanceof Float) {            format.setFloat(key, (Float) value);        } else if (value instanceof String) {            format.setString(key, (String) value);        }        Ln.d("Codec option set: " + key + " (" + value.getClass().getSimpleName() + ") = " + value);    }
    private static MediaFormat createFormat(int bitRate, int maxFps, List<CodecOption> codecOptions) {        MediaFormat format = new MediaFormat();        format.setString(MediaFormat.KEY_MIME, MediaFormat.MIMETYPE_VIDEO_AVC);        format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);        // must be present to configure the encoder, but does not impact the actual frame rate, which is variable        format.setInteger(MediaFormat.KEY_FRAME_RATE, 60);        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, DEFAULT_I_FRAME_INTERVAL);        // display the very first frame, and recover from bad quality when no new frames        format.setLong(MediaFormat.KEY_REPEAT_PREVIOUS_FRAME_AFTER, REPEAT_FRAME_DELAY_US); // µs        if (maxFps > 0) {            // The key existed privately before Android 10:            // <https://android.googlesource.com/platform/frameworks/base/+/625f0aad9f7a259b6881006ad8710adce57d1384%5E%21/>            // <https://github.com/Genymobile/scrcpy/issues/488#issuecomment-567321437>            format.setFloat(KEY_MAX_FPS_TO_ENCODER, maxFps);        }        if (codecOptions != null) {            for (CodecOption option : codecOptions) {                setCodecOption(format, option);            }        }        return format;    }
    private long ptsOrigin;    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps, List<CodecOption> codecOptions) {        this.sendFrameMeta = sendFrameMeta;        this.bitRate = bitRate;        this.maxFps = maxFps;
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps, List<CodecOption> codecOptions) {        this.sendFrameMeta = sendFrameMeta;        this.bitRate = bitRate;        this.maxFps = maxFps;        this.codecOptions = codecOptions;    }
    private static Options createOptions(String... args) {        if (args.length < 1) {            throw new IllegalArgumentException("Missing client version");        }        String clientVersion = args[0];        if (!clientVersion.equals(BuildConfig.VERSION_NAME)) {            throw new IllegalArgumentException(                    "The server version (" + BuildConfig.VERSION_NAME + ") does not match the client " + "(" + clientVersion + ")");        }        final int expectedParameters = 12;        if (args.length != expectedParameters) {            throw new IllegalArgumentException("Expecting " + expectedParameters + " parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[1]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[2]);        options.setBitRate(bitRate);        int maxFps = Integer.parseInt(args[3]);        options.setMaxFps(maxFps);        int lockedVideoOrientation = Integer.parseInt(args[4]);        options.setLockedVideoOrientation(lockedVideoOrientation);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[5]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[6]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[7]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[8]);        options.setControl(control);        int displayId = Integer.parseInt(args[9]);        options.setDisplayId(displayId);        boolean showTouches = Boolean.parseBoolean(args[10]);        options.setShowTouches(showTouches);        boolean stayAwake = Boolean.parseBoolean(args[11]);        options.setStayAwake(stayAwake);        return options;    }
    private static void scrcpy(Options options) throws IOException {        Ln.i("Device: " + Build.MANUFACTURER + " " + Build.MODEL + " (Android " + Build.VERSION.RELEASE + ")");        final Device device = new Device(options);        boolean mustDisableShowTouchesOnCleanUp = false;        int restoreStayOn = -1;        if (options.getShowTouches() || options.getStayAwake()) {            try (ContentProvider settings = device.createSettingsProvider()) {                if (options.getShowTouches()) {                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_SYSTEM, "show_touches", "1");                    // If "show touches" was disabled, it must be disabled back on clean up                    mustDisableShowTouchesOnCleanUp = !"1".equals(oldValue);                }                if (options.getStayAwake()) {                    int stayOn = BatteryManager.BATTERY_PLUGGED_AC | BatteryManager.BATTERY_PLUGGED_USB | BatteryManager.BATTERY_PLUGGED_WIRELESS;                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_GLOBAL, "stay_on_while_plugged_in", String.valueOf(stayOn));                    try {                        restoreStayOn = Integer.parseInt(oldValue);                        if (restoreStayOn == stayOn) {                            // No need to restore                            restoreStayOn = -1;                        }                    } catch (NumberFormatException e) {                        restoreStayOn = 0;                    }                }            }        }        CleanUp.configure(mustDisableShowTouchesOnCleanUp, restoreStayOn);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate(), options.getMaxFps());            if (options.getControl()) {                final Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());                device.setClipboardListener(new Device.ClipboardListener() {                    @Override                    public void onClipboardTextChanged(String text) {                        controller.getSender().pushClipboardText(text);                    }                });            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    private static Options createOptions(String... args) {        if (args.length < 1) {            throw new IllegalArgumentException("Missing client version");        }        String clientVersion = args[0];        if (!clientVersion.equals(BuildConfig.VERSION_NAME)) {            throw new IllegalArgumentException(                    "The server version (" + BuildConfig.VERSION_NAME + ") does not match the client " + "(" + clientVersion + ")");        }        final int expectedParameters = 13;        if (args.length != expectedParameters) {            throw new IllegalArgumentException("Expecting " + expectedParameters + " parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[1]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[2]);        options.setBitRate(bitRate);        int maxFps = Integer.parseInt(args[3]);        options.setMaxFps(maxFps);        int lockedVideoOrientation = Integer.parseInt(args[4]);        options.setLockedVideoOrientation(lockedVideoOrientation);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[5]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[6]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[7]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[8]);        options.setControl(control);        int displayId = Integer.parseInt(args[9]);        options.setDisplayId(displayId);        boolean showTouches = Boolean.parseBoolean(args[10]);        options.setShowTouches(showTouches);        boolean stayAwake = Boolean.parseBoolean(args[11]);        options.setStayAwake(stayAwake);        String codecOptions = args[12];        options.setCodecOptions(codecOptions);        return options;    }
    private static void scrcpy(Options options) throws IOException {        Ln.i("Device: " + Build.MANUFACTURER + " " + Build.MODEL + " (Android " + Build.VERSION.RELEASE + ")");        final Device device = new Device(options);        List<CodecOption> codecOptions = CodecOption.parse(options.getCodecOptions());        boolean mustDisableShowTouchesOnCleanUp = false;        int restoreStayOn = -1;        if (options.getShowTouches() || options.getStayAwake()) {            try (ContentProvider settings = device.createSettingsProvider()) {                if (options.getShowTouches()) {                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_SYSTEM, "show_touches", "1");                    // If "show touches" was disabled, it must be disabled back on clean up                    mustDisableShowTouchesOnCleanUp = !"1".equals(oldValue);                }                if (options.getStayAwake()) {                    int stayOn = BatteryManager.BATTERY_PLUGGED_AC | BatteryManager.BATTERY_PLUGGED_USB | BatteryManager.BATTERY_PLUGGED_WIRELESS;                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_GLOBAL, "stay_on_while_plugged_in", String.valueOf(stayOn));                    try {                        restoreStayOn = Integer.parseInt(oldValue);                        if (restoreStayOn == stayOn) {                            // No need to restore                            restoreStayOn = -1;                        }                    } catch (NumberFormatException e) {                        restoreStayOn = 0;                    }                }            }        }        CleanUp.configure(mustDisableShowTouchesOnCleanUp, restoreStayOn);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate(), options.getMaxFps(), codecOptions);            if (options.getControl()) {                final Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());                device.setClipboardListener(new Device.ClipboardListener() {                    @Override                    public void onClipboardTextChanged(String text) {                        controller.getSender().pushClipboardText(text);                    }                });            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    public Point getPhysicalPoint(Position position) {        // it hides the field on purpose, to read it with a lock        @SuppressWarnings("checkstyle:HiddenField")        ScreenInfo screenInfo = getScreenInfo(); // read with synchronization        Size videoSize = screenInfo.getVideoSize();        int deviceRotation = screenInfo.getRotation();        int reverseVideoRotation = getReverseVideoRotation(deviceRotation);        // reverse the video rotation to apply the events        Position devicePosition = position.rotate(reverseVideoRotation);        Size clientVideoSize = devicePosition.getScreenSize();        if (!videoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event            return null;        }        Rect contentRect = screenInfo.getContentRect();        Point point = devicePosition.getPoint();        int convertedX = contentRect.left + point.getX() * contentRect.width() / videoSize.getWidth();        int convertedY = contentRect.top + point.getY() * contentRect.height() / videoSize.getHeight();        return new Point(convertedX, convertedY);    }
    public Device(Options options) {        lockedVideoOrientation = options.getLockedVideoOrientation();        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        screenInfo = ScreenInfo.computeScreenInfo(displayInfo, options.getCrop(), options.getMaxSize());        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    screenInfo = screenInfo.withRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        });    }
    public Point getPhysicalPoint(Position position) {        // it hides the field on purpose, to read it with a lock        @SuppressWarnings("checkstyle:HiddenField")        ScreenInfo screenInfo = getScreenInfo(); // read with synchronization        Size videoSize = screenInfo.getVideoSize();        int deviceRotation = screenInfo.getDeviceRotation();        int reverseVideoRotation = getReverseVideoRotation(deviceRotation);        // reverse the video rotation to apply the events        Position devicePosition = position.rotate(reverseVideoRotation);        Size clientVideoSize = devicePosition.getScreenSize();        if (!videoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event            return null;        }        Rect contentRect = screenInfo.getContentRect();        Point point = devicePosition.getPoint();        int convertedX = contentRect.left + point.getX() * contentRect.width() / videoSize.getWidth();        int convertedY = contentRect.top + point.getY() * contentRect.height() / videoSize.getHeight();        return new Point(convertedX, convertedY);    }
    public Device(Options options) {        lockedVideoOrientation = options.getLockedVideoOrientation();        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        screenInfo = ScreenInfo.computeScreenInfo(displayInfo, options.getCrop(), options.getMaxSize());        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    screenInfo = screenInfo.withDeviceRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        });    }
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        Workarounds.prepareMainLooper();        Workarounds.fillAppInfo();        MediaFormat format = createFormat(bitRate, maxFps, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                ScreenInfo screenInfo = device.getScreenInfo();                Rect contentRect = screenInfo.getContentRect();                Rect videoRect = screenInfo.getVideoSize().toRect();                int videoRotation = device.getVideoRotation(screenInfo.getRotation());                setSize(format, videoRotation, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, videoRotation, contentRect, videoRect);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        Workarounds.prepareMainLooper();        Workarounds.fillAppInfo();        MediaFormat format = createFormat(bitRate, maxFps, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                ScreenInfo screenInfo = device.getScreenInfo();                Rect contentRect = screenInfo.getContentRect();                Rect videoRect = screenInfo.getVideoSize().toRect();                int videoRotation = device.getVideoRotation(screenInfo.getDeviceRotation());                setSize(format, videoRotation, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, videoRotation, contentRect, videoRect);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    public ScreenInfo(Rect contentRect, Size videoSize, int rotation) {        this.contentRect = contentRect;        this.videoSize = videoSize;        this.rotation = rotation;    }
    public ScreenInfo withRotation(int newRotation) {        if (newRotation == rotation) {            return this;        }        // true if changed between portrait and landscape        boolean orientationChanged = (rotation + newRotation) % 2 != 0;        Rect newContentRect;        Size newVideoSize;        if (orientationChanged) {            newContentRect = flipRect(contentRect);            newVideoSize = videoSize.rotate();        } else {            newContentRect = contentRect;            newVideoSize = videoSize;        }        return new ScreenInfo(newContentRect, newVideoSize, newRotation);    }
    public int getRotation() {        return rotation;    }
    public int getRotation() {        return rotation;    }
    public ScreenInfo(Rect contentRect, Size videoSize, int rotation) {        this.contentRect = contentRect;        this.videoSize = videoSize;        this.rotation = rotation;    }
    public ScreenInfo(Rect contentRect, Size videoSize, int rotation) {        this.contentRect = contentRect;        this.videoSize = videoSize;        this.rotation = rotation;    }
    public ScreenInfo(Rect contentRect, Size videoSize, int deviceRotation) {        this.contentRect = contentRect;        this.videoSize = videoSize;        this.deviceRotation = deviceRotation;    }
    public ScreenInfo withDeviceRotation(int newDeviceRotation) {        if (newDeviceRotation == deviceRotation) {            return this;        }        // true if changed between portrait and landscape        boolean orientationChanged = (deviceRotation + newDeviceRotation) % 2 != 0;        Rect newContentRect;        Size newVideoSize;        if (orientationChanged) {            newContentRect = flipRect(contentRect);            newVideoSize = videoSize.rotate();        } else {            newContentRect = contentRect;            newVideoSize = videoSize;        }        return new ScreenInfo(newContentRect, newVideoSize, newDeviceRotation);    }
    public int getDeviceRotation() {        return deviceRotation;    }
    public ScreenInfo withDeviceRotation(int newDeviceRotation) {        if (newDeviceRotation == deviceRotation) {            return this;        }        // true if changed between portrait and landscape        boolean orientationChanged = (deviceRotation + newDeviceRotation) % 2 != 0;        Rect newContentRect;        Size newVideoSize;        if (orientationChanged) {            newContentRect = flipRect(contentRect);            newVideoSize = videoSize.rotate();        } else {            newContentRect = contentRect;            newVideoSize = videoSize;        }        return new ScreenInfo(newContentRect, newVideoSize, newDeviceRotation);    }
    public ScreenInfo(Rect contentRect, Size videoSize, int deviceRotation) {        this.contentRect = contentRect;        this.videoSize = videoSize;        this.deviceRotation = deviceRotation;    }
    public int getDeviceRotation() {        return deviceRotation;    }
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    char max_fps_string[6];    char lock_video_orientation_string[5];    char display_id_string[6];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    sprintf(max_fps_string, "%"PRIu16, params->max_fps);    sprintf(lock_video_orientation_string, "%"PRIi8, params->lock_video_orientation);    sprintf(display_id_string, "%"PRIu16, params->display_id);    const char *const cmd[] = {        "shell",        "CLASSPATH=" DEVICE_SERVER_PATH,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"# ifdef SERVER_DEBUGGER_METHOD_NEW        /* Android 9 and above */        "-XjdwpProvider:internal -XjdwpOptions:transport=dt_socket,suspend=y,server=y,address="# else        /* Android 8 and below */        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="# endif            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,        max_size_string,        bit_rate_string,        max_fps_string,        lock_video_orientation_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",        display_id_string,        params->show_touches ? "true" : "false",        params->stay_awake ? "true" : "false",        params->codec_options ? params->codec_options : "-",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    char max_fps_string[6];    char lock_video_orientation_string[5];    char display_id_string[6];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    sprintf(max_fps_string, "%"PRIu16, params->max_fps);    sprintf(lock_video_orientation_string, "%"PRIi8, params->lock_video_orientation);    sprintf(display_id_string, "%"PRIu16, params->display_id);    const char *const cmd[] = {        "shell",        "CLASSPATH=" DEVICE_SERVER_PATH,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"# ifdef SERVER_DEBUGGER_METHOD_NEW        /* Android 9 and above */        "-XjdwpProvider:internal -XjdwpOptions:transport=dt_socket,suspend=y,server=y,address="# else        /* Android 8 and below */        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="# endif            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,#ifndef NDEBUG        "debug",#else        "info",#endif        max_size_string,        bit_rate_string,        max_fps_string,        lock_video_orientation_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",        display_id_string,        params->show_touches ? "true" : "false",        params->stay_awake ? "true" : "false",        params->codec_options ? params->codec_options : "-",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
    private static Options createOptions(String... args) {        if (args.length < 1) {            throw new IllegalArgumentException("Missing client version");        }        String clientVersion = args[0];        if (!clientVersion.equals(BuildConfig.VERSION_NAME)) {            throw new IllegalArgumentException(                    "The server version (" + BuildConfig.VERSION_NAME + ") does not match the client " + "(" + clientVersion + ")");        }        final int expectedParameters = 13;        if (args.length != expectedParameters) {            throw new IllegalArgumentException("Expecting " + expectedParameters + " parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[1]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[2]);        options.setBitRate(bitRate);        int maxFps = Integer.parseInt(args[3]);        options.setMaxFps(maxFps);        int lockedVideoOrientation = Integer.parseInt(args[4]);        options.setLockedVideoOrientation(lockedVideoOrientation);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[5]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[6]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[7]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[8]);        options.setControl(control);        int displayId = Integer.parseInt(args[9]);        options.setDisplayId(displayId);        boolean showTouches = Boolean.parseBoolean(args[10]);        options.setShowTouches(showTouches);        boolean stayAwake = Boolean.parseBoolean(args[11]);        options.setStayAwake(stayAwake);        String codecOptions = args[12];        options.setCodecOptions(codecOptions);        return options;    }
    public static void main(String... args) throws Exception {        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {            @Override            public void uncaughtException(Thread t, Throwable e) {                Ln.e("Exception on thread " + t, e);                suggestFix(e);            }        });        Options options = createOptions(args);        scrcpy(options);    }}
    private static Options createOptions(String... args) {        if (args.length < 1) {            throw new IllegalArgumentException("Missing client version");        }        String clientVersion = args[0];        if (!clientVersion.equals(BuildConfig.VERSION_NAME)) {            throw new IllegalArgumentException(                    "The server version (" + BuildConfig.VERSION_NAME + ") does not match the client " + "(" + clientVersion + ")");        }        final int expectedParameters = 14;        if (args.length != expectedParameters) {            throw new IllegalArgumentException("Expecting " + expectedParameters + " parameters");        }        Options options = new Options();        Ln.Level level = Ln.Level.valueOf(args[1].toUpperCase());        options.setLogLevel(level);        int maxSize = Integer.parseInt(args[2]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[3]);        options.setBitRate(bitRate);        int maxFps = Integer.parseInt(args[4]);        options.setMaxFps(maxFps);        int lockedVideoOrientation = Integer.parseInt(args[5]);        options.setLockedVideoOrientation(lockedVideoOrientation);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[6]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[7]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[8]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[9]);        options.setControl(control);        int displayId = Integer.parseInt(args[10]);        options.setDisplayId(displayId);        boolean showTouches = Boolean.parseBoolean(args[11]);        options.setShowTouches(showTouches);        boolean stayAwake = Boolean.parseBoolean(args[12]);        options.setStayAwake(stayAwake);        String codecOptions = args[13];        options.setCodecOptions(codecOptions);        return options;    }
    public static void main(String... args) throws Exception {        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {            @Override            public void uncaughtException(Thread t, Throwable e) {                Ln.e("Exception on thread " + t, e);                suggestFix(e);            }        });        Options options = createOptions(args);        Ln.initLogLevel(options.getLogLevel());        scrcpy(options);    }}
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    --shortcut-mod key[+...]][,...]\n"        "        Specify the modifiers to use for scrcpy shortcuts.\n"        "        Possible keys are \"lctrl\", \"rctrl\", \"lalt\", \"ralt\",\n"        "        \"lsuper\" and \"rsuper\".\n"        "\n"        "        A shortcut can consist in several keys, separated by '+'.\n"        "        Several shortcuts can be specified, separated by ','.\n"        "\n"        "        For example, to use either LCtrl+LAlt or LSuper for scrcpy\n"        "        shortcuts, pass \"lctrl+lalt,lsuper\".\n"        "\n"        "        Default is \"lalt,lsuper\" (left-Alt or left-Super).\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    In the following list, MOD is the shortcut modifier. By default,\n"        "    it's (left) Alt or (left) Super, but it can be configured by\n"        "    --shortcut-mod.\n"        "\n"        "    MOD+f\n"        "        Switch fullscreen mode\n"        "\n"        "    MOD+Left\n"        "        Rotate display left\n"        "\n"        "    MOD+Right\n"        "        Rotate display right\n"        "\n"        "    MOD+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    MOD+w\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    MOD+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    MOD+b\n"        "    MOD+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    MOD+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    MOD+m\n"        "        Click on MENU\n"        "\n"        "    MOD+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    MOD+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    MOD+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    MOD+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    MOD+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    MOD+r\n"        "        Rotate device screen\n"        "\n"        "    MOD+n\n"        "        Expand notification panel\n"        "\n"        "    MOD+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    MOD+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    MOD+Shift+v\n"        "        Copy computer clipboard to device (and paste if the device\n"        "        runs Android >= 7)\n"        "\n"        "    MOD+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    --shortcut-mod key[+...]][,...]\n"        "        Specify the modifiers to use for scrcpy shortcuts.\n"        "        Possible keys are \"lctrl\", \"rctrl\", \"lalt\", \"ralt\",\n"        "        \"lsuper\" and \"rsuper\".\n"        "\n"        "        A shortcut can consist in several keys, separated by '+'.\n"        "        Several shortcuts can be specified, separated by ','.\n"        "\n"        "        For example, to use either LCtrl+LAlt or LSuper for scrcpy\n"        "        shortcuts, pass \"lctrl+lalt,lsuper\".\n"        "\n"        "        Default is \"lalt,lsuper\" (left-Alt or left-Super).\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    In the following list, MOD is the shortcut modifier. By default,\n"        "    it's (left) Alt or (left) Super, but it can be configured by\n"        "    --shortcut-mod.\n"        "\n"        "    MOD+f\n"        "        Switch fullscreen mode\n"        "\n"        "    MOD+Left\n"        "        Rotate display left\n"        "\n"        "    MOD+Right\n"        "        Rotate display right\n"        "\n"        "    MOD+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    MOD+w\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    MOD+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    MOD+b\n"        "    MOD+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    MOD+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    MOD+m\n"        "        Click on MENU\n"        "\n"        "    MOD+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    MOD+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    MOD+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    MOD+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    MOD+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    MOD+r\n"        "        Rotate device screen\n"        "\n"        "    MOD+n\n"        "        Expand notification panel\n"        "\n"        "    MOD+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    MOD+c\n"        "        Copy to clipboard (inject COPY keycode, Android >= 7 only)\n"        "\n"        "    MOD+x\n"        "        Cut to clipboard (inject CUT keycode, Android >= 7 only)\n"        "\n"        "    MOD+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    MOD+Shift+v\n"        "        Copy computer clipboard to device (and paste if the device\n"        "        runs Android >= 7)\n"        "\n"        "    MOD+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    bool smod = is_shortcut_mod(im, event->keysym.mod);    struct controller *controller = im->controller;    SDL_Keycode keycode = event->keysym.sym;    bool down = event->type == SDL_KEYDOWN;    bool ctrl = event->keysym.mod & KMOD_CTRL;    bool shift = event->keysym.mod & KMOD_SHIFT;    bool repeat = event->repeat;    // The shortcut modifier is pressed    if (smod) {        int action = down ? ACTION_DOWN : ACTION_UP;        switch (keycode) {            case SDLK_h:                if (control && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                if (control && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (!shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (!shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_v:                if (control && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_w:                if (!shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    if (ctrl && !shift && keycode == SDLK_v && down && !repeat) {        // Synchronize the computer clipboard to the device clipboard before        // sending Ctrl+v, to allow seamless copy-paste.        set_device_clipboard(controller, false);    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    bool smod = is_shortcut_mod(im, event->keysym.mod);    struct controller *controller = im->controller;    SDL_Keycode keycode = event->keysym.sym;    bool down = event->type == SDL_KEYDOWN;    bool ctrl = event->keysym.mod & KMOD_CTRL;    bool shift = event->keysym.mod & KMOD_SHIFT;    bool repeat = event->repeat;    // The shortcut modifier is pressed    if (smod) {        int action = down ? ACTION_DOWN : ACTION_UP;        switch (keycode) {            case SDLK_h:                if (control && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                if (control && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (!shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (!shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_v:                if (control && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_w:                if (!shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    if (ctrl && !shift && keycode == SDLK_v && down && !repeat) {        // Synchronize the computer clipboard to the device clipboard before        // sending Ctrl+v, to allow seamless copy-paste.        set_device_clipboard(controller, false);    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    bool smod = is_shortcut_mod(im, event->keysym.mod);    struct controller *controller = im->controller;    SDL_Keycode keycode = event->keysym.sym;    bool down = event->type == SDL_KEYDOWN;    bool ctrl = event->keysym.mod & KMOD_CTRL;    bool shift = event->keysym.mod & KMOD_SHIFT;    bool repeat = event->repeat;    // The shortcut modifier is pressed    if (smod) {        int action = down ? ACTION_DOWN : ACTION_UP;        switch (keycode) {            case SDLK_h:                if (control && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                if (control && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (!shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (!shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_v:                if (control && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_w:                if (!shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    if (ctrl && !shift && keycode == SDLK_v && down && !repeat) {        // Synchronize the computer clipboard to the device clipboard before        // sending Ctrl+v, to allow seamless copy-paste.        set_device_clipboard(controller, false);    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    bool smod = is_shortcut_mod(im, event->keysym.mod);    struct controller *controller = im->controller;    SDL_Keycode keycode = event->keysym.sym;    bool down = event->type == SDL_KEYDOWN;    bool ctrl = event->keysym.mod & KMOD_CTRL;    bool shift = event->keysym.mod & KMOD_SHIFT;    bool repeat = event->repeat;    // The shortcut modifier is pressed    if (smod) {        int action = down ? ACTION_DOWN : ACTION_UP;        switch (keycode) {            case SDLK_h:                if (control && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                if (control && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (!shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (!shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && !shift && !repeat) {                    action_copy(controller, action);                }                return;            case SDLK_x:                if (control && !shift && !repeat) {                    action_cut(controller, action);                }                return;            case SDLK_v:                if (control && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_w:                if (!shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    if (ctrl && !shift && keycode == SDLK_v && down && !repeat) {        // Synchronize the computer clipboard to the device clipboard before        // sending Ctrl+v, to allow seamless copy-paste.        set_device_clipboard(controller, false);    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
action_copy(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_COPY, actions, "COPY");}
action_cut(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_CUT, actions, "CUT");}
get_optimal_window_size(const struct screen *screen, struct size content_size) {    struct size windowed_size = get_windowed_window_size(screen);    return get_optimal_size(windowed_size, content_size);}
get_optimal_window_size(const struct screen *screen, struct size content_size) {    struct size windowed_size = get_windowed_window_size(screen);    return get_optimal_size(windowed_size, content_size);}
screen_switch_fullscreen(struct screen *screen) {    uint32_t new_mode = screen->fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;    if (SDL_SetWindowFullscreen(screen->window, new_mode)) {        LOGW("Could not switch fullscreen mode: %s", SDL_GetError());        return;    }    screen->fullscreen = !screen->fullscreen;    apply_windowed_size(screen);    LOGD("Switched to %s mode", screen->fullscreen ? "fullscreen" : "windowed");    screen_render(screen);}
get_window_size(SDL_Window *window) {    int width;    int height;    SDL_GetWindowSize(window, &width, &height);    struct size size;    size.width = width;    size.height = height;    return size;}
get_window_size(SDL_Window *window) {    int width;    int height;    SDL_GetWindowSize(window, &width, &height);    struct size size;    size.width = width;    size.height = height;    return size;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation, bool mipmaps) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size = get_rotated_size(frame_size, screen->rotation);    screen->content_size = content_size;    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_RendererInfo renderer_info;    int r = SDL_GetRendererInfo(screen->renderer, &renderer_info);    const char *renderer_name = r ? NULL : renderer_info.name;    LOGI("Renderer: %s", renderer_name ? renderer_name : "(unknown)");    if (SDL_RenderSetLogicalSize(screen->renderer, content_size.width,                                 content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    // starts with "opengl"    screen->use_opengl = renderer_name && !strncmp(renderer_name, "opengl", 6);    if (screen->use_opengl) {        struct sc_opengl *gl = &screen->gl;        sc_opengl_init(gl);        LOGI("OpenGL version: %s", gl->version);        if (mipmaps) {            bool supports_mipmaps =                sc_opengl_version_at_least(gl, 3, 0, /* OpenGL 3.0+ */                                               2, 0  /* OpenGL ES 2.0+ */);            if (supports_mipmaps) {                LOGI("Trilinear filtering enabled");                screen->mipmaps = true;            } else {                LOGW("Trilinear filtering disabled "                     "(OpenGL 3.0+ or ES 2.0+ required)");            }        } else {            LOGI("Trilinear filtering disabled");        }    } else {        LOGW("Trilinear filtering disabled (not an OpenGL renderer)");    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
get_windowed_window_size(const struct screen *screen) {    if (screen->fullscreen || screen->maximized) {        return screen->windowed_window_size;    }    return get_window_size(screen->window);}
get_window_size(SDL_Window *window) {    int width;    int height;    SDL_GetWindowSize(window, &width, &height);    struct size size;    size.width = width;    size.height = height;    return size;}
screen_handle_window_event(struct screen *screen,                           const SDL_WindowEvent *event) {    switch (event->event) {        case SDL_WINDOWEVENT_EXPOSED:            screen_render(screen);            break;        case SDL_WINDOWEVENT_SIZE_CHANGED:            if (!screen->fullscreen && !screen->maximized) {                // Backup the previous size: if we receive the MAXIMIZED event,                // then the new size must be ignored (it's the maximized size).                // We could not rely on the window flags due to race conditions                // (they could be updated asynchronously, at least on X11).                screen->windowed_window_size_backup =                    screen->windowed_window_size;                // Save the windowed size, so that it is available once the                // window is maximized or fullscreen is enabled.                screen->windowed_window_size = get_window_size(screen->window);            }            screen_render(screen);            break;        case SDL_WINDOWEVENT_MAXIMIZED:            // The backup size must be non-nul.            assert(screen->windowed_window_size_backup.width);            assert(screen->windowed_window_size_backup.height);            // Revert the last size, it was updated while screen was maximized.            screen->windowed_window_size = screen->windowed_window_size_backup;#ifdef DEBUG            // Reset the backup to invalid values to detect unexpected usage            screen->windowed_window_size_backup.width = 0;            screen->windowed_window_size_backup.height = 0;#endif            screen->maximized = true;            break;        case SDL_WINDOWEVENT_RESTORED:            screen->maximized = false;            apply_windowed_size(screen);            break;    }}
set_content_size(struct screen *screen, struct size new_content_size) {    struct size old_content_size = screen->content_size;    struct size windowed_size = get_windowed_window_size(screen);    struct size target_size = {        .width = (uint32_t) windowed_size.width * new_content_size.width                / old_content_size.width,        .height = (uint32_t) windowed_size.height * new_content_size.height                / old_content_size.height,    };    target_size = get_optimal_size(target_size, new_content_size);    set_window_size(screen, target_size);    screen->content_size = new_content_size;}
set_window_size(struct screen *screen, struct size new_size) {    // setting the window size during fullscreen is implementation defined,    // so apply the resize only after fullscreen is disabled    screen->windowed_window_size = new_size;    apply_windowed_size(screen);}
apply_windowed_size(struct screen *screen) {    if (!screen->fullscreen && !screen->maximized) {        SDL_SetWindowSize(screen->window, screen->windowed_window_size.width,                                          screen->windowed_window_size.height);    }}
get_optimal_window_size(const struct screen *screen, struct size content_size) {    struct size window_size = get_window_size(screen);    return get_optimal_size(window_size, content_size);}
resize_for_content(struct screen *screen, struct size old_content_size,                                                 struct size new_content_size) {    struct size window_size = get_window_size(screen);    struct size target_size = {        .width = (uint32_t) window_size.width * new_content_size.width                / old_content_size.width,        .height = (uint32_t) window_size.height * new_content_size.height                / old_content_size.height,    };    target_size = get_optimal_size(target_size, new_content_size);    set_window_size(screen, target_size);}
screen_switch_fullscreen(struct screen *screen) {    uint32_t new_mode = screen->fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;    if (SDL_SetWindowFullscreen(screen->window, new_mode)) {        LOGW("Could not switch fullscreen mode: %s", SDL_GetError());        return;    }    screen->fullscreen = !screen->fullscreen;    if (!screen->fullscreen && !screen->maximized) {        apply_pending_resize(screen);    }    LOGD("Switched to %s mode", screen->fullscreen ? "fullscreen" : "windowed");    screen_render(screen);}
get_window_size(const struct screen *screen) {    int width;    int height;    SDL_GetWindowSize(screen->window, &width, &height);    struct size size;    size.width = width;    size.height = height;    return size;}
apply_pending_resize(struct screen *screen) {    assert(!screen->fullscreen);    assert(!screen->maximized);    if (screen->resize_pending) {        resize_for_content(screen, screen->windowed_content_size,                                   screen->content_size);        screen->resize_pending = false;    }}
    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_RendererInfo renderer_info;    int r = SDL_GetRendererInfo(screen->renderer, &renderer_info);    const char *renderer_name = r ? NULL : renderer_info.name;    LOGI("Renderer: %s", renderer_name ? renderer_name : "(unknown)");    if (SDL_RenderSetLogicalSize(screen->renderer, content_size.width,                                 content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    // starts with "opengl"    screen->use_opengl = renderer_name && !strncmp(renderer_name, "opengl", 6);    if (screen->use_opengl) {        struct sc_opengl *gl = &screen->gl;        sc_opengl_init(gl);        LOGI("OpenGL version: %s", gl->version);        if (mipmaps) {            bool supports_mipmaps =                sc_opengl_version_at_least(gl, 3, 0, /* OpenGL 3.0+ */                                               2, 0  /* OpenGL ES 2.0+ */);            if (supports_mipmaps) {                LOGI("Trilinear filtering enabled");                screen->mipmaps = true;            } else {                LOGW("Trilinear filtering disabled "                     "(OpenGL 3.0+ or ES 2.0+ required)");            }        } else {            LOGI("Trilinear filtering disabled");        }    } else {        LOGW("Trilinear filtering disabled (not an OpenGL renderer)");    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    return true;}voidscreen_show_window(struct screen *screen) {    SDL_ShowWindow(screen->window);}voidscreen_destroy(struct screen *screen) {    if (screen->texture) {        SDL_DestroyTexture(screen->texture);    }    if (screen->renderer) {        SDL_DestroyRenderer(screen->renderer);    }    if (screen->window) {        SDL_DestroyWindow(screen->window);    }}static voidresize_for_content(struct screen *screen, struct size old_content_size,                                                 struct size new_content_size) {
set_window_size(struct screen *screen, struct size new_size) {    assert(!screen->fullscreen);    assert(!screen->maximized);    SDL_SetWindowSize(screen->window, new_size.width, new_size.height);}// get the preferred display bounds (i.e. the screen bounds with some margins)
get_window_size(const struct screen *screen) {    int width;    int height;    SDL_GetWindowSize(screen->window, &width, &height);    struct size size;    size.width = width;    size.height = height;    return size;}
screen_handle_window_event(struct screen *screen,                           const SDL_WindowEvent *event) {    switch (event->event) {        case SDL_WINDOWEVENT_EXPOSED:            screen_render(screen);            break;        case SDL_WINDOWEVENT_SIZE_CHANGED:            screen_render(screen);            break;        case SDL_WINDOWEVENT_MAXIMIZED:            screen->maximized = true;            break;        case SDL_WINDOWEVENT_RESTORED:            screen->maximized = false;            apply_pending_resize(screen);            break;    }}
set_content_size(struct screen *screen, struct size new_content_size) {    if (!screen->fullscreen && !screen->maximized) {        resize_for_content(screen, screen->content_size, new_content_size);    } else if (!screen->resize_pending) {        // Store the windowed size to be able to compute the optimal size once        // fullscreen and maximized are disabled        screen->windowed_content_size = screen->content_size;        screen->resize_pending = true;    }    screen->content_size = new_content_size;}
set_window_size(struct screen *screen, struct size new_size) {    assert(!screen->fullscreen);    assert(!screen->maximized);    SDL_SetWindowSize(screen->window, new_size.width, new_size.height);}
    SDL_Rect rect;#ifdef SCRCPY_SDL_HAS_GET_DISPLAY_USABLE_BOUNDS# define GET_DISPLAY_BOUNDS(i, r) SDL_GetDisplayUsableBounds((i), (r))#else# define GET_DISPLAY_BOUNDS(i, r) SDL_GetDisplayBounds((i), (r))#endif    if (GET_DISPLAY_BOUNDS(0, &rect)) {
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    --shortcut-mod key[+...]][,...]\n"        "        Specify the modifiers to use for scrcpy shortcuts.\n"        "        Possible keys are \"lctrl\", \"rctrl\", \"lalt\", \"ralt\",\n"        "        \"lsuper\" and \"rsuper\".\n"        "\n"        "        A shortcut can consist in several keys, separated by '+'.\n"        "        Several shortcuts can be specified, separated by ','.\n"        "\n"        "        For example, to use either LCtrl+LAlt or LSuper for scrcpy\n"        "        shortcuts, pass \"lctrl+lalt,lsuper\".\n"        "\n"        "        Default is \"lalt,lsuper\" (left-Alt or left-Super).\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    In the following list, MOD is the shortcut modifier. By default,\n"        "    it's (left) Alt or (left) Super, but it can be configured by\n"        "    --shortcut-mod.\n"        "\n"        "    MOD+f\n"        "        Switch fullscreen mode\n"        "\n"        "    MOD+Left\n"        "        Rotate display left\n"        "\n"        "    MOD+Right\n"        "        Rotate display right\n"        "\n"        "    MOD+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    MOD+w\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    MOD+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    MOD+b\n"        "    MOD+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    MOD+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    MOD+m\n"        "        Click on MENU\n"        "\n"        "    MOD+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    MOD+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    MOD+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    MOD+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    MOD+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    MOD+r\n"        "        Rotate device screen\n"        "\n"        "    MOD+n\n"        "        Expand notification panel\n"        "\n"        "    MOD+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    MOD+c\n"        "        Copy to clipboard (inject COPY keycode, Android >= 7 only)\n"        "\n"        "    MOD+x\n"        "        Cut to clipboard (inject CUT keycode, Android >= 7 only)\n"        "\n"        "    MOD+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    MOD+Shift+v\n"        "        Copy computer clipboard to device (and paste if the device\n"        "        runs Android >= 7)\n"        "\n"        "    MOD+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    --shortcut-mod key[+...]][,...]\n"        "        Specify the modifiers to use for scrcpy shortcuts.\n"        "        Possible keys are \"lctrl\", \"rctrl\", \"lalt\", \"ralt\",\n"        "        \"lsuper\" and \"rsuper\".\n"        "\n"        "        A shortcut can consist in several keys, separated by '+'.\n"        "        Several shortcuts can be specified, separated by ','.\n"        "\n"        "        For example, to use either LCtrl+LAlt or LSuper for scrcpy\n"        "        shortcuts, pass \"lctrl+lalt,lsuper\".\n"        "\n"        "        Default is \"lalt,lsuper\" (left-Alt or left-Super).\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    In the following list, MOD is the shortcut modifier. By default,\n"        "    it's (left) Alt or (left) Super, but it can be configured by\n"        "    --shortcut-mod.\n"        "\n"        "    MOD+f\n"        "        Switch fullscreen mode\n"        "\n"        "    MOD+Left\n"        "        Rotate display left\n"        "\n"        "    MOD+Right\n"        "        Rotate display right\n"        "\n"        "    MOD+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    MOD+w\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    MOD+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    MOD+b\n"        "    MOD+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    MOD+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    MOD+m\n"        "        Click on MENU\n"        "\n"        "    MOD+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    MOD+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    MOD+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    MOD+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    MOD+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    MOD+r\n"        "        Rotate device screen\n"        "\n"        "    MOD+n\n"        "        Expand notification panel\n"        "\n"        "    MOD+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    MOD+c\n"        "        Copy to clipboard (inject COPY keycode, Android >= 7 only)\n"        "\n"        "    MOD+x\n"        "        Cut to clipboard (inject CUT keycode, Android >= 7 only)\n"        "\n"        "    MOD+v\n"        "        Copy computer clipboard to device, then paste (inject PASTE\n"        "        keycode, Android >= 7 only)\n"        "\n"        "    MOD+Shift+v\n"        "        Inject computer clipboard text as a sequence of key events\n"        "\n"        "    MOD+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    bool smod = is_shortcut_mod(im, event->keysym.mod);    struct controller *controller = im->controller;    SDL_Keycode keycode = event->keysym.sym;    bool down = event->type == SDL_KEYDOWN;    bool ctrl = event->keysym.mod & KMOD_CTRL;    bool shift = event->keysym.mod & KMOD_SHIFT;    bool repeat = event->repeat;    // The shortcut modifier is pressed    if (smod) {        int action = down ? ACTION_DOWN : ACTION_UP;        switch (keycode) {            case SDLK_h:                if (control && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                if (control && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (!shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (!shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && !shift && !repeat) {                    action_copy(controller, action);                }                return;            case SDLK_x:                if (control && !shift && !repeat) {                    action_cut(controller, action);                }                return;            case SDLK_v:                if (control && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_w:                if (!shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    if (ctrl && !shift && keycode == SDLK_v && down && !repeat) {        // Synchronize the computer clipboard to the device clipboard before        // sending Ctrl+v, to allow seamless copy-paste.        set_device_clipboard(controller, false);    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    bool smod = is_shortcut_mod(im, event->keysym.mod);    struct controller *controller = im->controller;    SDL_Keycode keycode = event->keysym.sym;    bool down = event->type == SDL_KEYDOWN;    bool ctrl = event->keysym.mod & KMOD_CTRL;    bool shift = event->keysym.mod & KMOD_SHIFT;    bool repeat = event->repeat;    // The shortcut modifier is pressed    if (smod) {        int action = down ? ACTION_DOWN : ACTION_UP;        switch (keycode) {            case SDLK_h:                if (control && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                if (control && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (!shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (!shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && !shift && !repeat) {                    action_copy(controller, action);                }                return;            case SDLK_x:                if (control && !shift && !repeat) {                    action_cut(controller, action);                }                return;            case SDLK_v:                if (control && !repeat && down) {                    if (shift) {                        // inject the text as input events                        clipboard_paste(controller);                    } else {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    }                }                return;            case SDLK_f:                if (!shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_w:                if (!shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    if (ctrl && !shift && keycode == SDLK_v && down && !repeat) {        // Synchronize the computer clipboard to the device clipboard before        // sending Ctrl+v, to allow seamless copy-paste.        set_device_clipboard(controller, false);    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
send_keycode(struct controller *controller, enum android_keycode keycode,             int actions, const char *name) {    // send DOWN event    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_KEYCODE;    msg.inject_keycode.keycode = keycode;    msg.inject_keycode.metastate = 0;    if (actions & ACTION_DOWN) {        msg.inject_keycode.action = AKEY_EVENT_ACTION_DOWN;        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject %s (DOWN)'", name);            return;        }    }    if (actions & ACTION_UP) {        msg.inject_keycode.action = AKEY_EVENT_ACTION_UP;        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject %s (UP)'", name);        }    }}
send_keycode(struct controller *controller, enum android_keycode keycode,             int actions, const char *name) {    // send DOWN event    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_KEYCODE;    msg.inject_keycode.keycode = keycode;    msg.inject_keycode.metastate = 0;    msg.inject_keycode.repeat = 0;    if (actions & ACTION_DOWN) {        msg.inject_keycode.action = AKEY_EVENT_ACTION_DOWN;        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject %s (DOWN)'", name);            return;        }    }    if (actions & ACTION_UP) {        msg.inject_keycode.action = AKEY_EVENT_ACTION_UP;        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject %s (UP)'", name);        }    }}
screen_resize_to_fit(struct screen *screen) {    if (screen->fullscreen) {        return;    }    if (screen->maximized) {        SDL_RestoreWindow(screen->window);        screen->maximized = false;    }    struct size optimal_size =        get_optimal_window_size(screen, screen->content_size);    SDL_SetWindowSize(screen->window, optimal_size.width, optimal_size.height);    LOGD("Resized to optimal size");}
screen_resize_to_pixel_perfect(struct screen *screen) {    if (screen->fullscreen) {        return;    }    if (screen->maximized) {        SDL_RestoreWindow(screen->window);        screen->maximized = false;    }    struct size content_size = screen->content_size;    SDL_SetWindowSize(screen->window, content_size.width, content_size.height);    LOGD("Resized to pixel-perfect");}
screen_resize_to_fit(struct screen *screen) {    if (screen->fullscreen) {        return;    }    if (screen->maximized) {        SDL_RestoreWindow(screen->window);        screen->maximized = false;    }    struct size optimal_size =        get_optimal_window_size(screen, screen->content_size);    SDL_SetWindowSize(screen->window, optimal_size.width, optimal_size.height);    LOGD("Resized to optimal size: %ux%u", optimal_size.width,                                           optimal_size.height);}
screen_resize_to_pixel_perfect(struct screen *screen) {    if (screen->fullscreen) {        return;    }    if (screen->maximized) {        SDL_RestoreWindow(screen->window);        screen->maximized = false;    }    struct size content_size = screen->content_size;    SDL_SetWindowSize(screen->window, content_size.width, content_size.height);    LOGD("Resized to pixel-perfect: %ux%u", content_size.width,                                            content_size.height);}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device (and paste if the device\n"        "        runs Android >= 7)\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
control_msg_serialize(const struct control_msg *msg, unsigned char *buf) {    buf[0] = msg->type;    switch (msg->type) {        case CONTROL_MSG_TYPE_INJECT_KEYCODE:            buf[1] = msg->inject_keycode.action;            buffer_write32be(&buf[2], msg->inject_keycode.keycode);            buffer_write32be(&buf[6], msg->inject_keycode.metastate);            return 10;        case CONTROL_MSG_TYPE_INJECT_TEXT: {            size_t len =                write_string(msg->inject_text.text,                             CONTROL_MSG_INJECT_TEXT_MAX_LENGTH, &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT:            buf[1] = msg->inject_touch_event.action;            buffer_write64be(&buf[2], msg->inject_touch_event.pointer_id);            write_position(&buf[10], &msg->inject_touch_event.position);            uint16_t pressure =                to_fixed_point_16(msg->inject_touch_event.pressure);            buffer_write16be(&buf[22], pressure);            buffer_write32be(&buf[24], msg->inject_touch_event.buttons);            return 28;        case CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT:            write_position(&buf[1], &msg->inject_scroll_event.position);            buffer_write32be(&buf[13],                             (uint32_t) msg->inject_scroll_event.hscroll);            buffer_write32be(&buf[17],                             (uint32_t) msg->inject_scroll_event.vscroll);            return 21;        case CONTROL_MSG_TYPE_SET_CLIPBOARD: {            size_t len = write_string(msg->set_clipboard.text,                                      CONTROL_MSG_CLIPBOARD_TEXT_MAX_LENGTH,                                      &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE:            buf[1] = msg->set_screen_power_mode.mode;            return 2;        case CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_GET_CLIPBOARD:        case CONTROL_MSG_TYPE_ROTATE_DEVICE:            // no additional data            return 1;        default:            LOGW("Unknown message type: %u", (unsigned) msg->type);            return 0;    }}
control_msg_serialize(const struct control_msg *msg, unsigned char *buf) {    buf[0] = msg->type;    switch (msg->type) {        case CONTROL_MSG_TYPE_INJECT_KEYCODE:            buf[1] = msg->inject_keycode.action;            buffer_write32be(&buf[2], msg->inject_keycode.keycode);            buffer_write32be(&buf[6], msg->inject_keycode.metastate);            return 10;        case CONTROL_MSG_TYPE_INJECT_TEXT: {            size_t len =                write_string(msg->inject_text.text,                             CONTROL_MSG_INJECT_TEXT_MAX_LENGTH, &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT:            buf[1] = msg->inject_touch_event.action;            buffer_write64be(&buf[2], msg->inject_touch_event.pointer_id);            write_position(&buf[10], &msg->inject_touch_event.position);            uint16_t pressure =                to_fixed_point_16(msg->inject_touch_event.pressure);            buffer_write16be(&buf[22], pressure);            buffer_write32be(&buf[24], msg->inject_touch_event.buttons);            return 28;        case CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT:            write_position(&buf[1], &msg->inject_scroll_event.position);            buffer_write32be(&buf[13],                             (uint32_t) msg->inject_scroll_event.hscroll);            buffer_write32be(&buf[17],                             (uint32_t) msg->inject_scroll_event.vscroll);            return 21;        case CONTROL_MSG_TYPE_SET_CLIPBOARD: {            buf[1] = !!msg->set_clipboard.paste;            size_t len = write_string(msg->set_clipboard.text,                                      CONTROL_MSG_CLIPBOARD_TEXT_MAX_LENGTH,                                      &buf[2]);            return 2 + len;        }        case CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE:            buf[1] = msg->set_screen_power_mode.mode;            return 2;        case CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_GET_CLIPBOARD:        case CONTROL_MSG_TYPE_ROTATE_DEVICE:            // no additional data            return 1;        default:            LOGW("Unknown message type: %u", (unsigned) msg->type);            return 0;    }}
set_device_clipboard(struct controller *controller) {    char *text = SDL_GetClipboardText();    if (!text) {        LOGW("Could not get clipboard text: %s", SDL_GetError());        return;    }    if (!*text) {        // empty text        SDL_free(text);        return;    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_SET_CLIPBOARD;    msg.set_clipboard.text = text;    if (!controller_push_msg(controller, &msg)) {        SDL_free(text);        LOGW("Could not request 'set device clipboard'");    }}
set_device_clipboard(struct controller *controller) {    char *text = SDL_GetClipboardText();    if (!text) {        LOGW("Could not get clipboard text: %s", SDL_GetError());        return;    }    if (!*text) {        // empty text        SDL_free(text);        return;    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_SET_CLIPBOARD;    msg.set_clipboard.text = text;    if (!controller_push_msg(controller, &msg)) {        SDL_free(text);        LOGW("Could not request 'set device clipboard'");    }}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = im->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && !shift && down) {                    set_screen_power_mode(controller, SCREEN_POWER_MODE_OFF);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (cmd && !shift && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (cmd && !shift && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard                        set_device_clipboard(controller);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && cmd && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && cmd && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && cmd && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
set_device_clipboard(struct controller *controller, bool paste) {    char *text = SDL_GetClipboardText();    if (!text) {        LOGW("Could not get clipboard text: %s", SDL_GetError());        return;    }    if (!*text) {        // empty text        SDL_free(text);        return;    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_SET_CLIPBOARD;    msg.set_clipboard.text = text;    msg.set_clipboard.paste = paste;    if (!controller_push_msg(controller, &msg)) {        SDL_free(text);        LOGW("Could not request 'set device clipboard'");    }}
set_device_clipboard(struct controller *controller, bool paste) {    char *text = SDL_GetClipboardText();    if (!text) {        LOGW("Could not get clipboard text: %s", SDL_GetError());        return;    }    if (!*text) {        // empty text        SDL_free(text);        return;    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_SET_CLIPBOARD;    msg.set_clipboard.text = text;    msg.set_clipboard.paste = paste;    if (!controller_push_msg(controller, &msg)) {        SDL_free(text);        LOGW("Could not request 'set device clipboard'");    }}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = im->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && !shift && down) {                    set_screen_power_mode(controller, SCREEN_POWER_MODE_OFF);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (cmd && !shift && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (cmd && !shift && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && cmd && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && cmd && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && cmd && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
static void test_serialize_set_clipboard(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_SET_CLIPBOARD,        .set_clipboard = {            .text = "hello, world!",        },    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 16);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_SET_CLIPBOARD,        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_set_clipboard(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_SET_CLIPBOARD,        .set_clipboard = {            .paste = true,            .text = "hello, world!",        },    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 17);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_SET_CLIPBOARD,        1, // paste        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
    public static ControlMessage createSetClipboard(String text) {        ControlMessage msg = new ControlMessage();        msg.type = TYPE_SET_CLIPBOARD;        msg.text = text;        return msg;    }
    public static ControlMessage createSetClipboard(String text) {        ControlMessage msg = new ControlMessage();        msg.type = TYPE_SET_CLIPBOARD;        msg.text = text;        return msg;    }
    public static ControlMessage createSetClipboard(String text) {        ControlMessage msg = new ControlMessage();        msg.type = TYPE_SET_CLIPBOARD;        msg.text = text;        return msg;    }
        return msg;    }    public static ControlMessage createSetClipboard(String text, boolean paste) {        ControlMessage msg = new ControlMessage();        msg.type = TYPE_SET_CLIPBOARD;        msg.text = text;
    public static ControlMessage createSetClipboard(String text, boolean paste) {        ControlMessage msg = new ControlMessage();        msg.type = TYPE_SET_CLIPBOARD;        msg.text = text;        if (paste) {            msg.flags = FLAGS_PASTE;        }        return msg;    }
    public int getFlags() {        return flags;    }}
    private ControlMessage parseSetClipboard() {        String text = parseString();        if (text == null) {            return null;        }        return ControlMessage.createSetClipboard(text);    }
    private ControlMessage parseSetClipboard() {        if (buffer.remaining() < SET_CLIPBOARD_FIXED_PAYLOAD_LENGTH) {            return null;        }        boolean parse = buffer.get() != 0;        String text = parseString();        if (text == null) {            return null;        }        return ControlMessage.createSetClipboard(text, parse);    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                if (device.supportsInputEvents()) {                    injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                }                break;            case ControlMessage.TYPE_INJECT_TEXT:                if (device.supportsInputEvents()) {                    injectText(msg.getText());                }                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                if (device.supportsInputEvents()) {                    injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), msg.getButtons());                }                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                if (device.supportsInputEvents()) {                    injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                }                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                if (device.supportsInputEvents()) {                    pressBackOrTurnScreenOn();                }                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                boolean setClipboardOk = device.setClipboardText(msg.getText());                if (setClipboardOk) {                    Ln.i("Device clipboard set");                }                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                if (device.supportsInputEvents()) {                    int mode = msg.getAction();                    boolean setPowerModeOk = device.setScreenPowerMode(mode);                    if (setPowerModeOk) {                        Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));                    }                }                break;            case ControlMessage.TYPE_ROTATE_DEVICE:                device.rotateDevice();                break;            default:                // do nothing        }    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                if (device.supportsInputEvents()) {                    injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                }                break;            case ControlMessage.TYPE_INJECT_TEXT:                if (device.supportsInputEvents()) {                    injectText(msg.getText());                }                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                if (device.supportsInputEvents()) {                    injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), msg.getButtons());                }                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                if (device.supportsInputEvents()) {                    injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                }                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                if (device.supportsInputEvents()) {                    pressBackOrTurnScreenOn();                }                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                boolean setClipboardOk = device.setClipboardText(msg.getText());                if (setClipboardOk) {                    Ln.i("Device clipboard set");                }                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                if (device.supportsInputEvents()) {                    int mode = msg.getAction();                    boolean setPowerModeOk = device.setScreenPowerMode(mode);                    if (setPowerModeOk) {                        Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));                    }                }                break;            case ControlMessage.TYPE_ROTATE_DEVICE:                device.rotateDevice();                break;            default:                // do nothing        }    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                if (device.supportsInputEvents()) {                    injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                }                break;            case ControlMessage.TYPE_INJECT_TEXT:                if (device.supportsInputEvents()) {                    injectText(msg.getText());                }                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                if (device.supportsInputEvents()) {                    injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), msg.getButtons());                }                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                if (device.supportsInputEvents()) {                    injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                }                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                if (device.supportsInputEvents()) {                    pressBackOrTurnScreenOn();                }                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                boolean paste = (msg.getFlags() & ControlMessage.FLAGS_PASTE) != 0;                setClipboard(msg.getText(), paste);                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                if (device.supportsInputEvents()) {                    int mode = msg.getAction();                    boolean setPowerModeOk = device.setScreenPowerMode(mode);                    if (setPowerModeOk) {                        Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));                    }                }                break;            case ControlMessage.TYPE_ROTATE_DEVICE:                device.rotateDevice();                break;            default:                // do nothing        }    }
    private boolean setClipboard(String text, boolean paste) {        boolean ok = device.setClipboardText(text);        if (ok) {            Ln.i("Device clipboard set");        }        // On Android >= 7, also press the PASTE key if requested        if (paste && Build.VERSION.SDK_INT >= Build.VERSION_CODES.N && device.supportsInputEvents()) {            device.injectKeycode(KeyEvent.KEYCODE_PASTE);        }        return ok;    }}
    public void testParseSetClipboardEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_SET_CLIPBOARD);        byte[] text = "testé".getBytes(StandardCharsets.UTF_8);        dos.writeShort(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_SET_CLIPBOARD, event.getType());        Assert.assertEquals("testé", event.getText());    }
    public void testParseBigSetClipboardEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_SET_CLIPBOARD);        byte[] rawText = new byte[ControlMessageReader.CLIPBOARD_TEXT_MAX_LENGTH];        Arrays.fill(rawText, (byte) 'a');        String text = new String(rawText, 0, rawText.length);        dos.writeShort(rawText.length);        dos.write(rawText);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_SET_CLIPBOARD, event.getType());        Assert.assertEquals(text, event.getText());    }
    public void testParseSetClipboardEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_SET_CLIPBOARD);        dos.writeByte(1); // paste        byte[] text = "testé".getBytes(StandardCharsets.UTF_8);        dos.writeShort(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_SET_CLIPBOARD, event.getType());        Assert.assertEquals("testé", event.getText());        boolean parse = (event.getFlags() & ControlMessage.FLAGS_PASTE) != 0;        Assert.assertTrue(parse);    }
    public void testParseBigSetClipboardEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_SET_CLIPBOARD);        byte[] rawText = new byte[ControlMessageReader.CLIPBOARD_TEXT_MAX_LENGTH];        dos.writeByte(1); // paste        Arrays.fill(rawText, (byte) 'a');        String text = new String(rawText, 0, rawText.length);        dos.writeShort(rawText.length);        dos.write(rawText);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_SET_CLIPBOARD, event.getType());        Assert.assertEquals(text, event.getText());        boolean parse = (event.getFlags() & ControlMessage.FLAGS_PASTE) != 0;        Assert.assertTrue(parse);    }
create_texture(struct screen *screen) {    SDL_Renderer *renderer = screen->renderer;    struct size size = screen->frame_size;    SDL_Texture *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12,                                             SDL_TEXTUREACCESS_STREAMING,                                             size.width, size.height);    if (!texture) {        return NULL;    }    if (screen->mipmaps) {        struct sc_opengl *gl = &screen->gl;        SDL_GL_BindTexture(texture, NULL, NULL);        // Enable trilinear filtering for downscaling        gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,                          GL_LINEAR_MIPMAP_LINEAR);        gl->TexParameterf(GL_TEXTURE_2D, GL_TEXTURE_LOD_BIAS, -.5f);        SDL_GL_UnbindTexture(texture);    }    return texture;}
create_texture(struct screen *screen) {    SDL_Renderer *renderer = screen->renderer;    struct size size = screen->frame_size;    SDL_Texture *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12,                                             SDL_TEXTUREACCESS_STREAMING,                                             size.width, size.height);    if (!texture) {        return NULL;    }    if (screen->mipmaps) {        struct sc_opengl *gl = &screen->gl;        SDL_GL_BindTexture(texture, NULL, NULL);        // Enable trilinear filtering for downscaling        gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,                          GL_LINEAR_MIPMAP_LINEAR);        gl->TexParameterf(GL_TEXTURE_2D, GL_TEXTURE_LOD_BIAS, -1.f);        SDL_GL_UnbindTexture(texture);    }    return texture;}
control_msg_serialize(const struct control_msg *msg, unsigned char *buf) {    buf[0] = msg->type;    switch (msg->type) {        case CONTROL_MSG_TYPE_INJECT_KEYCODE:            buf[1] = msg->inject_keycode.action;            buffer_write32be(&buf[2], msg->inject_keycode.keycode);            buffer_write32be(&buf[6], msg->inject_keycode.metastate);            return 10;        case CONTROL_MSG_TYPE_INJECT_TEXT: {            size_t len =                write_string(msg->inject_text.text,                             CONTROL_MSG_INJECT_TEXT_MAX_LENGTH, &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT:            buf[1] = msg->inject_touch_event.action;            buffer_write64be(&buf[2], msg->inject_touch_event.pointer_id);            write_position(&buf[10], &msg->inject_touch_event.position);            uint16_t pressure =                to_fixed_point_16(msg->inject_touch_event.pressure);            buffer_write16be(&buf[22], pressure);            buffer_write32be(&buf[24], msg->inject_touch_event.buttons);            return 28;        case CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT:            write_position(&buf[1], &msg->inject_scroll_event.position);            buffer_write32be(&buf[13],                             (uint32_t) msg->inject_scroll_event.hscroll);            buffer_write32be(&buf[17],                             (uint32_t) msg->inject_scroll_event.vscroll);            return 21;        case CONTROL_MSG_TYPE_SET_CLIPBOARD: {            size_t len = write_string(msg->inject_text.text,                                      CONTROL_MSG_CLIPBOARD_TEXT_MAX_LENGTH,                                      &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE:            buf[1] = msg->set_screen_power_mode.mode;            return 2;        case CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_GET_CLIPBOARD:        case CONTROL_MSG_TYPE_ROTATE_DEVICE:            // no additional data            return 1;        default:            LOGW("Unknown message type: %u", (unsigned) msg->type);            return 0;    }}
control_msg_serialize(const struct control_msg *msg, unsigned char *buf) {    buf[0] = msg->type;    switch (msg->type) {        case CONTROL_MSG_TYPE_INJECT_KEYCODE:            buf[1] = msg->inject_keycode.action;            buffer_write32be(&buf[2], msg->inject_keycode.keycode);            buffer_write32be(&buf[6], msg->inject_keycode.metastate);            return 10;        case CONTROL_MSG_TYPE_INJECT_TEXT: {            size_t len =                write_string(msg->inject_text.text,                             CONTROL_MSG_INJECT_TEXT_MAX_LENGTH, &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT:            buf[1] = msg->inject_touch_event.action;            buffer_write64be(&buf[2], msg->inject_touch_event.pointer_id);            write_position(&buf[10], &msg->inject_touch_event.position);            uint16_t pressure =                to_fixed_point_16(msg->inject_touch_event.pressure);            buffer_write16be(&buf[22], pressure);            buffer_write32be(&buf[24], msg->inject_touch_event.buttons);            return 28;        case CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT:            write_position(&buf[1], &msg->inject_scroll_event.position);            buffer_write32be(&buf[13],                             (uint32_t) msg->inject_scroll_event.hscroll);            buffer_write32be(&buf[17],                             (uint32_t) msg->inject_scroll_event.vscroll);            return 21;        case CONTROL_MSG_TYPE_SET_CLIPBOARD: {            size_t len = write_string(msg->set_clipboard.text,                                      CONTROL_MSG_CLIPBOARD_TEXT_MAX_LENGTH,                                      &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE:            buf[1] = msg->set_screen_power_mode.mode;            return 2;        case CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_GET_CLIPBOARD:        case CONTROL_MSG_TYPE_ROTATE_DEVICE:            // no additional data            return 1;        default:            LOGW("Unknown message type: %u", (unsigned) msg->type);            return 0;    }}
static void test_serialize_set_clipboard(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_SET_CLIPBOARD,        .inject_text = {            .text = "hello, world!",        },    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 16);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_SET_CLIPBOARD,        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_set_clipboard(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_SET_CLIPBOARD,        .set_clipboard = {            .text = "hello, world!",        },    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 16);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_SET_CLIPBOARD,        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
screen_resize_to_fit(struct screen *screen) {    if (!screen->fullscreen && !screen->maximized) {        struct size optimal_size = get_optimal_window_size(screen,                                                           screen->frame_size);        SDL_SetWindowSize(screen->window, optimal_size.width,                          optimal_size.height);        LOGD("Resized to optimal size");    }}
screen_resize_to_pixel_perfect(struct screen *screen) {    if (!screen->fullscreen && !screen->maximized) {        SDL_SetWindowSize(screen->window, screen->frame_size.width,                          screen->frame_size.height);        LOGD("Resized to pixel-perfect");    }}
screen_resize_to_fit(struct screen *screen) {    if (screen->fullscreen) {        return;    }    if (screen->maximized) {        SDL_RestoreWindow(screen->window);        screen->maximized = false;    }    struct size optimal_size =        get_optimal_window_size(screen, screen->frame_size);    SDL_SetWindowSize(screen->window, optimal_size.width, optimal_size.height);    LOGD("Resized to optimal size");}
screen_resize_to_pixel_perfect(struct screen *screen) {    if (screen->fullscreen) {        return;    }    if (screen->maximized) {        SDL_RestoreWindow(screen->window);        screen->maximized = false;    }    SDL_SetWindowSize(screen->window, screen->frame_size.width,                      screen->frame_size.height);    LOGD("Resized to pixel-perfect");}
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate(), options.getMaxFps(),                    options.getLockedVideoOrientation());            if (options.getControl()) {                Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    private static void scrcpy(Options options) throws IOException {        Ln.i("Device: " + Build.MANUFACTURER + " " + Build.MODEL + " (Android " + Build.VERSION.RELEASE + ")");        final Device device = new Device(options);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate(), options.getMaxFps(),                    options.getLockedVideoOrientation());            if (options.getControl()) {                Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"codec-options",          required_argument, NULL, OPT_CODEC_OPTIONS},        {"crop",                   required_argument, NULL, OPT_CROP},        {"disable-screensaver",    no_argument,       NULL,                                                  OPT_DISABLE_SCREENSAVER},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"force-adb-forward",      no_argument,       NULL,                                                  OPT_FORCE_ADB_FORWARD},        {"forward-all-clicks",     no_argument,       NULL,                                                  OPT_FORWARD_ALL_CLICKS},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-key-repeat",          no_argument,       NULL, OPT_NO_KEY_REPEAT},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"port",                   required_argument, NULL, 'p'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"shortcut-mod",           required_argument, NULL, OPT_SHORTCUT_MOD},        {"show-touches",           no_argument,       NULL, 't'},        {"stay-awake",             no_argument,       NULL, 'w'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"verbosity",              required_argument, NULL, 'V'},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTvV:w",                            long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case 'V':                if (!parse_log_level(optarg, &opts->log_level)) {                    return false;                }                break;            case 'w':                opts->stay_awake = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            case OPT_NO_KEY_REPEAT:                opts->forward_key_repeat = false;                break;            case OPT_CODEC_OPTIONS:                opts->codec_options = optarg;                break;            case OPT_FORCE_ADB_FORWARD:                opts->force_adb_forward = true;                break;            case OPT_DISABLE_SCREENSAVER:                opts->disable_screensaver = true;                break;            case OPT_SHORTCUT_MOD:                if (!parse_shortcut_mods(optarg, &opts->shortcut_mods)) {                    return false;                }                break;            case OPT_FORWARD_ALL_CLICKS:                opts->forward_all_clicks = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    if (!opts->control && opts->stay_awake) {        LOGE("Could not request to stay awake if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    --forward-all-clicks\n"        "        By default, right-click triggers BACK (or POWER on) and\n"        "        middle-click triggers HOME. This option disables these\n"        "        shortcuts and forward the clicks to the device instead.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-key-repeat\n"        "        Do not forward repeated key events when a key is held down.\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    --shortcut-mod key[+...]][,...]\n"        "        Specify the modifiers to use for scrcpy shortcuts.\n"        "        Possible keys are \"lctrl\", \"rctrl\", \"lalt\", \"ralt\",\n"        "        \"lsuper\" and \"rsuper\".\n"        "\n"        "        A shortcut can consist in several keys, separated by '+'.\n"        "        Several shortcuts can be specified, separated by ','.\n"        "\n"        "        For example, to use either LCtrl+LAlt or LSuper for scrcpy\n"        "        shortcuts, pass \"lctrl+lalt,lsuper\".\n"        "\n"        "        Default is \"lalt,lsuper\" (left-Alt or left-Super).\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    In the following list, MOD is the shortcut modifier. By default,\n"        "    it's (left) Alt or (left) Super, but it can be configured by\n"        "    --shortcut-mod (see above).\n"        "\n"        "    MOD+f\n"        "        Switch fullscreen mode\n"        "\n"        "    MOD+Left\n"        "        Rotate display left\n"        "\n"        "    MOD+Right\n"        "        Rotate display right\n"        "\n"        "    MOD+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    MOD+w\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    MOD+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    MOD+b\n"        "    MOD+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    MOD+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    MOD+m\n"        "        Click on MENU\n"        "\n"        "    MOD+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    MOD+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    MOD+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    MOD+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    MOD+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    MOD+r\n"        "        Rotate device screen\n"        "\n"        "    MOD+n\n"        "        Expand notification panel\n"        "\n"        "    MOD+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    MOD+c\n"        "        Copy to clipboard (inject COPY keycode, Android >= 7 only)\n"        "\n"        "    MOD+x\n"        "        Cut to clipboard (inject CUT keycode, Android >= 7 only)\n"        "\n"        "    MOD+v\n"        "        Copy computer clipboard to device, then paste (inject PASTE\n"        "        keycode, Android >= 7 only)\n"        "\n"        "    MOD+Shift+v\n"        "        Inject computer clipboard text as a sequence of key events\n"        "\n"        "    MOD+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Ctrl+click-and-move\n"        "        Pinch-to-zoom from the center of the screen\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"codec-options",          required_argument, NULL, OPT_CODEC_OPTIONS},        {"crop",                   required_argument, NULL, OPT_CROP},        {"disable-screensaver",    no_argument,       NULL,                                                  OPT_DISABLE_SCREENSAVER},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"force-adb-forward",      no_argument,       NULL,                                                  OPT_FORCE_ADB_FORWARD},        {"forward-all-clicks",     no_argument,       NULL,                                                  OPT_FORWARD_ALL_CLICKS},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"legacy-paste",           no_argument,       NULL, OPT_LEGACY_PASTE},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-key-repeat",          no_argument,       NULL, OPT_NO_KEY_REPEAT},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"port",                   required_argument, NULL, 'p'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"shortcut-mod",           required_argument, NULL, OPT_SHORTCUT_MOD},        {"show-touches",           no_argument,       NULL, 't'},        {"stay-awake",             no_argument,       NULL, 'w'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"verbosity",              required_argument, NULL, 'V'},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTvV:w",                            long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case 'V':                if (!parse_log_level(optarg, &opts->log_level)) {                    return false;                }                break;            case 'w':                opts->stay_awake = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            case OPT_NO_KEY_REPEAT:                opts->forward_key_repeat = false;                break;            case OPT_CODEC_OPTIONS:                opts->codec_options = optarg;                break;            case OPT_FORCE_ADB_FORWARD:                opts->force_adb_forward = true;                break;            case OPT_DISABLE_SCREENSAVER:                opts->disable_screensaver = true;                break;            case OPT_SHORTCUT_MOD:                if (!parse_shortcut_mods(optarg, &opts->shortcut_mods)) {                    return false;                }                break;            case OPT_FORWARD_ALL_CLICKS:                opts->forward_all_clicks = true;                break;            case OPT_LEGACY_PASTE:                opts->legacy_paste = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    if (!opts->control && opts->stay_awake) {        LOGE("Could not request to stay awake if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    --forward-all-clicks\n"        "        By default, right-click triggers BACK (or POWER on) and\n"        "        middle-click triggers HOME. This option disables these\n"        "        shortcuts and forward the clicks to the device instead.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --legacy-paste\n"        "        Inject computer clipboard text as a sequence of key events\n"        "        on Ctrl+v (like MOD+Shift+v).\n"        "        This is a workaround for some devices not behaving as\n"        "        expected when setting the device clipboard programmatically.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-key-repeat\n"        "        Do not forward repeated key events when a key is held down.\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    --shortcut-mod key[+...]][,...]\n"        "        Specify the modifiers to use for scrcpy shortcuts.\n"        "        Possible keys are \"lctrl\", \"rctrl\", \"lalt\", \"ralt\",\n"        "        \"lsuper\" and \"rsuper\".\n"        "\n"        "        A shortcut can consist in several keys, separated by '+'.\n"        "        Several shortcuts can be specified, separated by ','.\n"        "\n"        "        For example, to use either LCtrl+LAlt or LSuper for scrcpy\n"        "        shortcuts, pass \"lctrl+lalt,lsuper\".\n"        "\n"        "        Default is \"lalt,lsuper\" (left-Alt or left-Super).\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    In the following list, MOD is the shortcut modifier. By default,\n"        "    it's (left) Alt or (left) Super, but it can be configured by\n"        "    --shortcut-mod (see above).\n"        "\n"        "    MOD+f\n"        "        Switch fullscreen mode\n"        "\n"        "    MOD+Left\n"        "        Rotate display left\n"        "\n"        "    MOD+Right\n"        "        Rotate display right\n"        "\n"        "    MOD+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    MOD+w\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    MOD+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    MOD+b\n"        "    MOD+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    MOD+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    MOD+m\n"        "        Click on MENU\n"        "\n"        "    MOD+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    MOD+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    MOD+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    MOD+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    MOD+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    MOD+r\n"        "        Rotate device screen\n"        "\n"        "    MOD+n\n"        "        Expand notification panel\n"        "\n"        "    MOD+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    MOD+c\n"        "        Copy to clipboard (inject COPY keycode, Android >= 7 only)\n"        "\n"        "    MOD+x\n"        "        Cut to clipboard (inject CUT keycode, Android >= 7 only)\n"        "\n"        "    MOD+v\n"        "        Copy computer clipboard to device, then paste (inject PASTE\n"        "        keycode, Android >= 7 only)\n"        "\n"        "    MOD+Shift+v\n"        "        Inject computer clipboard text as a sequence of key events\n"        "\n"        "    MOD+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Ctrl+click-and-move\n"        "        Pinch-to-zoom from the center of the screen\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event) {    // control: indicates the state of the command-line option --no-control    bool control = im->control;    bool smod = is_shortcut_mod(im, event->keysym.mod);    struct controller *controller = im->controller;    SDL_Keycode keycode = event->keysym.sym;    bool down = event->type == SDL_KEYDOWN;    bool ctrl = event->keysym.mod & KMOD_CTRL;    bool shift = event->keysym.mod & KMOD_SHIFT;    bool repeat = event->repeat;    // The shortcut modifier is pressed    if (smod) {        int action = down ? ACTION_DOWN : ACTION_UP;        switch (keycode) {            case SDLK_h:                if (control && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                if (control && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (!shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (!shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && !shift && !repeat) {                    action_copy(controller, action);                }                return;            case SDLK_x:                if (control && !shift && !repeat) {                    action_cut(controller, action);                }                return;            case SDLK_v:                if (control && !repeat && down) {                    if (shift) {                        // inject the text as input events                        clipboard_paste(controller);                    } else {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    }                }                return;            case SDLK_f:                if (!shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_w:                if (!shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        if (!im->forward_key_repeat) {            return;        }        ++im->repeat;    } else {        im->repeat = 0;    }    if (ctrl && !shift && keycode == SDLK_v && down && !repeat) {        // Synchronize the computer clipboard to the device clipboard before        // sending Ctrl+v, to allow seamless copy-paste.        set_device_clipboard(controller, false);    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_init(struct input_manager *im,                   const struct scrcpy_options *options){    im->control = options->control;    im->forward_key_repeat = options->forward_key_repeat;    im->prefer_text = options->prefer_text;    im->forward_all_clicks = options->forward_all_clicks;    const struct sc_shortcut_mods *shortcut_mods = &options->shortcut_mods;    assert(shortcut_mods->count);    assert(shortcut_mods->count < SC_MAX_SHORTCUT_MODS);    for (unsigned i = 0; i < shortcut_mods->count; ++i) {        uint16_t sdl_mod = to_sdl_mod(shortcut_mods->data[i]);        assert(sdl_mod);        im->sdl_shortcut_mods.data[i] = sdl_mod;    }    im->sdl_shortcut_mods.count = shortcut_mods->count;    im->vfinger_down = false;}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event) {    // control: indicates the state of the command-line option --no-control    bool control = im->control;    bool smod = is_shortcut_mod(im, event->keysym.mod);    struct controller *controller = im->controller;    SDL_Keycode keycode = event->keysym.sym;    bool down = event->type == SDL_KEYDOWN;    bool ctrl = event->keysym.mod & KMOD_CTRL;    bool shift = event->keysym.mod & KMOD_SHIFT;    bool repeat = event->repeat;    // The shortcut modifier is pressed    if (smod) {        int action = down ? ACTION_DOWN : ACTION_UP;        switch (keycode) {            case SDLK_h:                if (control && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                if (control && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (!shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (!shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && !shift && !repeat) {                    action_copy(controller, action);                }                return;            case SDLK_x:                if (control && !shift && !repeat) {                    action_cut(controller, action);                }                return;            case SDLK_v:                if (control && !repeat && down) {                    if (shift || im->legacy_paste) {                        // inject the text as input events                        clipboard_paste(controller);                    } else {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    }                }                return;            case SDLK_f:                if (!shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_w:                if (!shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        if (!im->forward_key_repeat) {            return;        }        ++im->repeat;    } else {        im->repeat = 0;    }    if (ctrl && !shift && keycode == SDLK_v && down && !repeat) {        if (im->legacy_paste) {            // inject the text as input events            clipboard_paste(controller);            return;        }        // Synchronize the computer clipboard to the device clipboard before        // sending Ctrl+v, to allow seamless copy-paste.        set_device_clipboard(controller, false);    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_init(struct input_manager *im,                   const struct scrcpy_options *options){    im->control = options->control;    im->forward_key_repeat = options->forward_key_repeat;    im->prefer_text = options->prefer_text;    im->forward_all_clicks = options->forward_all_clicks;    im->legacy_paste = options->legacy_paste;    const struct sc_shortcut_mods *shortcut_mods = &options->shortcut_mods;    assert(shortcut_mods->count);    assert(shortcut_mods->count < SC_MAX_SHORTCUT_MODS);    for (unsigned i = 0; i < shortcut_mods->count; ++i) {        uint16_t sdl_mod = to_sdl_mod(shortcut_mods->data[i]);        assert(sdl_mod);        im->sdl_shortcut_mods.data[i] = sdl_mod;    }    im->sdl_shortcut_mods.count = shortcut_mods->count;    im->vfinger_down = false;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .log_level = options->log_level,        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,        .show_touches = options->show_touches,        .stay_awake = options->stay_awake,        .codec_options = options->codec_options,        .encoder_name = options->encoder_name,        .force_adb_forward = options->force_adb_forward,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver,                                options->disable_screensaver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options->mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    input_manager_init(&input_manager, options);    ret = event_loop(options);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    if (!server_init(&server)) {        return false;    }    bool server_started = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    bool record = !!options->record_filename;    struct server_params params = {        .log_level = options->log_level,        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,        .show_touches = options->show_touches,        .stay_awake = options->stay_awake,        .codec_options = options->codec_options,        .encoder_name = options->encoder_name,        .force_adb_forward = options->force_adb_forward,    };    if (!server_start(&server, options->serial, &params)) {        goto end;    }    server_started = true;    if (!sdl_init_and_configure(options->display, options->render_driver,                                options->disable_screensaver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options->mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    input_manager_init(&input_manager, options);    bool ret = event_loop(options);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    if (server_started) {        // shutdown the sockets and kill the server        server_stop(&server);    }    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    server_destroy(&server);    return ret;}
server_init(struct server *server) {    *server = (struct server) SERVER_INITIALIZER;}
server_init(struct server *server) {    server->serial = NULL;    server->process = PROCESS_NONE;    server->wait_server_thread = NULL;    atomic_flag_clear_explicit(&server->server_socket_closed,                               memory_order_relaxed);    server->server_socket = INVALID_SOCKET;    server->video_socket = INVALID_SOCKET;    server->control_socket = INVALID_SOCKET;    server->port_range.first = 0;    server->port_range.last = 0;    server->local_port = 0;    server->tunnel_enabled = false;    server->tunnel_forward = false;    return true;}
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    --shortcut-mod key[+...]][,...]\n"        "        Specify the modifiers to use for scrcpy shortcuts.\n"        "        Possible keys are \"lctrl\", \"rctrl\", \"lalt\", \"ralt\",\n"        "        \"lsuper\" and \"rsuper\".\n"        "\n"        "        A shortcut can consist in several keys, separated by '+'.\n"        "        Several shortcuts can be specified, separated by ','.\n"        "\n"        "        For example, to use either LCtrl+LAlt or LSuper for scrcpy\n"        "        shortcuts, pass \"lctrl+lalt,lsuper\".\n"        "\n"        "        Default is \"lalt,lsuper\" (left-Alt or left-Super).\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    In the following list, MOD is the shortcut modifier. By default,\n"        "    it's (left) Alt or (left) Super, but it can be configured by\n"        "    --shortcut-mod.\n"        "\n"        "    MOD+f\n"        "        Switch fullscreen mode\n"        "\n"        "    MOD+Left\n"        "        Rotate display left\n"        "\n"        "    MOD+Right\n"        "        Rotate display right\n"        "\n"        "    MOD+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    MOD+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    MOD+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    MOD+b\n"        "    MOD+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    MOD+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    MOD+m\n"        "        Click on MENU\n"        "\n"        "    MOD+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    MOD+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    MOD+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    MOD+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    MOD+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    MOD+r\n"        "        Rotate device screen\n"        "\n"        "    MOD+n\n"        "        Expand notification panel\n"        "\n"        "    MOD+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    MOD+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    MOD+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    MOD+Shift+v\n"        "        Copy computer clipboard to device (and paste if the device\n"        "        runs Android >= 7)\n"        "\n"        "    MOD+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    --shortcut-mod key[+...]][,...]\n"        "        Specify the modifiers to use for scrcpy shortcuts.\n"        "        Possible keys are \"lctrl\", \"rctrl\", \"lalt\", \"ralt\",\n"        "        \"lsuper\" and \"rsuper\".\n"        "\n"        "        A shortcut can consist in several keys, separated by '+'.\n"        "        Several shortcuts can be specified, separated by ','.\n"        "\n"        "        For example, to use either LCtrl+LAlt or LSuper for scrcpy\n"        "        shortcuts, pass \"lctrl+lalt,lsuper\".\n"        "\n"        "        Default is \"lalt,lsuper\" (left-Alt or left-Super).\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    In the following list, MOD is the shortcut modifier. By default,\n"        "    it's (left) Alt or (left) Super, but it can be configured by\n"        "    --shortcut-mod.\n"        "\n"        "    MOD+f\n"        "        Switch fullscreen mode\n"        "\n"        "    MOD+Left\n"        "        Rotate display left\n"        "\n"        "    MOD+Right\n"        "        Rotate display right\n"        "\n"        "    MOD+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    MOD+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    MOD+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    MOD+b\n"        "    MOD+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    MOD+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    MOD+m\n"        "        Click on MENU\n"        "\n"        "    MOD+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    MOD+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    MOD+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    MOD+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    MOD+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    MOD+r\n"        "        Rotate device screen\n"        "\n"        "    MOD+n\n"        "        Expand notification panel\n"        "\n"        "    MOD+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    MOD+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    MOD+Shift+v\n"        "        Copy computer clipboard to device (and paste if the device\n"        "        runs Android >= 7)\n"        "\n"        "    MOD+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}static boolparse_integer_arg(const char *s, long *out, bool accept_suffix, long min,                  long max, const char *name) {
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    bool smod = is_shortcut_mod(im, event->keysym.mod);    struct controller *controller = im->controller;    SDL_Keycode keycode = event->keysym.sym;    bool down = event->type == SDL_KEYDOWN;    bool ctrl = event->keysym.mod & KMOD_CTRL;    bool shift = event->keysym.mod & KMOD_SHIFT;    bool repeat = event->repeat;    // The shortcut modifier is pressed    if (smod) {        int action = down ? ACTION_DOWN : ACTION_UP;        switch (keycode) {            case SDLK_h:                if (control && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                if (control && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (!shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (!shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    if (ctrl && !shift && keycode == SDLK_v && down && !repeat) {        // Synchronize the computer clipboard to the device clipboard before        // sending Ctrl+v, to allow seamless copy-paste.        set_device_clipboard(controller, false);    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
request_device_clipboard(struct controller *controller) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_GET_CLIPBOARD;    if (!controller_push_msg(controller, &msg)) {        LOGW("Could not request device clipboard");    }}
    bool down = event->type == SDL_KEYDOWN;    bool ctrl = event->keysym.mod & KMOD_CTRL;    bool shift = event->keysym.mod & KMOD_SHIFT;    bool repeat = event->repeat;    // The shortcut modifier is pressed    if (smod) {        int action = down ? ACTION_DOWN : ACTION_UP;        switch (keycode) {            case SDLK_h:                if (control && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                if (control && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (!shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (!shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_v:                if (control && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    if (ctrl && !shift && keycode == SDLK_v && down && !repeat) {        // Synchronize the computer clipboard to the device clipboard before        // sending Ctrl+v, to allow seamless copy-paste.        set_device_clipboard(controller, false);    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}static boolconvert_mouse_motion(const SDL_MouseMotionEvent *from, struct screen *screen,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    to->inject_touch_event.action = AMOTION_EVENT_ACTION_MOVE;    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen->frame_size;    to->inject_touch_event.position.point =        screen_convert_window_to_frame_coords(screen, from->x, from->y);    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons = convert_mouse_buttons(from->state);    return true;}
set_device_clipboard(struct controller *controller, bool paste) {    char *text = SDL_GetClipboardText();    if (!text) {        LOGW("Could not get clipboard text: %s", SDL_GetError());        return;    }    if (!*text) {        // empty text        SDL_free(text);
input_manager_init(struct input_manager *im, bool prefer_text,                   const struct sc_shortcut_mods *shortcut_mods){    im->prefer_text = prefer_text;    assert(shortcut_mods->count);    assert(shortcut_mods->count < SC_MAX_SHORTCUT_MODS);    for (unsigned i = 0; i < shortcut_mods->count; ++i) {        uint16_t sdl_mod = to_sdl_mod(shortcut_mods->data[i]);        assert(sdl_mod);        im->sdl_shortcut_mods.data[i] = sdl_mod;    }    im->sdl_shortcut_mods.count = shortcut_mods->count;}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    bool smod = is_shortcut_mod(im, event->keysym.mod);    struct controller *controller = im->controller;    SDL_Keycode keycode = event->keysym.sym;    bool down = event->type == SDL_KEYDOWN;    bool ctrl = event->keysym.mod & KMOD_CTRL;    bool shift = event->keysym.mod & KMOD_SHIFT;    bool repeat = event->repeat;    // The shortcut modifier is pressed    if (smod) {        int action = down ? ACTION_DOWN : ACTION_UP;        switch (keycode) {            case SDLK_h:                if (control && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                if (control && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (!shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (!shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && !shift && !repeat) {                    action_copy(controller, action);                }                return;            case SDLK_x:                if (control && !shift && !repeat) {                    action_cut(controller, action);                }                return;            case SDLK_v:                if (control && !repeat && down) {                    if (shift) {                        // inject the text as input events                        clipboard_paste(controller);                    } else {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    }                }                return;            case SDLK_f:                if (!shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_w:                if (!shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    if (ctrl && !shift && keycode == SDLK_v && down && !repeat) {        // Synchronize the computer clipboard to the device clipboard before        // sending Ctrl+v, to allow seamless copy-paste.        set_device_clipboard(controller, false);    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_init(struct input_manager *im, bool prefer_text,                   const struct sc_shortcut_mods *shortcut_mods){    im->prefer_text = prefer_text;    assert(shortcut_mods->count);    assert(shortcut_mods->count < SC_MAX_SHORTCUT_MODS);    for (unsigned i = 0; i < shortcut_mods->count; ++i) {        uint16_t sdl_mod = to_sdl_mod(shortcut_mods->data[i]);        assert(sdl_mod);        im->sdl_shortcut_mods.data[i] = sdl_mod;    }    im->sdl_shortcut_mods.count = shortcut_mods->count;}
input_manager_process_mouse_button(struct input_manager *im,                                   const SDL_MouseButtonEvent *event,                                   bool control) {    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (control && event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(im->controller);            return;        }        if (control && event->button == SDL_BUTTON_MIDDLE) {            action_home(im->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            int32_t x = event->x;            int32_t y = event->y;            screen_hidpi_scale_coords(im->screen, &x, &y);            SDL_Rect *r = &im->screen->rect;            bool outside = x < r->x || x >= r->x + r->w                        || y < r->y || y >= r->y + r->h;            if (outside) {                screen_resize_to_fit(im->screen);                return;            }        }        // otherwise, send the click event to the device    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_mouse_button(event, im->screen, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject mouse button event'");        }    }}
input_manager_process_mouse_button(struct input_manager *im,                                   const SDL_MouseButtonEvent *event,                                   bool control) {    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (control && event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(im->controller);            return;        }        if (control && event->button == SDL_BUTTON_MIDDLE) {            action_home(im->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            int32_t x = event->x;            int32_t y = event->y;            screen_hidpi_scale_coords(im->screen, &x, &y);            SDL_Rect *r = &im->screen->rect;            bool outside = x < r->x || x >= r->x + r->w                        || y < r->y || y >= r->y + r->h;            if (outside) {                screen_resize_to_fit(im->screen);                return;            }        }        // otherwise, send the click event to the device    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_mouse_button(event, im->screen, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject mouse button event'");        }    }}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    bool smod = is_shortcut_mod(im, event->keysym.mod);    struct controller *controller = im->controller;    SDL_Keycode keycode = event->keysym.sym;    bool down = event->type == SDL_KEYDOWN;    bool ctrl = event->keysym.mod & KMOD_CTRL;    bool shift = event->keysym.mod & KMOD_SHIFT;    bool repeat = event->repeat;    // The shortcut modifier is pressed    if (smod) {        int action = down ? ACTION_DOWN : ACTION_UP;        switch (keycode) {            case SDLK_h:                if (control && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                if (control && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (!shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (!shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && !shift && !repeat) {                    action_copy(controller, action);                }                return;            case SDLK_x:                if (control && !shift && !repeat) {                    action_cut(controller, action);                }                return;            case SDLK_v:                if (control && !repeat && down) {                    if (shift) {                        // inject the text as input events                        clipboard_paste(controller);                    } else {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    }                }                return;            case SDLK_f:                if (!shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_w:                if (!shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    if (ctrl && !shift && keycode == SDLK_v && down && !repeat) {        // Synchronize the computer clipboard to the device clipboard before        // sending Ctrl+v, to allow seamless copy-paste.        set_device_clipboard(controller, false);    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_init(struct input_manager *im,                   const struct scrcpy_options *options){    im->control = options->control;    im->prefer_text = options->prefer_text;    const struct sc_shortcut_mods *shortcut_mods = &options->shortcut_mods;    assert(shortcut_mods->count);    assert(shortcut_mods->count < SC_MAX_SHORTCUT_MODS);    for (unsigned i = 0; i < shortcut_mods->count; ++i) {        uint16_t sdl_mod = to_sdl_mod(shortcut_mods->data[i]);        assert(sdl_mod);        im->sdl_shortcut_mods.data[i] = sdl_mod;    }    im->sdl_shortcut_mods.count = shortcut_mods->count;
voidinput_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event) {    // control: indicates the state of the command-line option --no-control    bool control = im->control;    bool smod = is_shortcut_mod(im, event->keysym.mod);    struct controller *controller = im->controller;    SDL_Keycode keycode = event->keysym.sym;    bool down = event->type == SDL_KEYDOWN;    bool ctrl = event->keysym.mod & KMOD_CTRL;    bool shift = event->keysym.mod & KMOD_SHIFT;    bool repeat = event->repeat;    // The shortcut modifier is pressed    if (smod) {        int action = down ? ACTION_DOWN : ACTION_UP;        switch (keycode) {            case SDLK_h:                if (control && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                if (control && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (!shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (!shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && !shift && !repeat) {                    action_copy(controller, action);                }                return;            case SDLK_x:                if (control && !shift && !repeat) {                    action_cut(controller, action);                }                return;            case SDLK_v:                if (control && !repeat && down) {                    if (shift) {                        // inject the text as input events                        clipboard_paste(controller);                    } else {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    }                }                return;            case SDLK_f:                if (!shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_w:                if (!shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    if (ctrl && !shift && keycode == SDLK_v && down && !repeat) {        // Synchronize the computer clipboard to the device clipboard before        // sending Ctrl+v, to allow seamless copy-paste.        set_device_clipboard(controller, false);    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }
input_manager_init(struct input_manager *im,                   const struct scrcpy_options *options){    im->control = options->control;    im->prefer_text = options->prefer_text;    const struct sc_shortcut_mods *shortcut_mods = &options->shortcut_mods;    assert(shortcut_mods->count);    assert(shortcut_mods->count < SC_MAX_SHORTCUT_MODS);    for (unsigned i = 0; i < shortcut_mods->count; ++i) {        uint16_t sdl_mod = to_sdl_mod(shortcut_mods->data[i]);        assert(sdl_mod);        im->sdl_shortcut_mods.data[i] = sdl_mod;    }    im->sdl_shortcut_mods.count = shortcut_mods->count;}
input_manager_process_mouse_button(struct input_manager *im,                                   const SDL_MouseButtonEvent *event) {    bool control = im->control;    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (control && event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(im->controller);            return;        }        if (control && event->button == SDL_BUTTON_MIDDLE) {            action_home(im->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            int32_t x = event->x;            int32_t y = event->y;            screen_hidpi_scale_coords(im->screen, &x, &y);            SDL_Rect *r = &im->screen->rect;            bool outside = x < r->x || x >= r->x + r->w                        || y < r->y || y >= r->y + r->h;            if (outside) {                screen_resize_to_fit(im->screen);                return;            }        }        // otherwise, send the click event to the device    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_mouse_button(event, im->screen, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject mouse button event'");        }    }}
voidinput_manager_process_mouse_button(struct input_manager *im,                                   const SDL_MouseButtonEvent *event) {    bool control = im->control;    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (control && event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(im->controller);            return;        }        if (control && event->button == SDL_BUTTON_MIDDLE) {            action_home(im->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            int32_t x = event->x;            int32_t y = event->y;            screen_hidpi_scale_coords(im->screen, &x, &y);            SDL_Rect *r = &im->screen->rect;            bool outside = x < r->x || x >= r->x + r->w                        || y < r->y || y >= r->y + r->h;            if (outside) {                screen_resize_to_fit(im->screen);                return;            }        }        // otherwise, send the click event to the device    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_mouse_button(event, im->screen, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject mouse button event'");        }
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event) {    // control: indicates the state of the command-line option --no-control    bool control = im->control;    bool smod = is_shortcut_mod(im, event->keysym.mod);    struct controller *controller = im->controller;    SDL_Keycode keycode = event->keysym.sym;    bool down = event->type == SDL_KEYDOWN;    bool ctrl = event->keysym.mod & KMOD_CTRL;    bool shift = event->keysym.mod & KMOD_SHIFT;    bool repeat = event->repeat;    // The shortcut modifier is pressed    if (smod) {        int action = down ? ACTION_DOWN : ACTION_UP;        switch (keycode) {            case SDLK_h:                if (control && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                if (control && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (!shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (!shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && !shift && !repeat) {                    action_copy(controller, action);                }                return;            case SDLK_x:                if (control && !shift && !repeat) {                    action_cut(controller, action);                }                return;            case SDLK_v:                if (control && !repeat && down) {                    if (shift) {                        // inject the text as input events                        clipboard_paste(controller);                    } else {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    }                }                return;            case SDLK_f:                if (!shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_w:                if (!shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    if (ctrl && !shift && keycode == SDLK_v && down && !repeat) {        // Synchronize the computer clipboard to the device clipboard before        // sending Ctrl+v, to allow seamless copy-paste.        set_device_clipboard(controller, false);    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
handle_event(SDL_Event *event, bool control) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = true;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return EVENT_RESULT_CONTINUE;            }            break;        case SDL_WINDOWEVENT:            screen_handle_window_event(&screen, &event->window);            break;        case SDL_TEXTINPUT:            if (!control) {                break;            }            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            // some key events do not interact with the device, so process the            // event even if control is disabled            input_manager_process_key(&input_manager, &event->key, control);            break;        case SDL_MOUSEMOTION:            if (!control) {                break;            }            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            if (!control) {                break;            }            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            // some mouse events do not interact with the device, so process            // the event even if control is disabled            input_manager_process_mouse_button(&input_manager, &event->button,                                               control);            break;        case SDL_FINGERMOTION:        case SDL_FINGERDOWN:        case SDL_FINGERUP:            input_manager_process_touch(&input_manager, &event->tfinger);            break;        case SDL_DROPFILE: {            if (!control) {                break;            }            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .log_level = options->log_level,        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,        .show_touches = options->show_touches,        .stay_awake = options->stay_awake,        .codec_options = options->codec_options,        .force_adb_forward = options->force_adb_forward,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver,                                options->disable_screensaver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options-> mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    input_manager_init(&input_manager, options->prefer_text,                       &options->shortcut_mods);    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    server_destroy(&server);    return ret;}
handle_event(SDL_Event *event, bool control) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = true;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return EVENT_RESULT_CONTINUE;            }            break;        case SDL_WINDOWEVENT:            screen_handle_window_event(&screen, &event->window);            break;        case SDL_TEXTINPUT:            if (!control) {                break;            }            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            // some key events do not interact with the device, so process the            // event even if control is disabled            input_manager_process_key(&input_manager, &event->key);            break;        case SDL_MOUSEMOTION:            if (!control) {                break;            }            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            if (!control) {                break;            }            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            // some mouse events do not interact with the device, so process            // the event even if control is disabled            input_manager_process_mouse_button(&input_manager, &event->button);            break;        case SDL_FINGERMOTION:        case SDL_FINGERDOWN:        case SDL_FINGERUP:            input_manager_process_touch(&input_manager, &event->tfinger);            break;        case SDL_DROPFILE: {            if (!control) {                break;            }            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .log_level = options->log_level,        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,        .show_touches = options->show_touches,        .stay_awake = options->stay_awake,        .codec_options = options->codec_options,        .force_adb_forward = options->force_adb_forward,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver,                                options->disable_screensaver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options-> mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    input_manager_init(&input_manager, options);    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    server_destroy(&server);    return ret;}
server_start(struct server *server, const char *serial,             const struct server_params *params) {    server->port_range = params->port_range;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        goto error1;    }    if (!enable_tunnel_any_port(server, params->port_range)) {        goto error1;    }    // server will connect to our server socket    server->process = execute_server(server, params);    if (server->process == PROCESS_NONE) {        goto error2;    }    // If the server process dies before connecting to the server socket, then    // the client will be stuck forever on accept(). To avoid the problem, we    // must be able to wake up the accept() call when the server dies. To keep    // things simple and multiplatform, just spawn a new thread waiting for the    // server process and calling shutdown()/close() on the server socket if    // necessary to wake up any accept() blocking call.    server->wait_server_thread =        SDL_CreateThread(run_wait_server, "wait-server", server);    if (!server->wait_server_thread) {        if (!cmd_terminate(server->process)) {            LOGW("Could not terminate server");        }        cmd_simple_wait(server->process, NULL); // ignore exit code        goto error2;    }    server->tunnel_enabled = true;    return true;error2:    if (!server->tunnel_forward) {        // the wait server thread is not started, SDL_AtomicSet() is sufficient        SDL_AtomicSet(&server->server_socket_closed, 1);        close_socket(server->server_socket);    }    disable_tunnel(server);error1:    SDL_free(server->serial);    return false;}
server_stop(struct server *server) {    if (server->server_socket != INVALID_SOCKET            && SDL_AtomicCAS(&server->server_socket_closed, 0, 1)) {        close_socket(server->server_socket);    }    if (server->video_socket != INVALID_SOCKET) {        close_socket(server->video_socket);    }    if (server->control_socket != INVALID_SOCKET) {        close_socket(server->control_socket);    }    assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Could not terminate server");    }    if (server->tunnel_enabled) {        // ignore failure        disable_tunnel(server);    }    SDL_WaitThread(server->wait_server_thread, NULL);}
server_start(struct server *server, const char *serial,             const struct server_params *params) {    server->port_range = params->port_range;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        goto error1;    }    if (!enable_tunnel_any_port(server, params->port_range)) {        goto error1;    }    // server will connect to our server socket    server->process = execute_server(server, params);    if (server->process == PROCESS_NONE) {        goto error2;    }    // If the server process dies before connecting to the server socket, then    // the client will be stuck forever on accept(). To avoid the problem, we    // must be able to wake up the accept() call when the server dies. To keep    // things simple and multiplatform, just spawn a new thread waiting for the    // server process and calling shutdown()/close() on the server socket if    // necessary to wake up any accept() blocking call.    server->wait_server_thread =        SDL_CreateThread(run_wait_server, "wait-server", server);    if (!server->wait_server_thread) {        cmd_terminate(server->process);        cmd_simple_wait(server->process, NULL); // ignore exit code        goto error2;    }    server->tunnel_enabled = true;    return true;error2:    if (!server->tunnel_forward) {        // the wait server thread is not started, SDL_AtomicSet() is sufficient        SDL_AtomicSet(&server->server_socket_closed, 1);        close_socket(server->server_socket);    }    disable_tunnel(server);error1:    SDL_free(server->serial);    return false;}
server_stop(struct server *server) {    if (server->server_socket != INVALID_SOCKET            && SDL_AtomicCAS(&server->server_socket_closed, 0, 1)) {        close_socket(server->server_socket);    }    if (server->video_socket != INVALID_SOCKET) {        close_socket(server->video_socket);    }    if (server->control_socket != INVALID_SOCKET) {        close_socket(server->control_socket);    }    assert(server->process != PROCESS_NONE);    cmd_terminate(server->process);    if (server->tunnel_enabled) {        // ignore failure        disable_tunnel(server);    }    SDL_WaitThread(server->wait_server_thread, NULL);}
guess_record_format(const char *filename) {    size_t len = strlen(filename);    if (len < 4) {        return 0;    }    const char *ext = &filename[len - 4];    if (!strcmp(ext, ".mp4")) {        return RECORDER_FORMAT_MP4;    }    if (!strcmp(ext, ".mkv")) {        return RECORDER_FORMAT_MKV;    }    return 0;}
parse_record_format(const char *optarg, enum recorder_format *format) {    if (!strcmp(optarg, "mp4")) {        *format = RECORDER_FORMAT_MP4;        return true;    }    if (!strcmp(optarg, "mkv")) {        *format = RECORDER_FORMAT_MKV;        return true;    }    LOGE("Unsupported format: %s (expected mp4 or mkv)", optarg);    return false;}
parse_window_position(const char *s, int16_t *position) {    // special value for "auto"    static_assert(WINDOW_POSITION_UNDEFINED == -0x8000, "unexpected value");    if (!strcmp(s, "auto")) {        *position = WINDOW_POSITION_UNDEFINED;        return true;    }    long value;    bool ok = parse_integer_arg(s, &value, false, -0x7FFF, 0x7FFF,                                "window position");    if (!ok) {        return false;    }    *position = (int16_t) value;    return true;}
parse_record_format(const char *optarg, enum recorder_format *format) {    if (!strcmp(optarg, "mp4")) {        *format = RECORDER_FORMAT_MP4;        return true;    }    if (!strcmp(optarg, "mkv")) {        *format = RECORDER_FORMAT_MKV;        return true;    }    LOGE("Unsupported format: %s (expected mp4 or mkv)", optarg);    return false;}
parse_port_range(const char *s, struct port_range *port_range) {    long values[2];    size_t count = parse_integers_arg(s, 2, values, 0, 0xFFFF, "port");    if (!count) {        return false;    }    uint16_t v0 = (uint16_t) values[0];    if (count == 1) {        port_range->first = v0;        port_range->last = v0;        return true;    }    assert(count == 2);    uint16_t v1 = (uint16_t) values[1];    if (v0 < v1) {        port_range->first = v0;        port_range->last = v1;    } else {        port_range->first = v1;        port_range->last = v0;    }    return true;}
parse_port_range(const char *s, struct port_range *port_range) {    long values[2];    size_t count = parse_integers_arg(s, 2, values, 0, 0xFFFF, "port");    if (!count) {        return false;    }    uint16_t v0 = (uint16_t) values[0];    if (count == 1) {        port_range->first = v0;        port_range->last = v0;        return true;    }    assert(count == 2);    uint16_t v1 = (uint16_t) values[1];    if (v0 < v1) {        port_range->first = v0;        port_range->last = v1;    } else {        port_range->first = v1;        port_range->last = v0;    }    return true;}
guess_record_format(const char *filename) {    size_t len = strlen(filename);    if (len < 4) {        return 0;    }    const char *ext = &filename[len - 4];    if (!strcmp(ext, ".mp4")) {        return SC_RECORD_FORMAT_MP4;    }    if (!strcmp(ext, ".mkv")) {        return SC_RECORD_FORMAT_MKV;    }    return 0;}
parse_record_format(const char *optarg, enum sc_record_format *format) {    if (!strcmp(optarg, "mp4")) {        *format = SC_RECORD_FORMAT_MP4;        return true;    }    if (!strcmp(optarg, "mkv")) {        *format = SC_RECORD_FORMAT_MKV;        return true;    }    LOGE("Unsupported format: %s (expected mp4 or mkv)", optarg);    return false;}
parse_window_position(const char *s, int16_t *position) {    // special value for "auto"    static_assert(SC_WINDOW_POSITION_UNDEFINED == -0x8000, "unexpected value");    if (!strcmp(s, "auto")) {        *position = SC_WINDOW_POSITION_UNDEFINED;        return true;    }    long value;    bool ok = parse_integer_arg(s, &value, false, -0x7FFF, 0x7FFF,                                "window position");    if (!ok) {        return false;    }    *position = (int16_t) value;    return true;}
static boolparse_record_format(const char *optarg, enum sc_record_format *format) {    if (!strcmp(optarg, "mp4")) {        *format = SC_RECORD_FORMAT_MP4;        return true;    }    if (!strcmp(optarg, "mkv")) {        *format = SC_RECORD_FORMAT_MKV;        return true;    }    LOGE("Unsupported format: %s (expected mp4 or mkv)", optarg);    return false;}
static boolparse_port_range(const char *s, struct sc_port_range *port_range) {    long values[2];    size_t count = parse_integers_arg(s, 2, values, 0, 0xFFFF, "port");    if (!count) {        return false;    }    uint16_t v0 = (uint16_t) values[0];    if (count == 1) {        port_range->first = v0;        port_range->last = v0;        return true;    }    assert(count == 2);    uint16_t v1 = (uint16_t) values[1];    if (v0 < v1) {        port_range->first = v0;        port_range->last = v1;    } else {        port_range->first = v1;        port_range->last = v0;    }    return true;}
parse_port_range(const char *s, struct sc_port_range *port_range) {    long values[2];    size_t count = parse_integers_arg(s, 2, values, 0, 0xFFFF, "port");    if (!count) {        return false;    }    uint16_t v0 = (uint16_t) values[0];    if (count == 1) {        port_range->first = v0;        port_range->last = v0;        return true;    }    assert(count == 2);    uint16_t v1 = (uint16_t) values[1];    if (v0 < v1) {        port_range->first = v0;        port_range->last = v1;    } else {        port_range->first = v1;        port_range->last = v0;    }    return true;}
recorder_get_format_name(enum recorder_format format) {    switch (format) {        case RECORDER_FORMAT_MP4: return "mp4";        case RECORDER_FORMAT_MKV: return "matroska";        default: return NULL;    }}
recorder_init(struct recorder *recorder,              const char *filename,              enum recorder_format format,              struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Could not strdup filename");        return false;    }    recorder->mutex = SDL_CreateMutex();    if (!recorder->mutex) {        LOGC("Could not create mutex");        SDL_free(recorder->filename);        return false;    }    recorder->queue_cond = SDL_CreateCond();    if (!recorder->queue_cond) {        LOGC("Could not create cond");        SDL_DestroyMutex(recorder->mutex);        SDL_free(recorder->filename);        return false;    }    queue_init(&recorder->queue);    recorder->stopped = false;    recorder->failed = false;    recorder->format = format;    recorder->declared_frame_size = declared_frame_size;    recorder->header_written = false;    recorder->previous = NULL;    return true;}
recorder_init(struct recorder *recorder,              const char *filename,              enum recorder_format format,              struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Could not strdup filename");        return false;    }    recorder->mutex = SDL_CreateMutex();    if (!recorder->mutex) {        LOGC("Could not create mutex");        SDL_free(recorder->filename);        return false;    }    recorder->queue_cond = SDL_CreateCond();    if (!recorder->queue_cond) {        LOGC("Could not create cond");        SDL_DestroyMutex(recorder->mutex);        SDL_free(recorder->filename);        return false;    }    queue_init(&recorder->queue);    recorder->stopped = false;    recorder->failed = false;    recorder->format = format;    recorder->declared_frame_size = declared_frame_size;    recorder->header_written = false;    recorder->previous = NULL;    return true;}
recorder_get_format_name(enum recorder_format format) {    switch (format) {        case RECORDER_FORMAT_MP4: return "mp4";        case RECORDER_FORMAT_MKV: return "matroska";        default: return NULL;    }}
recorder_get_format_name(enum sc_record_format format) {    switch (format) {        case SC_RECORD_FORMAT_MP4: return "mp4";        case SC_RECORD_FORMAT_MKV: return "matroska";        default: return NULL;    }}
recorder_init(struct recorder *recorder,              const char *filename,              enum sc_record_format format,              struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Could not strdup filename");        return false;    }    recorder->mutex = SDL_CreateMutex();    if (!recorder->mutex) {        LOGC("Could not create mutex");        SDL_free(recorder->filename);        return false;    }    recorder->queue_cond = SDL_CreateCond();    if (!recorder->queue_cond) {        LOGC("Could not create cond");        SDL_DestroyMutex(recorder->mutex);        SDL_free(recorder->filename);        return false;    }    queue_init(&recorder->queue);    recorder->stopped = false;    recorder->failed = false;    recorder->format = format;    recorder->declared_frame_size = declared_frame_size;    recorder->header_written = false;    recorder->previous = NULL;    return true;}
recorder_init(struct recorder *recorder,              const char *filename,              enum sc_record_format format,              struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Could not strdup filename");        return false;    }    recorder->mutex = SDL_CreateMutex();    if (!recorder->mutex) {        LOGC("Could not create mutex");        SDL_free(recorder->filename);        return false;    }    recorder->queue_cond = SDL_CreateCond();    if (!recorder->queue_cond) {        LOGC("Could not create cond");        SDL_DestroyMutex(recorder->mutex);        SDL_free(recorder->filename);        return false;    }    queue_init(&recorder->queue);    recorder->stopped = false;    recorder->failed = false;    recorder->format = format;    recorder->declared_frame_size = declared_frame_size;    recorder->header_written = false;    recorder->previous = NULL;    return true;}
recorder_get_format_name(enum sc_record_format format) {    switch (format) {        case SC_RECORD_FORMAT_MP4: return "mp4";        case SC_RECORD_FORMAT_MKV: return "matroska";        default: return NULL;    }}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation, bool mipmaps) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size = get_rotated_size(frame_size, screen->rotation);    screen->content_size = content_size;    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_RendererInfo renderer_info;    int r = SDL_GetRendererInfo(screen->renderer, &renderer_info);    const char *renderer_name = r ? NULL : renderer_info.name;    LOGI("Renderer: %s", renderer_name ? renderer_name : "(unknown)");    // starts with "opengl"    screen->use_opengl = renderer_name && !strncmp(renderer_name, "opengl", 6);    if (screen->use_opengl) {        struct sc_opengl *gl = &screen->gl;        sc_opengl_init(gl);        LOGI("OpenGL version: %s", gl->version);        if (mipmaps) {            bool supports_mipmaps =                sc_opengl_version_at_least(gl, 3, 0, /* OpenGL 3.0+ */                                               2, 0  /* OpenGL ES 2.0+ */);            if (supports_mipmaps) {                LOGI("Trilinear filtering enabled");                screen->mipmaps = true;            } else {                LOGW("Trilinear filtering disabled "                     "(OpenGL 3.0+ or ES 2.0+ required)");            }        } else {            LOGI("Trilinear filtering disabled");        }    } else {        LOGD("Trilinear filtering disabled (not an OpenGL renderer)");    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    // Reset the window size to trigger a SIZE_CHANGED event, to workaround    // HiDPI issues with some SDL renderers when several displays having    // different HiDPI scaling are connected    SDL_SetWindowSize(screen->window, window_size.width, window_size.height);    screen_update_content_rect(screen);    return true;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation, bool mipmaps) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size = get_rotated_size(frame_size, screen->rotation);    screen->content_size = content_size;    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != SC_WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != SC_WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_RendererInfo renderer_info;    int r = SDL_GetRendererInfo(screen->renderer, &renderer_info);    const char *renderer_name = r ? NULL : renderer_info.name;    LOGI("Renderer: %s", renderer_name ? renderer_name : "(unknown)");    // starts with "opengl"    screen->use_opengl = renderer_name && !strncmp(renderer_name, "opengl", 6);    if (screen->use_opengl) {        struct sc_opengl *gl = &screen->gl;        sc_opengl_init(gl);        LOGI("OpenGL version: %s", gl->version);        if (mipmaps) {            bool supports_mipmaps =                sc_opengl_version_at_least(gl, 3, 0, /* OpenGL 3.0+ */                                               2, 0  /* OpenGL ES 2.0+ */);            if (supports_mipmaps) {                LOGI("Trilinear filtering enabled");                screen->mipmaps = true;            } else {                LOGW("Trilinear filtering disabled "                     "(OpenGL 3.0+ or ES 2.0+ required)");            }        } else {            LOGI("Trilinear filtering disabled");        }    } else {        LOGD("Trilinear filtering disabled (not an OpenGL renderer)");    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    // Reset the window size to trigger a SIZE_CHANGED event, to workaround    // HiDPI issues with some SDL renderers when several displays having    // different HiDPI scaling are connected    SDL_SetWindowSize(screen->window, window_size.width, window_size.height);    screen_update_content_rect(screen);    return true;}
enable_tunnel_any_port(struct server *server, struct port_range port_range,                       bool force_adb_forward) {    if (!force_adb_forward) {        // Attempt to use "adb reverse"        if (enable_tunnel_reverse_any_port(server, port_range)) {            return true;        }        // if "adb reverse" does not work (e.g. over "adb connect"), it        // fallbacks to "adb forward", so the app socket is the client        LOGW("'adb reverse' failed, fallback to 'adb forward'");    }    return enable_tunnel_forward_any_port(server, port_range);}
enable_tunnel_forward_any_port(struct server *server,                               struct port_range port_range) {    server->tunnel_forward = true;    uint16_t port = port_range.first;    for (;;) {        if (enable_tunnel_forward(server->serial, port)) {            // success            server->local_port = port;            return true;        }        if (port < port_range.last) {            LOGW("Could not forward port %" PRIu16", retrying on %" PRIu16,                 port, port + 1);            port++;            continue;        }        if (port_range.first == port_range.last) {            LOGE("Could not forward port %" PRIu16, port_range.first);        } else {            LOGE("Could not forward any port in range %" PRIu16 ":%" PRIu16,                 port_range.first, port_range.last);        }        return false;    }}
enable_tunnel_forward_any_port(struct server *server,                               struct port_range port_range) {    server->tunnel_forward = true;    uint16_t port = port_range.first;    for (;;) {        if (enable_tunnel_forward(server->serial, port)) {            // success            server->local_port = port;            return true;        }        if (port < port_range.last) {            LOGW("Could not forward port %" PRIu16", retrying on %" PRIu16,                 port, port + 1);            port++;            continue;        }        if (port_range.first == port_range.last) {            LOGE("Could not forward port %" PRIu16, port_range.first);        } else {            LOGE("Could not forward any port in range %" PRIu16 ":%" PRIu16,                 port_range.first, port_range.last);        }        return false;    }}
enable_tunnel_reverse_any_port(struct server *server,                               struct port_range port_range) {    uint16_t port = port_range.first;    for (;;) {        if (!enable_tunnel_reverse(server->serial, port)) {            // the command itself failed, it will fail on any port            return false;        }        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(port);        if (server->server_socket != INVALID_SOCKET) {            // success            server->local_port = port;            return true;        }        // failure, disable tunnel and try another port        if (!disable_tunnel_reverse(server->serial)) {            LOGW("Could not remove reverse tunnel on port %" PRIu16, port);        }        // check before incrementing to avoid overflow on port 65535        if (port < port_range.last) {            LOGW("Could not listen on port %" PRIu16", retrying on %" PRIu16,                 port, (uint16_t) (port + 1));            port++;            continue;        }        if (port_range.first == port_range.last) {            LOGE("Could not listen on port %" PRIu16, port_range.first);        } else {            LOGE("Could not listen on any port in range %" PRIu16 ":%" PRIu16,                 port_range.first, port_range.last);        }        return false;    }}
enable_tunnel_any_port(struct server *server, struct port_range port_range,                       bool force_adb_forward) {    if (!force_adb_forward) {        // Attempt to use "adb reverse"        if (enable_tunnel_reverse_any_port(server, port_range)) {            return true;        }        // if "adb reverse" does not work (e.g. over "adb connect"), it        // fallbacks to "adb forward", so the app socket is the client        LOGW("'adb reverse' failed, fallback to 'adb forward'");    }    return enable_tunnel_forward_any_port(server, port_range);}
enable_tunnel_reverse_any_port(struct server *server,                               struct port_range port_range) {    uint16_t port = port_range.first;    for (;;) {        if (!enable_tunnel_reverse(server->serial, port)) {            // the command itself failed, it will fail on any port            return false;        }        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(port);        if (server->server_socket != INVALID_SOCKET) {            // success            server->local_port = port;            return true;        }        // failure, disable tunnel and try another port        if (!disable_tunnel_reverse(server->serial)) {            LOGW("Could not remove reverse tunnel on port %" PRIu16, port);        }        // check before incrementing to avoid overflow on port 65535        if (port < port_range.last) {            LOGW("Could not listen on port %" PRIu16", retrying on %" PRIu16,                 port, (uint16_t) (port + 1));            port++;            continue;        }        if (port_range.first == port_range.last) {            LOGE("Could not listen on port %" PRIu16, port_range.first);        } else {            LOGE("Could not listen on any port in range %" PRIu16 ":%" PRIu16,                 port_range.first, port_range.last);        }        return false;    }}
enable_tunnel_any_port(struct server *server, struct sc_port_range port_range,                       bool force_adb_forward) {    if (!force_adb_forward) {        // Attempt to use "adb reverse"        if (enable_tunnel_reverse_any_port(server, port_range)) {            return true;        }        // if "adb reverse" does not work (e.g. over "adb connect"), it        // fallbacks to "adb forward", so the app socket is the client        LOGW("'adb reverse' failed, fallback to 'adb forward'");    }    return enable_tunnel_forward_any_port(server, port_range);}
enable_tunnel_forward_any_port(struct server *server,                               struct sc_port_range port_range) {    server->tunnel_forward = true;    uint16_t port = port_range.first;    for (;;) {        if (enable_tunnel_forward(server->serial, port)) {            // success            server->local_port = port;            return true;        }        if (port < port_range.last) {            LOGW("Could not forward port %" PRIu16", retrying on %" PRIu16,                 port, port + 1);            port++;            continue;        }        if (port_range.first == port_range.last) {            LOGE("Could not forward port %" PRIu16, port_range.first);        } else {            LOGE("Could not forward any port in range %" PRIu16 ":%" PRIu16,                 port_range.first, port_range.last);        }        return false;    }}
enable_tunnel_forward_any_port(struct server *server,                               struct sc_port_range port_range) {    server->tunnel_forward = true;    uint16_t port = port_range.first;    for (;;) {        if (enable_tunnel_forward(server->serial, port)) {            // success            server->local_port = port;            return true;        }        if (port < port_range.last) {            LOGW("Could not forward port %" PRIu16", retrying on %" PRIu16,                 port, port + 1);            port++;            continue;        }        if (port_range.first == port_range.last) {            LOGE("Could not forward port %" PRIu16, port_range.first);        } else {            LOGE("Could not forward any port in range %" PRIu16 ":%" PRIu16,                 port_range.first, port_range.last);        }        return false;    }}
enable_tunnel_reverse_any_port(struct server *server,                               struct sc_port_range port_range) {    uint16_t port = port_range.first;    for (;;) {        if (!enable_tunnel_reverse(server->serial, port)) {            // the command itself failed, it will fail on any port            return false;        }        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(port);        if (server->server_socket != INVALID_SOCKET) {            // success            server->local_port = port;            return true;        }        // failure, disable tunnel and try another port        if (!disable_tunnel_reverse(server->serial)) {            LOGW("Could not remove reverse tunnel on port %" PRIu16, port);        }        // check before incrementing to avoid overflow on port 65535        if (port < port_range.last) {            LOGW("Could not listen on port %" PRIu16", retrying on %" PRIu16,                 port, (uint16_t) (port + 1));            port++;            continue;        }        if (port_range.first == port_range.last) {            LOGE("Could not listen on port %" PRIu16, port_range.first);        } else {            LOGE("Could not listen on any port in range %" PRIu16 ":%" PRIu16,                 port_range.first, port_range.last);        }        return false;    }}
enable_tunnel_any_port(struct server *server, struct sc_port_range port_range,                       bool force_adb_forward) {    if (!force_adb_forward) {        // Attempt to use "adb reverse"        if (enable_tunnel_reverse_any_port(server, port_range)) {            return true;        }        // if "adb reverse" does not work (e.g. over "adb connect"), it        // fallbacks to "adb forward", so the app socket is the client        LOGW("'adb reverse' failed, fallback to 'adb forward'");    }    return enable_tunnel_forward_any_port(server, port_range);}
enable_tunnel_reverse_any_port(struct server *server,                               struct sc_port_range port_range) {    uint16_t port = port_range.first;    for (;;) {        if (!enable_tunnel_reverse(server->serial, port)) {            // the command itself failed, it will fail on any port            return false;        }        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(port);        if (server->server_socket != INVALID_SOCKET) {            // success            server->local_port = port;            return true;        }        // failure, disable tunnel and try another port        if (!disable_tunnel_reverse(server->serial)) {            LOGW("Could not remove reverse tunnel on port %" PRIu16, port);        }        // check before incrementing to avoid overflow on port 65535        if (port < port_range.last) {            LOGW("Could not listen on port %" PRIu16", retrying on %" PRIu16,                 port, (uint16_t) (port + 1));            port++;            continue;        }        if (port_range.first == port_range.last) {            LOGE("Could not listen on port %" PRIu16, port_range.first);        } else {            LOGE("Could not listen on any port in range %" PRIu16 ":%" PRIu16,                 port_range.first, port_range.last);        }        return false;    }}
static void test_options2(void) {    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    char *argv[] = {        "scrcpy",        "--no-control",        "--no-display",        "--record", "file.mp4", // cannot enable --no-display without recording    };    bool ok = scrcpy_parse_args(&args, ARRAY_LEN(argv), argv);    assert(ok);    const struct scrcpy_options *opts = &args.opts;    assert(!opts->control);    assert(!opts->display);    assert(!strcmp(opts->record_filename, "file.mp4"));    assert(opts->record_format == RECORDER_FORMAT_MP4);}
static void test_options(void) {    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    char *argv[] = {        "scrcpy",        "--always-on-top",        "--bit-rate", "5M",        "--crop", "100:200:300:400",        "--fullscreen",        "--max-fps", "30",        "--max-size", "1024",        "--lock-video-orientation", "2",        // "--no-control" is not compatible with "--turn-screen-off"        // "--no-display" is not compatible with "--fulscreen"        "--port", "1234:1236",        "--push-target", "/sdcard/Movies",        "--record", "file",        "--record-format", "mkv",        "--render-expired-frames",        "--serial", "0123456789abcdef",        "--show-touches",        "--turn-screen-off",        "--prefer-text",        "--window-title", "my device",        "--window-x", "100",        "--window-y", "-1",        "--window-width", "600",        "--window-height", "0",        "--window-borderless",    };    bool ok = scrcpy_parse_args(&args, ARRAY_LEN(argv), argv);    assert(ok);    const struct scrcpy_options *opts = &args.opts;    assert(opts->always_on_top);    assert(opts->bit_rate == 5000000);    assert(!strcmp(opts->crop, "100:200:300:400"));    assert(opts->fullscreen);    assert(opts->max_fps == 30);    assert(opts->max_size == 1024);    assert(opts->lock_video_orientation == 2);    assert(opts->port_range.first == 1234);    assert(opts->port_range.last == 1236);    assert(!strcmp(opts->push_target, "/sdcard/Movies"));    assert(!strcmp(opts->record_filename, "file"));    assert(opts->record_format == RECORDER_FORMAT_MKV);    assert(opts->render_expired_frames);    assert(!strcmp(opts->serial, "0123456789abcdef"));    assert(opts->show_touches);    assert(opts->turn_screen_off);    assert(opts->prefer_text);    assert(!strcmp(opts->window_title, "my device"));    assert(opts->window_x == 100);    assert(opts->window_y == -1);    assert(opts->window_width == 600);    assert(opts->window_height == 0);    assert(opts->window_borderless);}
static void test_options2(void) {    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    char *argv[] = {        "scrcpy",        "--no-control",        "--no-display",        "--record", "file.mp4", // cannot enable --no-display without recording    };    bool ok = scrcpy_parse_args(&args, ARRAY_LEN(argv), argv);    assert(ok);    const struct scrcpy_options *opts = &args.opts;    assert(!opts->control);    assert(!opts->display);    assert(!strcmp(opts->record_filename, "file.mp4"));    assert(opts->record_format == SC_RECORD_FORMAT_MP4);}
static void test_options(void) {    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    char *argv[] = {        "scrcpy",        "--always-on-top",        "--bit-rate", "5M",        "--crop", "100:200:300:400",        "--fullscreen",        "--max-fps", "30",        "--max-size", "1024",        "--lock-video-orientation", "2",        // "--no-control" is not compatible with "--turn-screen-off"        // "--no-display" is not compatible with "--fulscreen"        "--port", "1234:1236",        "--push-target", "/sdcard/Movies",        "--record", "file",        "--record-format", "mkv",        "--render-expired-frames",        "--serial", "0123456789abcdef",        "--show-touches",        "--turn-screen-off",        "--prefer-text",        "--window-title", "my device",        "--window-x", "100",        "--window-y", "-1",        "--window-width", "600",        "--window-height", "0",        "--window-borderless",    };    bool ok = scrcpy_parse_args(&args, ARRAY_LEN(argv), argv);    assert(ok);    const struct scrcpy_options *opts = &args.opts;    assert(opts->always_on_top);    assert(opts->bit_rate == 5000000);    assert(!strcmp(opts->crop, "100:200:300:400"));    assert(opts->fullscreen);    assert(opts->max_fps == 30);    assert(opts->max_size == 1024);    assert(opts->lock_video_orientation == 2);    assert(opts->port_range.first == 1234);    assert(opts->port_range.last == 1236);    assert(!strcmp(opts->push_target, "/sdcard/Movies"));    assert(!strcmp(opts->record_filename, "file"));    assert(opts->record_format == SC_RECORD_FORMAT_MKV);    assert(opts->render_expired_frames);    assert(!strcmp(opts->serial, "0123456789abcdef"));    assert(opts->show_touches);    assert(opts->turn_screen_off);    assert(opts->prefer_text);    assert(!strcmp(opts->window_title, "my device"));    assert(opts->window_x == 100);    assert(opts->window_y == -1);    assert(opts->window_width == 600);    assert(opts->window_height == 0);    assert(opts->window_borderless);}
get_server_path(void) {    const char *server_path_env = getenv("SCRCPY_SERVER_PATH");    if (server_path_env) {        LOGD("Using SCRCPY_SERVER_PATH: %s", server_path_env);        // if the envvar is set, use it        return server_path_env;    }#ifndef PORTABLE    LOGD("Using server: " DEFAULT_SERVER_PATH);    // the absolute path is hardcoded    return DEFAULT_SERVER_PATH;#else    // use scrcpy-server in the same directory as the executable    char *executable_path = get_executable_path();    if (!executable_path) {        LOGE("Could not get executable path, "             "using " SERVER_FILENAME " from current directory");        // not found, use current directory        return SERVER_FILENAME;    }    char *dir = dirname(executable_path);    size_t dirlen = strlen(dir);    // sizeof(SERVER_FILENAME) gives statically the size including the null byte    size_t len = dirlen + 1 + sizeof(SERVER_FILENAME);    char *server_path = SDL_malloc(len);    if (!server_path) {        LOGE("Could not alloc server path string, "             "using " SERVER_FILENAME " from current directory");        SDL_free(executable_path);        return SERVER_FILENAME;    }    memcpy(server_path, dir, dirlen);    server_path[dirlen] = PATH_SEPARATOR;    memcpy(&server_path[dirlen + 1], SERVER_FILENAME, sizeof(SERVER_FILENAME));    // the final null byte has been copied with SERVER_FILENAME    SDL_free(executable_path);    LOGD("Using server (portable): %s", server_path);    return server_path;#endif}
push_server(const char *serial) {    const char *server_path = get_server_path();    if (!is_regular_file(server_path)) {        LOGE("'%s' does not exist or is not a regular file\n", server_path);        return false;    }    process_t process = adb_push(serial, server_path, DEVICE_SERVER_PATH);    return process_check_success(process, "adb push");}
get_server_path(void) {    const char *server_path_env = getenv("SCRCPY_SERVER_PATH");    if (server_path_env) {        // if the envvar is set, use it        char *server_path = SDL_strdup(server_path_env);        if (!server_path) {            LOGE("Could not allocate memory");            return NULL;        }        LOGD("Using SCRCPY_SERVER_PATH: %s", server_path);        return server_path;    }#ifndef PORTABLE    LOGD("Using server: " DEFAULT_SERVER_PATH);    char *server_path = SDL_strdup(DEFAULT_SERVER_PATH);    if (!server_path) {        LOGE("Could not allocate memory");        return NULL;    }    // the absolute path is hardcoded    return server_path;#else    // use scrcpy-server in the same directory as the executable    char *executable_path = get_executable_path();    if (!executable_path) {        LOGE("Could not get executable path, "             "using " SERVER_FILENAME " from current directory");        // not found, use current directory        return SERVER_FILENAME;    }    char *dir = dirname(executable_path);    size_t dirlen = strlen(dir);    // sizeof(SERVER_FILENAME) gives statically the size including the null byte    size_t len = dirlen + 1 + sizeof(SERVER_FILENAME);    char *server_path = SDL_malloc(len);    if (!server_path) {        LOGE("Could not alloc server path string, "             "using " SERVER_FILENAME " from current directory");        SDL_free(executable_path);        return SERVER_FILENAME;    }    memcpy(server_path, dir, dirlen);    server_path[dirlen] = PATH_SEPARATOR;    memcpy(&server_path[dirlen + 1], SERVER_FILENAME, sizeof(SERVER_FILENAME));    // the final null byte has been copied with SERVER_FILENAME    SDL_free(executable_path);    LOGD("Using server (portable): %s", server_path);    return server_path;#endif}
push_server(const char *serial) {    char *server_path = get_server_path();    if (!server_path) {        return false;    }    if (!is_regular_file(server_path)) {        LOGE("'%s' does not exist or is not a regular file\n", server_path);        SDL_free(server_path);        return false;    }    process_t process = adb_push(serial, server_path, DEVICE_SERVER_PATH);    SDL_free(server_path);    return process_check_success(process, "adb push");}
screen_set_rotation(struct screen *screen, unsigned rotation) {    assert(rotation < 4);    if (rotation == screen->rotation) {        return;    }    struct size old_content_size =        get_rotated_size(screen->frame_size, screen->rotation);    struct size new_content_size =        get_rotated_size(screen->frame_size, rotation);    if (SDL_RenderSetLogicalSize(screen->renderer,                                 new_content_size.width,                                 new_content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        return;    }    struct size windowed_size = get_windowed_window_size(screen);    struct size target_size = {        .width = (uint32_t) windowed_size.width * new_content_size.width                / old_content_size.width,        .height = (uint32_t) windowed_size.height * new_content_size.height                / old_content_size.height,    };    target_size = get_optimal_size(target_size, new_content_size);    set_window_size(screen, target_size);    screen->rotation = rotation;    LOGI("Display rotation set to %u", rotation);    screen_render(screen);}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size =        get_rotated_size(frame_size, screen->rotation);    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, content_size.width,                                 content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width            || screen->frame_size.height != new_frame_size.height) {        struct size new_content_size =            get_rotated_size(new_frame_size, screen->rotation);        if (SDL_RenderSetLogicalSize(screen->renderer,                                     new_content_size.width,                                     new_content_size.height)) {            LOGE("Could not set renderer logical size: %s", SDL_GetError());            return false;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        struct size content_size =            get_rotated_size(screen->frame_size, screen->rotation);        struct size windowed_size = get_windowed_window_size(screen);        struct size target_size = {            (uint32_t) windowed_size.width * new_content_size.width                    / content_size.width,            (uint32_t) windowed_size.height * new_content_size.height                    / content_size.height,        };        target_size = get_optimal_size(target_size, new_content_size);        set_window_size(screen, target_size);        screen->frame_size = new_frame_size;        LOGI("New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = create_texture(screen->renderer, new_frame_size);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return false;        }    }    return true;}
screen_resize_to_fit(struct screen *screen) {    if (screen->fullscreen) {        return;    }    if (screen->maximized) {        SDL_RestoreWindow(screen->window);        screen->maximized = false;    }    struct size content_size =        get_rotated_size(screen->frame_size, screen->rotation);    struct size optimal_size =        get_optimal_window_size(screen, content_size);    SDL_SetWindowSize(screen->window, optimal_size.width, optimal_size.height);    LOGD("Resized to optimal size");}
screen_resize_to_pixel_perfect(struct screen *screen) {    if (screen->fullscreen) {        return;    }    if (screen->maximized) {        SDL_RestoreWindow(screen->window);        screen->maximized = false;    }    struct size content_size =        get_rotated_size(screen->frame_size, screen->rotation);    SDL_SetWindowSize(screen->window, content_size.width, content_size.height);    LOGD("Resized to pixel-perfect");}
screen_render(struct screen *screen) {    SDL_RenderClear(screen->renderer);    if (screen->rotation == 0) {        SDL_RenderCopy(screen->renderer, screen->texture, NULL, NULL);    } else {        // rotation in RenderCopyEx() is clockwise, while screen->rotation is        // counterclockwise (to be consistent with --lock-video-orientation)        int cw_rotation = (4 - screen->rotation) % 4;        double angle = 90 * cw_rotation;        SDL_Rect *dstrect = NULL;        SDL_Rect rect;        if (screen->rotation & 1) {            struct size size =                get_rotated_size(screen->frame_size, screen->rotation);            rect.x = (size.width - size.height) / 2;            rect.y = (size.height - size.width) / 2;            rect.w = size.height;            rect.h = size.width;            dstrect = &rect;        }        SDL_RenderCopyEx(screen->renderer, screen->texture, NULL, dstrect,                         angle, NULL, 0);    }    SDL_RenderPresent(screen->renderer);}
screen_set_rotation(struct screen *screen, unsigned rotation) {    assert(rotation < 4);    if (rotation == screen->rotation) {        return;    }    struct size old_content_size = screen->content_size;    struct size new_content_size =        get_rotated_size(screen->frame_size, rotation);    if (SDL_RenderSetLogicalSize(screen->renderer,                                 new_content_size.width,                                 new_content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        return;    }    struct size windowed_size = get_windowed_window_size(screen);    struct size target_size = {        .width = (uint32_t) windowed_size.width * new_content_size.width                / old_content_size.width,        .height = (uint32_t) windowed_size.height * new_content_size.height                / old_content_size.height,    };    target_size = get_optimal_size(target_size, new_content_size);    set_window_size(screen, target_size);    screen->content_size = new_content_size;    screen->rotation = rotation;    LOGI("Display rotation set to %u", rotation);    screen_render(screen);}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size = get_rotated_size(frame_size, screen->rotation);    screen->content_size = content_size;    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, content_size.width,                                 content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width            || screen->frame_size.height != new_frame_size.height) {        struct size new_content_size =            get_rotated_size(new_frame_size, screen->rotation);        if (SDL_RenderSetLogicalSize(screen->renderer,                                     new_content_size.width,                                     new_content_size.height)) {            LOGE("Could not set renderer logical size: %s", SDL_GetError());            return false;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        struct size content_size = screen->content_size;        struct size windowed_size = get_windowed_window_size(screen);        struct size target_size = {            (uint32_t) windowed_size.width * new_content_size.width                    / content_size.width,            (uint32_t) windowed_size.height * new_content_size.height                    / content_size.height,        };        target_size = get_optimal_size(target_size, new_content_size);        set_window_size(screen, target_size);        screen->frame_size = new_frame_size;        screen->content_size = new_content_size;        LOGI("New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = create_texture(screen->renderer, new_frame_size);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return false;        }    }    return true;}
screen_resize_to_fit(struct screen *screen) {    if (screen->fullscreen) {        return;    }    if (screen->maximized) {        SDL_RestoreWindow(screen->window);        screen->maximized = false;    }    struct size optimal_size =        get_optimal_window_size(screen, screen->content_size);    SDL_SetWindowSize(screen->window, optimal_size.width, optimal_size.height);    LOGD("Resized to optimal size");}
screen_resize_to_pixel_perfect(struct screen *screen) {    if (screen->fullscreen) {        return;    }    if (screen->maximized) {        SDL_RestoreWindow(screen->window);        screen->maximized = false;    }    struct size content_size = screen->content_size;    SDL_SetWindowSize(screen->window, content_size.width, content_size.height);    LOGD("Resized to pixel-perfect");}
screen_render(struct screen *screen) {    SDL_RenderClear(screen->renderer);    if (screen->rotation == 0) {        SDL_RenderCopy(screen->renderer, screen->texture, NULL, NULL);    } else {        // rotation in RenderCopyEx() is clockwise, while screen->rotation is        // counterclockwise (to be consistent with --lock-video-orientation)        int cw_rotation = (4 - screen->rotation) % 4;        double angle = 90 * cw_rotation;        SDL_Rect *dstrect = NULL;        SDL_Rect rect;        if (screen->rotation & 1) {            struct size size = screen->content_size;            rect.x = (size.width - size.height) / 2;            rect.y = (size.height - size.width) / 2;            rect.w = size.height;            rect.h = size.width;            dstrect = &rect;        }        SDL_RenderCopyEx(screen->renderer, screen->texture, NULL, dstrect,                         angle, NULL, 0);    }    SDL_RenderPresent(screen->renderer);}
convert_keycode(SDL_Keycode from, enum android_keycode *to, uint16_t mod,                bool prefer_text) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_HOME,         AKEYCODE_MOVE_HOME);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);        MAP(SDLK_LCTRL,        AKEYCODE_CTRL_LEFT);        MAP(SDLK_RCTRL,        AKEYCODE_CTRL_RIGHT);    }    if (!(mod & (KMOD_NUM | KMOD_SHIFT))) {        // Handle Numpad events when Num Lock is disabled        // If SHIFT is pressed, a text event will be sent instead        switch(from) {            MAP(SDLK_KP_0,            AKEYCODE_INSERT);            MAP(SDLK_KP_1,            AKEYCODE_MOVE_END);            MAP(SDLK_KP_2,            AKEYCODE_DPAD_DOWN);            MAP(SDLK_KP_3,            AKEYCODE_PAGE_DOWN);            MAP(SDLK_KP_4,            AKEYCODE_DPAD_LEFT);            MAP(SDLK_KP_6,            AKEYCODE_DPAD_RIGHT);            MAP(SDLK_KP_7,            AKEYCODE_MOVE_HOME);            MAP(SDLK_KP_8,            AKEYCODE_DPAD_UP);            MAP(SDLK_KP_9,            AKEYCODE_PAGE_UP);            MAP(SDLK_KP_PERIOD,       AKEYCODE_FORWARD_DEL);        }    }    if (prefer_text && !(mod & KMOD_CTRL)) {        // do not forward alpha and space key events (unless Ctrl is pressed)        return false;    }    if (mod & (KMOD_LALT | KMOD_RALT | KMOD_LGUI | KMOD_RGUI)) {        return false;    }    // if ALT and META are not pressed, also handle letters and space    switch (from) {        MAP(SDLK_a,            AKEYCODE_A);        MAP(SDLK_b,            AKEYCODE_B);        MAP(SDLK_c,            AKEYCODE_C);        MAP(SDLK_d,            AKEYCODE_D);        MAP(SDLK_e,            AKEYCODE_E);        MAP(SDLK_f,            AKEYCODE_F);        MAP(SDLK_g,            AKEYCODE_G);        MAP(SDLK_h,            AKEYCODE_H);        MAP(SDLK_i,            AKEYCODE_I);        MAP(SDLK_j,            AKEYCODE_J);        MAP(SDLK_k,            AKEYCODE_K);        MAP(SDLK_l,            AKEYCODE_L);        MAP(SDLK_m,            AKEYCODE_M);        MAP(SDLK_n,            AKEYCODE_N);        MAP(SDLK_o,            AKEYCODE_O);        MAP(SDLK_p,            AKEYCODE_P);        MAP(SDLK_q,            AKEYCODE_Q);        MAP(SDLK_r,            AKEYCODE_R);        MAP(SDLK_s,            AKEYCODE_S);        MAP(SDLK_t,            AKEYCODE_T);        MAP(SDLK_u,            AKEYCODE_U);        MAP(SDLK_v,            AKEYCODE_V);        MAP(SDLK_w,            AKEYCODE_W);        MAP(SDLK_x,            AKEYCODE_X);        MAP(SDLK_y,            AKEYCODE_Y);        MAP(SDLK_z,            AKEYCODE_Z);        MAP(SDLK_SPACE,        AKEYCODE_SPACE);        FAIL;    }}
convert_keycode(SDL_Keycode from, enum android_keycode *to, uint16_t mod,                bool prefer_text) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_HOME,         AKEYCODE_MOVE_HOME);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);        MAP(SDLK_LCTRL,        AKEYCODE_CTRL_LEFT);        MAP(SDLK_RCTRL,        AKEYCODE_CTRL_RIGHT);        MAP(SDLK_LSHIFT,       AKEYCODE_SHIFT_LEFT);        MAP(SDLK_RSHIFT,       AKEYCODE_SHIFT_RIGHT);    }    if (!(mod & (KMOD_NUM | KMOD_SHIFT))) {        // Handle Numpad events when Num Lock is disabled        // If SHIFT is pressed, a text event will be sent instead        switch(from) {            MAP(SDLK_KP_0,            AKEYCODE_INSERT);            MAP(SDLK_KP_1,            AKEYCODE_MOVE_END);            MAP(SDLK_KP_2,            AKEYCODE_DPAD_DOWN);            MAP(SDLK_KP_3,            AKEYCODE_PAGE_DOWN);            MAP(SDLK_KP_4,            AKEYCODE_DPAD_LEFT);            MAP(SDLK_KP_6,            AKEYCODE_DPAD_RIGHT);            MAP(SDLK_KP_7,            AKEYCODE_MOVE_HOME);            MAP(SDLK_KP_8,            AKEYCODE_DPAD_UP);            MAP(SDLK_KP_9,            AKEYCODE_PAGE_UP);            MAP(SDLK_KP_PERIOD,       AKEYCODE_FORWARD_DEL);        }    }    if (prefer_text && !(mod & KMOD_CTRL)) {        // do not forward alpha and space key events (unless Ctrl is pressed)        return false;    }    if (mod & (KMOD_LALT | KMOD_RALT | KMOD_LGUI | KMOD_RGUI)) {        return false;    }    // if ALT and META are not pressed, also handle letters and space    switch (from) {        MAP(SDLK_a,            AKEYCODE_A);        MAP(SDLK_b,            AKEYCODE_B);        MAP(SDLK_c,            AKEYCODE_C);        MAP(SDLK_d,            AKEYCODE_D);        MAP(SDLK_e,            AKEYCODE_E);        MAP(SDLK_f,            AKEYCODE_F);        MAP(SDLK_g,            AKEYCODE_G);        MAP(SDLK_h,            AKEYCODE_H);        MAP(SDLK_i,            AKEYCODE_I);        MAP(SDLK_j,            AKEYCODE_J);        MAP(SDLK_k,            AKEYCODE_K);        MAP(SDLK_l,            AKEYCODE_L);        MAP(SDLK_m,            AKEYCODE_M);        MAP(SDLK_n,            AKEYCODE_N);        MAP(SDLK_o,            AKEYCODE_O);        MAP(SDLK_p,            AKEYCODE_P);        MAP(SDLK_q,            AKEYCODE_Q);        MAP(SDLK_r,            AKEYCODE_R);        MAP(SDLK_s,            AKEYCODE_S);        MAP(SDLK_t,            AKEYCODE_T);        MAP(SDLK_u,            AKEYCODE_U);        MAP(SDLK_v,            AKEYCODE_V);        MAP(SDLK_w,            AKEYCODE_W);        MAP(SDLK_x,            AKEYCODE_X);        MAP(SDLK_y,            AKEYCODE_Y);        MAP(SDLK_z,            AKEYCODE_Z);        MAP(SDLK_SPACE,        AKEYCODE_SPACE);        FAIL;    }}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"codec-options",          required_argument, NULL, OPT_CODEC_OPTIONS},        {"crop",                   required_argument, NULL, OPT_CROP},        {"disable-screensaver",    no_argument,       NULL,                                                  OPT_DISABLE_SCREENSAVER},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"force-adb-forward",      no_argument,       NULL,                                                  OPT_FORCE_ADB_FORWARD},        {"forward-all-clicks",     no_argument,       NULL,                                                  OPT_FORWARD_ALL_CLICKS},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"legacy-paste",           no_argument,       NULL, OPT_LEGACY_PASTE},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-key-repeat",          no_argument,       NULL, OPT_NO_KEY_REPEAT},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"port",                   required_argument, NULL, 'p'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"shortcut-mod",           required_argument, NULL, OPT_SHORTCUT_MOD},        {"show-touches",           no_argument,       NULL, 't'},        {"stay-awake",             no_argument,       NULL, 'w'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"verbosity",              required_argument, NULL, 'V'},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTvV:w",                            long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case 'V':                if (!parse_log_level(optarg, &opts->log_level)) {                    return false;                }                break;            case 'w':                opts->stay_awake = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            case OPT_NO_KEY_REPEAT:                opts->forward_key_repeat = false;                break;            case OPT_CODEC_OPTIONS:                opts->codec_options = optarg;                break;            case OPT_FORCE_ADB_FORWARD:                opts->force_adb_forward = true;                break;            case OPT_DISABLE_SCREENSAVER:                opts->disable_screensaver = true;                break;            case OPT_SHORTCUT_MOD:                if (!parse_shortcut_mods(optarg, &opts->shortcut_mods)) {                    return false;                }                break;            case OPT_FORWARD_ALL_CLICKS:                opts->forward_all_clicks = true;                break;            case OPT_LEGACY_PASTE:                opts->legacy_paste = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    if (!opts->control && opts->stay_awake) {        LOGE("Could not request to stay awake if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    --forward-all-clicks\n"        "        By default, right-click triggers BACK (or POWER on) and\n"        "        middle-click triggers HOME. This option disables these\n"        "        shortcuts and forward the clicks to the device instead.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --legacy-paste\n"        "        Inject computer clipboard text as a sequence of key events\n"        "        on Ctrl+v (like MOD+Shift+v).\n"        "        This is a workaround for some devices not behaving as\n"        "        expected when setting the device clipboard programmatically.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-key-repeat\n"        "        Do not forward repeated key events when a key is held down.\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    --shortcut-mod key[+...]][,...]\n"        "        Specify the modifiers to use for scrcpy shortcuts.\n"        "        Possible keys are \"lctrl\", \"rctrl\", \"lalt\", \"ralt\",\n"        "        \"lsuper\" and \"rsuper\".\n"        "\n"        "        A shortcut can consist in several keys, separated by '+'.\n"        "        Several shortcuts can be specified, separated by ','.\n"        "\n"        "        For example, to use either LCtrl+LAlt or LSuper for scrcpy\n"        "        shortcuts, pass \"lctrl+lalt,lsuper\".\n"        "\n"        "        Default is \"lalt,lsuper\" (left-Alt or left-Super).\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    In the following list, MOD is the shortcut modifier. By default,\n"        "    it's (left) Alt or (left) Super, but it can be configured by\n"        "    --shortcut-mod (see above).\n"        "\n"        "    MOD+f\n"        "        Switch fullscreen mode\n"        "\n"        "    MOD+Left\n"        "        Rotate display left\n"        "\n"        "    MOD+Right\n"        "        Rotate display right\n"        "\n"        "    MOD+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    MOD+w\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    MOD+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    MOD+b\n"        "    MOD+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    MOD+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    MOD+m\n"        "        Click on MENU\n"        "\n"        "    MOD+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    MOD+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    MOD+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    MOD+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    MOD+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    MOD+r\n"        "        Rotate device screen\n"        "\n"        "    MOD+n\n"        "        Expand notification panel\n"        "\n"        "    MOD+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    MOD+c\n"        "        Copy to clipboard (inject COPY keycode, Android >= 7 only)\n"        "\n"        "    MOD+x\n"        "        Cut to clipboard (inject CUT keycode, Android >= 7 only)\n"        "\n"        "    MOD+v\n"        "        Copy computer clipboard to device, then paste (inject PASTE\n"        "        keycode, Android >= 7 only)\n"        "\n"        "    MOD+Shift+v\n"        "        Inject computer clipboard text as a sequence of key events\n"        "\n"        "    MOD+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Ctrl+click-and-move\n"        "        Pinch-to-zoom from the center of the screen\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"codec-options",          required_argument, NULL, OPT_CODEC_OPTIONS},        {"crop",                   required_argument, NULL, OPT_CROP},        {"disable-screensaver",    no_argument,       NULL,                                                  OPT_DISABLE_SCREENSAVER},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"encoder",                required_argument, NULL, OPT_ENCODER_NAME},        {"force-adb-forward",      no_argument,       NULL,                                                  OPT_FORCE_ADB_FORWARD},        {"forward-all-clicks",     no_argument,       NULL,                                                  OPT_FORWARD_ALL_CLICKS},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"legacy-paste",           no_argument,       NULL, OPT_LEGACY_PASTE},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-key-repeat",          no_argument,       NULL, OPT_NO_KEY_REPEAT},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"port",                   required_argument, NULL, 'p'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"shortcut-mod",           required_argument, NULL, OPT_SHORTCUT_MOD},        {"show-touches",           no_argument,       NULL, 't'},        {"stay-awake",             no_argument,       NULL, 'w'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"verbosity",              required_argument, NULL, 'V'},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTvV:w",                            long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case 'V':                if (!parse_log_level(optarg, &opts->log_level)) {                    return false;                }                break;            case 'w':                opts->stay_awake = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            case OPT_NO_KEY_REPEAT:                opts->forward_key_repeat = false;                break;            case OPT_CODEC_OPTIONS:                opts->codec_options = optarg;                break;            case OPT_ENCODER_NAME:                opts->encoder_name = optarg;                break;            case OPT_FORCE_ADB_FORWARD:                opts->force_adb_forward = true;                break;            case OPT_DISABLE_SCREENSAVER:                opts->disable_screensaver = true;                break;            case OPT_SHORTCUT_MOD:                if (!parse_shortcut_mods(optarg, &opts->shortcut_mods)) {                    return false;                }                break;            case OPT_FORWARD_ALL_CLICKS:                opts->forward_all_clicks = true;                break;            case OPT_LEGACY_PASTE:                opts->legacy_paste = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    if (!opts->control && opts->stay_awake) {        LOGE("Could not request to stay awake if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --encoder name\n"        "        Use a specific MediaCodec encoder (must be a H.264 encoder).\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    --forward-all-clicks\n"        "        By default, right-click triggers BACK (or POWER on) and\n"        "        middle-click triggers HOME. This option disables these\n"        "        shortcuts and forward the clicks to the device instead.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --legacy-paste\n"        "        Inject computer clipboard text as a sequence of key events\n"        "        on Ctrl+v (like MOD+Shift+v).\n"        "        This is a workaround for some devices not behaving as\n"        "        expected when setting the device clipboard programmatically.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-key-repeat\n"        "        Do not forward repeated key events when a key is held down.\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    --shortcut-mod key[+...]][,...]\n"        "        Specify the modifiers to use for scrcpy shortcuts.\n"        "        Possible keys are \"lctrl\", \"rctrl\", \"lalt\", \"ralt\",\n"        "        \"lsuper\" and \"rsuper\".\n"        "\n"        "        A shortcut can consist in several keys, separated by '+'.\n"        "        Several shortcuts can be specified, separated by ','.\n"        "\n"        "        For example, to use either LCtrl+LAlt or LSuper for scrcpy\n"        "        shortcuts, pass \"lctrl+lalt,lsuper\".\n"        "\n"        "        Default is \"lalt,lsuper\" (left-Alt or left-Super).\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    In the following list, MOD is the shortcut modifier. By default,\n"        "    it's (left) Alt or (left) Super, but it can be configured by\n"        "    --shortcut-mod (see above).\n"        "\n"        "    MOD+f\n"        "        Switch fullscreen mode\n"        "\n"        "    MOD+Left\n"        "        Rotate display left\n"        "\n"        "    MOD+Right\n"        "        Rotate display right\n"        "\n"        "    MOD+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    MOD+w\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    MOD+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    MOD+b\n"        "    MOD+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    MOD+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    MOD+m\n"        "        Click on MENU\n"        "\n"        "    MOD+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    MOD+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    MOD+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    MOD+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    MOD+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    MOD+r\n"        "        Rotate device screen\n"        "\n"        "    MOD+n\n"        "        Expand notification panel\n"        "\n"        "    MOD+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    MOD+c\n"        "        Copy to clipboard (inject COPY keycode, Android >= 7 only)\n"        "\n"        "    MOD+x\n"        "        Cut to clipboard (inject CUT keycode, Android >= 7 only)\n"        "\n"        "    MOD+v\n"        "        Copy computer clipboard to device, then paste (inject PASTE\n"        "        keycode, Android >= 7 only)\n"        "\n"        "    MOD+Shift+v\n"        "        Inject computer clipboard text as a sequence of key events\n"        "\n"        "    MOD+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Ctrl+click-and-move\n"        "        Pinch-to-zoom from the center of the screen\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .log_level = options->log_level,        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,        .show_touches = options->show_touches,        .stay_awake = options->stay_awake,        .codec_options = options->codec_options,        .force_adb_forward = options->force_adb_forward,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver,                                options->disable_screensaver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options->mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    input_manager_init(&input_manager, options);    ret = event_loop(options);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .log_level = options->log_level,        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,        .show_touches = options->show_touches,        .stay_awake = options->stay_awake,        .codec_options = options->codec_options,        .encoder_name = options->encoder_name,        .force_adb_forward = options->force_adb_forward,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver,                                options->disable_screensaver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options->mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    input_manager_init(&input_manager, options);    ret = event_loop(options);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    server_destroy(&server);    return ret;}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    char max_fps_string[6];    char lock_video_orientation_string[5];    char display_id_string[6];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    sprintf(max_fps_string, "%"PRIu16, params->max_fps);    sprintf(lock_video_orientation_string, "%"PRIi8, params->lock_video_orientation);    sprintf(display_id_string, "%"PRIu16, params->display_id);    const char *const cmd[] = {        "shell",        "CLASSPATH=" DEVICE_SERVER_PATH,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"# ifdef SERVER_DEBUGGER_METHOD_NEW        /* Android 9 and above */        "-XjdwpProvider:internal -XjdwpOptions:transport=dt_socket,suspend=y,server=y,address="# else        /* Android 8 and below */        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="# endif            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,        log_level_to_server_string(params->log_level),        max_size_string,        bit_rate_string,        max_fps_string,        lock_video_orientation_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",        display_id_string,        params->show_touches ? "true" : "false",        params->stay_awake ? "true" : "false",        params->codec_options ? params->codec_options : "-",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    char max_fps_string[6];    char lock_video_orientation_string[5];    char display_id_string[6];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    sprintf(max_fps_string, "%"PRIu16, params->max_fps);    sprintf(lock_video_orientation_string, "%"PRIi8, params->lock_video_orientation);    sprintf(display_id_string, "%"PRIu16, params->display_id);    const char *const cmd[] = {        "shell",        "CLASSPATH=" DEVICE_SERVER_PATH,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"# ifdef SERVER_DEBUGGER_METHOD_NEW        /* Android 9 and above */        "-XjdwpProvider:internal -XjdwpOptions:transport=dt_socket,suspend=y,server=y,address="# else        /* Android 8 and below */        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="# endif            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,        log_level_to_server_string(params->log_level),        max_size_string,        bit_rate_string,        max_fps_string,        lock_video_orientation_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",        display_id_string,        params->show_touches ? "true" : "false",        params->stay_awake ? "true" : "false",        params->codec_options ? params->codec_options : "-",        params->encoder_name ? params->encoder_name : "-",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps, List<CodecOption> codecOptions) {        this.sendFrameMeta = sendFrameMeta;        this.bitRate = bitRate;        this.maxFps = maxFps;        this.codecOptions = codecOptions;    }
    private void internalStreamScreen(Device device, FileDescriptor fd) throws IOException {        MediaFormat format = createFormat(bitRate, maxFps, codecOptions);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                ScreenInfo screenInfo = device.getScreenInfo();                Rect contentRect = screenInfo.getContentRect();                // include the locked video orientation                Rect videoRect = screenInfo.getVideoSize().toRect();                // does not include the locked video orientation                Rect unlockedVideoRect = screenInfo.getUnlockedVideoSize().toRect();                int videoRotation = screenInfo.getVideoRotation();                int layerStack = device.getLayerStack();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, videoRotation, contentRect, unlockedVideoRect, layerStack);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps, List<CodecOption> codecOptions) {        this.sendFrameMeta = sendFrameMeta;        this.bitRate = bitRate;        this.maxFps = maxFps;        this.codecOptions = codecOptions;    }
    private static MediaCodec createCodec() throws IOException {        return MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_VIDEO_AVC);    }
    private static MediaCodec createCodec() throws IOException {        return MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_VIDEO_AVC);    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps, List<CodecOption> codecOptions, String encoderName) {        this.sendFrameMeta = sendFrameMeta;        this.bitRate = bitRate;        this.maxFps = maxFps;        this.codecOptions = codecOptions;        this.encoderName = encoderName;
    private void internalStreamScreen(Device device, FileDescriptor fd) throws IOException {        MediaFormat format = createFormat(bitRate, maxFps, codecOptions);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec(encoderName);                IBinder display = createDisplay();                ScreenInfo screenInfo = device.getScreenInfo();                Rect contentRect = screenInfo.getContentRect();                // include the locked video orientation                Rect videoRect = screenInfo.getVideoSize().toRect();                // does not include the locked video orientation                Rect unlockedVideoRect = screenInfo.getUnlockedVideoSize().toRect();                int videoRotation = screenInfo.getVideoRotation();                int layerStack = device.getLayerStack();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, videoRotation, contentRect, unlockedVideoRect, layerStack);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps, List<CodecOption> codecOptions, String encoderName) {        this.sendFrameMeta = sendFrameMeta;        this.bitRate = bitRate;        this.maxFps = maxFps;        this.codecOptions = codecOptions;        this.encoderName = encoderName;    }
    private static MediaCodec createCodec(String encoderName) throws IOException {        if (encoderName != null) {            Ln.d("Creating encoder by name: '" + encoderName + "'");            return MediaCodec.createByCodecName(encoderName);        }        return MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_VIDEO_AVC);    }
    }    private static MediaCodec createCodec(String encoderName) throws IOException {        if (encoderName != null) {
    private static Options createOptions(String... args) {        if (args.length < 1) {            throw new IllegalArgumentException("Missing client version");        }        String clientVersion = args[0];        if (!clientVersion.equals(BuildConfig.VERSION_NAME)) {            throw new IllegalArgumentException(                    "The server version (" + BuildConfig.VERSION_NAME + ") does not match the client " + "(" + clientVersion + ")");        }        final int expectedParameters = 14;        if (args.length != expectedParameters) {            throw new IllegalArgumentException("Expecting " + expectedParameters + " parameters");        }        Options options = new Options();        Ln.Level level = Ln.Level.valueOf(args[1].toUpperCase(Locale.ENGLISH));        options.setLogLevel(level);        int maxSize = Integer.parseInt(args[2]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[3]);        options.setBitRate(bitRate);        int maxFps = Integer.parseInt(args[4]);        options.setMaxFps(maxFps);        int lockedVideoOrientation = Integer.parseInt(args[5]);        options.setLockedVideoOrientation(lockedVideoOrientation);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[6]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[7]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[8]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[9]);        options.setControl(control);        int displayId = Integer.parseInt(args[10]);        options.setDisplayId(displayId);        boolean showTouches = Boolean.parseBoolean(args[11]);        options.setShowTouches(showTouches);        boolean stayAwake = Boolean.parseBoolean(args[12]);        options.setStayAwake(stayAwake);        String codecOptions = args[13];        options.setCodecOptions(codecOptions);        return options;    }
    private static void scrcpy(Options options) throws IOException {        Ln.i("Device: " + Build.MANUFACTURER + " " + Build.MODEL + " (Android " + Build.VERSION.RELEASE + ")");        final Device device = new Device(options);        List<CodecOption> codecOptions = CodecOption.parse(options.getCodecOptions());        boolean mustDisableShowTouchesOnCleanUp = false;        int restoreStayOn = -1;        if (options.getShowTouches() || options.getStayAwake()) {            try (ContentProvider settings = Device.createSettingsProvider()) {                if (options.getShowTouches()) {                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_SYSTEM, "show_touches", "1");                    // If "show touches" was disabled, it must be disabled back on clean up                    mustDisableShowTouchesOnCleanUp = !"1".equals(oldValue);                }                if (options.getStayAwake()) {                    int stayOn = BatteryManager.BATTERY_PLUGGED_AC | BatteryManager.BATTERY_PLUGGED_USB | BatteryManager.BATTERY_PLUGGED_WIRELESS;                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_GLOBAL, "stay_on_while_plugged_in", String.valueOf(stayOn));                    try {                        restoreStayOn = Integer.parseInt(oldValue);                        if (restoreStayOn == stayOn) {                            // No need to restore                            restoreStayOn = -1;                        }                    } catch (NumberFormatException e) {                        restoreStayOn = 0;                    }                }            }        }        CleanUp.configure(mustDisableShowTouchesOnCleanUp, restoreStayOn, true);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate(), options.getMaxFps(), codecOptions);            if (options.getControl()) {                final Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());                device.setClipboardListener(new Device.ClipboardListener() {                    @Override                    public void onClipboardTextChanged(String text) {                        controller.getSender().pushClipboardText(text);                    }                });            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    private static Options createOptions(String... args) {        if (args.length < 1) {            throw new IllegalArgumentException("Missing client version");        }        String clientVersion = args[0];        if (!clientVersion.equals(BuildConfig.VERSION_NAME)) {            throw new IllegalArgumentException(                    "The server version (" + BuildConfig.VERSION_NAME + ") does not match the client " + "(" + clientVersion + ")");        }        final int expectedParameters = 15;        if (args.length != expectedParameters) {            throw new IllegalArgumentException("Expecting " + expectedParameters + " parameters");        }        Options options = new Options();        Ln.Level level = Ln.Level.valueOf(args[1].toUpperCase(Locale.ENGLISH));        options.setLogLevel(level);        int maxSize = Integer.parseInt(args[2]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[3]);        options.setBitRate(bitRate);        int maxFps = Integer.parseInt(args[4]);        options.setMaxFps(maxFps);        int lockedVideoOrientation = Integer.parseInt(args[5]);        options.setLockedVideoOrientation(lockedVideoOrientation);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[6]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[7]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[8]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[9]);        options.setControl(control);        int displayId = Integer.parseInt(args[10]);        options.setDisplayId(displayId);        boolean showTouches = Boolean.parseBoolean(args[11]);        options.setShowTouches(showTouches);        boolean stayAwake = Boolean.parseBoolean(args[12]);        options.setStayAwake(stayAwake);        String codecOptions = args[13];        options.setCodecOptions(codecOptions);        String encoderName = "-".equals(args[14]) ? null : args[14];        options.setEncoderName(encoderName);        return options;    }
    private static void scrcpy(Options options) throws IOException {        Ln.i("Device: " + Build.MANUFACTURER + " " + Build.MODEL + " (Android " + Build.VERSION.RELEASE + ")");        final Device device = new Device(options);        List<CodecOption> codecOptions = CodecOption.parse(options.getCodecOptions());        boolean mustDisableShowTouchesOnCleanUp = false;        int restoreStayOn = -1;        if (options.getShowTouches() || options.getStayAwake()) {            try (ContentProvider settings = Device.createSettingsProvider()) {                if (options.getShowTouches()) {                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_SYSTEM, "show_touches", "1");                    // If "show touches" was disabled, it must be disabled back on clean up                    mustDisableShowTouchesOnCleanUp = !"1".equals(oldValue);                }                if (options.getStayAwake()) {                    int stayOn = BatteryManager.BATTERY_PLUGGED_AC | BatteryManager.BATTERY_PLUGGED_USB | BatteryManager.BATTERY_PLUGGED_WIRELESS;                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_GLOBAL, "stay_on_while_plugged_in", String.valueOf(stayOn));                    try {                        restoreStayOn = Integer.parseInt(oldValue);                        if (restoreStayOn == stayOn) {                            // No need to restore                            restoreStayOn = -1;                        }                    } catch (NumberFormatException e) {                        restoreStayOn = 0;                    }                }            }        }        CleanUp.configure(mustDisableShowTouchesOnCleanUp, restoreStayOn, true);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate(), options.getMaxFps(), codecOptions,                    options.getEncoderName());            if (options.getControl()) {                final Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());                device.setClipboardListener(new Device.ClipboardListener() {                    @Override                    public void onClipboardTextChanged(String text) {                        controller.getSender().pushClipboardText(text);                    }                });            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    public Device(Options options) {        displayId = options.getDisplayId();        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo(displayId);        if (displayInfo == null) {            int[] displayIds = serviceManager.getDisplayManager().getDisplayIds();            throw new InvalidDisplayIdException(displayId, displayIds);        }        int displayInfoFlags = displayInfo.getFlags();        screenInfo = ScreenInfo.computeScreenInfo(displayInfo, options.getCrop(), options.getMaxSize(), options.getLockedVideoOrientation());        layerStack = displayInfo.getLayerStack();        isPresentationDisplay = (displayInfoFlags & DisplayInfo.FLAG_PRESENTATION) != 0;        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    screenInfo = screenInfo.withDeviceRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        }, displayId);        if ((displayInfoFlags & DisplayInfo.FLAG_SUPPORTS_PROTECTED_BUFFERS) == 0) {            Ln.w("Display doesn't have FLAG_SUPPORTS_PROTECTED_BUFFERS flag, mirroring can be restricted");        }        if (!supportsInputEvents()) {            Ln.w("Input events are not supported for displays with FLAG_PRESENTATION enabled for devices with API lower than 29");        }    }
    public boolean supportsInputEvents() {        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {            return true;        }        return !isPresentationDisplay;    }
    public Device(Options options) {        displayId = options.getDisplayId();        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo(displayId);        if (displayInfo == null) {            int[] displayIds = serviceManager.getDisplayManager().getDisplayIds();            throw new InvalidDisplayIdException(displayId, displayIds);        }        int displayInfoFlags = displayInfo.getFlags();        screenInfo = ScreenInfo.computeScreenInfo(displayInfo, options.getCrop(), options.getMaxSize(), options.getLockedVideoOrientation());        layerStack = displayInfo.getLayerStack();        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    screenInfo = screenInfo.withDeviceRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        }, displayId);        if ((displayInfoFlags & DisplayInfo.FLAG_SUPPORTS_PROTECTED_BUFFERS) == 0) {            Ln.w("Display doesn't have FLAG_SUPPORTS_PROTECTED_BUFFERS flag, mirroring can be restricted");        }        // main display or any display on Android >= Q        supportsInputEvents = displayId == 0 || Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q;        if (!supportsInputEvents) {            Ln.w("Input events are not supported for secondary displays before Android 10");        }    }
    public boolean supportsInputEvents() {        return supportsInputEvents;    }
    public static boolean setDisplayId(InputEvent inputEvent, int displayId) {        try {            Method method = getSetDisplayIdMethod();            method.invoke(inputEvent, displayId);            return true;        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            // just a warning, it might happen on old devices            Ln.w("Cannot associate a display id to the input event");            return false;        }    }}
    public static boolean setDisplayId(InputEvent inputEvent, int displayId) {        try {            Method method = getSetDisplayIdMethod();            method.invoke(inputEvent, displayId);            return true;        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            Ln.e("Cannot associate a display id to the input event", e);            return false;        }    }}
input_manager_process_text_input(struct input_manager *im,                                 const SDL_TextInputEvent *event) {    if (!im->prefer_text) {        char c = event->text[0];        if (isalpha(c) || c == ' ') {            assert(event->text[1] == '\0');            // letters and space are handled as raw key event            return;        }    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    msg.inject_text.text = SDL_strdup(event->text);    if (!msg.inject_text.text) {        LOGW("Could not strdup input text");        return;    }    if (!controller_push_msg(im->controller, &msg)) {        SDL_free(msg.inject_text.text);        LOGW("Could not request 'inject text'");    }}
input_manager_process_text_input(struct input_manager *im,                                 const SDL_TextInputEvent *event) {    if (is_shortcut_mod(im, SDL_GetModState())) {        // A shortcut must never generate text events        return;    }    if (!im->prefer_text) {        char c = event->text[0];        if (isalpha(c) || c == ' ') {            assert(event->text[1] == '\0');            // letters and space are handled as raw key event            return;        }    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    msg.inject_text.text = SDL_strdup(event->text);    if (!msg.inject_text.text) {        LOGW("Could not strdup input text");        return;    }    if (!controller_push_msg(im->controller, &msg)) {        SDL_free(msg.inject_text.text);        LOGW("Could not request 'inject text'");    }}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"codec-options",          required_argument, NULL, OPT_CODEC_OPTIONS},        {"crop",                   required_argument, NULL, OPT_CROP},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"port",                   required_argument, NULL, 'p'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"stay-awake",             no_argument,       NULL, 'w'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"verbosity",              required_argument, NULL, 'V'},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTvV:w",                            long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case 'V':                if (!parse_log_level(optarg, &opts->log_level)) {                    return false;                }                break;            case 'w':                opts->stay_awake = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            case OPT_CODEC_OPTIONS:                opts->codec_options = optarg;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    if (!opts->control && opts->stay_awake) {        LOGE("Could not request to stay awake if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"codec-options",          required_argument, NULL, OPT_CODEC_OPTIONS},        {"crop",                   required_argument, NULL, OPT_CROP},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"force-adb-forward",      no_argument,       NULL,                                                  OPT_FORCE_ADB_FORWARD},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"port",                   required_argument, NULL, 'p'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"stay-awake",             no_argument,       NULL, 'w'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"verbosity",              required_argument, NULL, 'V'},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTvV:w",                            long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case 'V':                if (!parse_log_level(optarg, &opts->log_level)) {                    return false;                }                break;            case 'w':                opts->stay_awake = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            case OPT_CODEC_OPTIONS:                opts->codec_options = optarg;                break;            case OPT_FORCE_ADB_FORWARD:                opts->force_adb_forward = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    if (!opts->control && opts->stay_awake) {        LOGE("Could not request to stay awake if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .log_level = options->log_level,        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,        .show_touches = options->show_touches,        .stay_awake = options->stay_awake,        .codec_options = options->codec_options,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options-> mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .log_level = options->log_level,        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,        .show_touches = options->show_touches,        .stay_awake = options->stay_awake,        .codec_options = options->codec_options,        .force_adb_forward = options->force_adb_forward,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options-> mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    server_destroy(&server);    return ret;}
enable_tunnel_any_port(struct server *server, struct port_range port_range) {    if (enable_tunnel_reverse_any_port(server, port_range)) {        return true;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    LOGW("'adb reverse' failed, fallback to 'adb forward'");    return enable_tunnel_forward_any_port(server, port_range);}
enable_tunnel_any_port(struct server *server, struct port_range port_range) {    if (enable_tunnel_reverse_any_port(server, port_range)) {        return true;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    LOGW("'adb reverse' failed, fallback to 'adb forward'");    return enable_tunnel_forward_any_port(server, port_range);}
server_start(struct server *server, const char *serial,             const struct server_params *params) {    server->port_range = params->port_range;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        goto error1;    }    if (!enable_tunnel_any_port(server, params->port_range)) {        goto error1;    }    // server will connect to our server socket    server->process = execute_server(server, params);    if (server->process == PROCESS_NONE) {        goto error2;    }    // If the server process dies before connecting to the server socket, then    // the client will be stuck forever on accept(). To avoid the problem, we    // must be able to wake up the accept() call when the server dies. To keep    // things simple and multiplatform, just spawn a new thread waiting for the    // server process and calling shutdown()/close() on the server socket if    // necessary to wake up any accept() blocking call.    server->wait_server_thread =        SDL_CreateThread(run_wait_server, "wait-server", server);    if (!server->wait_server_thread) {        cmd_terminate(server->process);        cmd_simple_wait(server->process, NULL); // ignore exit code        goto error2;    }    server->tunnel_enabled = true;    return true;error2:    if (!server->tunnel_forward) {        bool was_closed =            atomic_flag_test_and_set(&server->server_socket_closed);        // the thread is not started, the flag could not be already set        assert(!was_closed);        (void) was_closed;        close_socket(server->server_socket);    }    disable_tunnel(server);error1:    SDL_free(server->serial);    return false;}
enable_tunnel_any_port(struct server *server, struct port_range port_range,                       bool force_adb_forward) {    if (!force_adb_forward) {        // Attempt to use "adb reverse"        if (enable_tunnel_reverse_any_port(server, port_range)) {            return true;        }        // if "adb reverse" does not work (e.g. over "adb connect"), it        // fallbacks to "adb forward", so the app socket is the client        LOGW("'adb reverse' failed, fallback to 'adb forward'");    }    return enable_tunnel_forward_any_port(server, port_range);}
enable_tunnel_any_port(struct server *server, struct port_range port_range,                       bool force_adb_forward) {    if (!force_adb_forward) {        // Attempt to use "adb reverse"        if (enable_tunnel_reverse_any_port(server, port_range)) {            return true;        }        // if "adb reverse" does not work (e.g. over "adb connect"), it        // fallbacks to "adb forward", so the app socket is the client        LOGW("'adb reverse' failed, fallback to 'adb forward'");
server_start(struct server *server, const char *serial,             const struct server_params *params) {    server->port_range = params->port_range;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        goto error1;    }    if (!enable_tunnel_any_port(server, params->port_range,                                params->force_adb_forward)) {        goto error1;    }    // server will connect to our server socket    server->process = execute_server(server, params);    if (server->process == PROCESS_NONE) {        goto error2;    }    // If the server process dies before connecting to the server socket, then    // the client will be stuck forever on accept(). To avoid the problem, we    // must be able to wake up the accept() call when the server dies. To keep    // things simple and multiplatform, just spawn a new thread waiting for the    // server process and calling shutdown()/close() on the server socket if    // necessary to wake up any accept() blocking call.    server->wait_server_thread =        SDL_CreateThread(run_wait_server, "wait-server", server);    if (!server->wait_server_thread) {        cmd_terminate(server->process);        cmd_simple_wait(server->process, NULL); // ignore exit code        goto error2;    }    server->tunnel_enabled = true;    return true;error2:    if (!server->tunnel_forward) {        bool was_closed =            atomic_flag_test_and_set(&server->server_socket_closed);        // the thread is not started, the flag could not be already set        assert(!was_closed);        (void) was_closed;        close_socket(server->server_socket);    }    disable_tunnel(server);error1:    SDL_free(server->serial);    return false;}
convert_touch(const SDL_TouchFingerEvent *from, struct screen *screen,              struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_touch_action(from->type, &to->inject_touch_event.action)) {        return false;    }    struct size frame_size = screen->frame_size;    to->inject_touch_event.pointer_id = from->fingerId;    to->inject_touch_event.position.screen_size = frame_size;    // SDL touch event coordinates are normalized in the range [0; 1]    float x = from->x * frame_size.width;    float y = from->y * frame_size.height;    to->inject_touch_event.position.point = rotate_position(screen, x, y);    to->inject_touch_event.pressure = from->pressure;    to->inject_touch_event.buttons = 0;    return true;}
convert_touch(const SDL_TouchFingerEvent *from, struct screen *screen,              struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_touch_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = from->fingerId;    to->inject_touch_event.position.screen_size = screen->frame_size;    // SDL touch event coordinates are normalized in the range [0; 1]    float x = from->x * screen->content_size.width;    float y = from->y * screen->content_size.height;    to->inject_touch_event.position.point = rotate_position(screen, x, y);    to->inject_touch_event.pressure = from->pressure;    to->inject_touch_event.buttons = 0;    return true;}
BOOL windows_ctrl_handler(DWORD ctrl_type) {    if (ctrl_type == CTRL_C_EVENT) {        SDL_Event event;        event.type = SDL_QUIT;        SDL_PushEvent(&event);        return TRUE;    }    return FALSE;}#endif // _WIN32
BOOL WINAPI windows_ctrl_handler(DWORD ctrl_type) {    if (ctrl_type == CTRL_C_EVENT) {        SDL_Event event;        event.type = SDL_QUIT;        SDL_PushEvent(&event);        return TRUE;    }    return FALSE;}#endif // _WIN32
    public void setClipboardText(String text) {        serviceManager.getClipboardManager().setText(text);        Ln.i("Device clipboard set");    }
    public void setScreenPowerMode(int mode) {        IBinder d = SurfaceControl.getBuiltInDisplay();        if (d == null) {            Ln.e("Could not get built-in display");            return;        }        SurfaceControl.setDisplayPowerMode(d, mode);        Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));    }
    public void setClipboardText(String text) {        boolean ok = serviceManager.getClipboardManager().setText(text);        if (ok) {            Ln.i("Device clipboard set");        }    }
    public void setScreenPowerMode(int mode) {        IBinder d = SurfaceControl.getBuiltInDisplay();        if (d == null) {            Ln.e("Could not get built-in display");            return;        }        boolean ok = SurfaceControl.setDisplayPowerMode(d, mode);        if (ok) {            Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));        }    }
    public void setText(CharSequence text) {        try {            Method method = getSetPrimaryClipMethod();            ClipData clipData = ClipData.newPlainText(null, text);            setPrimaryClip(method, manager, clipData);        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            Ln.e("Could not invoke method", e);        }    }}
    public boolean setText(CharSequence text) {        try {            Method method = getSetPrimaryClipMethod();            ClipData clipData = ClipData.newPlainText(null, text);            setPrimaryClip(method, manager, clipData);            return true;        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            Ln.e("Could not invoke method", e);            return false;        }    }}
    public static void setDisplayPowerMode(IBinder displayToken, int mode) {        try {            Method method = getSetDisplayPowerModeMethod();            method.invoke(null, displayToken, mode);        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            Ln.e("Could not invoke method", e);        }    }
    public static boolean setDisplayPowerMode(IBinder displayToken, int mode) {        try {            Method method = getSetDisplayPowerModeMethod();            method.invoke(null, displayToken, mode);            return true;        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            Ln.e("Could not invoke method", e);            return false;        }    }
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    --no-key-repeat\n"        "        Do not forward repeated key events when a key is held down.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    --shortcut-mod key[+...]][,...]\n"        "        Specify the modifiers to use for scrcpy shortcuts.\n"        "        Possible keys are \"lctrl\", \"rctrl\", \"lalt\", \"ralt\",\n"        "        \"lsuper\" and \"rsuper\".\n"        "\n"        "        A shortcut can consist in several keys, separated by '+'.\n"        "        Several shortcuts can be specified, separated by ','.\n"        "\n"        "        For example, to use either LCtrl+LAlt or LSuper for scrcpy\n"        "        shortcuts, pass \"lctrl+lalt,lsuper\".\n"        "\n"        "        Default is \"lalt,lsuper\" (left-Alt or left-Super).\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    In the following list, MOD is the shortcut modifier. By default,\n"        "    it's (left) Alt or (left) Super, but it can be configured by\n"        "    --shortcut-mod (see above).\n"        "\n"        "    MOD+f\n"        "        Switch fullscreen mode\n"        "\n"        "    MOD+Left\n"        "        Rotate display left\n"        "\n"        "    MOD+Right\n"        "        Rotate display right\n"        "\n"        "    MOD+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    MOD+w\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    MOD+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    MOD+b\n"        "    MOD+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    MOD+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    MOD+m\n"        "        Click on MENU\n"        "\n"        "    MOD+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    MOD+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    MOD+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    MOD+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    MOD+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    MOD+r\n"        "        Rotate device screen\n"        "\n"        "    MOD+n\n"        "        Expand notification panel\n"        "\n"        "    MOD+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    MOD+c\n"        "        Copy to clipboard (inject COPY keycode, Android >= 7 only)\n"        "\n"        "    MOD+x\n"        "        Cut to clipboard (inject CUT keycode, Android >= 7 only)\n"        "\n"        "    MOD+v\n"        "        Copy computer clipboard to device, then paste (inject PASTE\n"        "        keycode, Android >= 7 only)\n"        "\n"        "    MOD+Shift+v\n"        "        Inject computer clipboard text as a sequence of key events\n"        "\n"        "    MOD+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Ctrl+click-and-move\n"        "        Pinch-to-zoom from the center of the screen\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"codec-options",          required_argument, NULL, OPT_CODEC_OPTIONS},        {"crop",                   required_argument, NULL, OPT_CROP},        {"disable-screensaver",    no_argument,       NULL,                                                  OPT_DISABLE_SCREENSAVER},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"force-adb-forward",      no_argument,       NULL,                                                  OPT_FORCE_ADB_FORWARD},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"no-key-repeat",          no_argument,       NULL, OPT_NO_KEY_REPEAT},        {"port",                   required_argument, NULL, 'p'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"shortcut-mod",           required_argument, NULL, OPT_SHORTCUT_MOD},        {"show-touches",           no_argument,       NULL, 't'},        {"stay-awake",             no_argument,       NULL, 'w'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"verbosity",              required_argument, NULL, 'V'},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTvV:w",                            long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case 'V':                if (!parse_log_level(optarg, &opts->log_level)) {                    return false;                }                break;            case 'w':                opts->stay_awake = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            case OPT_NO_KEY_REPEAT:                opts->forward_key_repeat = false;                break;            case OPT_CODEC_OPTIONS:                opts->codec_options = optarg;                break;            case OPT_FORCE_ADB_FORWARD:                opts->force_adb_forward = true;                break;            case OPT_DISABLE_SCREENSAVER:                opts->disable_screensaver = true;                break;            case OPT_SHORTCUT_MOD:                if (!parse_shortcut_mods(optarg, &opts->shortcut_mods)) {                    return false;                }                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    if (!opts->control && opts->stay_awake) {        LOGE("Could not request to stay awake if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-key-repeat\n"        "        Do not forward repeated key events when a key is held down.\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    --shortcut-mod key[+...]][,...]\n"        "        Specify the modifiers to use for scrcpy shortcuts.\n"        "        Possible keys are \"lctrl\", \"rctrl\", \"lalt\", \"ralt\",\n"        "        \"lsuper\" and \"rsuper\".\n"        "\n"        "        A shortcut can consist in several keys, separated by '+'.\n"        "        Several shortcuts can be specified, separated by ','.\n"        "\n"        "        For example, to use either LCtrl+LAlt or LSuper for scrcpy\n"        "        shortcuts, pass \"lctrl+lalt,lsuper\".\n"        "\n"        "        Default is \"lalt,lsuper\" (left-Alt or left-Super).\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    In the following list, MOD is the shortcut modifier. By default,\n"        "    it's (left) Alt or (left) Super, but it can be configured by\n"        "    --shortcut-mod (see above).\n"        "\n"        "    MOD+f\n"        "        Switch fullscreen mode\n"        "\n"        "    MOD+Left\n"        "        Rotate display left\n"        "\n"        "    MOD+Right\n"        "        Rotate display right\n"        "\n"        "    MOD+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    MOD+w\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    MOD+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    MOD+b\n"        "    MOD+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    MOD+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    MOD+m\n"        "        Click on MENU\n"        "\n"        "    MOD+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    MOD+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    MOD+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    MOD+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    MOD+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    MOD+r\n"        "        Rotate device screen\n"        "\n"        "    MOD+n\n"        "        Expand notification panel\n"        "\n"        "    MOD+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    MOD+c\n"        "        Copy to clipboard (inject COPY keycode, Android >= 7 only)\n"        "\n"        "    MOD+x\n"        "        Cut to clipboard (inject CUT keycode, Android >= 7 only)\n"        "\n"        "    MOD+v\n"        "        Copy computer clipboard to device, then paste (inject PASTE\n"        "        keycode, Android >= 7 only)\n"        "\n"        "    MOD+Shift+v\n"        "        Inject computer clipboard text as a sequence of key events\n"        "\n"        "    MOD+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Ctrl+click-and-move\n"        "        Pinch-to-zoom from the center of the screen\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"codec-options",          required_argument, NULL, OPT_CODEC_OPTIONS},        {"crop",                   required_argument, NULL, OPT_CROP},        {"disable-screensaver",    no_argument,       NULL,                                                  OPT_DISABLE_SCREENSAVER},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"force-adb-forward",      no_argument,       NULL,                                                  OPT_FORCE_ADB_FORWARD},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-key-repeat",          no_argument,       NULL, OPT_NO_KEY_REPEAT},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"port",                   required_argument, NULL, 'p'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"shortcut-mod",           required_argument, NULL, OPT_SHORTCUT_MOD},        {"show-touches",           no_argument,       NULL, 't'},        {"stay-awake",             no_argument,       NULL, 'w'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"verbosity",              required_argument, NULL, 'V'},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTvV:w",                            long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case 'V':                if (!parse_log_level(optarg, &opts->log_level)) {                    return false;                }                break;            case 'w':                opts->stay_awake = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            case OPT_NO_KEY_REPEAT:                opts->forward_key_repeat = false;                break;            case OPT_CODEC_OPTIONS:                opts->codec_options = optarg;                break;            case OPT_FORCE_ADB_FORWARD:                opts->force_adb_forward = true;                break;            case OPT_DISABLE_SCREENSAVER:                opts->disable_screensaver = true;                break;            case OPT_SHORTCUT_MOD:                if (!parse_shortcut_mods(optarg, &opts->shortcut_mods)) {                    return false;                }                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    if (!opts->control && opts->stay_awake) {        LOGE("Could not request to stay awake if control is disabled");        return false;    }    return true;}
    public static ControlMessage createSetClipboard(String text, boolean paste) {        ControlMessage msg = new ControlMessage();        msg.type = TYPE_SET_CLIPBOARD;        msg.text = text;        if (paste) {            msg.flags = FLAGS_PASTE;        }        return msg;    }
    public int getFlags() {        return flags;    }
    public int getFlags() {        return flags;    }
    public static ControlMessage createSetClipboard(String text, boolean paste) {        ControlMessage msg = new ControlMessage();        msg.type = TYPE_SET_CLIPBOARD;        msg.text = text;        msg.paste = paste;        return msg;    }
    public int getRepeat() {        return repeat;    }}
    public boolean getPaste() {        return paste;    }
    private ControlMessage parseSetClipboard() {        if (buffer.remaining() < SET_CLIPBOARD_FIXED_PAYLOAD_LENGTH) {            return null;        }        boolean parse = buffer.get() != 0;        String text = parseString();        if (text == null) {            return null;        }        return ControlMessage.createSetClipboard(text, parse);    }
    private ControlMessage parseSetClipboard() {        if (buffer.remaining() < SET_CLIPBOARD_FIXED_PAYLOAD_LENGTH) {            return null;        }        boolean paste = buffer.get() != 0;        String text = parseString();        if (text == null) {            return null;        }        return ControlMessage.createSetClipboard(text, paste);    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                if (device.supportsInputEvents()) {                    injectKeycode(msg.getAction(), msg.getKeycode(), msg.getRepeat(), msg.getMetaState());                }                break;            case ControlMessage.TYPE_INJECT_TEXT:                if (device.supportsInputEvents()) {                    injectText(msg.getText());                }                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                if (device.supportsInputEvents()) {                    injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), msg.getButtons());                }                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                if (device.supportsInputEvents()) {                    injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                }                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                if (device.supportsInputEvents()) {                    pressBackOrTurnScreenOn();                }                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                if (clipboardText != null) {                    sender.pushClipboardText(clipboardText);                }                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                boolean paste = (msg.getFlags() & ControlMessage.FLAGS_PASTE) != 0;                setClipboard(msg.getText(), paste);                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                if (device.supportsInputEvents()) {                    int mode = msg.getAction();                    boolean setPowerModeOk = Device.setScreenPowerMode(mode);                    if (setPowerModeOk) {                        Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));                    }                }                break;            case ControlMessage.TYPE_ROTATE_DEVICE:                device.rotateDevice();                break;            default:                // do nothing        }    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                if (device.supportsInputEvents()) {                    injectKeycode(msg.getAction(), msg.getKeycode(), msg.getRepeat(), msg.getMetaState());                }                break;            case ControlMessage.TYPE_INJECT_TEXT:                if (device.supportsInputEvents()) {                    injectText(msg.getText());                }                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                if (device.supportsInputEvents()) {                    injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), msg.getButtons());                }                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                if (device.supportsInputEvents()) {                    injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                }                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                if (device.supportsInputEvents()) {                    pressBackOrTurnScreenOn();                }                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                if (clipboardText != null) {                    sender.pushClipboardText(clipboardText);                }                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                setClipboard(msg.getText(), msg.getPaste());                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                if (device.supportsInputEvents()) {                    int mode = msg.getAction();                    boolean setPowerModeOk = Device.setScreenPowerMode(mode);                    if (setPowerModeOk) {                        Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));                    }                }                break;            case ControlMessage.TYPE_ROTATE_DEVICE:                device.rotateDevice();                break;            default:                // do nothing        }    }
    public void testParseSetClipboardEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_SET_CLIPBOARD);        dos.writeByte(1); // paste        byte[] text = "testé".getBytes(StandardCharsets.UTF_8);        dos.writeInt(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_SET_CLIPBOARD, event.getType());        Assert.assertEquals("testé", event.getText());        boolean parse = (event.getFlags() & ControlMessage.FLAGS_PASTE) != 0;        Assert.assertTrue(parse);    }
    public void testParseBigSetClipboardEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_SET_CLIPBOARD);        byte[] rawText = new byte[ControlMessageReader.CLIPBOARD_TEXT_MAX_LENGTH];        dos.writeByte(1); // paste        Arrays.fill(rawText, (byte) 'a');        String text = new String(rawText, 0, rawText.length);        dos.writeInt(rawText.length);        dos.write(rawText);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_SET_CLIPBOARD, event.getType());        Assert.assertEquals(text, event.getText());        boolean parse = (event.getFlags() & ControlMessage.FLAGS_PASTE) != 0;        Assert.assertTrue(parse);    }
    public void testParseSetClipboardEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_SET_CLIPBOARD);        dos.writeByte(1); // paste        byte[] text = "testé".getBytes(StandardCharsets.UTF_8);        dos.writeInt(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_SET_CLIPBOARD, event.getType());        Assert.assertEquals("testé", event.getText());        Assert.assertTrue(event.getPaste());    }
    public void testParseBigSetClipboardEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_SET_CLIPBOARD);        byte[] rawText = new byte[ControlMessageReader.CLIPBOARD_TEXT_MAX_LENGTH];        dos.writeByte(1); // paste        Arrays.fill(rawText, (byte) 'a');        String text = new String(rawText, 0, rawText.length);        dos.writeInt(rawText.length);        dos.write(rawText);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_SET_CLIPBOARD, event.getType());        Assert.assertEquals(text, event.getText());        Assert.assertTrue(event.getPaste());    }
convert_mouse_motion(const SDL_MouseMotionEvent *from, struct screen *screen,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    to->inject_touch_event.action = AMOTION_EVENT_ACTION_MOVE;    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen->frame_size;    to->inject_touch_event.position.point =        screen_convert_to_frame_coords(screen, from->x, from->y);    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons = convert_mouse_buttons(from->state);    return true;}
convert_mouse_button(const SDL_MouseButtonEvent *from, struct screen *screen,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_mouse_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen->frame_size;    to->inject_touch_event.position.point =        screen_convert_to_frame_coords(screen, from->x, from->y);    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons =        convert_mouse_buttons(SDL_BUTTON(from->button));    return true;}
convert_touch(const SDL_TouchFingerEvent *from, struct screen *screen,              struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_touch_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = from->fingerId;    to->inject_touch_event.position.screen_size = screen->frame_size;    int ww;    int wh;    SDL_GL_GetDrawableSize(screen->window, &ww, &wh);    // SDL touch event coordinates are normalized in the range [0; 1]    int32_t x = from->x * ww;    int32_t y = from->y * wh;    to->inject_touch_event.position.point =        screen_convert_to_frame_coords(screen, x, y);    to->inject_touch_event.pressure = from->pressure;    to->inject_touch_event.buttons = 0;    return true;}
convert_mouse_wheel(const SDL_MouseWheelEvent *from, struct screen *screen,                    struct control_msg *to) {    // mouse_x and mouse_y are expressed in pixels relative to the window    int mouse_x;    int mouse_y;    SDL_GetMouseState(&mouse_x, &mouse_y);    struct position position = {        .screen_size = screen->frame_size,        .point = screen_convert_to_frame_coords(screen, mouse_x, mouse_y),    };    to->type = CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT;    to->inject_scroll_event.position = position;    to->inject_scroll_event.hscroll = from->x;    to->inject_scroll_event.vscroll = from->y;    return true;}
convert_mouse_motion(const SDL_MouseMotionEvent *from, struct screen *screen,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    to->inject_touch_event.action = AMOTION_EVENT_ACTION_MOVE;    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen->frame_size;    to->inject_touch_event.position.point =        screen_convert_window_to_frame_coords(screen, from->x, from->y);    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons = convert_mouse_buttons(from->state);    return true;}
convert_mouse_button(const SDL_MouseButtonEvent *from, struct screen *screen,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_mouse_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen->frame_size;    to->inject_touch_event.position.point =        screen_convert_window_to_frame_coords(screen, from->x, from->y);    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons =        convert_mouse_buttons(SDL_BUTTON(from->button));    return true;}
convert_touch(const SDL_TouchFingerEvent *from, struct screen *screen,              struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_touch_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = from->fingerId;    to->inject_touch_event.position.screen_size = screen->frame_size;    int dw;    int dh;    SDL_GL_GetDrawableSize(screen->window, &dw, &dh);    // SDL touch event coordinates are normalized in the range [0; 1]    int32_t x = from->x * dw;    int32_t y = from->y * dh;    to->inject_touch_event.position.point =        screen_convert_drawable_to_frame_coords(screen, x, y);    to->inject_touch_event.pressure = from->pressure;    to->inject_touch_event.buttons = 0;    return true;}
convert_mouse_wheel(const SDL_MouseWheelEvent *from, struct screen *screen,                    struct control_msg *to) {    // mouse_x and mouse_y are expressed in pixels relative to the window    int mouse_x;    int mouse_y;    SDL_GetMouseState(&mouse_x, &mouse_y);    struct position position = {        .screen_size = screen->frame_size,        .point = screen_convert_window_to_frame_coords(screen,                                                       mouse_x, mouse_y),    };    to->type = CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT;    to->inject_scroll_event.position = position;    to->inject_scroll_event.hscroll = from->x;    to->inject_scroll_event.vscroll = from->y;    return true;}
        case SDL_WINDOWEVENT_RESTORED:            if (screen->fullscreen) {                // On Windows, in maximized+fullscreen, disabling fullscreen                // mode unexpectedly triggers the "restored" then "maximized"                // events, leaving the window in a weird state (maximized                // according to the events, but not maximized visually).                break;            }            screen->maximized = false;            apply_pending_resize(screen);            break;    }}struct pointscreen_convert_to_frame_coords(struct screen *screen, int32_t x, int32_t y) {    unsigned rotation = screen->rotation;    assert(rotation < 4);    int32_t w = screen->content_size.width;    int32_t h = screen->content_size.height;
        case SDL_WINDOWEVENT_RESTORED:            if (screen->fullscreen) {                // On Windows, in maximized+fullscreen, disabling fullscreen                // mode unexpectedly triggers the "restored" then "maximized"                // events, leaving the window in a weird state (maximized                // according to the events, but not maximized visually).                break;            }            screen->maximized = false;            apply_pending_resize(screen);            break;    }}struct pointscreen_convert_to_frame_coords(struct screen *screen, int32_t x, int32_t y) {    unsigned rotation = screen->rotation;    assert(rotation < 4);    int32_t w = screen->content_size.width;    int32_t h = screen->content_size.height;
screen_convert_to_frame_coords(struct screen *screen, int32_t x, int32_t y) {    unsigned rotation = screen->rotation;    assert(rotation < 4);    int32_t w = screen->content_size.width;    int32_t h = screen->content_size.height;    screen_hidpi_scale_coords(screen, &x, &y);    x = (int64_t) (x - screen->rect.x) * w / screen->rect.w;    y = (int64_t) (y - screen->rect.y) * h / screen->rect.h;    // rotate    struct point result;    switch (rotation) {        case 0:            result.x = x;            result.y = y;            break;        case 1:            result.x = h - y;            result.y = x;            break;        case 2:            result.x = w - x;            result.y = h - y;            break;        default:            assert(rotation == 3);            result.x = y;            result.y = w - x;            break;    }    return result;}
screen_convert_window_to_frame_coords(struct screen *screen,                                      int32_t x, int32_t y) {    screen_hidpi_scale_coords(screen, &x, &y);    return screen_convert_drawable_to_frame_coords(screen, x, y);}
screen_convert_drawable_to_frame_coords(struct screen *screen,                                        int32_t x, int32_t y) {    unsigned rotation = screen->rotation;    assert(rotation < 4);    int32_t w = screen->content_size.width;    int32_t h = screen->content_size.height;    x = (int64_t) (x - screen->rect.x) * w / screen->rect.w;    y = (int64_t) (y - screen->rect.y) * h / screen->rect.h;    // rotate    struct point result;    switch (rotation) {        case 0:            result.x = x;            result.y = y;            break;        case 1:            result.x = h - y;            result.y = x;            break;        case 2:            result.x = w - x;            result.y = h - y;            break;        default:            assert(rotation == 3);            result.x = y;            result.y = w - x;            break;    }    return result;}
screen_convert_drawable_to_frame_coords(struct screen *screen,                                        int32_t x, int32_t y) {    unsigned rotation = screen->rotation;    assert(rotation < 4);    int32_t w = screen->content_size.width;    int32_t h = screen->content_size.height;    x = (int64_t) (x - screen->rect.x) * w / screen->rect.w;    y = (int64_t) (y - screen->rect.y) * h / screen->rect.h;    // rotate    struct point result;    switch (rotation) {        case 0:            result.x = x;            result.y = y;            break;        case 1:            result.x = h - y;            result.y = x;            break;        case 2:            result.x = w - x;            result.y = h - y;            break;        default:            assert(rotation == 3);            result.x = y;            result.y = w - x;            break;    }    return result;}
        int displayInfoFlags = displayInfo.getFlags();        screenInfo = ScreenInfo.computeScreenInfo(displayInfo, options.getCrop(), options.getMaxSize(), options.getLockedVideoOrientation());        layerStack = displayInfo.getLayerStack();        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    screenInfo = screenInfo.withDeviceRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        }, displayId);        if ((displayInfoFlags & DisplayInfo.FLAG_SUPPORTS_PROTECTED_BUFFERS) == 0) {            Ln.w("Display doesn't have FLAG_SUPPORTS_PROTECTED_BUFFERS flag, mirroring can be restricted");        }        // main display or any display on Android >= Q        supportsInputEvents = displayId == 0 || Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q;        if (!supportsInputEvents) {            Ln.w("Input events are not supported for secondary displays before Android 10");        }    }    public synchronized ScreenInfo getScreenInfo() {        return screenInfo;    }    public int getLayerStack() {        return layerStack;    }    public Point getPhysicalPoint(Position position) {
    public ContentProvider createSettingsProvider() {        return serviceManager.getActivityManager().createSettingsProvider();    }}
        }        return displayManager;    }    public InputManager getInputManager() {        if (inputManager == null) {            inputManager = new InputManager(getService("input", "android.hardware.input.IInputManager"));        }        return inputManager;    }    public PowerManager getPowerManager() {        if (powerManager == null) {            powerManager = new PowerManager(getService("power", "android.os.IPowerManager"));        }        return powerManager;    }    public StatusBarManager getStatusBarManager() {        if (statusBarManager == null) {            statusBarManager = new StatusBarManager(getService("statusbar", "com.android.internal.statusbar.IStatusBarService"));        }        return statusBarManager;    }    public ClipboardManager getClipboardManager() {        if (clipboardManager == null) {            clipboardManager = new ClipboardManager(getService("clipboard", "android.content.IClipboard"));        }        return clipboardManager;    }}
    public ActivityManager getActivityManager() {        if (activityManager == null) {            try {                // On old Android versions, the ActivityManager is not exposed via AIDL,                // so use ActivityManagerNative.getDefault()                Class<?> cls = Class.forName("android.app.ActivityManagerNative");                Method getDefaultMethod = cls.getDeclaredMethod("getDefault");                IInterface am = (IInterface) getDefaultMethod.invoke(null);                activityManager = new ActivityManager(am);            } catch (Exception e) {                throw new AssertionError(e);            }        }        return activityManager;    }}
BOOL windows_ctrl_handler(DWORD ctrl_type) {    if (ctrl_type == CTRL_C_EVENT) {        SDL_Event event;        event.type = SDL_QUIT;        SDL_PushEvent(&event);        return TRUE;    }    return FALSE;}#endif // _WIN32
BOOL WINAPI windows_ctrl_handler(DWORD ctrl_type) {    if (ctrl_type == CTRL_C_EVENT) {        SDL_Event event;        event.type = SDL_QUIT;        SDL_PushEvent(&event);        return TRUE;    }    return FALSE;}#endif // _WIN32
rotate_position(struct screen *screen, int32_t x, int32_t y) {    unsigned rotation = screen->rotation;    assert(rotation < 4);    int32_t w = screen->content_size.width;    int32_t h = screen->content_size.height;    struct point result;    switch (rotation) {        case 0:            result.x = x;            result.y = y;            break;        case 1:            result.x = h - y;            result.y = x;            break;        case 2:            result.x = w - x;            result.y = h - y;            break;        case 3:            result.x = y;            result.y = w - x;            break;        default:            assert(!"Unreachable");    }    return result;}
rotate_position(struct screen *screen, int32_t x, int32_t y) {    unsigned rotation = screen->rotation;    assert(rotation < 4);    int32_t w = screen->content_size.width;    int32_t h = screen->content_size.height;    struct point result;    switch (rotation) {        case 0:            result.x = x;            result.y = y;            break;        case 1:            result.x = h - y;            result.y = x;            break;        case 2:            result.x = w - x;            result.y = h - y;            break;        default:            assert(rotation == 3);            result.x = y;            result.y = w - x;            break;    }    return result;}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"crop",                   required_argument, NULL, OPT_CROP},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"port",                   required_argument, NULL, 'p'},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"crop",                   required_argument, NULL, OPT_CROP},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"port",                   required_argument, NULL, 'p'},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
sdl_init_and_configure(bool display) {    uint32_t flags = display ? SDL_INIT_VIDEO : SDL_INIT_EVENTS;    if (SDL_Init(flags)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return false;    }    atexit(SDL_Quit);    if (!display) {        return true;    }    // Linear filtering    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        LOGW("Could not enable linear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif#ifdef SCRCPY_SDL_HAS_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR    // Disable compositor bypassing on X11    if (!SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, "0")) {        LOGW("Could not disable X11 compositor bypass");    }#endif    // Do not minimize on focus loss    if (!SDL_SetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, "0")) {        LOGW("Could not disable minimize on focus loss");    }    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return true;}
sdl_init_and_configure(bool display) {    uint32_t flags = display ? SDL_INIT_VIDEO : SDL_INIT_EVENTS;    if (SDL_Init(flags)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return false;    }    atexit(SDL_Quit);    if (!display) {        return true;    }    // Linear filtering    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        LOGW("Could not enable linear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif#ifdef SCRCPY_SDL_HAS_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR    // Disable compositor bypassing on X11    if (!SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, "0")) {        LOGW("Could not disable X11 compositor bypass");    }#endif    // Do not minimize on focus loss    if (!SDL_SetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, "0")) {        LOGW("Could not disable minimize on focus loss");    }    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return true;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
sdl_init_and_configure(bool display, const char *render_driver) {    uint32_t flags = display ? SDL_INIT_VIDEO : SDL_INIT_EVENTS;    if (SDL_Init(flags)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return false;    }    atexit(SDL_Quit);    if (!display) {        return true;    }    if (render_driver && !SDL_SetHint(SDL_HINT_RENDER_DRIVER, render_driver)) {        LOGW("Could not set render driver");    }    // Linear filtering    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        LOGW("Could not enable linear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif#ifdef SCRCPY_SDL_HAS_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR    // Disable compositor bypassing on X11    if (!SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, "0")) {        LOGW("Could not disable X11 compositor bypass");    }#endif    // Do not minimize on focus loss    if (!SDL_SetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, "0")) {        LOGW("Could not disable minimize on focus loss");    }    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();
sdl_init_and_configure(bool display, const char *render_driver) {    uint32_t flags = display ? SDL_INIT_VIDEO : SDL_INIT_EVENTS;    if (SDL_Init(flags)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return false;    }    atexit(SDL_Quit);    if (!display) {        return true;    }    if (render_driver && !SDL_SetHint(SDL_HINT_RENDER_DRIVER, render_driver)) {        LOGW("Could not set render driver");    }    // Linear filtering    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        LOGW("Could not enable linear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif#ifdef SCRCPY_SDL_HAS_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR    // Disable compositor bypassing on X11    if (!SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, "0")) {        LOGW("Could not disable X11 compositor bypass");    }#endif    // Do not minimize on focus loss    if (!SDL_SetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, "0")) {        LOGW("Could not disable minimize on focus loss");    }    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return true;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size = get_rotated_size(frame_size, screen->rotation);    screen->content_size = content_size;    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, content_size.width,                                 content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size = get_rotated_size(frame_size, screen->rotation);    screen->content_size = content_size;    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_RendererInfo renderer_info;    int r = SDL_GetRendererInfo(screen->renderer, &renderer_info);    const char *renderer_name = r ? NULL : renderer_info.name;    LOGI("Renderer: %s", renderer_name ? renderer_name : "(unknown)");    if (SDL_RenderSetLogicalSize(screen->renderer, content_size.width,                                 content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
    private static Options createOptions(String... args) {        if (args.length < 1) {            throw new IllegalArgumentException("Missing client version");        }        String clientVersion = args[0];        if (!clientVersion.equals(BuildConfig.VERSION_NAME)) {            throw new IllegalArgumentException(                    "The server version (" + clientVersion + ") does not match the client " + "(" + BuildConfig.VERSION_NAME + ")");        }        if (args.length != 9) {            throw new IllegalArgumentException("Expecting 9 parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[1]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[2]);        options.setBitRate(bitRate);        int maxFps = Integer.parseInt(args[3]);        options.setMaxFps(maxFps);        int lockedVideoOrientation = Integer.parseInt(args[4]);        options.setLockedVideoOrientation(lockedVideoOrientation);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[5]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[6]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[7]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[8]);        options.setControl(control);        return options;    }
    private static Options createOptions(String... args) {        if (args.length < 1) {            throw new IllegalArgumentException("Missing client version");        }        String clientVersion = args[0];        if (!clientVersion.equals(BuildConfig.VERSION_NAME)) {            throw new IllegalArgumentException(                    "The server version (" + BuildConfig.VERSION_NAME + ") does not match the client " + "(" + clientVersion + ")");        }        if (args.length != 9) {            throw new IllegalArgumentException("Expecting 9 parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[1]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[2]);        options.setBitRate(bitRate);        int maxFps = Integer.parseInt(args[3]);        options.setMaxFps(maxFps);        int lockedVideoOrientation = Integer.parseInt(args[4]);        options.setLockedVideoOrientation(lockedVideoOrientation);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[5]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[6]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[7]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[8]);        options.setControl(control);        return options;    }
screen_switch_fullscreen(struct screen *screen) {    if (!screen->fullscreen) {        // going to fullscreen, store the current windowed window size        screen->windowed_window_size = get_window_size(screen->window);    }    uint32_t new_mode = screen->fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;    if (SDL_SetWindowFullscreen(screen->window, new_mode)) {        LOGW("Could not switch fullscreen mode: %s", SDL_GetError());        return;    }    screen->fullscreen = !screen->fullscreen;    if (!screen->fullscreen) {        // fullscreen disabled, restore expected windowed window size        SDL_SetWindowSize(screen->window, screen->windowed_window_size.width,                          screen->windowed_window_size.height);    }    LOGD("Switched to %s mode", screen->fullscreen ? "fullscreen" : "windowed");    screen_render(screen);}
get_windowed_window_size(const struct screen *screen) {    if (screen->fullscreen) {        return screen->windowed_window_size;    }    return get_window_size(screen->window);}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    screen->window = SDL_CreateWindow(window_title, SDL_WINDOWPOS_UNDEFINED,                                      SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    return true;}
screen_handle_window_event(struct screen *screen,                           const SDL_WindowEvent *event) {    switch (event->event) {        case SDL_WINDOWEVENT_EXPOSED:        case SDL_WINDOWEVENT_SIZE_CHANGED:            screen_render(screen);            break;    }}
screen_resize_to_fit(struct screen *screen) {    if (!screen->fullscreen) {        struct size optimal_size = get_optimal_window_size(screen,                                                           screen->frame_size);        SDL_SetWindowSize(screen->window, optimal_size.width,                          optimal_size.height);        LOGD("Resized to optimal size");    }}
screen_resize_to_fit(struct screen *screen) {    if (!screen->fullscreen) {        struct size optimal_size = get_optimal_window_size(screen,                                                           screen->frame_size);        SDL_SetWindowSize(screen->window, optimal_size.width,                          optimal_size.height);        LOGD("Resized to optimal size");    }}
set_window_size(struct screen *screen, struct size new_size) {    // setting the window size during fullscreen is implementation defined,    // so apply the resize only after fullscreen is disabled    if (screen->fullscreen) {        // SDL_SetWindowSize will be called when fullscreen will be disabled        screen->windowed_window_size = new_size;    } else {        SDL_SetWindowSize(screen->window, new_size.width, new_size.height);    }}
screen_resize_to_pixel_perfect(struct screen *screen) {    if (!screen->fullscreen) {        SDL_SetWindowSize(screen->window, screen->frame_size.width,                          screen->frame_size.height);        LOGD("Resized to pixel-perfect");    }}
screen_switch_fullscreen(struct screen *screen) {    uint32_t new_mode = screen->fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;    if (SDL_SetWindowFullscreen(screen->window, new_mode)) {        LOGW("Could not switch fullscreen mode: %s", SDL_GetError());        return;    }    screen->fullscreen = !screen->fullscreen;    apply_windowed_size(screen);    LOGD("Switched to %s mode", screen->fullscreen ? "fullscreen" : "windowed");    screen_render(screen);}
get_windowed_window_size(const struct screen *screen) {    if (screen->fullscreen || screen->maximized) {        return screen->windowed_window_size;    }    return get_window_size(screen->window);}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    screen->window = SDL_CreateWindow(window_title, SDL_WINDOWPOS_UNDEFINED,                                      SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
screen_handle_window_event(struct screen *screen,                           const SDL_WindowEvent *event) {    switch (event->event) {        case SDL_WINDOWEVENT_EXPOSED:            screen_render(screen);            break;        case SDL_WINDOWEVENT_SIZE_CHANGED:            if (!screen->fullscreen && !screen->maximized) {                // Backup the previous size: if we receive the MAXIMIZED event,                // then the new size must be ignored (it's the maximized size).                // We could not rely on the window flags due to race conditions                // (they could be updated asynchronously, at least on X11).                screen->windowed_window_size_backup =                    screen->windowed_window_size;                // Save the windowed size, so that it is available once the                // window is maximized or fullscreen is enabled.                screen->windowed_window_size = get_window_size(screen->window);            }            screen_render(screen);            break;        case SDL_WINDOWEVENT_MAXIMIZED:            // The backup size must be non-nul.            SDL_assert(screen->windowed_window_size_backup.width);            SDL_assert(screen->windowed_window_size_backup.height);            // Revert the last size, it was updated while screen was maximized.            screen->windowed_window_size = screen->windowed_window_size_backup;#ifdef DEBUG            // Reset the backup to invalid values to detect unexpected usage            screen->windowed_window_size_backup.width = 0;            screen->windowed_window_size_backup.height = 0;#endif            screen->maximized = true;            break;        case SDL_WINDOWEVENT_RESTORED:            screen->maximized = false;            apply_windowed_size(screen);            break;    }}
screen_resize_to_fit(struct screen *screen) {    if (!screen->fullscreen && !screen->maximized) {        struct size optimal_size = get_optimal_window_size(screen,                                                           screen->frame_size);        SDL_SetWindowSize(screen->window, optimal_size.width,                          optimal_size.height);        LOGD("Resized to optimal size");    }}
apply_windowed_size(struct screen *screen) {    if (!screen->fullscreen && !screen->maximized) {        SDL_SetWindowSize(screen->window, screen->windowed_window_size.width,                                          screen->windowed_window_size.height);    }}
set_window_size(struct screen *screen, struct size new_size) {    // setting the window size during fullscreen is implementation defined,    // so apply the resize only after fullscreen is disabled    screen->windowed_window_size = new_size;    apply_windowed_size(screen);}
screen_resize_to_pixel_perfect(struct screen *screen) {    if (!screen->fullscreen && !screen->maximized) {        SDL_SetWindowSize(screen->window, screen->frame_size.width,                          screen->frame_size.height);        LOGD("Resized to pixel-perfect");    }}
event_watcher(void *data, SDL_Event *event) {    (void) data;    if (event->type == SDL_WINDOWEVENT            && event->window.event == SDL_WINDOWEVENT_RESIZED) {        // called from another thread, not very safe, but it's a workaround!        screen_render(&screen);    }    return 0;}#endif
event_watcher(void *data, SDL_Event *event) {    (void) data;    if (event->type == SDL_WINDOWEVENT            && event->window.event == SDL_WINDOWEVENT_SIZE_CHANGED) {        // In practice, it seems to always be called from the same thread in        // that specific case. Anyway, it's just a workaround.        screen_handle_window_event(&screen, &event->window);    }    return 0;}#endif
process_msg(struct controller *controller,              const struct control_msg *msg) {    unsigned char serialized_msg[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int length = control_msg_serialize(msg, serialized_msg);    if (!length) {        return false;    }    int w = net_send_all(controller->control_socket, serialized_msg, length);    return w == length;}
process_msg(struct controller *controller,              const struct control_msg *msg) {    unsigned char serialized_msg[CONTROL_MSG_MAX_SIZE];    int length = control_msg_serialize(msg, serialized_msg);    if (!length) {        return false;    }    int w = net_send_all(controller->control_socket, serialized_msg, length);    return w == length;}
run_receiver(void *data) {    struct receiver *receiver = data;    unsigned char buf[DEVICE_MSG_SERIALIZED_MAX_SIZE];    size_t head = 0;    for (;;) {        assert(head < DEVICE_MSG_SERIALIZED_MAX_SIZE);        ssize_t r = net_recv(receiver->control_socket, buf,                             DEVICE_MSG_SERIALIZED_MAX_SIZE - head);        if (r <= 0) {            LOGD("Receiver stopped");            break;        }        ssize_t consumed = process_msgs(buf, r);        if (consumed == -1) {            // an error occurred            break;        }        if (consumed) {            // shift the remaining data in the buffer            memmove(buf, &buf[consumed], r - consumed);            head = r - consumed;        }    }    return 0;}
run_receiver(void *data) {    struct receiver *receiver = data;    unsigned char buf[DEVICE_MSG_MAX_SIZE];    size_t head = 0;    for (;;) {        assert(head < DEVICE_MSG_MAX_SIZE);        ssize_t r = net_recv(receiver->control_socket, buf,                             DEVICE_MSG_MAX_SIZE - head);        if (r <= 0) {            LOGD("Receiver stopped");            break;        }        ssize_t consumed = process_msgs(buf, r);        if (consumed == -1) {            // an error occurred            break;        }        if (consumed) {            // shift the remaining data in the buffer            memmove(buf, &buf[consumed], r - consumed);            head = r - consumed;        }    }    return 0;}
static void test_serialize_collapse_notification_panel(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL,    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 1);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL,    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_inject_keycode(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_INJECT_KEYCODE,        .inject_keycode = {            .action = AKEY_EVENT_ACTION_UP,            .keycode = AKEYCODE_ENTER,            .metastate = AMETA_SHIFT_ON | AMETA_SHIFT_LEFT_ON,        },    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 10);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_INJECT_KEYCODE,        0x01, // AKEY_EVENT_ACTION_UP        0x00, 0x00, 0x00, 0x42, // AKEYCODE_ENTER        0x00, 0x00, 0x00, 0x41, // AMETA_SHIFT_ON | AMETA_SHIFT_LEFT_ON    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_expand_notification_panel(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL,    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 1);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL,    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_set_clipboard(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_SET_CLIPBOARD,        .set_clipboard = {            .paste = true,            .text = "hello, world!",        },    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 17);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_SET_CLIPBOARD,        1, // paste        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_rotate_device(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_ROTATE_DEVICE,    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 1);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_ROTATE_DEVICE,    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_inject_touch_event(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT,        .inject_touch_event = {            .action = AMOTION_EVENT_ACTION_DOWN,            .pointer_id = 0x1234567887654321L,            .position = {                .point = {                    .x = 100,                    .y = 200,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },            .pressure = 1.0f,            .buttons = AMOTION_EVENT_BUTTON_PRIMARY,        },    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 28);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT,        0x00, // AKEY_EVENT_ACTION_DOWN        0x12, 0x34, 0x56, 0x78, 0x87, 0x65, 0x43, 0x21, // pointer id        0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0xc8, // 100 200        0x04, 0x38, 0x07, 0x80, // 1080 1920        0xff, 0xff, // pressure        0x00, 0x00, 0x00, 0x01 // AMOTION_EVENT_BUTTON_PRIMARY    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_set_screen_power_mode(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE,        .set_screen_power_mode = {            .mode = SCREEN_POWER_MODE_NORMAL,        },    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 2);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE,        0x02, // SCREEN_POWER_MODE_NORMAL    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_inject_text(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_INJECT_TEXT,        .inject_text = {            .text = "hello, world!",        },    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 16);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_INJECT_TEXT,        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_get_clipboard(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_GET_CLIPBOARD,    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 1);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_GET_CLIPBOARD,    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_inject_text_long(void) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    char text[CONTROL_MSG_INJECT_TEXT_MAX_LENGTH + 1];    memset(text, 'a', sizeof(text));    text[CONTROL_MSG_INJECT_TEXT_MAX_LENGTH] = '\0';    msg.inject_text.text = text;    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 3 + CONTROL_MSG_INJECT_TEXT_MAX_LENGTH);    unsigned char expected[3 + CONTROL_MSG_INJECT_TEXT_MAX_LENGTH];    expected[0] = CONTROL_MSG_TYPE_INJECT_TEXT;    expected[1] = 0x01;    expected[2] = 0x2c; // text length (16 bits)    memset(&expected[3], 'a', CONTROL_MSG_INJECT_TEXT_MAX_LENGTH);    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_inject_scroll_event(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT,        .inject_scroll_event = {            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },            .hscroll = 1,            .vscroll = -1,        },    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 21);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT,        0x00, 0x00, 0x01, 0x04, 0x00, 0x00, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920        0x00, 0x00, 0x00, 0x01, // 1        0xFF, 0xFF, 0xFF, 0xFF, // -1    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_back_or_screen_on(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON,    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 1);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON,    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_collapse_notification_panel(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL,    };    unsigned char buf[CONTROL_MSG_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 1);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL,    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_inject_keycode(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_INJECT_KEYCODE,        .inject_keycode = {            .action = AKEY_EVENT_ACTION_UP,            .keycode = AKEYCODE_ENTER,            .metastate = AMETA_SHIFT_ON | AMETA_SHIFT_LEFT_ON,        },    };    unsigned char buf[CONTROL_MSG_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 10);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_INJECT_KEYCODE,        0x01, // AKEY_EVENT_ACTION_UP        0x00, 0x00, 0x00, 0x42, // AKEYCODE_ENTER        0x00, 0x00, 0x00, 0x41, // AMETA_SHIFT_ON | AMETA_SHIFT_LEFT_ON    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_expand_notification_panel(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL,    };    unsigned char buf[CONTROL_MSG_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 1);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL,    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_set_clipboard(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_SET_CLIPBOARD,        .set_clipboard = {            .paste = true,            .text = "hello, world!",        },    };    unsigned char buf[CONTROL_MSG_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 17);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_SET_CLIPBOARD,        1, // paste        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_rotate_device(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_ROTATE_DEVICE,    };    unsigned char buf[CONTROL_MSG_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 1);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_ROTATE_DEVICE,    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_inject_touch_event(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT,        .inject_touch_event = {            .action = AMOTION_EVENT_ACTION_DOWN,            .pointer_id = 0x1234567887654321L,            .position = {                .point = {                    .x = 100,                    .y = 200,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },            .pressure = 1.0f,            .buttons = AMOTION_EVENT_BUTTON_PRIMARY,        },    };    unsigned char buf[CONTROL_MSG_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 28);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT,        0x00, // AKEY_EVENT_ACTION_DOWN        0x12, 0x34, 0x56, 0x78, 0x87, 0x65, 0x43, 0x21, // pointer id        0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0xc8, // 100 200        0x04, 0x38, 0x07, 0x80, // 1080 1920        0xff, 0xff, // pressure        0x00, 0x00, 0x00, 0x01 // AMOTION_EVENT_BUTTON_PRIMARY    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_set_screen_power_mode(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE,        .set_screen_power_mode = {            .mode = SCREEN_POWER_MODE_NORMAL,        },    };    unsigned char buf[CONTROL_MSG_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 2);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE,        0x02, // SCREEN_POWER_MODE_NORMAL    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_inject_text(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_INJECT_TEXT,        .inject_text = {            .text = "hello, world!",        },    };    unsigned char buf[CONTROL_MSG_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 16);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_INJECT_TEXT,        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_get_clipboard(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_GET_CLIPBOARD,    };    unsigned char buf[CONTROL_MSG_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 1);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_GET_CLIPBOARD,    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_inject_text_long(void) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    char text[CONTROL_MSG_INJECT_TEXT_MAX_LENGTH + 1];    memset(text, 'a', sizeof(text));    text[CONTROL_MSG_INJECT_TEXT_MAX_LENGTH] = '\0';    msg.inject_text.text = text;    unsigned char buf[CONTROL_MSG_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 3 + CONTROL_MSG_INJECT_TEXT_MAX_LENGTH);    unsigned char expected[3 + CONTROL_MSG_INJECT_TEXT_MAX_LENGTH];    expected[0] = CONTROL_MSG_TYPE_INJECT_TEXT;    expected[1] = 0x01;    expected[2] = 0x2c; // text length (16 bits)    memset(&expected[3], 'a', CONTROL_MSG_INJECT_TEXT_MAX_LENGTH);    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_inject_scroll_event(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT,        .inject_scroll_event = {            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },            .hscroll = 1,            .vscroll = -1,        },    };    unsigned char buf[CONTROL_MSG_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 21);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT,        0x00, 0x00, 0x01, 0x04, 0x00, 0x00, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920        0x00, 0x00, 0x00, 0x01, // 1        0xFF, 0xFF, 0xFF, 0xFF, // -1    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_back_or_screen_on(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON,    };    unsigned char buf[CONTROL_MSG_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 1);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON,    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_deserialize_clipboard_big(void) {    unsigned char input[DEVICE_MSG_SERIALIZED_MAX_SIZE];    input[0] = DEVICE_MSG_TYPE_CLIPBOARD;    input[1] = DEVICE_MSG_TEXT_MAX_LENGTH >> 8; // MSB    input[2] = DEVICE_MSG_TEXT_MAX_LENGTH & 0xff; // LSB    memset(input + 3, 'a', DEVICE_MSG_TEXT_MAX_LENGTH);    struct device_msg msg;    ssize_t r = device_msg_deserialize(input, sizeof(input), &msg);    assert(r == DEVICE_MSG_SERIALIZED_MAX_SIZE);    assert(msg.type == DEVICE_MSG_TYPE_CLIPBOARD);    assert(msg.clipboard.text);    assert(strlen(msg.clipboard.text) == DEVICE_MSG_TEXT_MAX_LENGTH);    assert(msg.clipboard.text[0] == 'a');    device_msg_destroy(&msg);}
static void test_deserialize_clipboard_big(void) {    unsigned char input[DEVICE_MSG_MAX_SIZE];    input[0] = DEVICE_MSG_TYPE_CLIPBOARD;    input[1] = DEVICE_MSG_TEXT_MAX_LENGTH >> 8; // MSB    input[2] = DEVICE_MSG_TEXT_MAX_LENGTH & 0xff; // LSB    memset(input + 3, 'a', DEVICE_MSG_TEXT_MAX_LENGTH);    struct device_msg msg;    ssize_t r = device_msg_deserialize(input, sizeof(input), &msg);    assert(r == DEVICE_MSG_MAX_SIZE);    assert(msg.type == DEVICE_MSG_TYPE_CLIPBOARD);    assert(msg.clipboard.text);    assert(strlen(msg.clipboard.text) == DEVICE_MSG_TEXT_MAX_LENGTH);    assert(msg.clipboard.text[0] == 'a');    device_msg_destroy(&msg);}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"crop",                   required_argument, NULL, OPT_CROP},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"port",                   required_argument, NULL, 'p'},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"crop",                   required_argument, NULL, OPT_CROP},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"port",                   required_argument, NULL, 'p'},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
recorder_push(struct recorder *recorder, const AVPacket *packet) {    mutex_lock(recorder->mutex);    assert(!recorder->stopped);    if (recorder->failed) {        // reject any new packet (this will stop the stream)        return false;    }    struct record_packet *rec = record_packet_new(packet);    if (!rec) {        LOGC("Could not allocate record packet");        return false;    }    queue_push(&recorder->queue, next, rec);    cond_signal(recorder->queue_cond);    mutex_unlock(recorder->mutex);    return true;}
recorder_push(struct recorder *recorder, const AVPacket *packet) {    mutex_lock(recorder->mutex);    assert(!recorder->stopped);    if (recorder->failed) {        // reject any new packet (this will stop the stream)        mutex_unlock(recorder->mutex);        return false;    }    struct record_packet *rec = record_packet_new(packet);    if (!rec) {        LOGC("Could not allocate record packet");        mutex_unlock(recorder->mutex);        return false;    }    queue_push(&recorder->queue, next, rec);    cond_signal(recorder->queue_cond);    mutex_unlock(recorder->mutex);    return true;}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"crop",                   required_argument, NULL, OPT_CROP},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"port",                   required_argument, NULL, 'p'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"crop",                   required_argument, NULL, OPT_CROP},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"port",                   required_argument, NULL, 'p'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"stay-awake",             no_argument,       NULL, 'w'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTvw", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case 'w':                opts->stay_awake = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    if (!opts->control && opts->stay_awake) {        LOGE("Could not request to stay awake if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,        .show_touches = options->show_touches,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options-> mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,        .show_touches = options->show_touches,        .stay_awake = options->stay_awake,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options-> mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    server_destroy(&server);    return ret;}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    char max_fps_string[6];    char lock_video_orientation_string[3];    char display_id_string[6];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    sprintf(max_fps_string, "%"PRIu16, params->max_fps);    sprintf(lock_video_orientation_string, "%"PRIi8, params->lock_video_orientation);    sprintf(display_id_string, "%"PRIu16, params->display_id);    const char *const cmd[] = {        "shell",        "CLASSPATH=" DEVICE_SERVER_PATH,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"# ifdef SERVER_DEBUGGER_METHOD_NEW        /* Android 9 and above */        "-XjdwpProvider:internal -XjdwpOptions:transport=dt_socket,suspend=y,server=y,address="# else        /* Android 8 and below */        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="# endif            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,        max_size_string,        bit_rate_string,        max_fps_string,        lock_video_orientation_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",        display_id_string,        params->show_touches ? "true" : "false",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    char max_fps_string[6];    char lock_video_orientation_string[3];    char display_id_string[6];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    sprintf(max_fps_string, "%"PRIu16, params->max_fps);    sprintf(lock_video_orientation_string, "%"PRIi8, params->lock_video_orientation);    sprintf(display_id_string, "%"PRIu16, params->display_id);    const char *const cmd[] = {        "shell",        "CLASSPATH=" DEVICE_SERVER_PATH,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"# ifdef SERVER_DEBUGGER_METHOD_NEW        /* Android 9 and above */        "-XjdwpProvider:internal -XjdwpOptions:transport=dt_socket,suspend=y,server=y,address="# else        /* Android 8 and below */        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="# endif            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,        max_size_string,        bit_rate_string,        max_fps_string,        lock_video_orientation_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",        display_id_string,        params->show_touches ? "true" : "false",        params->stay_awake ? "true" : "false",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
    public static void configure(boolean disableShowTouches) throws IOException {        boolean needProcess = disableShowTouches;        if (needProcess) {            startProcess(disableShowTouches);        } else {            // There is no additional clean up to do when scrcpy dies            unlinkSelf();        }    }
    public static void main(String... args) {        unlinkSelf();        try {            // Wait for the server to die            System.in.read();        } catch (IOException e) {            // Expected when the server is dead        }        Ln.i("Cleaning up");        boolean disableShowTouches = Boolean.parseBoolean(args[0]);        if (disableShowTouches) {            ServiceManager serviceManager = new ServiceManager();            try (ContentProvider settings = serviceManager.getActivityManager().createSettingsProvider()) {                Ln.i("Disabling \"show touches\"");                settings.putValue(ContentProvider.TABLE_SYSTEM, "show_touches", "0");            }        }    }}
    private static void startProcess(boolean disableShowTouches) throws IOException {        String[] cmd = {"app_process", "/", CleanUp.class.getName(), String.valueOf(disableShowTouches)};        ProcessBuilder builder = new ProcessBuilder(cmd);        builder.environment().put("CLASSPATH", SERVER_PATH);        builder.start();    }
    public static void configure(boolean disableShowTouches) throws IOException {        boolean needProcess = disableShowTouches;        if (needProcess) {            startProcess(disableShowTouches);        } else {            // There is no additional clean up to do when scrcpy dies            unlinkSelf();        }    }
    private static void startProcess(boolean disableShowTouches) throws IOException {        String[] cmd = {"app_process", "/", CleanUp.class.getName(), String.valueOf(disableShowTouches)};        ProcessBuilder builder = new ProcessBuilder(cmd);        builder.environment().put("CLASSPATH", SERVER_PATH);        builder.start();    }
    public static void configure(boolean disableShowTouches, int restoreStayOn) throws IOException {        boolean needProcess = disableShowTouches || restoreStayOn != -1;        if (needProcess) {            startProcess(disableShowTouches, restoreStayOn);        } else {            // There is no additional clean up to do when scrcpy dies            unlinkSelf();        }    }
    public static void main(String... args) {        unlinkSelf();        try {            // Wait for the server to die            System.in.read();        } catch (IOException e) {            // Expected when the server is dead        }        Ln.i("Cleaning up");        boolean disableShowTouches = Boolean.parseBoolean(args[0]);        int restoreStayOn = Integer.parseInt(args[1]);        if (disableShowTouches || restoreStayOn != -1) {            ServiceManager serviceManager = new ServiceManager();            try (ContentProvider settings = serviceManager.getActivityManager().createSettingsProvider()) {                if (disableShowTouches) {                    Ln.i("Disabling \"show touches\"");                    settings.putValue(ContentProvider.TABLE_SYSTEM, "show_touches", "0");                }                if (restoreStayOn != -1) {                    Ln.i("Restoring \"stay awake\"");                    settings.putValue(ContentProvider.TABLE_GLOBAL, "stay_on_while_plugged_in", String.valueOf(restoreStayOn));                }            }        }    }}
    private static void startProcess(boolean disableShowTouches, int restoreStayOn) throws IOException {        String[] cmd = {"app_process", "/", CleanUp.class.getName(), String.valueOf(disableShowTouches), String.valueOf(restoreStayOn)};        ProcessBuilder builder = new ProcessBuilder(cmd);        builder.environment().put("CLASSPATH", SERVER_PATH);        builder.start();    }
    public static void configure(boolean disableShowTouches, int restoreStayOn) throws IOException {        boolean needProcess = disableShowTouches || restoreStayOn != -1;        if (needProcess) {            startProcess(disableShowTouches, restoreStayOn);        } else {            // There is no additional clean up to do when scrcpy dies            unlinkSelf();        }    }
    private static void startProcess(boolean disableShowTouches, int restoreStayOn) throws IOException {        String[] cmd = {"app_process", "/", CleanUp.class.getName(), String.valueOf(disableShowTouches), String.valueOf(restoreStayOn)};        ProcessBuilder builder = new ProcessBuilder(cmd);        builder.environment().put("CLASSPATH", SERVER_PATH);        builder.start();    }
    public int getMaxFps() {        return maxFps;    }    public void setMaxFps(int maxFps) {        this.maxFps = maxFps;    }
    public int getMaxFps() {        return maxFps;    }    public void setMaxFps(int maxFps) {        this.maxFps = maxFps;    }
    public boolean getStayAwake() {        return stayAwake;    }
    public void setStayAwake(boolean stayAwake) {        this.stayAwake = stayAwake;    }}
    private static Options createOptions(String... args) {        if (args.length < 1) {            throw new IllegalArgumentException("Missing client version");        }        String clientVersion = args[0];        if (!clientVersion.equals(BuildConfig.VERSION_NAME)) {            throw new IllegalArgumentException(                    "The server version (" + BuildConfig.VERSION_NAME + ") does not match the client " + "(" + clientVersion + ")");        }        final int expectedParameters = 11;        if (args.length != expectedParameters) {            throw new IllegalArgumentException("Expecting " + expectedParameters + " parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[1]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[2]);        options.setBitRate(bitRate);        int maxFps = Integer.parseInt(args[3]);        options.setMaxFps(maxFps);        int lockedVideoOrientation = Integer.parseInt(args[4]);        options.setLockedVideoOrientation(lockedVideoOrientation);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[5]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[6]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[7]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[8]);        options.setControl(control);        int displayId = Integer.parseInt(args[9]);        options.setDisplayId(displayId);        boolean showTouches = Boolean.parseBoolean(args[10]);        options.setShowTouches(showTouches);        return options;    }
    private static void scrcpy(Options options) throws IOException {        Ln.i("Device: " + Build.MANUFACTURER + " " + Build.MODEL + " (Android " + Build.VERSION.RELEASE + ")");        final Device device = new Device(options);        boolean mustDisableShowTouchesOnCleanUp = false;        if (options.getShowTouches()) {            try (ContentProvider settings = device.createSettingsProvider()) {                String oldValue = settings.getAndPutValue(ContentProvider.TABLE_SYSTEM, "show_touches", "1");                // If "show touches" was disabled, it must be disabled back on clean up                mustDisableShowTouchesOnCleanUp = !"1".equals(oldValue);            }        }        CleanUp.configure(mustDisableShowTouchesOnCleanUp);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate(), options.getMaxFps());            if (options.getControl()) {                Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    private static Options createOptions(String... args) {        if (args.length < 1) {            throw new IllegalArgumentException("Missing client version");        }        String clientVersion = args[0];        if (!clientVersion.equals(BuildConfig.VERSION_NAME)) {            throw new IllegalArgumentException(                    "The server version (" + BuildConfig.VERSION_NAME + ") does not match the client " + "(" + clientVersion + ")");        }        final int expectedParameters = 12;        if (args.length != expectedParameters) {            throw new IllegalArgumentException("Expecting " + expectedParameters + " parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[1]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[2]);        options.setBitRate(bitRate);        int maxFps = Integer.parseInt(args[3]);        options.setMaxFps(maxFps);        int lockedVideoOrientation = Integer.parseInt(args[4]);        options.setLockedVideoOrientation(lockedVideoOrientation);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[5]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[6]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[7]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[8]);        options.setControl(control);        int displayId = Integer.parseInt(args[9]);        options.setDisplayId(displayId);        boolean showTouches = Boolean.parseBoolean(args[10]);        options.setShowTouches(showTouches);        boolean stayAwake = Boolean.parseBoolean(args[11]);        options.setStayAwake(stayAwake);        return options;    }
    private static void scrcpy(Options options) throws IOException {        Ln.i("Device: " + Build.MANUFACTURER + " " + Build.MODEL + " (Android " + Build.VERSION.RELEASE + ")");        final Device device = new Device(options);        boolean mustDisableShowTouchesOnCleanUp = false;        int restoreStayOn = -1;        if (options.getShowTouches() || options.getStayAwake()) {            try (ContentProvider settings = device.createSettingsProvider()) {                if (options.getShowTouches()) {                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_SYSTEM, "show_touches", "1");                    // If "show touches" was disabled, it must be disabled back on clean up                    mustDisableShowTouchesOnCleanUp = !"1".equals(oldValue);                }                if (options.getStayAwake()) {                    int stayOn = BatteryManager.BATTERY_PLUGGED_AC | BatteryManager.BATTERY_PLUGGED_USB | BatteryManager.BATTERY_PLUGGED_WIRELESS;                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_GLOBAL, "stay_on_while_plugged_in", String.valueOf(stayOn));                    try {                        restoreStayOn = Integer.parseInt(oldValue);                        if (restoreStayOn == stayOn) {                            // No need to restore                            restoreStayOn = -1;                        }                    } catch (NumberFormatException e) {                        restoreStayOn = 0;                    }                }            }        }        CleanUp.configure(mustDisableShowTouchesOnCleanUp, restoreStayOn);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate(), options.getMaxFps());            if (options.getControl()) {                Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    private static Options createOptions(String... args) {        if (args.length < 1) {            throw new IllegalArgumentException("Missing client version");        }        String clientVersion = args[0];        if (!clientVersion.equals(BuildConfig.VERSION_NAME)) {            throw new IllegalArgumentException(                    "The server version (" + BuildConfig.VERSION_NAME + ") does not match the client " + "(" + clientVersion + ")");        }        final int expectedParameters = 14;        if (args.length != expectedParameters) {            throw new IllegalArgumentException("Expecting " + expectedParameters + " parameters");        }        Options options = new Options();        Ln.Level level = Ln.Level.valueOf(args[1].toUpperCase());        options.setLogLevel(level);        int maxSize = Integer.parseInt(args[2]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[3]);        options.setBitRate(bitRate);        int maxFps = Integer.parseInt(args[4]);        options.setMaxFps(maxFps);        int lockedVideoOrientation = Integer.parseInt(args[5]);        options.setLockedVideoOrientation(lockedVideoOrientation);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[6]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[7]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[8]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[9]);        options.setControl(control);        int displayId = Integer.parseInt(args[10]);        options.setDisplayId(displayId);        boolean showTouches = Boolean.parseBoolean(args[11]);        options.setShowTouches(showTouches);        boolean stayAwake = Boolean.parseBoolean(args[12]);        options.setStayAwake(stayAwake);        String codecOptions = args[13];        options.setCodecOptions(codecOptions);        return options;    }
    private static Options createOptions(String... args) {        if (args.length < 1) {            throw new IllegalArgumentException("Missing client version");        }        String clientVersion = args[0];        if (!clientVersion.equals(BuildConfig.VERSION_NAME)) {            throw new IllegalArgumentException(                    "The server version (" + BuildConfig.VERSION_NAME + ") does not match the client " + "(" + clientVersion + ")");        }        final int expectedParameters = 14;        if (args.length != expectedParameters) {            throw new IllegalArgumentException("Expecting " + expectedParameters + " parameters");        }        Options options = new Options();        Ln.Level level = Ln.Level.valueOf(args[1].toUpperCase(Locale.ENGLISH));        options.setLogLevel(level);        int maxSize = Integer.parseInt(args[2]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[3]);        options.setBitRate(bitRate);        int maxFps = Integer.parseInt(args[4]);        options.setMaxFps(maxFps);        int lockedVideoOrientation = Integer.parseInt(args[5]);        options.setLockedVideoOrientation(lockedVideoOrientation);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[6]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[7]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[8]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[9]);        options.setControl(control);        int displayId = Integer.parseInt(args[10]);        options.setDisplayId(displayId);        boolean showTouches = Boolean.parseBoolean(args[11]);        options.setShowTouches(showTouches);        boolean stayAwake = Boolean.parseBoolean(args[12]);        options.setStayAwake(stayAwake);        String codecOptions = args[13];        options.setCodecOptions(codecOptions);        return options;    }
run_receiver(void *data) {    struct receiver *receiver = data;    unsigned char buf[DEVICE_MSG_MAX_SIZE];    size_t head = 0;    for (;;) {        assert(head < DEVICE_MSG_MAX_SIZE);        ssize_t r = net_recv(receiver->control_socket, buf,                             DEVICE_MSG_MAX_SIZE - head);        if (r <= 0) {            LOGD("Receiver stopped");            break;        }        ssize_t consumed = process_msgs(buf, r);        if (consumed == -1) {            // an error occurred            break;        }        if (consumed) {            // shift the remaining data in the buffer            memmove(buf, &buf[consumed], r - consumed);            head = r - consumed;        }    }    return 0;}
run_receiver(void *data) {    struct receiver *receiver = data;    unsigned char buf[DEVICE_MSG_MAX_SIZE];    size_t head = 0;    for (;;) {        assert(head < DEVICE_MSG_MAX_SIZE);        ssize_t r = net_recv(receiver->control_socket, buf + head,                             DEVICE_MSG_MAX_SIZE - head);        if (r <= 0) {            LOGD("Receiver stopped");            break;        }        head += r;        ssize_t consumed = process_msgs(buf, head);        if (consumed == -1) {            // an error occurred            break;        }        if (consumed) {            head -= consumed;            // shift the remaining data in the buffer            memmove(buf, &buf[consumed], head);        }    }    return 0;}
    public static void main(String... args) {        unlinkSelf();        try {            // Wait for the server to die            System.in.read();        } catch (IOException e) {            // Expected when the server is dead        }        Ln.i("Cleaning up");        boolean disableShowTouches = Boolean.parseBoolean(args[0]);        int restoreStayOn = Integer.parseInt(args[1]);        if (disableShowTouches || restoreStayOn != -1) {            ServiceManager serviceManager = new ServiceManager();            try (ContentProvider settings = serviceManager.getActivityManager().createSettingsProvider()) {                if (disableShowTouches) {                    Ln.i("Disabling \"show touches\"");                    settings.putValue(ContentProvider.TABLE_SYSTEM, "show_touches", "0");                }                if (restoreStayOn != -1) {                    Ln.i("Restoring \"stay awake\"");                    settings.putValue(ContentProvider.TABLE_GLOBAL, "stay_on_while_plugged_in", String.valueOf(restoreStayOn));                }            }        }    }}
    public static void configure(boolean disableShowTouches, int restoreStayOn) throws IOException {        boolean needProcess = disableShowTouches || restoreStayOn != -1;        if (needProcess) {            startProcess(disableShowTouches, restoreStayOn);        } else {            // There is no additional clean up to do when scrcpy dies            unlinkSelf();        }    }
    public static void configure(boolean disableShowTouches, int restoreStayOn) throws IOException {        boolean needProcess = disableShowTouches || restoreStayOn != -1;        if (needProcess) {            startProcess(disableShowTouches, restoreStayOn);        } else {            // There is no additional clean up to do when scrcpy dies            unlinkSelf();        }    }
    private static void startProcess(boolean disableShowTouches, int restoreStayOn) throws IOException {        String[] cmd = {"app_process", "/", CleanUp.class.getName(), String.valueOf(disableShowTouches), String.valueOf(restoreStayOn)};        ProcessBuilder builder = new ProcessBuilder(cmd);        builder.environment().put("CLASSPATH", SERVER_PATH);        builder.start();    }
    private static void startProcess(boolean disableShowTouches, int restoreStayOn) throws IOException {        String[] cmd = {"app_process", "/", CleanUp.class.getName(), String.valueOf(disableShowTouches), String.valueOf(restoreStayOn)};        ProcessBuilder builder = new ProcessBuilder(cmd);        builder.environment().put("CLASSPATH", SERVER_PATH);        builder.start();    }
    public static void main(String... args) {        unlinkSelf();        try {            // Wait for the server to die            System.in.read();        } catch (IOException e) {            // Expected when the server is dead        }        Ln.i("Cleaning up");        boolean disableShowTouches = Boolean.parseBoolean(args[0]);        int restoreStayOn = Integer.parseInt(args[1]);        boolean restoreNormalPowerMode = Boolean.parseBoolean(args[2]);        if (disableShowTouches || restoreStayOn != -1) {            ServiceManager serviceManager = new ServiceManager();            try (ContentProvider settings = serviceManager.getActivityManager().createSettingsProvider()) {                if (disableShowTouches) {                    Ln.i("Disabling \"show touches\"");                    settings.putValue(ContentProvider.TABLE_SYSTEM, "show_touches", "0");                }                if (restoreStayOn != -1) {                    Ln.i("Restoring \"stay awake\"");                    settings.putValue(ContentProvider.TABLE_GLOBAL, "stay_on_while_plugged_in", String.valueOf(restoreStayOn));                }            }        }        if (restoreNormalPowerMode) {            Ln.i("Restoring normal power mode");            Device.setScreenPowerMode(Device.POWER_MODE_NORMAL);        }    }}
    public static void configure(boolean disableShowTouches, int restoreStayOn, boolean restoreNormalPowerMode) throws IOException {        boolean needProcess = disableShowTouches || restoreStayOn != -1 || restoreNormalPowerMode;        if (needProcess) {            startProcess(disableShowTouches, restoreStayOn, restoreNormalPowerMode);        } else {            // There is no additional clean up to do when scrcpy dies            unlinkSelf();        }    }
    public static void configure(boolean disableShowTouches, int restoreStayOn, boolean restoreNormalPowerMode) throws IOException {        boolean needProcess = disableShowTouches || restoreStayOn != -1 || restoreNormalPowerMode;        if (needProcess) {            startProcess(disableShowTouches, restoreStayOn, restoreNormalPowerMode);        } else {            // There is no additional clean up to do when scrcpy dies            unlinkSelf();        }    }
    private static void startProcess(boolean disableShowTouches, int restoreStayOn, boolean restoreNormalPowerMode) throws IOException {        String[] cmd = {"app_process", "/", CleanUp.class.getName(), String.valueOf(disableShowTouches), String.valueOf(                restoreStayOn), String.valueOf(restoreNormalPowerMode)};        ProcessBuilder builder = new ProcessBuilder(cmd);        builder.environment().put("CLASSPATH", SERVER_PATH);        builder.start();    }
    private static void startProcess(boolean disableShowTouches, int restoreStayOn, boolean restoreNormalPowerMode) throws IOException {        String[] cmd = {"app_process", "/", CleanUp.class.getName(), String.valueOf(disableShowTouches), String.valueOf(                restoreStayOn), String.valueOf(restoreNormalPowerMode)};        ProcessBuilder builder = new ProcessBuilder(cmd);        builder.environment().put("CLASSPATH", SERVER_PATH);        builder.start();    }
    private static void scrcpy(Options options) throws IOException {        Ln.i("Device: " + Build.MANUFACTURER + " " + Build.MODEL + " (Android " + Build.VERSION.RELEASE + ")");        final Device device = new Device(options);        List<CodecOption> codecOptions = CodecOption.parse(options.getCodecOptions());        boolean mustDisableShowTouchesOnCleanUp = false;        int restoreStayOn = -1;        if (options.getShowTouches() || options.getStayAwake()) {            try (ContentProvider settings = device.createSettingsProvider()) {                if (options.getShowTouches()) {                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_SYSTEM, "show_touches", "1");                    // If "show touches" was disabled, it must be disabled back on clean up                    mustDisableShowTouchesOnCleanUp = !"1".equals(oldValue);                }                if (options.getStayAwake()) {                    int stayOn = BatteryManager.BATTERY_PLUGGED_AC | BatteryManager.BATTERY_PLUGGED_USB | BatteryManager.BATTERY_PLUGGED_WIRELESS;                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_GLOBAL, "stay_on_while_plugged_in", String.valueOf(stayOn));                    try {                        restoreStayOn = Integer.parseInt(oldValue);                        if (restoreStayOn == stayOn) {                            // No need to restore                            restoreStayOn = -1;                        }                    } catch (NumberFormatException e) {                        restoreStayOn = 0;                    }                }            }        }        CleanUp.configure(mustDisableShowTouchesOnCleanUp, restoreStayOn);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate(), options.getMaxFps(), codecOptions);            if (options.getControl()) {                final Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());                device.setClipboardListener(new Device.ClipboardListener() {                    @Override                    public void onClipboardTextChanged(String text) {                        controller.getSender().pushClipboardText(text);                    }                });            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    private static void scrcpy(Options options) throws IOException {        Ln.i("Device: " + Build.MANUFACTURER + " " + Build.MODEL + " (Android " + Build.VERSION.RELEASE + ")");        final Device device = new Device(options);        List<CodecOption> codecOptions = CodecOption.parse(options.getCodecOptions());        boolean mustDisableShowTouchesOnCleanUp = false;        int restoreStayOn = -1;        if (options.getShowTouches() || options.getStayAwake()) {            try (ContentProvider settings = device.createSettingsProvider()) {                if (options.getShowTouches()) {                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_SYSTEM, "show_touches", "1");                    // If "show touches" was disabled, it must be disabled back on clean up                    mustDisableShowTouchesOnCleanUp = !"1".equals(oldValue);                }                if (options.getStayAwake()) {                    int stayOn = BatteryManager.BATTERY_PLUGGED_AC | BatteryManager.BATTERY_PLUGGED_USB | BatteryManager.BATTERY_PLUGGED_WIRELESS;                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_GLOBAL, "stay_on_while_plugged_in", String.valueOf(stayOn));                    try {                        restoreStayOn = Integer.parseInt(oldValue);                        if (restoreStayOn == stayOn) {                            // No need to restore                            restoreStayOn = -1;                        }                    } catch (NumberFormatException e) {                        restoreStayOn = 0;                    }                }            }        }        CleanUp.configure(mustDisableShowTouchesOnCleanUp, restoreStayOn, true);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate(), options.getMaxFps(), codecOptions);            if (options.getControl()) {                final Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());                device.setClipboardListener(new Device.ClipboardListener() {                    @Override                    public void onClipboardTextChanged(String text) {                        controller.getSender().pushClipboardText(text);                    }                });            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
parse_window_position(const char *s, int16_t *position) {    // special value for "auto"    static_assert(WINDOW_POSITION_UNDEFINED == -0x8000);    if (!strcmp(s, "auto")) {        *position = WINDOW_POSITION_UNDEFINED;        return true;    }    long value;    bool ok = parse_integer_arg(s, &value, false, -0x7FFF, 0x7FFF,                                "window position");    if (!ok) {        return false;    }    *position = (int16_t) value;    return true;}
parse_window_position(const char *s, int16_t *position) {    // special value for "auto"    static_assert(WINDOW_POSITION_UNDEFINED == -0x8000, "unexpected value");    if (!strcmp(s, "auto")) {        *position = WINDOW_POSITION_UNDEFINED;        return true;    }    long value;    bool ok = parse_integer_arg(s, &value, false, -0x7FFF, 0x7FFF,                                "window position");    if (!ok) {        return false;    }    *position = (int16_t) value;    return true;}
recorder_init(struct recorder *recorder,              const char *filename,              enum recorder_format format,              struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Could not strdup filename");        return false;    }    recorder->mutex = SDL_CreateMutex();    if (!recorder->mutex) {        LOGC("Could not create mutex");        SDL_free(recorder->filename);        return false;    }    recorder->queue_cond = SDL_CreateCond();    if (!recorder->queue_cond) {        LOGC("Could not create cond");        SDL_DestroyMutex(recorder->mutex);        SDL_free(recorder->filename);        return false;    }    queue_init(&recorder->queue);    recorder->stopped = false;    recorder->failed = false;    recorder->format = format;    recorder->declared_frame_size = declared_frame_size;    recorder->header_written = false;    return true;}
run_recorder(void *data) {    struct recorder *recorder = data;    for (;;) {        mutex_lock(recorder->mutex);        while (!recorder->stopped && queue_is_empty(&recorder->queue)) {            cond_wait(recorder->queue_cond, recorder->mutex);        }        // if stopped is set, continue to process the remaining events (to        // finish the recording) before actually stopping        if (recorder->stopped && queue_is_empty(&recorder->queue)) {            mutex_unlock(recorder->mutex);            break;        }        struct record_packet *rec;        queue_take(&recorder->queue, next, &rec);        mutex_unlock(recorder->mutex);        bool ok = recorder_write(recorder, &rec->packet);        record_packet_delete(rec);        if (!ok) {            LOGE("Could not record packet");            mutex_lock(recorder->mutex);            recorder->failed = true;            // discard pending packets            recorder_queue_clear(&recorder->queue);            mutex_unlock(recorder->mutex);            break;        }    }    LOGD("Recorder thread ended");    return 0;}
recorder_init(struct recorder *recorder,              const char *filename,              enum recorder_format format,              struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Could not strdup filename");        return false;    }    recorder->mutex = SDL_CreateMutex();    if (!recorder->mutex) {        LOGC("Could not create mutex");        SDL_free(recorder->filename);        return false;    }    recorder->queue_cond = SDL_CreateCond();    if (!recorder->queue_cond) {        LOGC("Could not create cond");        SDL_DestroyMutex(recorder->mutex);        SDL_free(recorder->filename);        return false;    }    queue_init(&recorder->queue);    recorder->stopped = false;    recorder->failed = false;    recorder->format = format;    recorder->declared_frame_size = declared_frame_size;    recorder->header_written = false;    recorder->previous = NULL;    return true;}
run_recorder(void *data) {    struct recorder *recorder = data;    for (;;) {        mutex_lock(recorder->mutex);        while (!recorder->stopped && queue_is_empty(&recorder->queue)) {            cond_wait(recorder->queue_cond, recorder->mutex);        }        // if stopped is set, continue to process the remaining events (to        // finish the recording) before actually stopping        if (recorder->stopped && queue_is_empty(&recorder->queue)) {            mutex_unlock(recorder->mutex);            struct record_packet *last = recorder->previous;            if (last) {                // assign an arbitrary duration to the last packet                last->packet.duration = 100000;                bool ok = recorder_write(recorder, &last->packet);                if (!ok) {                    // failing to write the last frame is not very serious, no                    // future frame may depend on it, so the resulting file                    // will still be valid                    LOGW("Could not record last packet");                }                record_packet_delete(last);            }            break;        }        struct record_packet *rec;        queue_take(&recorder->queue, next, &rec);        mutex_unlock(recorder->mutex);        // recorder->previous is only written from this thread, no need to lock        struct record_packet *previous = recorder->previous;        recorder->previous = rec;        if (!previous) {            // we just received the first packet            continue;        }        // we now know the duration of the previous packet        previous->packet.duration = rec->packet.pts - previous->packet.pts;        bool ok = recorder_write(recorder, &previous->packet);        record_packet_delete(previous);        if (!ok) {            LOGE("Could not record packet");            mutex_lock(recorder->mutex);            recorder->failed = true;            // discard pending packets            recorder_queue_clear(&recorder->queue);            mutex_unlock(recorder->mutex);            break;        }    }    LOGD("Recorder thread ended");    return 0;}
    if (!wide) {        return NULL;    }    MultiByteToWideChar(CP_UTF8, 0, utf8, -1, wide, len);    return wide;}char *utf8_from_wide_char(const wchar_t *ws) {
parse_integers(const char *s, const char sep, size_t max_items, long *out) {    size_t count = 0;    char *endptr;    do {        errno = 0;        long value = strtol(s, &endptr, 0);        if (errno == ERANGE) {            return 0;        }        if (endptr == s || (*endptr != sep && *endptr != '\0')) {            return 0;        }        out[count++] = value;        if (*endptr == sep) {            if (count >= max_items) {                // max items already reached, could not accept a new item                return 0;            }            // parse the next token during the next iteration            s = endptr + 1;        }    } while (*endptr != '\0');    return count;}
int main(void) {    test_xstrncpy_simple();    test_xstrncpy_just_fit();    test_xstrncpy_truncated();    test_xstrjoin_simple();    test_xstrjoin_just_fit();    test_xstrjoin_truncated_in_token();    test_xstrjoin_truncated_before_sep();    test_xstrjoin_truncated_after_sep();    test_strquote();    test_utf8_truncate();    test_parse_integer();    test_parse_integer_with_suffix();    return 0;}
int main(void) {    test_xstrncpy_simple();    test_xstrncpy_just_fit();    test_xstrncpy_truncated();    test_xstrjoin_simple();    test_xstrjoin_just_fit();    test_xstrjoin_truncated_in_token();    test_xstrjoin_truncated_before_sep();    test_xstrjoin_truncated_after_sep();    test_strquote();    test_utf8_truncate();    test_parse_integer();    test_parse_integer_with_suffix();    return 0;}
int main(void) {    test_xstrncpy_simple();    test_xstrncpy_just_fit();    test_xstrncpy_truncated();    test_xstrjoin_simple();    test_xstrjoin_just_fit();    test_xstrjoin_truncated_in_token();    test_xstrjoin_truncated_before_sep();    test_xstrjoin_truncated_after_sep();    test_strquote();    test_utf8_truncate();    test_parse_integer();    test_parse_integers();    test_parse_integer_with_suffix();    return 0;}
static void test_parse_integers(void) {    long values[5];    size_t count = parse_integers("1234", ':', 5, values);    assert(count == 1);    assert(values[0] == 1234);    count = parse_integers("1234:5678", ':', 5, values);    assert(count == 2);    assert(values[0] == 1234);    assert(values[1] == 5678);    count = parse_integers("1234:5678", ':', 2, values);    assert(count == 2);    assert(values[0] == 1234);    assert(values[1] == 5678);    count = parse_integers("1234:-5678", ':', 2, values);    assert(count == 2);    assert(values[0] == 1234);    assert(values[1] == -5678);    count = parse_integers("1:2:3:4:5", ':', 5, values);    assert(count == 5);    assert(values[0] == 1);    assert(values[1] == 2);    assert(values[2] == 3);    assert(values[3] == 4);    assert(values[4] == 5);    count = parse_integers("1234:5678", ':', 1, values);    assert(count == 0); // max_items == 1    count = parse_integers("1:2:3:4:5", ':', 3, values);    assert(count == 0); // max_items == 3    count = parse_integers(":1234", ':', 5, values);    assert(count == 0); // invalid    count = parse_integers("1234:", ':', 5, values);    assert(count == 0); // invalid    count = parse_integers("1234:", ':', 1, values);    assert(count == 0); // invalid, even when max_items == 1    count = parse_integers("1234::5678", ':', 5, values);    assert(count == 0); // invalid}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options-> mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
set_show_touches_enabled(const char *serial, bool enabled) {    const char *value = enabled ? "1" : "0";    const char *const adb_cmd[] = {        "shell", "settings", "put", "system", "show_touches", value    };    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
wait_show_touches(process_t process) {    // reap the process, ignore the result    process_check_success(process, "show_touches");}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,        .show_touches = options->show_touches,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options-> mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    server_destroy(&server);    return ret;}
sdl_priority_from_av_level(int level) {    switch (level) {        case AV_LOG_PANIC:        case AV_LOG_FATAL:            return SDL_LOG_PRIORITY_CRITICAL;        case AV_LOG_ERROR:            return SDL_LOG_PRIORITY_ERROR;        case AV_LOG_WARNING:
        case AV_LOG_INFO:            return SDL_LOG_PRIORITY_INFO;    }    // do not forward others, which are too verbose    return 0;
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    char max_fps_string[6];    char lock_video_orientation_string[3];    char display_id_string[6];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    sprintf(max_fps_string, "%"PRIu16, params->max_fps);    sprintf(lock_video_orientation_string, "%"PRIi8, params->lock_video_orientation);    sprintf(display_id_string, "%"PRIu16, params->display_id);    const char *const cmd[] = {        "shell",        "CLASSPATH=" DEVICE_SERVER_PATH,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"# ifdef SERVER_DEBUGGER_METHOD_NEW        /* Android 9 and above */        "-XjdwpProvider:internal -XjdwpOptions:transport=dt_socket,suspend=y,server=y,address="# else        /* Android 8 and below */        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="# endif            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,        max_size_string,        bit_rate_string,        max_fps_string,        lock_video_orientation_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",        display_id_string,    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    char max_fps_string[6];    char lock_video_orientation_string[3];    char display_id_string[6];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    sprintf(max_fps_string, "%"PRIu16, params->max_fps);    sprintf(lock_video_orientation_string, "%"PRIi8, params->lock_video_orientation);    sprintf(display_id_string, "%"PRIu16, params->display_id);    const char *const cmd[] = {        "shell",        "CLASSPATH=" DEVICE_SERVER_PATH,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"# ifdef SERVER_DEBUGGER_METHOD_NEW        /* Android 9 and above */        "-XjdwpProvider:internal -XjdwpOptions:transport=dt_socket,suspend=y,server=y,address="# else        /* Android 8 and below */        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="# endif            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,        max_size_string,        bit_rate_string,        max_fps_string,        lock_video_orientation_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",        display_id_string,        params->show_touches ? "true" : "false",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
    private static void startProcess() throws IOException {        String[] cmd = {"app_process", "/", CleanUp.class.getName()};        ProcessBuilder builder = new ProcessBuilder(cmd);        builder.environment().put("CLASSPATH", SERVER_PATH);        builder.start();    }
    public static void main(String... args) {        unlinkSelf();        try {            // Wait for the server to die            System.in.read();        } catch (IOException e) {            // Expected when the server is dead        }        Ln.i("Cleaning up");        // TODO    }}
    public static void configure() throws IOException {        // TODO        boolean needProcess = false;        if (needProcess) {            startProcess();        } else {            // There is no additional clean up to do when scrcpy dies            unlinkSelf();        }    }
    private static void startProcess() throws IOException {        String[] cmd = {"app_process", "/", CleanUp.class.getName()};        ProcessBuilder builder = new ProcessBuilder(cmd);        builder.environment().put("CLASSPATH", SERVER_PATH);        builder.start();    }
    public static void configure() throws IOException {        // TODO        boolean needProcess = false;        if (needProcess) {            startProcess();        } else {            // There is no additional clean up to do when scrcpy dies            unlinkSelf();        }    }
        String[] cmd = {"app_process", "/", CleanUp.class.getName(), String.valueOf(disableShowTouches)};        ProcessBuilder builder = new ProcessBuilder(cmd);        builder.environment().put("CLASSPATH", SERVER_PATH);        builder.start();    }    private static void unlinkSelf() {
    public static void main(String... args) {        unlinkSelf();        try {            // Wait for the server to die            System.in.read();        } catch (IOException e) {            // Expected when the server is dead        }        Ln.i("Cleaning up");        boolean disableShowTouches = Boolean.parseBoolean(args[0]);        if (disableShowTouches) {            ServiceManager serviceManager = new ServiceManager();            try (ContentProvider settings = serviceManager.getActivityManager().createSettingsProvider()) {                Ln.i("Disabling \"show touches\"");                settings.putValue(ContentProvider.TABLE_SYSTEM, "show_touches", "0");            }        }    }}
    public static void configure(boolean disableShowTouches) throws IOException {        boolean needProcess = disableShowTouches;        if (needProcess) {            startProcess(disableShowTouches);        } else {            // There is no additional clean up to do when scrcpy dies            unlinkSelf();        }    }
    private static void startProcess(boolean disableShowTouches) throws IOException {        String[] cmd = {"app_process", "/", CleanUp.class.getName(), String.valueOf(disableShowTouches)};        ProcessBuilder builder = new ProcessBuilder(cmd);        builder.environment().put("CLASSPATH", SERVER_PATH);        builder.start();    }
    public static void configure(boolean disableShowTouches) throws IOException {        boolean needProcess = disableShowTouches;        if (needProcess) {            startProcess(disableShowTouches);        } else {            // There is no additional clean up to do when scrcpy dies            unlinkSelf();        }    }    private static void startProcess(boolean disableShowTouches) throws IOException {
    }    public int getBitRate() {        return bitRate;    }    public void setBitRate(int bitRate) {        this.bitRate = bitRate;    }    public int getMaxFps() {
    }    public int getBitRate() {        return bitRate;    }    public void setBitRate(int bitRate) {        this.bitRate = bitRate;    }    public int getMaxFps() {
    public void setShowTouches(boolean showTouches) {        this.showTouches = showTouches;    }}
    public boolean getShowTouches() {        return showTouches;    }
    private static Options createOptions(String... args) {        if (args.length < 1) {            throw new IllegalArgumentException("Missing client version");        }        String clientVersion = args[0];        if (!clientVersion.equals(BuildConfig.VERSION_NAME)) {            throw new IllegalArgumentException(                    "The server version (" + BuildConfig.VERSION_NAME + ") does not match the client " + "(" + clientVersion + ")");        }        if (args.length != 10) {            throw new IllegalArgumentException("Expecting 10 parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[1]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[2]);        options.setBitRate(bitRate);        int maxFps = Integer.parseInt(args[3]);        options.setMaxFps(maxFps);        int lockedVideoOrientation = Integer.parseInt(args[4]);        options.setLockedVideoOrientation(lockedVideoOrientation);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[5]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[6]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[7]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[8]);        options.setControl(control);        int displayId = Integer.parseInt(args[9]);        options.setDisplayId(displayId);        return options;    }
    private static void scrcpy(Options options) throws IOException {        Ln.i("Device: " + Build.MANUFACTURER + " " + Build.MODEL + " (Android " + Build.VERSION.RELEASE + ")");        final Device device = new Device(options);        CleanUp.configure();        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate(), options.getMaxFps());            if (options.getControl()) {                Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    private static Options createOptions(String... args) {        if (args.length < 1) {            throw new IllegalArgumentException("Missing client version");        }        String clientVersion = args[0];        if (!clientVersion.equals(BuildConfig.VERSION_NAME)) {            throw new IllegalArgumentException(                    "The server version (" + BuildConfig.VERSION_NAME + ") does not match the client " + "(" + clientVersion + ")");        }        final int expectedParameters = 11;        if (args.length != expectedParameters) {            throw new IllegalArgumentException("Expecting " + expectedParameters + " parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[1]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[2]);        options.setBitRate(bitRate);        int maxFps = Integer.parseInt(args[3]);        options.setMaxFps(maxFps);        int lockedVideoOrientation = Integer.parseInt(args[4]);        options.setLockedVideoOrientation(lockedVideoOrientation);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[5]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[6]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[7]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[8]);        options.setControl(control);        int displayId = Integer.parseInt(args[9]);        options.setDisplayId(displayId);        boolean showTouches = Boolean.parseBoolean(args[10]);        options.setShowTouches(showTouches);        return options;    }
    private static void scrcpy(Options options) throws IOException {        Ln.i("Device: " + Build.MANUFACTURER + " " + Build.MODEL + " (Android " + Build.VERSION.RELEASE + ")");        final Device device = new Device(options);        boolean mustDisableShowTouchesOnCleanUp = false;        if (options.getShowTouches()) {            try (ContentProvider settings = device.createSettingsProvider()) {                String oldValue = settings.getAndPutValue(ContentProvider.TABLE_SYSTEM, "show_touches", "1");                // If "show touches" was disabled, it must be disabled back on clean up                mustDisableShowTouchesOnCleanUp = !"1".equals(oldValue);            }        }        CleanUp.configure(mustDisableShowTouchesOnCleanUp);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate(), options.getMaxFps());            if (options.getControl()) {                Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_HOME,         AKEYCODE_MOVE_HOME);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);
mouse_motion_from_sdl_to_android(const SDL_MouseMotionEvent *from,                                 struct size screen_size,                                 struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_MOUSE_EVENT;    to->inject_mouse_event.action = AMOTION_EVENT_ACTION_MOVE;    to->inject_mouse_event.buttons = convert_mouse_buttons(from->state);    to->inject_mouse_event.position.screen_size = screen_size;    to->inject_mouse_event.position.point.x = from->x;    to->inject_mouse_event.position.point.y = from->y;    return true;}
mouse_motion_from_sdl_to_android(const SDL_MouseMotionEvent *from,                                 struct size screen_size,                                 struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_MOUSE_EVENT;    to->inject_mouse_event.action = AMOTION_EVENT_ACTION_MOVE;    to->inject_mouse_event.buttons = convert_mouse_buttons(from->state);    to->inject_mouse_event.position.screen_size = screen_size;    to->inject_mouse_event.position.point.x = from->x;    to->inject_mouse_event.position.point.y = from->y;    return true;}
mouse_wheel_from_sdl_to_android(const SDL_MouseWheelEvent *from,                                struct position position,                                struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT;    to->inject_scroll_event.position = position;    int mul = from->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    // SDL behavior seems inconsistent between horizontal and vertical scrolling    // so reverse the horizontal    // <https://wiki.libsdl.org/SDL_MouseWheelEvent#Remarks>    to->inject_scroll_event.hscroll = -mul * from->x;    to->inject_scroll_event.vscroll = mul * from->y;    return true;}
input_key_from_sdl_to_android(const SDL_KeyboardEvent *from,                              struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_KEYCODE;    if (!convert_keycode_action(from->type, &to->inject_keycode.action)) {        return false;    }    uint16_t mod = from->keysym.mod;    if (!convert_keycode(from->keysym.sym, &to->inject_keycode.keycode, mod)) {        return false;    }    to->inject_keycode.metastate = convert_meta_state(mod);    return true;}
input_key_from_sdl_to_android(const SDL_KeyboardEvent *from,                              struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_KEYCODE;    if (!convert_keycode_action(from->type, &to->inject_keycode.action)) {        return false;    }    uint16_t mod = from->keysym.mod;    if (!convert_keycode(from->keysym.sym, &to->inject_keycode.keycode, mod)) {        return false;    }    to->inject_keycode.metastate = convert_meta_state(mod);    return true;}
mouse_button_from_sdl_to_android(const SDL_MouseButtonEvent *from,                                 struct size screen_size,                                 struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_MOUSE_EVENT;    if (!convert_mouse_action(from->type, &to->inject_mouse_event.action)) {        return false;    }    to->inject_mouse_event.buttons =        convert_mouse_buttons(SDL_BUTTON(from->button));    to->inject_mouse_event.position.screen_size = screen_size;    to->inject_mouse_event.position.point.x = from->x;    to->inject_mouse_event.position.point.y = from->y;    return true;}
mouse_button_from_sdl_to_android(const SDL_MouseButtonEvent *from,                                 struct size screen_size,                                 struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_MOUSE_EVENT;    if (!convert_mouse_action(from->type, &to->inject_mouse_event.action)) {        return false;    }    to->inject_mouse_event.buttons =        convert_mouse_buttons(SDL_BUTTON(from->button));    to->inject_mouse_event.position.screen_size = screen_size;    to->inject_mouse_event.position.point.x = from->x;    to->inject_mouse_event.position.point.y = from->y;    return true;}
convert_mouse_wheel(const SDL_MouseWheelEvent *from, struct position position,                    struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT;    to->inject_scroll_event.position = position;    int mul = from->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    // SDL behavior seems inconsistent between horizontal and vertical scrolling    // so reverse the horizontal    // <https://wiki.libsdl.org/SDL_MouseWheelEvent#Remarks>    to->inject_scroll_event.hscroll = -mul * from->x;    to->inject_scroll_event.vscroll = mul * from->y;    return true;}
    to->inject_mouse_event.action = AMOTION_EVENT_ACTION_MOVE;    to->inject_mouse_event.buttons = convert_mouse_buttons(from->state);    to->inject_mouse_event.position.screen_size = screen_size;    to->inject_mouse_event.position.point.x = from->x;    to->inject_mouse_event.position.point.y = from->y;    return true;}boolconvert_mouse_wheel(const SDL_MouseWheelEvent *from, struct position position,                    struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT;
convert_input_key(const SDL_KeyboardEvent *from, struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_KEYCODE;    if (!convert_keycode_action(from->type, &to->inject_keycode.action)) {        return false;    }    uint16_t mod = from->keysym.mod;    if (!convert_keycode(from->keysym.sym, &to->inject_keycode.keycode, mod)) {        return false;    }    to->inject_keycode.metastate = convert_meta_state(mod);    return true;}
    to->inject_scroll_event.position = position;    int mul = from->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    // SDL behavior seems inconsistent between horizontal and vertical scrolling    // so reverse the horizontal    // <https://wiki.libsdl.org/SDL_MouseWheelEvent#Remarks>    to->inject_scroll_event.hscroll = -mul * from->x;    to->inject_scroll_event.vscroll = mul * from->y;    return true;}
    to->type = CONTROL_MSG_TYPE_INJECT_KEYCODE;    if (!convert_keycode_action(from->type, &to->inject_keycode.action)) {        return false;    }    uint16_t mod = from->keysym.mod;    if (!convert_keycode(from->keysym.sym, &to->inject_keycode.keycode, mod)) {        return false;    }    to->inject_keycode.metastate = convert_meta_state(mod);    return true;}boolconvert_mouse_button(const SDL_MouseButtonEvent *from, struct size screen_size,
convert_mouse_motion(const SDL_MouseMotionEvent *from, struct size screen_size,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_MOUSE_EVENT;    to->inject_mouse_event.action = AMOTION_EVENT_ACTION_MOVE;    to->inject_mouse_event.buttons = convert_mouse_buttons(from->state);    to->inject_mouse_event.position.screen_size = screen_size;    to->inject_mouse_event.position.point.x = from->x;    to->inject_mouse_event.position.point.y = from->y;    return true;}
    to->type = CONTROL_MSG_TYPE_INJECT_MOUSE_EVENT;    if (!convert_mouse_action(from->type, &to->inject_mouse_event.action)) {        return false;    }    to->inject_mouse_event.buttons =        convert_mouse_buttons(SDL_BUTTON(from->button));    to->inject_mouse_event.position.screen_size = screen_size;    to->inject_mouse_event.position.point.x = from->x;    to->inject_mouse_event.position.point.y = from->y;    return true;}boolconvert_mouse_motion(const SDL_MouseMotionEvent *from, struct size screen_size,                     struct control_msg *to) {
convert_mouse_button(const SDL_MouseButtonEvent *from, struct size screen_size,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_MOUSE_EVENT;    if (!convert_mouse_action(from->type, &to->inject_mouse_event.action)) {        return false;    }    to->inject_mouse_event.buttons =        convert_mouse_buttons(SDL_BUTTON(from->button));    to->inject_mouse_event.position.screen_size = screen_size;    to->inject_mouse_event.position.point.x = from->x;    to->inject_mouse_event.position.point.y = from->y;    return true;}
input_manager_process_mouse_wheel(struct input_manager *input_manager,                                  const SDL_MouseWheelEvent *event) {    struct position position = {        .screen_size = input_manager->screen->frame_size,        .point = get_mouse_point(input_manager->screen),    };    struct control_msg msg;    if (mouse_wheel_from_sdl_to_android(event, position, &msg)) {        if (!controller_push_msg(input_manager->controller, &msg)) {            LOGW("Could not request 'inject mouse wheel event'");        }    }}
input_manager_process_mouse_button(struct input_manager *input_manager,                                   const SDL_MouseButtonEvent *event,                                   bool control) {    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (control && event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(input_manager->controller);            return;        }        if (control && event->button == SDL_BUTTON_MIDDLE) {            action_home(input_manager->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            bool outside =                is_outside_device_screen(input_manager, event->x, event->y);            if (outside) {                screen_resize_to_fit(input_manager->screen);                return;            }        }        // otherwise, send the click event to the device    }    if (!control) {        return;    }    struct control_msg msg;    if (mouse_button_from_sdl_to_android(event,                                         input_manager->screen->frame_size,                                         &msg)) {        if (!controller_push_msg(input_manager->controller, &msg)) {            LOGW("Could not request 'inject mouse button event'");        }    }}
input_manager_process_key(struct input_manager *input_manager,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = input_manager->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && !shift && down) {                    set_screen_power_mode(controller, SCREEN_POWER_MODE_OFF);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard                        set_device_clipboard(controller);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && cmd && !repeat && down) {                    screen_switch_fullscreen(input_manager->screen);                }                return;            case SDLK_x:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_fit(input_manager->screen);                }                return;            case SDLK_g:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_pixel_perfect(input_manager->screen);                }                return;            case SDLK_i:                if (!shift && cmd && !repeat && down) {                    struct fps_counter *fps_counter =                        input_manager->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;        }        return;    }    if (!control) {        return;    }    struct control_msg msg;    if (input_key_from_sdl_to_android(event, &msg)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_process_mouse_motion(struct input_manager *input_manager,                                   const SDL_MouseMotionEvent *event) {    if (!event->state) {        // do not send motion events when no button is pressed        return;    }    struct control_msg msg;    if (mouse_motion_from_sdl_to_android(event,                                         input_manager->screen->frame_size,                                         &msg)) {        if (!controller_push_msg(input_manager->controller, &msg)) {            LOGW("Could not request 'inject mouse motion event'");        }    }}
input_manager_process_mouse_wheel(struct input_manager *input_manager,                                  const SDL_MouseWheelEvent *event) {    struct position position = {        .screen_size = input_manager->screen->frame_size,        .point = get_mouse_point(input_manager->screen),    };    struct control_msg msg;    if (convert_mouse_wheel(event, position, &msg)) {        if (!controller_push_msg(input_manager->controller, &msg)) {            LOGW("Could not request 'inject mouse wheel event'");        }    }}
input_manager_process_mouse_button(struct input_manager *input_manager,                                   const SDL_MouseButtonEvent *event,                                   bool control) {    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (control && event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(input_manager->controller);            return;        }        if (control && event->button == SDL_BUTTON_MIDDLE) {            action_home(input_manager->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            bool outside =                is_outside_device_screen(input_manager, event->x, event->y);            if (outside) {                screen_resize_to_fit(input_manager->screen);                return;            }        }        // otherwise, send the click event to the device    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_mouse_button(event, input_manager->screen->frame_size, &msg)) {        if (!controller_push_msg(input_manager->controller, &msg)) {            LOGW("Could not request 'inject mouse button event'");        }    }}
input_manager_process_key(struct input_manager *input_manager,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = input_manager->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && !shift && down) {                    set_screen_power_mode(controller, SCREEN_POWER_MODE_OFF);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard                        set_device_clipboard(controller);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && cmd && !repeat && down) {                    screen_switch_fullscreen(input_manager->screen);                }                return;            case SDLK_x:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_fit(input_manager->screen);                }                return;            case SDLK_g:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_pixel_perfect(input_manager->screen);                }                return;            case SDLK_i:                if (!shift && cmd && !repeat && down) {                    struct fps_counter *fps_counter =                        input_manager->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;        }        return;    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_input_key(event, &msg)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_process_mouse_motion(struct input_manager *input_manager,                                   const SDL_MouseMotionEvent *event) {    if (!event->state) {        // do not send motion events when no button is pressed        return;    }    struct control_msg msg;    if (convert_mouse_motion(event, input_manager->screen->frame_size, &msg)) {        if (!controller_push_msg(input_manager->controller, &msg)) {            LOGW("Could not request 'inject mouse motion event'");        }    }}
cmd_execute(const char *const argv[], HANDLE *handle) {    STARTUPINFOW si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    char cmd[256];    if (build_cmd(cmd, sizeof(cmd), argv)) {        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }    wchar_t *wide = utf8_to_wide_char(cmd);    if (!wide) {        LOGC("Could not allocate wide char string");        return PROCESS_ERROR_GENERIC;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcessW(NULL, wide, NULL, NULL, FALSE, flags, NULL, NULL, &si,                        &pi)) {        SDL_free(wide);        *handle = NULL;        if (GetLastError() == ERROR_FILE_NOT_FOUND) {            return PROCESS_ERROR_MISSING_BINARY;        }        return PROCESS_ERROR_GENERIC;    }    SDL_free(wide);    *handle = pi.hProcess;    return PROCESS_SUCCESS;}
cmd_execute(const char *const argv[], HANDLE *handle) {    STARTUPINFOW si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    char cmd[256];    if (build_cmd(cmd, sizeof(cmd), argv)) {        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }    wchar_t *wide = utf8_to_wide_char(cmd);    if (!wide) {        LOGC("Could not allocate wide char string");        return PROCESS_ERROR_GENERIC;    }    if (!CreateProcessW(NULL, wide, NULL, NULL, FALSE, 0, NULL, NULL, &si,                        &pi)) {        SDL_free(wide);        *handle = NULL;        if (GetLastError() == ERROR_FILE_NOT_FOUND) {            return PROCESS_ERROR_MISSING_BINARY;        }        return PROCESS_ERROR_GENERIC;    }    SDL_free(wide);    *handle = pi.hProcess;    return PROCESS_SUCCESS;}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    bool smod = is_shortcut_mod(im, event->keysym.mod);    struct controller *controller = im->controller;    // The shortcut modifier is pressed    if (smod) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                if (control && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                if (control && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (!shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (!shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    bool smod = is_shortcut_mod(im, event->keysym.mod);    struct controller *controller = im->controller;    SDL_Keycode keycode = event->keysym.sym;    bool down = event->type == SDL_KEYDOWN;    bool ctrl = event->keysym.mod & KMOD_CTRL;    bool shift = event->keysym.mod & KMOD_SHIFT;    bool repeat = event->repeat;    // The shortcut modifier is pressed    if (smod) {        int action = down ? ACTION_DOWN : ACTION_UP;        switch (keycode) {            case SDLK_h:                if (control && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                if (control && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (!shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (!shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    if (ctrl && !shift && keycode == SDLK_v && down && !repeat) {        // Synchronize the computer clipboard to the device clipboard before        // sending Ctrl+v, to allow seamless copy-paste.        set_device_clipboard(controller, false);    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"crop",                   required_argument, NULL, OPT_CROP},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"port",                   required_argument, NULL, 'p'},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value. Values are integers in the\n"        "        range [-1..3]. Natural device orientation is 0 and each\n"        "        increment adds 90 degrees counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value. Values are integers in the\n"        "        range [-1..3]. Natural device orientation is 0 and each\n"        "        increment adds 90 degrees counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"crop",                   required_argument, NULL, OPT_CROP},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"port",                   required_argument, NULL, 'p'},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value. Values are integers in the\n"        "        range [-1..3]. Natural device orientation is 0 and each\n"        "        increment adds 90 degrees counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
parse_rotation(const char *s, uint8_t *rotation) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 3, "rotation");    if (!ok) {        return false;    }    *rotation = (uint8_t) value;    return true;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless) {    screen->frame_size = frame_size;    struct size content_size =        get_rotated_size(frame_size, screen->rotation);    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, content_size.width,                                 content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless) {    screen->frame_size = frame_size;    struct size content_size =        get_rotated_size(frame_size, screen->rotation);    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, content_size.width,                                 content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size =        get_rotated_size(frame_size, screen->rotation);    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, content_size.width,                                 content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size =        get_rotated_size(frame_size, screen->rotation);    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, content_size.width,                                 content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
server_stop(struct server *server) {    if (server->server_socket != INVALID_SOCKET) {        close_socket(&server->server_socket);    }    if (server->video_socket != INVALID_SOCKET) {        close_socket(&server->video_socket);    }    if (server->control_socket != INVALID_SOCKET) {        close_socket(&server->control_socket);    }    assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Could not terminate server");    }    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->tunnel_enabled) {        // ignore failure        disable_tunnel(server);    }}
server_stop(struct server *server) {    if (server->server_socket != INVALID_SOCKET) {        close_socket(&server->server_socket);    }    if (server->video_socket != INVALID_SOCKET) {        close_socket(&server->video_socket);    }    if (server->control_socket != INVALID_SOCKET) {        close_socket(&server->control_socket);    }    assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Could not terminate server");    }    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->tunnel_enabled) {        // ignore failure        disable_tunnel(server);    }}
server_start(struct server *server, const char *serial,             const struct server_params *params) {    server->port_range = params->port_range;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        goto error1;    }    if (!enable_tunnel_any_port(server, params->port_range)) {        goto error1;    }    // server will connect to our server socket    server->process = execute_server(server, params);    if (server->process == PROCESS_NONE) {        goto error2;    }    server->tunnel_enabled = true;    return true;error2:    if (!server->tunnel_forward) {        close_socket(&server->server_socket);    }    disable_tunnel(server);error1:    SDL_free(server->serial);    return false;}
server_stop(struct server *server) {    if (server->server_socket != INVALID_SOCKET) {        close_socket(&server->server_socket);    }    if (server->video_socket != INVALID_SOCKET) {        close_socket(&server->video_socket);    }    if (server->control_socket != INVALID_SOCKET) {        close_socket(&server->control_socket);    }    assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Could not terminate server");    }    if (server->tunnel_enabled) {        // ignore failure        disable_tunnel(server);    }    SDL_WaitThread(server->wait_server_thread, NULL);}
run_wait_server(void *data) {    struct server *server = data;    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    return 0;}
server_start(struct server *server, const char *serial,             const struct server_params *params) {    server->port_range = params->port_range;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        goto error1;    }    if (!enable_tunnel_any_port(server, params->port_range)) {        goto error1;    }    // server will connect to our server socket    server->process = execute_server(server, params);    if (server->process == PROCESS_NONE) {        goto error2;    }    server->wait_server_thread =        SDL_CreateThread(run_wait_server, "wait-server", server);    if (!server->wait_server_thread) {        if (!cmd_terminate(server->process)) {            LOGW("Could not terminate server");        }        cmd_simple_wait(server->process, NULL); // ignore exit code        goto error2;    }    server->tunnel_enabled = true;    return true;error2:    if (!server->tunnel_forward) {        close_socket(&server->server_socket);    }    disable_tunnel(server);error1:    SDL_free(server->serial);    return false;}
control_msg_serialize(const struct control_msg *msg, unsigned char *buf) {    buf[0] = msg->type;    switch (msg->type) {        case CONTROL_MSG_TYPE_INJECT_KEYCODE:            buf[1] = msg->inject_keycode.action;            buffer_write32be(&buf[2], msg->inject_keycode.keycode);            buffer_write32be(&buf[6], msg->inject_keycode.metastate);            return 10;        case CONTROL_MSG_TYPE_INJECT_TEXT: {            size_t len =                write_string(msg->inject_text.text,                             CONTROL_MSG_INJECT_TEXT_MAX_LENGTH, &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT:            buf[1] = msg->inject_touch_event.action;            buffer_write64be(&buf[2], msg->inject_touch_event.pointer_id);            write_position(&buf[10], &msg->inject_touch_event.position);            uint16_t pressure =                to_fixed_point_16(msg->inject_touch_event.pressure);            buffer_write16be(&buf[22], pressure);            buffer_write32be(&buf[24], msg->inject_touch_event.buttons);            return 28;        case CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT:            write_position(&buf[1], &msg->inject_scroll_event.position);            buffer_write32be(&buf[13],                             (uint32_t) msg->inject_scroll_event.hscroll);            buffer_write32be(&buf[17],                             (uint32_t) msg->inject_scroll_event.vscroll);            return 21;        case CONTROL_MSG_TYPE_SET_CLIPBOARD: {            buf[1] = !!msg->set_clipboard.paste;            size_t len = write_string(msg->set_clipboard.text,                                      CONTROL_MSG_CLIPBOARD_TEXT_MAX_LENGTH,                                      &buf[2]);            return 2 + len;        }        case CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE:            buf[1] = msg->set_screen_power_mode.mode;            return 2;        case CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_GET_CLIPBOARD:        case CONTROL_MSG_TYPE_ROTATE_DEVICE:            // no additional data            return 1;        default:            LOGW("Unknown message type: %u", (unsigned) msg->type);            return 0;    }}
control_msg_serialize(const struct control_msg *msg, unsigned char *buf) {    buf[0] = msg->type;    switch (msg->type) {        case CONTROL_MSG_TYPE_INJECT_KEYCODE:            buf[1] = msg->inject_keycode.action;            buffer_write32be(&buf[2], msg->inject_keycode.keycode);            buffer_write32be(&buf[6], msg->inject_keycode.repeat);            buffer_write32be(&buf[10], msg->inject_keycode.metastate);            return 14;        case CONTROL_MSG_TYPE_INJECT_TEXT: {            size_t len =                write_string(msg->inject_text.text,                             CONTROL_MSG_INJECT_TEXT_MAX_LENGTH, &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT:            buf[1] = msg->inject_touch_event.action;            buffer_write64be(&buf[2], msg->inject_touch_event.pointer_id);            write_position(&buf[10], &msg->inject_touch_event.position);            uint16_t pressure =                to_fixed_point_16(msg->inject_touch_event.pressure);            buffer_write16be(&buf[22], pressure);            buffer_write32be(&buf[24], msg->inject_touch_event.buttons);            return 28;        case CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT:            write_position(&buf[1], &msg->inject_scroll_event.position);            buffer_write32be(&buf[13],                             (uint32_t) msg->inject_scroll_event.hscroll);            buffer_write32be(&buf[17],                             (uint32_t) msg->inject_scroll_event.vscroll);            return 21;        case CONTROL_MSG_TYPE_SET_CLIPBOARD: {            buf[1] = !!msg->set_clipboard.paste;            size_t len = write_string(msg->set_clipboard.text,                                      CONTROL_MSG_CLIPBOARD_TEXT_MAX_LENGTH,                                      &buf[2]);            return 2 + len;        }        case CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE:            buf[1] = msg->set_screen_power_mode.mode;            return 2;        case CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_GET_CLIPBOARD:        case CONTROL_MSG_TYPE_ROTATE_DEVICE:            // no additional data            return 1;        default:            LOGW("Unknown message type: %u", (unsigned) msg->type);            return 0;    }}
convert_input_key(const SDL_KeyboardEvent *from, struct control_msg *to,                  bool prefer_text) {    to->type = CONTROL_MSG_TYPE_INJECT_KEYCODE;    if (!convert_keycode_action(from->type, &to->inject_keycode.action)) {        return false;    }    uint16_t mod = from->keysym.mod;    if (!convert_keycode(from->keysym.sym, &to->inject_keycode.keycode, mod,                         prefer_text)) {        return false;    }    to->inject_keycode.metastate = convert_meta_state(mod);    return true;}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = im->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (cmd && !shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (cmd && !shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && cmd && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && cmd && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && cmd && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
convert_input_key(const SDL_KeyboardEvent *from, struct control_msg *to,                  bool prefer_text) {    to->type = CONTROL_MSG_TYPE_INJECT_KEYCODE;    if (!convert_keycode_action(from->type, &to->inject_keycode.action)) {        return false;    }    uint16_t mod = from->keysym.mod;    if (!convert_keycode(from->keysym.sym, &to->inject_keycode.keycode, mod,                         prefer_text)) {        return false;    }    to->inject_keycode.metastate = convert_meta_state(mod);    return true;}
convert_input_key(const SDL_KeyboardEvent *from, struct control_msg *to,                  bool prefer_text, uint32_t repeat) {    to->type = CONTROL_MSG_TYPE_INJECT_KEYCODE;    if (!convert_keycode_action(from->type, &to->inject_keycode.action)) {        return false;    }    uint16_t mod = from->keysym.mod;    if (!convert_keycode(from->keysym.sym, &to->inject_keycode.keycode, mod,                         prefer_text)) {        return false;    }    to->inject_keycode.repeat = repeat;    to->inject_keycode.metastate = convert_meta_state(mod);    return true;}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = im->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (cmd && !shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (cmd && !shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && cmd && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && cmd && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && cmd && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
convert_input_key(const SDL_KeyboardEvent *from, struct control_msg *to,                  bool prefer_text, uint32_t repeat) {    to->type = CONTROL_MSG_TYPE_INJECT_KEYCODE;    if (!convert_keycode_action(from->type, &to->inject_keycode.action)) {        return false;    }    uint16_t mod = from->keysym.mod;    if (!convert_keycode(from->keysym.sym, &to->inject_keycode.keycode, mod,                         prefer_text)) {        return false;    }    to->inject_keycode.repeat = repeat;    to->inject_keycode.metastate = convert_meta_state(mod);    return true;}
static void test_serialize_inject_keycode(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_INJECT_KEYCODE,        .inject_keycode = {            .action = AKEY_EVENT_ACTION_UP,            .keycode = AKEYCODE_ENTER,            .metastate = AMETA_SHIFT_ON | AMETA_SHIFT_LEFT_ON,        },    };    unsigned char buf[CONTROL_MSG_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 10);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_INJECT_KEYCODE,        0x01, // AKEY_EVENT_ACTION_UP        0x00, 0x00, 0x00, 0x42, // AKEYCODE_ENTER        0x00, 0x00, 0x00, 0x41, // AMETA_SHIFT_ON | AMETA_SHIFT_LEFT_ON    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_inject_keycode(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_INJECT_KEYCODE,        .inject_keycode = {            .action = AKEY_EVENT_ACTION_UP,            .keycode = AKEYCODE_ENTER,            .repeat = 5,            .metastate = AMETA_SHIFT_ON | AMETA_SHIFT_LEFT_ON,        },    };    unsigned char buf[CONTROL_MSG_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 14);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_INJECT_KEYCODE,        0x01, // AKEY_EVENT_ACTION_UP        0x00, 0x00, 0x00, 0x42, // AKEYCODE_ENTER        0x00, 0x00, 0x00, 0X05, // repeat        0x00, 0x00, 0x00, 0x41, // AMETA_SHIFT_ON | AMETA_SHIFT_LEFT_ON    };    assert(!memcmp(buf, expected, sizeof(expected)));}
public final class ControlMessage {    public static final int TYPE_INJECT_KEYCODE = 0;    public static final int TYPE_INJECT_TEXT = 1;    public static final int TYPE_INJECT_TOUCH_EVENT = 2;    public static final int TYPE_INJECT_SCROLL_EVENT = 3;    public static final int TYPE_BACK_OR_SCREEN_ON = 4;    public static final int TYPE_EXPAND_NOTIFICATION_PANEL = 5;    public static final int TYPE_COLLAPSE_NOTIFICATION_PANEL = 6;    public static final int TYPE_GET_CLIPBOARD = 7;    public static final int TYPE_SET_CLIPBOARD = 8;    public static final int TYPE_SET_SCREEN_POWER_MODE = 9;    public static final int TYPE_ROTATE_DEVICE = 10;    public static final int FLAGS_PASTE = 1;    private int type;    private String text;    private int metaState; // KeyEvent.META_*    private int action; // KeyEvent.ACTION_* or MotionEvent.ACTION_* or POWER_MODE_*    private int keycode; // KeyEvent.KEYCODE_*    private int buttons; // MotionEvent.BUTTON_*    private long pointerId;
    public static ControlMessage createInjectKeycode(int action, int keycode, int metaState) {        ControlMessage msg = new ControlMessage();        msg.type = TYPE_INJECT_KEYCODE;        msg.action = action;        msg.keycode = keycode;        msg.metaState = metaState;        return msg;    }
    public static ControlMessage createInjectKeycode(int action, int keycode, int metaState) {        ControlMessage msg = new ControlMessage();        msg.type = TYPE_INJECT_KEYCODE;        msg.action = action;        msg.keycode = keycode;        msg.metaState = metaState;        return msg;    }
    public int getRepeat() {        return repeat;    }}
    public static ControlMessage createInjectKeycode(int action, int keycode, int repeat, int metaState) {        ControlMessage msg = new ControlMessage();        msg.type = TYPE_INJECT_KEYCODE;        msg.action = action;        msg.keycode = keycode;        msg.repeat = repeat;        msg.metaState = metaState;        return msg;    }
    public static ControlMessage createInjectKeycode(int action, int keycode, int repeat, int metaState) {        ControlMessage msg = new ControlMessage();        msg.type = TYPE_INJECT_KEYCODE;        msg.action = action;        msg.keycode = keycode;        msg.repeat = repeat;        msg.metaState = metaState;        return msg;
    private ControlMessage parseInjectKeycode() {        if (buffer.remaining() < INJECT_KEYCODE_PAYLOAD_LENGTH) {            return null;        }        int action = toUnsigned(buffer.get());        int keycode = buffer.getInt();        int metaState = buffer.getInt();        return ControlMessage.createInjectKeycode(action, keycode, metaState);    }
    private ControlMessage parseInjectKeycode() {        if (buffer.remaining() < INJECT_KEYCODE_PAYLOAD_LENGTH) {            return null;        }        int action = toUnsigned(buffer.get());        int keycode = buffer.getInt();        int repeat = buffer.getInt();        int metaState = buffer.getInt();        return ControlMessage.createInjectKeycode(action, keycode, repeat, metaState);    }
    private boolean injectKeycode(int action, int keycode, int metaState) {        return device.injectKeyEvent(action, keycode, 0, metaState);    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                if (device.supportsInputEvents()) {                    injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                }                break;            case ControlMessage.TYPE_INJECT_TEXT:                if (device.supportsInputEvents()) {                    injectText(msg.getText());                }                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                if (device.supportsInputEvents()) {                    injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), msg.getButtons());                }                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                if (device.supportsInputEvents()) {                    injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                }                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                if (device.supportsInputEvents()) {                    pressBackOrTurnScreenOn();                }                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                if (clipboardText != null) {                    sender.pushClipboardText(clipboardText);                }                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                boolean paste = (msg.getFlags() & ControlMessage.FLAGS_PASTE) != 0;                setClipboard(msg.getText(), paste);                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                if (device.supportsInputEvents()) {                    int mode = msg.getAction();                    boolean setPowerModeOk = device.setScreenPowerMode(mode);                    if (setPowerModeOk) {                        Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));                    }                }                break;            case ControlMessage.TYPE_ROTATE_DEVICE:                device.rotateDevice();                break;            default:                // do nothing        }    }
    private boolean injectKeycode(int action, int keycode, int metaState) {        return device.injectKeyEvent(action, keycode, 0, metaState);    }
    private boolean injectKeycode(int action, int keycode, int repeat, int metaState) {        return device.injectKeyEvent(action, keycode, repeat, metaState);    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                if (device.supportsInputEvents()) {                    injectKeycode(msg.getAction(), msg.getKeycode(), msg.getRepeat(), msg.getMetaState());                }                break;            case ControlMessage.TYPE_INJECT_TEXT:                if (device.supportsInputEvents()) {                    injectText(msg.getText());                }                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                if (device.supportsInputEvents()) {                    injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), msg.getButtons());                }                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                if (device.supportsInputEvents()) {                    injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                }                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                if (device.supportsInputEvents()) {                    pressBackOrTurnScreenOn();                }                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                if (clipboardText != null) {                    sender.pushClipboardText(clipboardText);                }                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                boolean paste = (msg.getFlags() & ControlMessage.FLAGS_PASTE) != 0;                setClipboard(msg.getText(), paste);                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                if (device.supportsInputEvents()) {                    int mode = msg.getAction();                    boolean setPowerModeOk = device.setScreenPowerMode(mode);                    if (setPowerModeOk) {                        Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));                    }                }                break;            case ControlMessage.TYPE_ROTATE_DEVICE:                device.rotateDevice();                break;            default:                // do nothing        }    }
    private boolean injectKeycode(int action, int keycode, int repeat, int metaState) {        return device.injectKeyEvent(action, keycode, repeat, metaState);    }
    public void testPartialEvents() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(KeyEvent.META_CTRL_ON);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(MotionEvent.ACTION_DOWN);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(KeyEvent.ACTION_UP, event.getAction());        Assert.assertEquals(KeyEvent.KEYCODE_ENTER, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());        event = reader.next();        Assert.assertNull(event); // the event is not complete        bos.reset();        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(KeyEvent.META_CTRL_ON);        packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        // the event is now complete        event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }}
    public void testParseKeycodeEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        // The message type (1 byte) does not count        Assert.assertEquals(ControlMessageReader.INJECT_KEYCODE_PAYLOAD_LENGTH, packet.length - 1);        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(KeyEvent.ACTION_UP, event.getAction());        Assert.assertEquals(KeyEvent.KEYCODE_ENTER, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }
    public void testMultiEvents() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(KeyEvent.META_CTRL_ON);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(KeyEvent.ACTION_UP, event.getAction());        Assert.assertEquals(KeyEvent.KEYCODE_ENTER, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());        event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }
    public void testPartialEvents() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(4); // repeat        dos.writeInt(KeyEvent.META_CTRL_ON);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(MotionEvent.ACTION_DOWN);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(KeyEvent.ACTION_UP, event.getAction());        Assert.assertEquals(KeyEvent.KEYCODE_ENTER, event.getKeycode());        Assert.assertEquals(4, event.getRepeat());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());        event = reader.next();        Assert.assertNull(event); // the event is not complete        bos.reset();        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(5); // repeat        dos.writeInt(KeyEvent.META_CTRL_ON);        packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        // the event is now complete        event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getKeycode());        Assert.assertEquals(5, event.getRepeat());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }}
    public void testParseKeycodeEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(5); // repeat        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        // The message type (1 byte) does not count        Assert.assertEquals(ControlMessageReader.INJECT_KEYCODE_PAYLOAD_LENGTH, packet.length - 1);        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(KeyEvent.ACTION_UP, event.getAction());        Assert.assertEquals(KeyEvent.KEYCODE_ENTER, event.getKeycode());        Assert.assertEquals(5, event.getRepeat());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }
    public void testMultiEvents() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(0); // repeat        dos.writeInt(KeyEvent.META_CTRL_ON);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(1); // repeat        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(KeyEvent.ACTION_UP, event.getAction());        Assert.assertEquals(KeyEvent.KEYCODE_ENTER, event.getKeycode());        Assert.assertEquals(0, event.getRepeat());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());        event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getKeycode());        Assert.assertEquals(1, event.getRepeat());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }
    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid port: %s", optarg);        return false;    }    if (value & ~0xffff) {        LOGE("Port out of range: %ld", value);        return false;    }    *port = (uint16_t) value;    return true;}static boolparse_record_format(const char *optarg, enum recorder_format *format) {    if (!strcmp(optarg, "mp4")) {        *format = RECORDER_FORMAT_MP4;        return true;    }    if (!strcmp(optarg, "mkv")) {        *format = RECORDER_FORMAT_MKV;        return true;    }    LOGE("Unsupported format: %s (expected mp4 or mkv)", optarg);    return false;}static enum recorder_formatguess_record_format(const char *filename) {    size_t len = strlen(filename);    if (len < 4) {        return 0;    }    const char *ext = &filename[len - 4];    if (!strcmp(ext, ".mp4")) {        return RECORDER_FORMAT_MP4;    }    if (!strcmp(ext, ".mkv")) {        return RECORDER_FORMAT_MKV;    }    return 0;}#define OPT_RENDER_EXPIRED_FRAMES 1000#define OPT_WINDOW_TITLE          1001#define OPT_PUSH_TARGET           1002#define OPT_ALWAYS_ON_TOP         1003#define OPT_CROP                  1004#define OPT_RECORD_FORMAT         1005#define OPT_PREFER_TEXT           1006static boolparse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, OPT_CROP},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"push-target",           required_argument, NULL, OPT_PUSH_TARGET},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, OPT_RECORD_FORMAT},
static void usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, OPT_CROP},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"push-target",           required_argument, NULL, OPT_PUSH_TARGET},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, OPT_RECORD_FORMAT},        {"render-expired-frames", no_argument,       NULL,                                                     OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"prefer-text",           no_argument,       NULL, OPT_PREFER_TEXT},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL,                                                     OPT_WINDOW_TITLE},        {NULL,                    0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port(optarg, &opts->port)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
parse_window_position(char *optarg, int16_t *position) {    char *endptr;    if (*optarg == '\0') {        LOGE("Window position parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid window position: %s", optarg);        return false;    }    if (value < -1 || value > 0x7fff) {        LOGE("Window position must be between -1 and 32767: %ld", value);        return false;    }    *position = (int16_t) value;    return true;}
static void usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is -1 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, OPT_CROP},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"push-target",           required_argument, NULL, OPT_PUSH_TARGET},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, OPT_RECORD_FORMAT},        {"render-expired-frames", no_argument,       NULL,                                                     OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"prefer-text",           no_argument,       NULL, OPT_PREFER_TEXT},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",              required_argument, NULL, OPT_WINDOW_X},        {"window-y",              required_argument, NULL, OPT_WINDOW_Y},        {NULL,                    0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port(optarg, &opts->port)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    screen->window = SDL_CreateWindow(window_title, SDL_WINDOWPOS_UNDEFINED,                                      SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    screen->window = SDL_CreateWindow(window_title, SDL_WINDOWPOS_UNDEFINED,                                      SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    int x = window_x != -1 ? window_x : SDL_WINDOWPOS_UNDEFINED;    int y = window_y != -1 ? window_y : SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    int x = window_x != -1 ? window_x : SDL_WINDOWPOS_UNDEFINED;    int y = window_y != -1 ? window_y : SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
    private boolean injectChar(char c) {        String decomposed = KeyComposition.decompose(c);        char[] chars = decomposed != null ? decomposed.toCharArray() : new char[]{c};        KeyEvent[] events = charMap.getEvents(chars);        if (events == null) {            return false;        }        for (KeyEvent event : events) {            if (!injectEvent(event)) {                return false;            }        }        return true;    }
    private boolean injectKeycode(int action, int keycode, int metaState) {        return injectKeyEvent(action, keycode, 0, metaState);    }
    private boolean injectTouch(int action, long pointerId, Position position, float pressure, int buttons) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        int pointerIndex = pointersState.getPointerIndex(pointerId);        if (pointerIndex == -1) {            Ln.w("Too many pointers for touch event");            return false;        }        Pointer pointer = pointersState.get(pointerIndex);        pointer.setPoint(point);        pointer.setPressure(pressure);        pointer.setUp(action == MotionEvent.ACTION_UP);        int pointerCount = pointersState.update(pointerProperties, pointerCoords);        if (pointerCount == 1) {            if (action == MotionEvent.ACTION_DOWN) {                lastTouchDown = now;            }        } else {            // secondary pointers must use ACTION_POINTER_* ORed with the pointerIndex            if (action == MotionEvent.ACTION_UP) {                action = MotionEvent.ACTION_POINTER_UP | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            } else if (action == MotionEvent.ACTION_DOWN) {                action = MotionEvent.ACTION_POINTER_DOWN | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            }        }        MotionEvent event = MotionEvent                .obtain(lastTouchDown, now, action, pointerCount, pointerProperties, pointerCoords, 0, buttons, 1f, 1f, DEVICE_ID_VIRTUAL, 0,                        InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
    private boolean injectKeyEvent(int action, int keyCode, int repeat, int metaState) {        long now = SystemClock.uptimeMillis();        KeyEvent event = new KeyEvent(now, now, action, keyCode, repeat, metaState, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, 0,                InputDevice.SOURCE_KEYBOARD);        return injectEvent(event);    }
    private boolean injectScroll(Position position, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        MotionEvent.PointerProperties props = pointerProperties[0];        props.id = 0;        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.x = point.getX();        coords.y = point.getY();        coords.setAxisValue(MotionEvent.AXIS_HSCROLL, hScroll);        coords.setAxisValue(MotionEvent.AXIS_VSCROLL, vScroll);        MotionEvent event = MotionEvent                .obtain(lastTouchDown, now, MotionEvent.ACTION_SCROLL, 1, pointerProperties, pointerCoords, 0, 0, 1f, 1f, DEVICE_ID_VIRTUAL, 0,                        InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
    public void control() throws IOException {        // on start, power on the device        if (!device.isScreenOn()) {            injectKeycode(KeyEvent.KEYCODE_POWER);            // dirty hack            // After POWER is injected, the device is powered on asynchronously.            // To turn the device screen off while mirroring, the client will send a message that            // would be handled before the device is actually powered on, so its effect would            // be "canceled" once the device is turned back on.            // Adding this delay prevents to handle the message before the device is actually            // powered on.            SystemClock.sleep(500);        }        while (true) {            handleEvent();        }    }
    private boolean pressBackOrTurnScreenOn() {        int keycode = device.isScreenOn() ? KeyEvent.KEYCODE_BACK : KeyEvent.KEYCODE_POWER;        return injectKeycode(keycode);    }}
    private boolean injectChar(char c) {        String decomposed = KeyComposition.decompose(c);        char[] chars = decomposed != null ? decomposed.toCharArray() : new char[]{c};        KeyEvent[] events = charMap.getEvents(chars);        if (events == null) {            return false;        }        for (KeyEvent event : events) {            if (!device.injectEvent(event)) {                return false;            }        }        return true;    }
    private boolean injectKeycode(int action, int keycode, int metaState) {        return device.injectKeyEvent(action, keycode, 0, metaState);    }
    private boolean injectTouch(int action, long pointerId, Position position, float pressure, int buttons) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        int pointerIndex = pointersState.getPointerIndex(pointerId);        if (pointerIndex == -1) {            Ln.w("Too many pointers for touch event");            return false;        }        Pointer pointer = pointersState.get(pointerIndex);        pointer.setPoint(point);        pointer.setPressure(pressure);        pointer.setUp(action == MotionEvent.ACTION_UP);        int pointerCount = pointersState.update(pointerProperties, pointerCoords);        if (pointerCount == 1) {            if (action == MotionEvent.ACTION_DOWN) {                lastTouchDown = now;            }        } else {            // secondary pointers must use ACTION_POINTER_* ORed with the pointerIndex            if (action == MotionEvent.ACTION_UP) {                action = MotionEvent.ACTION_POINTER_UP | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            } else if (action == MotionEvent.ACTION_DOWN) {                action = MotionEvent.ACTION_POINTER_DOWN | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            }        }        MotionEvent event = MotionEvent                .obtain(lastTouchDown, now, action, pointerCount, pointerProperties, pointerCoords, 0, buttons, 1f, 1f, DEVICE_ID_VIRTUAL, 0,                        InputDevice.SOURCE_TOUCHSCREEN, 0);        return device.injectEvent(event);    }
    }}
    private boolean injectScroll(Position position, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        MotionEvent.PointerProperties props = pointerProperties[0];        props.id = 0;        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.x = point.getX();        coords.y = point.getY();        coords.setAxisValue(MotionEvent.AXIS_HSCROLL, hScroll);        coords.setAxisValue(MotionEvent.AXIS_VSCROLL, vScroll);        MotionEvent event = MotionEvent                .obtain(lastTouchDown, now, MotionEvent.ACTION_SCROLL, 1, pointerProperties, pointerCoords, 0, 0, 1f, 1f, DEVICE_ID_VIRTUAL, 0,                        InputDevice.SOURCE_TOUCHSCREEN, 0);        return device.injectEvent(event);    }
    public void control() throws IOException {        // on start, power on the device        if (!device.isScreenOn()) {            device.injectKeycode(KeyEvent.KEYCODE_POWER);            // dirty hack            // After POWER is injected, the device is powered on asynchronously.            // To turn the device screen off while mirroring, the client will send a message that            // would be handled before the device is actually powered on, so its effect would            // be "canceled" once the device is turned back on.            // Adding this delay prevents to handle the message before the device is actually            // powered on.            SystemClock.sleep(500);        }        while (true) {            handleEvent();        }    }
    private boolean pressBackOrTurnScreenOn() {        int keycode = device.isScreenOn() ? KeyEvent.KEYCODE_BACK : KeyEvent.KEYCODE_POWER;        return device.injectKeycode(keycode);    }}
    public boolean injectInputEvent(InputEvent inputEvent, int mode) {        if (!supportsInputEvents()) {            throw new AssertionError("Could not inject input event if !supportsInputEvents()");        }        if (displayId != 0 && !InputManager.setDisplayId(inputEvent, displayId)) {            return false;        }        return serviceManager.getInputManager().injectInputEvent(inputEvent, mode);    }
    public boolean injectInputEvent(InputEvent inputEvent, int mode) {        if (!supportsInputEvents()) {            throw new AssertionError("Could not inject input event if !supportsInputEvents()");        }        if (displayId != 0 && !InputManager.setDisplayId(inputEvent, displayId)) {            return false;        }        return serviceManager.getInputManager().injectInputEvent(inputEvent, mode);    }
    public boolean injectInputEvent(InputEvent inputEvent, int mode) {        if (!supportsInputEvents()) {            throw new AssertionError("Could not inject input event if !supportsInputEvents()");        }        if (displayId != 0 && !InputManager.setDisplayId(inputEvent, displayId)) {            return false;        }        return serviceManager.getInputManager().injectInputEvent(inputEvent, mode);    }
    public boolean injectInputEvent(InputEvent inputEvent, int mode) {        if (!supportsInputEvents()) {            throw new AssertionError("Could not inject input event if !supportsInputEvents()");        }        if (displayId != 0 && !InputManager.setDisplayId(inputEvent, displayId)) {            return false;        }        return serviceManager.getInputManager().injectInputEvent(inputEvent, mode);    }
    public boolean injectInputEvent(InputEvent inputEvent, int mode) {        if (!supportsInputEvents()) {            throw new AssertionError("Could not inject input event if !supportsInputEvents()");        }        if (displayId != 0 && !InputManager.setDisplayId(inputEvent, displayId)) {            return false;        }        return serviceManager.getInputManager().injectInputEvent(inputEvent, mode);    }
    public boolean supportsInputEvents() {        return supportsInputEvents;    }    public boolean injectEvent(InputEvent inputEvent, int mode) {        if (!supportsInputEvents()) {            throw new AssertionError("Could not inject input event if !supportsInputEvents()");        }        if (displayId != 0 && !InputManager.setDisplayId(inputEvent, displayId)) {            return false;        }
    public boolean injectEvent(InputEvent inputEvent, int mode) {        if (!supportsInputEvents()) {            throw new AssertionError("Could not inject input event if !supportsInputEvents()");        }        if (displayId != 0 && !InputManager.setDisplayId(inputEvent, displayId)) {            return false;        }        return serviceManager.getInputManager().injectInputEvent(inputEvent, mode);    }
    public boolean injectKeyEvent(int action, int keyCode, int repeat, int metaState) {        long now = SystemClock.uptimeMillis();        KeyEvent event = new KeyEvent(now, now, action, keyCode, repeat, metaState, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, 0,                InputDevice.SOURCE_KEYBOARD);        return injectEvent(event);    }
    public boolean injectEvent(InputEvent event) {        return injectEvent(event, InputManager.INJECT_INPUT_EVENT_MODE_ASYNC);    }
    public boolean injectKeycode(int keyCode) {        return injectKeyEvent(KeyEvent.ACTION_DOWN, keyCode, 0, 0) && injectKeyEvent(KeyEvent.ACTION_UP, keyCode, 0, 0);    }
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation, bool mipmaps) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size = get_rotated_size(frame_size, screen->rotation);    screen->content_size = content_size;    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_RendererInfo renderer_info;    int r = SDL_GetRendererInfo(screen->renderer, &renderer_info);    const char *renderer_name = r ? NULL : renderer_info.name;    LOGI("Renderer: %s", renderer_name ? renderer_name : "(unknown)");    if (SDL_RenderSetLogicalSize(screen->renderer, content_size.width,                                 content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    // stats with "opengl"    screen->use_opengl = renderer_name && !strncmp(renderer_name, "opengl", 6);    if (screen->use_opengl) {        struct sc_opengl *gl = &screen->gl;        sc_opengl_init(gl);        LOGI("OpenGL version: %s", gl->version);        if (mipmaps) {            bool supports_mipmaps =                sc_opengl_version_at_least(gl, 3, 0, /* OpenGL 3.0+ */                                               2, 0  /* OpenGL ES 2.0+ */);            if (supports_mipmaps) {                LOGI("Trilinear filtering enabled");                screen->mipmaps = true;            } else {                LOGW("Trilinear filtering disabled "                     "(OpenGL 3.0+ or ES 2.0+ required)");            }        } else {            LOGI("Trilinear filtering disabled");        }    } else {        LOGW("Trilinear filtering disabled (not an OpenGL renderer)");    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation, bool mipmaps) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size = get_rotated_size(frame_size, screen->rotation);    screen->content_size = content_size;    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_RendererInfo renderer_info;    int r = SDL_GetRendererInfo(screen->renderer, &renderer_info);    const char *renderer_name = r ? NULL : renderer_info.name;    LOGI("Renderer: %s", renderer_name ? renderer_name : "(unknown)");    if (SDL_RenderSetLogicalSize(screen->renderer, content_size.width,                                 content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    // starts with "opengl"    screen->use_opengl = renderer_name && !strncmp(renderer_name, "opengl", 6);    if (screen->use_opengl) {        struct sc_opengl *gl = &screen->gl;        sc_opengl_init(gl);        LOGI("OpenGL version: %s", gl->version);        if (mipmaps) {            bool supports_mipmaps =                sc_opengl_version_at_least(gl, 3, 0, /* OpenGL 3.0+ */                                               2, 0  /* OpenGL ES 2.0+ */);            if (supports_mipmaps) {                LOGI("Trilinear filtering enabled");                screen->mipmaps = true;            } else {                LOGW("Trilinear filtering disabled "                     "(OpenGL 3.0+ or ES 2.0+ required)");            }        } else {            LOGI("Trilinear filtering disabled");        }    } else {        LOGW("Trilinear filtering disabled (not an OpenGL renderer)");    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
event_loop(bool display, bool control) {    (void) display;#ifdef CONTINUOUS_RESIZING_WORKAROUND    if (display) {        SDL_AddEventWatch(event_watcher, NULL);    }#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        enum event_result result = handle_event(&event, control);        switch (result) {            case EVENT_RESULT_STOPPED_BY_USER:                return true;            case EVENT_RESULT_STOPPED_BY_EOS:                LOGW("Device disconnected");                return false;            case EVENT_RESULT_CONTINUE:                break;        }    }    return false;}
handle_event(SDL_Event *event, bool control) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = true;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return EVENT_RESULT_CONTINUE;            }            break;        case SDL_WINDOWEVENT:            screen_handle_window_event(&screen, &event->window);            break;        case SDL_TEXTINPUT:            if (!control) {                break;            }            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            // some key events do not interact with the device, so process the            // event even if control is disabled            input_manager_process_key(&input_manager, &event->key);            break;        case SDL_MOUSEMOTION:            if (!control) {                break;            }            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            if (!control) {                break;            }            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            // some mouse events do not interact with the device, so process            // the event even if control is disabled            input_manager_process_mouse_button(&input_manager, &event->button);            break;        case SDL_FINGERMOTION:        case SDL_FINGERDOWN:        case SDL_FINGERUP:            input_manager_process_touch(&input_manager, &event->tfinger);            break;        case SDL_DROPFILE: {            if (!control) {                break;            }            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .log_level = options->log_level,        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,        .show_touches = options->show_touches,        .stay_awake = options->stay_awake,        .codec_options = options->codec_options,        .force_adb_forward = options->force_adb_forward,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver,                                options->disable_screensaver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options-> mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    input_manager_init(&input_manager, options);    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    server_destroy(&server);    return ret;}
handle_event(SDL_Event *event, bool control) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = true;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return EVENT_RESULT_CONTINUE;            }            break;        case SDL_WINDOWEVENT:            screen_handle_window_event(&screen, &event->window);            break;        case SDL_TEXTINPUT:            if (!control) {                break;            }            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            // some key events do not interact with the device, so process the            // event even if control is disabled            input_manager_process_key(&input_manager, &event->key);            break;        case SDL_MOUSEMOTION:            if (!control) {                break;            }            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            if (!control) {                break;            }            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            // some mouse events do not interact with the device, so process            // the event even if control is disabled            input_manager_process_mouse_button(&input_manager, &event->button);            break;        case SDL_FINGERMOTION:        case SDL_FINGERDOWN:        case SDL_FINGERUP:            input_manager_process_touch(&input_manager, &event->tfinger);            break;        case SDL_DROPFILE: {            if (!control) {                break;            }            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
event_loop(bool display, bool control) {    (void) display;#ifdef CONTINUOUS_RESIZING_WORKAROUND    if (display) {        SDL_AddEventWatch(event_watcher, NULL);    }#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        enum event_result result = handle_event(&event, control);        switch (result) {            case EVENT_RESULT_STOPPED_BY_USER:                return true;            case EVENT_RESULT_STOPPED_BY_EOS:                LOGW("Device disconnected");                return false;            case EVENT_RESULT_CONTINUE:                break;        }    }    return false;}
event_loop(const struct scrcpy_options *options) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    if (options->display) {        SDL_AddEventWatch(event_watcher, NULL);    }#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        enum event_result result = handle_event(&event, options);        switch (result) {            case EVENT_RESULT_STOPPED_BY_USER:                return true;            case EVENT_RESULT_STOPPED_BY_EOS:                LOGW("Device disconnected");                return false;            case EVENT_RESULT_CONTINUE:                break;        }    }    return false;}static SDL_LogPriority
handle_event(SDL_Event *event, const struct scrcpy_options *options) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = true;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return EVENT_RESULT_CONTINUE;            }            break;        case SDL_WINDOWEVENT:            screen_handle_window_event(&screen, &event->window);            break;        case SDL_TEXTINPUT:            if (!options->control) {                break;            }            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            // some key events do not interact with the device, so process the            // event even if control is disabled            input_manager_process_key(&input_manager, &event->key);            break;        case SDL_MOUSEMOTION:            if (!options->control) {                break;            }            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            if (!options->control) {                break;            }            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            // some mouse events do not interact with the device, so process            // the event even if control is disabled            input_manager_process_mouse_button(&input_manager, &event->button);            break;        case SDL_FINGERMOTION:        case SDL_FINGERDOWN:        case SDL_FINGERUP:            input_manager_process_touch(&input_manager, &event->tfinger);            break;        case SDL_DROPFILE: {            if (!options->control) {                break;            }            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .log_level = options->log_level,        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,        .show_touches = options->show_touches,        .stay_awake = options->stay_awake,        .codec_options = options->codec_options,        .force_adb_forward = options->force_adb_forward,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver,                                options->disable_screensaver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options-> mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    input_manager_init(&input_manager, options);    ret = event_loop(options);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    server_destroy(&server);    return ret;}
handle_event(SDL_Event *event, const struct scrcpy_options *options) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = true;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return EVENT_RESULT_CONTINUE;            }            break;        case SDL_WINDOWEVENT:            screen_handle_window_event(&screen, &event->window);            break;        case SDL_TEXTINPUT:            if (!options->control) {                break;            }            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            // some key events do not interact with the device, so process the            // event even if control is disabled            input_manager_process_key(&input_manager, &event->key);            break;        case SDL_MOUSEMOTION:            if (!options->control) {                break;            }            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            if (!options->control) {                break;            }            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            // some mouse events do not interact with the device, so process            // the event even if control is disabled            input_manager_process_mouse_button(&input_manager, &event->button);            break;        case SDL_FINGERMOTION:        case SDL_FINGERDOWN:        case SDL_FINGERUP:            input_manager_process_touch(&input_manager, &event->tfinger);            break;        case SDL_DROPFILE: {            if (!options->control) {                break;            }            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
event_loop(const struct scrcpy_options *options) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    if (options->display) {        SDL_AddEventWatch(event_watcher, NULL);    }#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        enum event_result result = handle_event(&event, options);        switch (result) {            case EVENT_RESULT_STOPPED_BY_USER:                return true;            case EVENT_RESULT_STOPPED_BY_EOS:                LOGW("Device disconnected");                return false;            case EVENT_RESULT_CONTINUE:                break;        }    }    return false;}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value. Values are integers in the\n"        "        range [-1..3]. Natural device orientation is 0 and each\n"        "        increment adds 90 degrees counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value. Values are integers in the\n"        "        range [-1..3]. Natural device orientation is 0 and each\n"        "        increment adds 90 degrees counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
static const char *adb_command;static inline const char *get_adb_command(void) {    if (!adb_command) {        adb_command = getenv("ADB");        if (!adb_command)            adb_command = "adb";    }    return adb_command;}// serialize argv to string "[arg1], [arg2], [arg3]"static size_targv_to_string(const char *const *argv, char *buf, size_t bufsize) {    size_t idx = 0;
is_regular_file(const char *path) {    struct stat path_stat;    int r = stat(path, &path_stat);    if (r) {        perror("stat");        return false;    }    return S_ISREG(path_stat.st_mode);}
push_server(const char *serial) {    process_t process = adb_push(serial, get_server_path(), DEVICE_SERVER_PATH);    return process_check_success(process, "adb push");}
push_server(const char *serial) {    const char *server_path = get_server_path();    if (!is_regular_file(server_path)) {        LOGE("'%s' does not exist or is not a regular file\n", server_path);        return false;    }    process_t process = adb_push(serial, server_path, DEVICE_SERVER_PATH);    return process_check_success(process, "adb push");}
    public static void fillAppInfo() {        try {            // ActivityThread activityThread = new ActivityThread();            Class<?> activityThreadClass = Class.forName("android.app.ActivityThread");            Constructor<?> activityThreadConstructor = activityThreadClass.getDeclaredConstructor();            activityThreadConstructor.setAccessible(true);            Object activityThread = activityThreadConstructor.newInstance();            // ActivityThread.sCurrentActivityThread = activityThread;            Field sCurrentActivityThreadField = activityThreadClass.getDeclaredField("sCurrentActivityThread");            sCurrentActivityThreadField.setAccessible(true);            sCurrentActivityThreadField.set(null, activityThread);            // ActivityThread.AppBindData appBindData = new ActivityThread.AppBindData();            Class<?> appBindDataClass = Class.forName("android.app.ActivityThread$AppBindData");            Constructor<?> appBindDataConstructor = appBindDataClass.getDeclaredConstructor();            appBindDataConstructor.setAccessible(true);            Object appBindData = appBindDataConstructor.newInstance();            ApplicationInfo applicationInfo = new ApplicationInfo();            applicationInfo.packageName = "com.genymobile.scrcpy";            // appBindData.appInfo = applicationInfo;            Field appInfoField = appBindDataClass.getDeclaredField("appInfo");            appInfoField.setAccessible(true);            appInfoField.set(appBindData, applicationInfo);            // activityThread.mBoundApplication = appBindData;            Field mBoundApplicationField = activityThreadClass.getDeclaredField("mBoundApplication");            mBoundApplicationField.setAccessible(true);            mBoundApplicationField.set(activityThread, appBindData);            // Context ctx = activityThread.getSystemContext();            Method getSystemContextMethod = activityThreadClass.getDeclaredMethod("getSystemContext");            Context ctx = (Context) getSystemContextMethod.invoke(activityThread);            Application app = Instrumentation.newApplication(Application.class, ctx);            // activityThread.mInitialApplication = app;            Field mInitialApplicationField = activityThreadClass.getDeclaredField("mInitialApplication");            mInitialApplicationField.setAccessible(true);            mInitialApplicationField.set(activityThread, app);        } catch (Throwable throwable) {            // this is a workaround, so failing is not an error            Ln.w("Could not fill app info: " + throwable.getMessage());        }    }}
    public static void fillAppInfo() {        try {            // ActivityThread activityThread = new ActivityThread();            Class<?> activityThreadClass = Class.forName("android.app.ActivityThread");            Constructor<?> activityThreadConstructor = activityThreadClass.getDeclaredConstructor();            activityThreadConstructor.setAccessible(true);            Object activityThread = activityThreadConstructor.newInstance();            // ActivityThread.sCurrentActivityThread = activityThread;            Field sCurrentActivityThreadField = activityThreadClass.getDeclaredField("sCurrentActivityThread");            sCurrentActivityThreadField.setAccessible(true);            sCurrentActivityThreadField.set(null, activityThread);            // ActivityThread.AppBindData appBindData = new ActivityThread.AppBindData();            Class<?> appBindDataClass = Class.forName("android.app.ActivityThread$AppBindData");            Constructor<?> appBindDataConstructor = appBindDataClass.getDeclaredConstructor();            appBindDataConstructor.setAccessible(true);            Object appBindData = appBindDataConstructor.newInstance();            ApplicationInfo applicationInfo = new ApplicationInfo();            applicationInfo.packageName = "com.genymobile.scrcpy";            // appBindData.appInfo = applicationInfo;            Field appInfoField = appBindDataClass.getDeclaredField("appInfo");            appInfoField.setAccessible(true);            appInfoField.set(appBindData, applicationInfo);            // activityThread.mBoundApplication = appBindData;            Field mBoundApplicationField = activityThreadClass.getDeclaredField("mBoundApplication");            mBoundApplicationField.setAccessible(true);            mBoundApplicationField.set(activityThread, appBindData);            // Context ctx = activityThread.getSystemContext();            Method getSystemContextMethod = activityThreadClass.getDeclaredMethod("getSystemContext");            Context ctx = (Context) getSystemContextMethod.invoke(activityThread);            Application app = Instrumentation.newApplication(Application.class, ctx);            // activityThread.mInitialApplication = app;            Field mInitialApplicationField = activityThreadClass.getDeclaredField("mInitialApplication");            mInitialApplicationField.setAccessible(true);            mInitialApplicationField.set(activityThread, app);        } catch (Throwable throwable) {            // this is a workaround, so failing is not an error            Ln.d("Could not fill app info: " + throwable.getMessage());        }    }}
        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}static boolparse_integer_arg(const char *s, long *out, bool accept_suffix, long min,                  long max, const char *name) {    long value;    bool ok;    if (accept_suffix) {        ok = parse_integer_with_suffix(s, &value);    } else {        ok = parse_integer(s, &value);    }    if (!ok) {        LOGE("Could not parse %s: %s", name, s);        return false;    }    if (value < min || value > max) {        LOGE("Could not parse %s: value (%ld) out-of-range (%ld; %ld)",             name, value, min, max);        return false;    }    *out = value;    return true;}static size_tparse_integers_arg(const char *s, size_t max_items, long *out, long min,                   long max, const char *name) {    size_t count = parse_integers(s, ':', max_items, out);    if (!count) {        LOGE("Could not parse %s: %s", name, s);        return 0;    }    for (size_t i = 0; i < count; ++i) {        long value = out[i];        if (value < min || value > max) {            LOGE("Could not parse %s: value (%ld) out-of-range (%ld; %ld)",                 name, value, min, max);            return 0;        }    }    return count;}static boolparse_bit_rate(const char *s, uint32_t *bit_rate) {    long value;    // long may be 32 bits (it is the case on mingw), so do not use more than    // 31 bits (long is signed)    bool ok = parse_integer_arg(s, &value, true, 0, 0x7FFFFFFF, "bit-rate");    if (!ok) {        return false;    }    *bit_rate = (uint32_t) value;    return true;}static boolparse_max_size(const char *s, uint16_t *max_size) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF, "max size");    if (!ok) {        return false;    }    *max_size = (uint16_t) value;    return true;}static boolparse_max_fps(const char *s, uint16_t *max_fps) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 1000, "max fps");    if (!ok) {        return false;    }    *max_fps = (uint16_t) value;    return true;}static boolparse_lock_video_orientation(const char *s, int8_t *lock_video_orientation) {    long value;    bool ok = parse_integer_arg(s, &value, false, -1, 3,                                "lock video orientation");    if (!ok) {        return false;    }    *lock_video_orientation = (int8_t) value;    return true;}static boolparse_rotation(const char *s, uint8_t *rotation) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 3, "rotation");    if (!ok) {        return false;    }    *rotation = (uint8_t) value;    return true;}static boolparse_window_position(const char *s, int16_t *position) {    // special value for "auto"    static_assert(SC_WINDOW_POSITION_UNDEFINED == -0x8000, "unexpected value");    if (!strcmp(s, "auto")) {        *position = SC_WINDOW_POSITION_UNDEFINED;        return true;    }    long value;    bool ok = parse_integer_arg(s, &value, false, -0x7FFF, 0x7FFF,                                "window position");    if (!ok) {        return false;    }    *position = (int16_t) value;    return true;}static boolparse_window_dimension(const char *s, uint16_t *dimension) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF,                                "window dimension");    if (!ok) {        return false;    }    *dimension = (uint16_t) value;    return true;}static boolparse_port_range(const char *s, struct sc_port_range *port_range) {    long values[2];    size_t count = parse_integers_arg(s, 2, values, 0, 0xFFFF, "port");    if (!count) {        return false;    }    uint16_t v0 = (uint16_t) values[0];    if (count == 1) {        port_range->first = v0;        port_range->last = v0;        return true;    }    assert(count == 2);    uint16_t v1 = (uint16_t) values[1];
        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}static boolparse_integer_arg(const char *s, long *out, bool accept_suffix, long min,                  long max, const char *name) {    long value;    bool ok;    if (accept_suffix) {        ok = parse_integer_with_suffix(s, &value);    } else {        ok = parse_integer(s, &value);    }    if (!ok) {        LOGE("Could not parse %s: %s", name, s);        return false;    }    if (value < min || value > max) {        LOGE("Could not parse %s: value (%ld) out-of-range (%ld; %ld)",             name, value, min, max);        return false;    }    *out = value;    return true;}static size_tparse_integers_arg(const char *s, size_t max_items, long *out, long min,                   long max, const char *name) {    size_t count = parse_integers(s, ':', max_items, out);    if (!count) {        LOGE("Could not parse %s: %s", name, s);        return 0;    }    for (size_t i = 0; i < count; ++i) {        long value = out[i];        if (value < min || value > max) {            LOGE("Could not parse %s: value (%ld) out-of-range (%ld; %ld)",                 name, value, min, max);            return 0;        }    }    return count;}static boolparse_bit_rate(const char *s, uint32_t *bit_rate) {    long value;    // long may be 32 bits (it is the case on mingw), so do not use more than    // 31 bits (long is signed)    bool ok = parse_integer_arg(s, &value, true, 0, 0x7FFFFFFF, "bit-rate");    if (!ok) {        return false;    }    *bit_rate = (uint32_t) value;    return true;}static boolparse_max_size(const char *s, uint16_t *max_size) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF, "max size");    if (!ok) {        return false;    }    *max_size = (uint16_t) value;    return true;}static boolparse_max_fps(const char *s, uint16_t *max_fps) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 1000, "max fps");    if (!ok) {        return false;    }    *max_fps = (uint16_t) value;    return true;}static boolparse_lock_video_orientation(const char *s, int8_t *lock_video_orientation) {    long value;    bool ok = parse_integer_arg(s, &value, false, -1, 3,                                "lock video orientation");    if (!ok) {        return false;    }    *lock_video_orientation = (int8_t) value;    return true;}static boolparse_rotation(const char *s, uint8_t *rotation) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 3, "rotation");    if (!ok) {        return false;    }    *rotation = (uint8_t) value;    return true;}static boolparse_window_position(const char *s, int16_t *position) {    // special value for "auto"    static_assert(SC_WINDOW_POSITION_UNDEFINED == -0x8000, "unexpected value");    if (!strcmp(s, "auto")) {        *position = SC_WINDOW_POSITION_UNDEFINED;        return true;    }    long value;    bool ok = parse_integer_arg(s, &value, false, -0x7FFF, 0x7FFF,                                "window position");    if (!ok) {        return false;    }    *position = (int16_t) value;    return true;}static boolparse_window_dimension(const char *s, uint16_t *dimension) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF,                                "window dimension");    if (!ok) {        return false;    }    *dimension = (uint16_t) value;    return true;}static boolparse_port_range(const char *s, struct sc_port_range *port_range) {    long values[2];    size_t count = parse_integers_arg(s, 2, values, 0, 0xFFFF, "port");    if (!count) {        return false;    }    uint16_t v0 = (uint16_t) values[0];    if (count == 1) {        port_range->first = v0;        port_range->last = v0;        return true;    }    assert(count == 2);    uint16_t v1 = (uint16_t) values[1];
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        Switch fullscreen mode\n"        "\n"        "    Ctrl+Left\n"        "        Rotate display left\n"        "\n"        "    Ctrl+Right\n"        "        Rotate display right\n"        "\n"        "    Ctrl+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    Ctrl+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    Ctrl+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    Ctrl+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    Ctrl+r\n"        "        Rotate device screen\n"        "\n"        "    Ctrl+n\n"        "        Expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    Ctrl+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    Ctrl+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    Ctrl+Shift+v\n"        "        Copy computer clipboard to device (and paste if the device\n"        "        runs Android >= 7)\n"        "\n"        "    Ctrl+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"codec-options",          required_argument, NULL, OPT_CODEC_OPTIONS},        {"crop",                   required_argument, NULL, OPT_CROP},        {"disable-screensaver",    no_argument,       NULL,                                                  OPT_DISABLE_SCREENSAVER},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"force-adb-forward",      no_argument,       NULL,                                                  OPT_FORCE_ADB_FORWARD},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"port",                   required_argument, NULL, 'p'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"stay-awake",             no_argument,       NULL, 'w'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"verbosity",              required_argument, NULL, 'V'},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTvV:w",                            long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case 'V':                if (!parse_log_level(optarg, &opts->log_level)) {                    return false;                }                break;            case 'w':                opts->stay_awake = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            case OPT_CODEC_OPTIONS:                opts->codec_options = optarg;                break;            case OPT_FORCE_ADB_FORWARD:                opts->force_adb_forward = true;                break;            case OPT_DISABLE_SCREENSAVER:                opts->disable_screensaver = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    if (!opts->control && opts->stay_awake) {        LOGE("Could not request to stay awake if control is disabled");        return false;    }    return true;}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"codec-options",          required_argument, NULL, OPT_CODEC_OPTIONS},        {"crop",                   required_argument, NULL, OPT_CROP},        {"disable-screensaver",    no_argument,       NULL,                                                  OPT_DISABLE_SCREENSAVER},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"force-adb-forward",      no_argument,       NULL,                                                  OPT_FORCE_ADB_FORWARD},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"port",                   required_argument, NULL, 'p'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"stay-awake",             no_argument,       NULL, 'w'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"verbosity",              required_argument, NULL, 'V'},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTvV:w",                            long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case 'V':                if (!parse_log_level(optarg, &opts->log_level)) {                    return false;                }                break;            case 'w':                opts->stay_awake = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            case OPT_CODEC_OPTIONS:                opts->codec_options = optarg;                break;            case OPT_FORCE_ADB_FORWARD:                opts->force_adb_forward = true;                break;            case OPT_DISABLE_SCREENSAVER:                opts->disable_screensaver = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    if (!opts->control && opts->stay_awake) {        LOGE("Could not request to stay awake if control is disabled");        return false;    }    return true;}
parse_shortcut_mods(const char *s, struct sc_shortcut_mods *mods) {    unsigned count = 0;    unsigned current = 0;    // LCtrl+LAlt or RCtrl or LCtrl+RSuper: "lctrl+lalt,rctrl,lctrl+rsuper"    for (;;) {        char *comma = strchr(s, ',');        if (comma && count == SC_MAX_SHORTCUT_MODS - 1) {            assert(count < SC_MAX_SHORTCUT_MODS);            LOGW("Too many shortcut modifiers alternatives");            return false;        }        assert(!comma || comma > s);        size_t limit = comma ? (size_t) (comma - s) : strlen(s);        unsigned mod = parse_shortcut_mods_item(s, limit);        if (!mod) {            LOGE("Invalid modifier keys: %.*s", (int) limit, s);            return false;        }        mods->data[current++] = mod;        ++count;        if (!comma) {            break;        }        s = comma + 1;    }    mods->count = count;    return true;}
sc_parse_shortcut_mods(const char *s, struct sc_shortcut_mods *mods) {    return parse_shortcut_mods(s, mods);}#endif
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    --shortcut-mod key[+...]][,...]\n"        "        Specify the modifiers to use for scrcpy shortcuts.\n"        "        Possible keys are \"lctrl\", \"rctrl\", \"lalt\", \"ralt\",\n"        "        \"lsuper\" and \"rsuper\".\n"        "\n"        "        A shortcut can consist in several keys, separated by '+'.\n"        "        Several shortcuts can be specified, separated by ','.\n"        "\n"        "        For example, to use either LCtrl+LAlt or LSuper for scrcpy\n"        "        shortcuts, pass \"lctrl+lalt,lsuper\".\n"        "\n"        "        Default is \"lalt\" (left-Alt).\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    In the following list, MOD is the shortcut modifier. By default,\n"        "    it's (left) Alt, but it can be configured by --shortcut-mod.\n"        "\n"        "    MOD+f\n"        "        Switch fullscreen mode\n"        "\n"        "    MOD+Left\n"        "        Rotate display left\n"        "\n"        "    MOD+Right\n"        "        Rotate display right\n"        "\n"        "    MOD+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    MOD+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    MOD+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    MOD+b\n"        "    MOD+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    MOD+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    MOD+m\n"        "        Click on MENU\n"        "\n"        "    MOD+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    MOD+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    MOD+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    MOD+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    MOD+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    MOD+r\n"        "        Rotate device screen\n"        "\n"        "    MOD+n\n"        "        Expand notification panel\n"        "\n"        "    MOD+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    MOD+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    MOD+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    MOD+Shift+v\n"        "        Copy computer clipboard to device (and paste if the device\n"        "        runs Android >= 7)\n"        "\n"        "    MOD+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"codec-options",          required_argument, NULL, OPT_CODEC_OPTIONS},        {"crop",                   required_argument, NULL, OPT_CROP},        {"disable-screensaver",    no_argument,       NULL,                                                  OPT_DISABLE_SCREENSAVER},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"force-adb-forward",      no_argument,       NULL,                                                  OPT_FORCE_ADB_FORWARD},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"port",                   required_argument, NULL, 'p'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"shortcut-mod",           required_argument, NULL, OPT_SHORTCUT_MOD},        {"show-touches",           no_argument,       NULL, 't'},        {"stay-awake",             no_argument,       NULL, 'w'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"verbosity",              required_argument, NULL, 'V'},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTvV:w",                            long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case 'V':                if (!parse_log_level(optarg, &opts->log_level)) {                    return false;                }                break;            case 'w':                opts->stay_awake = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            case OPT_CODEC_OPTIONS:                opts->codec_options = optarg;                break;            case OPT_FORCE_ADB_FORWARD:                opts->force_adb_forward = true;                break;            case OPT_DISABLE_SCREENSAVER:                opts->disable_screensaver = true;                break;            case OPT_SHORTCUT_MOD:                if (!parse_shortcut_mods(optarg, &opts->shortcut_mods)) {                    return false;                }                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    if (!opts->control && opts->stay_awake) {        LOGE("Could not request to stay awake if control is disabled");        return false;    }    return true;}
parse_shortcut_mods_item(const char *item, size_t len) {    unsigned mod = 0;    for (;;) {        char *plus = strchr(item, '+');        // strchr() does not consider the "len" parameter, to it could find an        // occurrence too far in the string (there is no strnchr())        bool has_plus = plus && plus < item + len;        assert(!has_plus || plus > item);        size_t key_len = has_plus ? (size_t) (plus - item) : len;#define STREQ(literal, s, len) \    ((sizeof(literal)-1 == len) && !memcmp(literal, s, len))        if (STREQ("lctrl", item, key_len)) {            mod |= SC_MOD_LCTRL;        } else if (STREQ("rctrl", item, key_len)) {            mod |= SC_MOD_RCTRL;        } else if (STREQ("lalt", item, key_len)) {            mod |= SC_MOD_LALT;        } else if (STREQ("ralt", item, key_len)) {            mod |= SC_MOD_RALT;        } else if (STREQ("lsuper", item, key_len)) {            mod |= SC_MOD_LSUPER;        } else if (STREQ("rsuper", item, key_len)) {            mod |= SC_MOD_RSUPER;        } else {            LOGW("Unknown modifier key: %.*s", (int) key_len, item);            return 0;        }#undef STREQ        if (!has_plus) {            break;        }        item = plus + 1;        assert(len >= key_len + 1);        len -= key_len + 1;    }    return mod;}
            bool outside = x < r->x || x >= r->x + r->w                        || y < r->y || y >= r->y + r->h;            if (outside) {                screen_resize_to_fit(im->screen);                return;            }        }        // otherwise, send the click event to the device    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_mouse_button(event, im->screen, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject mouse button event'");        }    }}static boolconvert_mouse_wheel(const SDL_MouseWheelEvent *from, struct screen *screen,                    struct control_msg *to) {    // mouse_x and mouse_y are expressed in pixels relative to the window    int mouse_x;    int mouse_y;    SDL_GetMouseState(&mouse_x, &mouse_y);    struct position position = {        .screen_size = screen->frame_size,        .point = screen_convert_window_to_frame_coords(screen,                                                       mouse_x, mouse_y),    };    to->type = CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT;    to->inject_scroll_event.position = position;    to->inject_scroll_event.hscroll = from->x;    to->inject_scroll_event.vscroll = from->y;    return true;}voidinput_manager_process_mouse_wheel(struct input_manager *im,                                  const SDL_MouseWheelEvent *event) {    struct control_msg msg;    if (convert_mouse_wheel(event, im->screen, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject mouse wheel event'");        }    }}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    if (alt || meta) {        // no shortcuts involve Alt or Meta, and they must not be forwarded to        // the device        return;    }    struct controller *controller = im->controller;    // capture all Ctrl events    if (ctrl) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                if (control && ctrl && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && ctrl && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && ctrl && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                if (control && ctrl && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && ctrl && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && ctrl && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && ctrl && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && ctrl && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (ctrl && !shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (ctrl && !shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && ctrl && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && ctrl && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (ctrl && !shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (ctrl && !shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (ctrl && !shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (ctrl && !shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && ctrl && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && ctrl && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    if (alt || meta) {        // no shortcuts involve Alt or Meta, and they must not be forwarded to        // the device        return;    }    struct controller *controller = im->controller;    // capture all Ctrl events    if (ctrl) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                if (control && ctrl && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && ctrl && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && ctrl && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                if (control && ctrl && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && ctrl && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && ctrl && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && ctrl && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && ctrl && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (ctrl && !shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (ctrl && !shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && ctrl && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && ctrl && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (ctrl && !shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (ctrl && !shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (ctrl && !shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (ctrl && !shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && ctrl && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && ctrl && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    if (alt || meta) {        // no shortcuts involve Alt or Meta, and they must not be forwarded to        // the device        return;    }    struct controller *controller = im->controller;    // capture all Ctrl events    if (ctrl) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                if (control && ctrl && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && ctrl && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && ctrl && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                if (control && ctrl && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && ctrl && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && ctrl && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && ctrl && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && ctrl && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (ctrl && !shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (ctrl && !shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && ctrl && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && ctrl && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (ctrl && !shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (ctrl && !shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (ctrl && !shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (ctrl && !shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && ctrl && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && ctrl && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_init(struct input_manager *im, bool prefer_text,                   const struct sc_shortcut_mods *shortcut_mods){    im->prefer_text = prefer_text;    assert(shortcut_mods->count);    assert(shortcut_mods->count < SC_MAX_SHORTCUT_MODS);    for (unsigned i = 0; i < shortcut_mods->count; ++i) {        uint16_t sdl_mod = to_sdl_mod(shortcut_mods->data[i]);        assert(sdl_mod);        im->sdl_shortcut_mods.data[i] = sdl_mod;    }    im->sdl_shortcut_mods.count = shortcut_mods->count;}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    bool smod = is_shortcut_mod(im, event->keysym.mod);    struct controller *controller = im->controller;    // The shortcut modifier is pressed    if (smod) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                if (control && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                if (control && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (!shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (!shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
to_sdl_mod(unsigned mod) {    uint16_t sdl_mod = 0;    if (mod & SC_MOD_LCTRL) {        sdl_mod |= KMOD_LCTRL;    }    if (mod & SC_MOD_RCTRL) {        sdl_mod |= KMOD_RCTRL;    }    if (mod & SC_MOD_LALT) {        sdl_mod |= KMOD_LALT;    }    if (mod & SC_MOD_RALT) {        sdl_mod |= KMOD_RALT;    }    if (mod & SC_MOD_LSUPER) {        sdl_mod |= KMOD_LGUI;    }    if (mod & SC_MOD_RSUPER) {        sdl_mod |= KMOD_RGUI;    }    return sdl_mod;}
is_shortcut_mod(struct input_manager *im, uint16_t sdl_mod) {    // keep only the relevant modifier keys    sdl_mod &= SC_SDL_SHORTCUT_MODS_MASK;    assert(im->sdl_shortcut_mods.count);    assert(im->sdl_shortcut_mods.count < SC_MAX_SHORTCUT_MODS);    for (unsigned i = 0; i < im->sdl_shortcut_mods.count; ++i) {        if (im->sdl_shortcut_mods.data[i] == sdl_mod) {            return true;        }    }    return false;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .log_level = options->log_level,        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,        .show_touches = options->show_touches,        .stay_awake = options->stay_awake,        .codec_options = options->codec_options,        .force_adb_forward = options->force_adb_forward,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver,                                options->disable_screensaver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options-> mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .log_level = options->log_level,        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,        .show_touches = options->show_touches,        .stay_awake = options->stay_awake,        .codec_options = options->codec_options,        .force_adb_forward = options->force_adb_forward,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver,                                options->disable_screensaver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options-> mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    input_manager_init(&input_manager, options->prefer_text,                       &options->shortcut_mods);    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    server_destroy(&server);    return ret;}
int main(int argc, char *argv[]) {    (void) argc;    (void) argv;    test_flag_version();    test_flag_help();    test_options();    test_options2();    return 0;};
int main(int argc, char *argv[]) {    (void) argc;    (void) argv;    test_flag_version();    test_flag_help();    test_options();    test_options2();    test_parse_shortcut_mods();    return 0;};
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    --shortcut-mod key[+...]][,...]\n"        "        Specify the modifiers to use for scrcpy shortcuts.\n"        "        Possible keys are \"lctrl\", \"rctrl\", \"lalt\", \"ralt\",\n"        "        \"lsuper\" and \"rsuper\".\n"        "\n"        "        A shortcut can consist in several keys, separated by '+'.\n"        "        Several shortcuts can be specified, separated by ','.\n"        "\n"        "        For example, to use either LCtrl+LAlt or LSuper for scrcpy\n"        "        shortcuts, pass \"lctrl+lalt,lsuper\".\n"        "\n"        "        Default is \"lalt\" (left-Alt).\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    In the following list, MOD is the shortcut modifier. By default,\n"        "    it's (left) Alt, but it can be configured by --shortcut-mod.\n"        "\n"        "    MOD+f\n"        "        Switch fullscreen mode\n"        "\n"        "    MOD+Left\n"        "        Rotate display left\n"        "\n"        "    MOD+Right\n"        "        Rotate display right\n"        "\n"        "    MOD+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    MOD+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    MOD+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    MOD+b\n"        "    MOD+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    MOD+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    MOD+m\n"        "        Click on MENU\n"        "\n"        "    MOD+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    MOD+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    MOD+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    MOD+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    MOD+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    MOD+r\n"        "        Rotate device screen\n"        "\n"        "    MOD+n\n"        "        Expand notification panel\n"        "\n"        "    MOD+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    MOD+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    MOD+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    MOD+Shift+v\n"        "        Copy computer clipboard to device (and paste if the device\n"        "        runs Android >= 7)\n"        "\n"        "    MOD+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    --shortcut-mod key[+...]][,...]\n"        "        Specify the modifiers to use for scrcpy shortcuts.\n"        "        Possible keys are \"lctrl\", \"rctrl\", \"lalt\", \"ralt\",\n"        "        \"lsuper\" and \"rsuper\".\n"        "\n"        "        A shortcut can consist in several keys, separated by '+'.\n"        "        Several shortcuts can be specified, separated by ','.\n"        "\n"        "        For example, to use either LCtrl+LAlt or LSuper for scrcpy\n"        "        shortcuts, pass \"lctrl+lalt,lsuper\".\n"        "\n"        "        Default is \"lalt,lsuper\" (left-Alt or left-Super).\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    In the following list, MOD is the shortcut modifier. By default,\n"        "    it's (left) Alt or (left) Super, but it can be configured by\n"        "    --shortcut-mod.\n"        "\n"        "    MOD+f\n"        "        Switch fullscreen mode\n"        "\n"        "    MOD+Left\n"        "        Rotate display left\n"        "\n"        "    MOD+Right\n"        "        Rotate display right\n"        "\n"        "    MOD+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    MOD+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    MOD+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    MOD+b\n"        "    MOD+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    MOD+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    MOD+m\n"        "        Click on MENU\n"        "\n"        "    MOD+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    MOD+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    MOD+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    MOD+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    MOD+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    MOD+r\n"        "        Rotate device screen\n"        "\n"        "    MOD+n\n"        "        Expand notification panel\n"        "\n"        "    MOD+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    MOD+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    MOD+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    MOD+Shift+v\n"        "        Copy computer clipboard to device (and paste if the device\n"        "        runs Android >= 7)\n"        "\n"        "    MOD+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
process_msg(struct device_msg *msg) {    switch (msg->type) {        case DEVICE_MSG_TYPE_CLIPBOARD:            LOGI("Device clipboard copied");            SDL_SetClipboardText(msg->clipboard.text);            break;    }}
process_msg(struct device_msg *msg) {    switch (msg->type) {        case DEVICE_MSG_TYPE_CLIPBOARD: {            char *current = SDL_GetClipboardText();            bool same = current && !strcmp(current, msg->clipboard.text);            SDL_free(current);            if (same) {                LOGD("Computer clipboard unchanged");                return;            }            LOGI("Device clipboard copied");            SDL_SetClipboardText(msg->clipboard.text);            break;        }    }}
create_texture(SDL_Renderer *renderer, struct size frame_size) {    return SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12,                             SDL_TEXTUREACCESS_STREAMING,                             frame_size.width, frame_size.height);}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size = get_rotated_size(frame_size, screen->rotation);    screen->content_size = content_size;    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_RendererInfo renderer_info;    int r = SDL_GetRendererInfo(screen->renderer, &renderer_info);    const char *renderer_name = r ? NULL : renderer_info.name;    LOGI("Renderer: %s", renderer_name ? renderer_name : "(unknown)");    if (SDL_RenderSetLogicalSize(screen->renderer, content_size.width,                                 content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width            || screen->frame_size.height != new_frame_size.height) {        struct size new_content_size =            get_rotated_size(new_frame_size, screen->rotation);        if (SDL_RenderSetLogicalSize(screen->renderer,                                     new_content_size.width,                                     new_content_size.height)) {            LOGE("Could not set renderer logical size: %s", SDL_GetError());            return false;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        struct size content_size = screen->content_size;        struct size windowed_size = get_windowed_window_size(screen);        struct size target_size = {            (uint32_t) windowed_size.width * new_content_size.width                    / content_size.width,            (uint32_t) windowed_size.height * new_content_size.height                    / content_size.height,        };        target_size = get_optimal_size(target_size, new_content_size);        set_window_size(screen, target_size);        screen->frame_size = new_frame_size;        screen->content_size = new_content_size;        LOGI("New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = create_texture(screen->renderer, new_frame_size);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return false;        }    }    return true;}
update_texture(struct screen *screen, const AVFrame *frame) {    SDL_UpdateYUVTexture(screen->texture, NULL,            frame->data[0], frame->linesize[0],            frame->data[1], frame->linesize[1],            frame->data[2], frame->linesize[2]);}
create_texture(SDL_Renderer *renderer, struct size frame_size) {    return SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12,                             SDL_TEXTUREACCESS_STREAMING,                             frame_size.width, frame_size.height);}
create_texture(struct screen *screen) {    SDL_Renderer *renderer = screen->renderer;    struct size size = screen->frame_size;    SDL_Texture *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12,                                             SDL_TEXTUREACCESS_STREAMING,                                             size.width, size.height);
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size = get_rotated_size(frame_size, screen->rotation);    screen->content_size = content_size;    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_RendererInfo renderer_info;    int r = SDL_GetRendererInfo(screen->renderer, &renderer_info);    const char *renderer_name = r ? NULL : renderer_info.name;    LOGI("Renderer: %s", renderer_name ? renderer_name : "(unknown)");    if (SDL_RenderSetLogicalSize(screen->renderer, content_size.width,                                 content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    // stats with "opengl"    screen->use_opengl = renderer_name && !strncmp(renderer_name, "opengl", 6);    if (screen->use_opengl) {        struct sc_opengl *gl = &screen->gl;        sc_opengl_init(gl);        LOGI("OpenGL version: %s", gl->version);        bool supports_mipmaps =            sc_opengl_version_at_least(gl, 3, 0, /* OpenGL 3.0+ */                                           2, 0  /* OpenGL ES 2.0+ */);        if (supports_mipmaps) {            LOGI("Trilinear filtering enabled");            screen->mipmaps = true;        } else {            LOGW("Trilinear filtering disabled "                 "(OpenGL 3.0+ or ES 2.0+ required)");        }    } else {        LOGW("Trilinear filtering disabled (not an OpenGL renderer)");    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width            || screen->frame_size.height != new_frame_size.height) {        struct size new_content_size =            get_rotated_size(new_frame_size, screen->rotation);        if (SDL_RenderSetLogicalSize(screen->renderer,                                     new_content_size.width,                                     new_content_size.height)) {            LOGE("Could not set renderer logical size: %s", SDL_GetError());            return false;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        struct size content_size = screen->content_size;        struct size windowed_size = get_windowed_window_size(screen);        struct size target_size = {            (uint32_t) windowed_size.width * new_content_size.width                    / content_size.width,            (uint32_t) windowed_size.height * new_content_size.height                    / content_size.height,        };        target_size = get_optimal_size(target_size, new_content_size);        set_window_size(screen, target_size);        screen->frame_size = new_frame_size;        screen->content_size = new_content_size;        LOGI("New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = create_texture(screen);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return false;        }    }    return true;}
update_texture(struct screen *screen, const AVFrame *frame) {    SDL_UpdateYUVTexture(screen->texture, NULL,            frame->data[0], frame->linesize[0],            frame->data[1], frame->linesize[1],            frame->data[2], frame->linesize[2]);    if (screen->mipmaps) {        assert(screen->use_opengl);        SDL_GL_BindTexture(screen->texture, NULL, NULL);        screen->gl.GenerateMipmap(GL_TEXTURE_2D);        SDL_GL_UnbindTexture(screen->texture);    }}
create_texture(struct screen *screen) {    SDL_Renderer *renderer = screen->renderer;    struct size size = screen->frame_size;    SDL_Texture *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12,                                             SDL_TEXTUREACCESS_STREAMING,                                             size.width, size.height);    if (!texture) {        return NULL;    }    if (screen->mipmaps) {        struct sc_opengl *gl = &screen->gl;        SDL_GL_BindTexture(texture, NULL, NULL);        // Enable trilinear filtering for downscaling        gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,                          GL_LINEAR_MIPMAP_LINEAR);        gl->TexParameterf(GL_TEXTURE_2D, GL_TEXTURE_LOD_BIAS, -.5f);        SDL_GL_UnbindTexture(texture);    }    return texture;}
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        Workarounds.prepareMainLooper();        Workarounds.fillAppInfo();        MediaFormat format = createFormat(bitRate, maxFps, DEFAULT_I_FRAME_INTERVAL);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                ScreenInfo screenInfo = device.getScreenInfo();                Rect contentRect = screenInfo.getContentRect();                // include the locked video orientation                Rect videoRect = screenInfo.getVideoSize().toRect();                // does not include the locked video orientation                Rect unlockedVideoRect = screenInfo.getUnlockedVideoSize().toRect();                int videoRotation = screenInfo.getVideoRotation();                int layerStack = device.getLayerStack();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, videoRotation, contentRect, unlockedVideoRect, layerStack);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        Workarounds.prepareMainLooper();        Workarounds.fillAppInfo();        MediaFormat format = createFormat(bitRate, maxFps, DEFAULT_I_FRAME_INTERVAL);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                ScreenInfo screenInfo = device.getScreenInfo();                Rect contentRect = screenInfo.getContentRect();                // include the locked video orientation                Rect videoRect = screenInfo.getVideoSize().toRect();                // does not include the locked video orientation                Rect unlockedVideoRect = screenInfo.getUnlockedVideoSize().toRect();                int videoRotation = screenInfo.getVideoRotation();                int layerStack = device.getLayerStack();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, videoRotation, contentRect, unlockedVideoRect, layerStack);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        Workarounds.prepareMainLooper();        try {            internalStreamScreen(device, fd);        } catch (NullPointerException e) {            // Retry with workarounds enabled:            // <https://github.com/Genymobile/scrcpy/issues/365>            // <https://github.com/Genymobile/scrcpy/issues/940>            Ln.d("Applying workarounds to avoid NullPointerException");            Workarounds.fillAppInfo();            internalStreamScreen(device, fd);        }    }
    private void internalStreamScreen(Device device, FileDescriptor fd) throws IOException {        MediaFormat format = createFormat(bitRate, maxFps, DEFAULT_I_FRAME_INTERVAL);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                ScreenInfo screenInfo = device.getScreenInfo();                Rect contentRect = screenInfo.getContentRect();                // include the locked video orientation                Rect videoRect = screenInfo.getVideoSize().toRect();                // does not include the locked video orientation                Rect unlockedVideoRect = screenInfo.getUnlockedVideoSize().toRect();                int videoRotation = screenInfo.getVideoRotation();                int layerStack = device.getLayerStack();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, videoRotation, contentRect, unlockedVideoRect, layerStack);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    private boolean injectKeycode(int action, int keycode, int repeat, int metaState) {        return device.injectKeyEvent(action, keycode, repeat, metaState);    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                if (device.supportsInputEvents()) {                    injectKeycode(msg.getAction(), msg.getKeycode(), msg.getRepeat(), msg.getMetaState());                }                break;            case ControlMessage.TYPE_INJECT_TEXT:                if (device.supportsInputEvents()) {                    injectText(msg.getText());                }                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                if (device.supportsInputEvents()) {                    injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), msg.getButtons());                }                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                if (device.supportsInputEvents()) {                    injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                }                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                if (device.supportsInputEvents()) {                    pressBackOrTurnScreenOn();                }                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                if (clipboardText != null) {                    sender.pushClipboardText(clipboardText);                }                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                setClipboard(msg.getText(), msg.getPaste());                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                if (device.supportsInputEvents()) {                    int mode = msg.getAction();                    boolean setPowerModeOk = Device.setScreenPowerMode(mode);                    if (setPowerModeOk) {                        Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));                    }                }                break;            case ControlMessage.TYPE_ROTATE_DEVICE:                device.rotateDevice();                break;            default:                // do nothing        }    }
    private boolean pressBackOrTurnScreenOn() {        int keycode = device.isScreenOn() ? KeyEvent.KEYCODE_BACK : KeyEvent.KEYCODE_WAKEUP;        return device.injectKeycode(keycode);    }
    private boolean pressBackOrTurnScreenOn() {        int keycode = device.isScreenOn() ? KeyEvent.KEYCODE_BACK : KeyEvent.KEYCODE_WAKEUP;        return device.injectKeycode(keycode);    }
    private boolean injectKeycode(int action, int keycode, int repeat, int metaState) {        if (keepPowerModeOff && action == KeyEvent.ACTION_UP && (keycode == KeyEvent.KEYCODE_POWER || keycode == KeyEvent.KEYCODE_WAKEUP)) {            schedulePowerModeOff();        }        return device.injectKeyEvent(action, keycode, repeat, metaState);    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                if (device.supportsInputEvents()) {                    injectKeycode(msg.getAction(), msg.getKeycode(), msg.getRepeat(), msg.getMetaState());                }                break;            case ControlMessage.TYPE_INJECT_TEXT:                if (device.supportsInputEvents()) {                    injectText(msg.getText());                }                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                if (device.supportsInputEvents()) {                    injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), msg.getButtons());                }                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                if (device.supportsInputEvents()) {                    injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                }                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                if (device.supportsInputEvents()) {                    pressBackOrTurnScreenOn();                }                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                if (clipboardText != null) {                    sender.pushClipboardText(clipboardText);                }                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                setClipboard(msg.getText(), msg.getPaste());                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                if (device.supportsInputEvents()) {                    int mode = msg.getAction();                    boolean setPowerModeOk = Device.setScreenPowerMode(mode);                    if (setPowerModeOk) {                        keepPowerModeOff = mode == Device.POWER_MODE_OFF;                        Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));                    }                }                break;            case ControlMessage.TYPE_ROTATE_DEVICE:                device.rotateDevice();                break;            default:                // do nothing        }    }
    private boolean pressBackOrTurnScreenOn() {        int keycode = device.isScreenOn() ? KeyEvent.KEYCODE_BACK : KeyEvent.KEYCODE_WAKEUP;        if (keepPowerModeOff && keycode == KeyEvent.KEYCODE_WAKEUP) {            schedulePowerModeOff();        }        return device.injectKeycode(keycode);    }
    private static void schedulePowerModeOff() {        EXECUTOR.schedule(new Runnable() {            @Override            public void run() {                Ln.i("Forcing screen off");                Device.setScreenPowerMode(Device.POWER_MODE_OFF);            }        }, 200, TimeUnit.MILLISECONDS);    }
to_fixed_point_16(float f) {    SDL_assert(f >= 0.0f && f <= 1.0f);    uint32_t u = f * 0x1p16f; // 2^16    if (u >= 0xffff) {        u = 0xffff;    }    return (uint16_t) u;}
to_fixed_point_16(float f) {    assert(f >= 0.0f && f <= 1.0f);    uint32_t u = f * 0x1p16f; // 2^16    if (u >= 0xffff) {        u = 0xffff;    }    return (uint16_t) u;}
run_controller(void *data) {    struct controller *controller = data;    for (;;) {        mutex_lock(controller->mutex);        while (!controller->stopped && cbuf_is_empty(&controller->queue)) {            cond_wait(controller->msg_cond, controller->mutex);        }        if (controller->stopped) {            // stop immediately, do not process further msgs            mutex_unlock(controller->mutex);            break;        }        struct control_msg msg;        bool non_empty = cbuf_take(&controller->queue, &msg);        SDL_assert(non_empty);        mutex_unlock(controller->mutex);        bool ok = process_msg(controller, &msg);        control_msg_destroy(&msg);        if (!ok) {            LOGD("Could not write msg to socket");            break;        }    }    return 0;}
run_controller(void *data) {    struct controller *controller = data;    for (;;) {        mutex_lock(controller->mutex);        while (!controller->stopped && cbuf_is_empty(&controller->queue)) {            cond_wait(controller->msg_cond, controller->mutex);        }        if (controller->stopped) {            // stop immediately, do not process further msgs            mutex_unlock(controller->mutex);            break;        }        struct control_msg msg;        bool non_empty = cbuf_take(&controller->queue, &msg);        assert(non_empty);        (void) non_empty;        mutex_unlock(controller->mutex);        bool ok = process_msg(controller, &msg);        control_msg_destroy(&msg);        if (!ok) {            LOGD("Could not write msg to socket");            break;        }    }    return 0;}
run_file_handler(void *data) {    struct file_handler *file_handler = data;    for (;;) {        mutex_lock(file_handler->mutex);        file_handler->current_process = PROCESS_NONE;        while (!file_handler->stopped && cbuf_is_empty(&file_handler->queue)) {            cond_wait(file_handler->event_cond, file_handler->mutex);        }        if (file_handler->stopped) {            // stop immediately, do not process further events            mutex_unlock(file_handler->mutex);            break;        }        struct file_handler_request req;        bool non_empty = cbuf_take(&file_handler->queue, &req);        SDL_assert(non_empty);        process_t process;        if (req.action == ACTION_INSTALL_APK) {            LOGI("Installing %s...", req.file);            process = install_apk(file_handler->serial, req.file);        } else {            LOGI("Pushing %s...", req.file);            process = push_file(file_handler->serial, req.file,                                file_handler->push_target);        }        file_handler->current_process = process;        mutex_unlock(file_handler->mutex);        if (req.action == ACTION_INSTALL_APK) {            if (process_check_success(process, "adb install")) {                LOGI("%s successfully installed", req.file);            } else {                LOGE("Failed to install %s", req.file);            }        } else {            if (process_check_success(process, "adb push")) {                LOGI("%s successfully pushed to %s", req.file,                                                     file_handler->push_target);            } else {                LOGE("Failed to push %s to %s", req.file,                                                file_handler->push_target);            }        }        file_handler_request_destroy(&req);    }    return 0;}
run_file_handler(void *data) {    struct file_handler *file_handler = data;    for (;;) {        mutex_lock(file_handler->mutex);        file_handler->current_process = PROCESS_NONE;        while (!file_handler->stopped && cbuf_is_empty(&file_handler->queue)) {            cond_wait(file_handler->event_cond, file_handler->mutex);        }        if (file_handler->stopped) {            // stop immediately, do not process further events            mutex_unlock(file_handler->mutex);            break;        }        struct file_handler_request req;        bool non_empty = cbuf_take(&file_handler->queue, &req);        assert(non_empty);        (void) non_empty;        process_t process;        if (req.action == ACTION_INSTALL_APK) {            LOGI("Installing %s...", req.file);            process = install_apk(file_handler->serial, req.file);        } else {            LOGI("Pushing %s...", req.file);            process = push_file(file_handler->serial, req.file,                                file_handler->push_target);        }        file_handler->current_process = process;        mutex_unlock(file_handler->mutex);        if (req.action == ACTION_INSTALL_APK) {            if (process_check_success(process, "adb install")) {                LOGI("%s successfully installed", req.file);            } else {                LOGE("Failed to install %s", req.file);            }        } else {            if (process_check_success(process, "adb push")) {                LOGI("%s successfully pushed to %s", req.file,                                                     file_handler->push_target);            } else {                LOGE("Failed to push %s to %s", req.file,                                                file_handler->push_target);            }        }        file_handler_request_destroy(&req);    }    return 0;}
run_fps_counter(void *data) {    struct fps_counter *counter = data;    mutex_lock(counter->mutex);    while (!counter->interrupted) {        while (!counter->interrupted && !SDL_AtomicGet(&counter->started)) {            cond_wait(counter->state_cond, counter->mutex);        }        while (!counter->interrupted && SDL_AtomicGet(&counter->started)) {            uint32_t now = SDL_GetTicks();            check_interval_expired(counter, now);            SDL_assert(counter->next_timestamp > now);            uint32_t remaining = counter->next_timestamp - now;            // ignore the reason (timeout or signaled), we just loop anyway            cond_wait_timeout(counter->state_cond, counter->mutex, remaining);        }    }    mutex_unlock(counter->mutex);    return 0;}
run_fps_counter(void *data) {    struct fps_counter *counter = data;    mutex_lock(counter->mutex);    while (!counter->interrupted) {        while (!counter->interrupted && !SDL_AtomicGet(&counter->started)) {            cond_wait(counter->state_cond, counter->mutex);        }        while (!counter->interrupted && SDL_AtomicGet(&counter->started)) {            uint32_t now = SDL_GetTicks();            check_interval_expired(counter, now);            assert(counter->next_timestamp > now);            uint32_t remaining = counter->next_timestamp - now;            // ignore the reason (timeout or signaled), we just loop anyway            cond_wait_timeout(counter->state_cond, counter->mutex, remaining);        }    }    mutex_unlock(counter->mutex);    return 0;}
input_manager_process_text_input(struct input_manager *im,                                 const SDL_TextInputEvent *event) {    if (!im->prefer_text) {        char c = event->text[0];        if (isalpha(c) || c == ' ') {            SDL_assert(event->text[1] == '\0');            // letters and space are handled as raw key event            return;        }    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    msg.inject_text.text = SDL_strdup(event->text);    if (!msg.inject_text.text) {        LOGW("Could not strdup input text");        return;    }    if (!controller_push_msg(im->controller, &msg)) {        SDL_free(msg.inject_text.text);        LOGW("Could not request 'inject text'");    }}
input_manager_process_text_input(struct input_manager *im,                                 const SDL_TextInputEvent *event) {    if (!im->prefer_text) {        char c = event->text[0];        if (isalpha(c) || c == ' ') {            assert(event->text[1] == '\0');            // letters and space are handled as raw key event            return;        }    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    msg.inject_text.text = SDL_strdup(event->text);    if (!msg.inject_text.text) {        LOGW("Could not strdup input text");        return;    }    if (!controller_push_msg(im->controller, &msg)) {        SDL_free(msg.inject_text.text);        LOGW("Could not request 'inject text'");    }}
process_msgs(const unsigned char *buf, size_t len) {    size_t head = 0;    for (;;) {        struct device_msg msg;        ssize_t r = device_msg_deserialize(&buf[head], len - head, &msg);        if (r == -1) {            return -1;        }        if (r == 0) {            return head;        }        process_msg(&msg);        device_msg_destroy(&msg);        head += r;        SDL_assert(head <= len);        if (head == len) {            return head;        }    }}
run_receiver(void *data) {    struct receiver *receiver = data;    unsigned char buf[DEVICE_MSG_SERIALIZED_MAX_SIZE];    size_t head = 0;    for (;;) {        SDL_assert(head < DEVICE_MSG_SERIALIZED_MAX_SIZE);        ssize_t r = net_recv(receiver->control_socket, buf,                             DEVICE_MSG_SERIALIZED_MAX_SIZE - head);        if (r <= 0) {            LOGD("Receiver stopped");            break;        }        ssize_t consumed = process_msgs(buf, r);        if (consumed == -1) {            // an error occurred            break;        }        if (consumed) {            // shift the remaining data in the buffer            memmove(buf, &buf[consumed], r - consumed);            head = r - consumed;        }    }    return 0;}
process_msgs(const unsigned char *buf, size_t len) {    size_t head = 0;    for (;;) {        struct device_msg msg;        ssize_t r = device_msg_deserialize(&buf[head], len - head, &msg);        if (r == -1) {            return -1;        }        if (r == 0) {            return head;        }        process_msg(&msg);        device_msg_destroy(&msg);        head += r;        assert(head <= len);        if (head == len) {            return head;        }    }}
run_receiver(void *data) {    struct receiver *receiver = data;    unsigned char buf[DEVICE_MSG_SERIALIZED_MAX_SIZE];    size_t head = 0;    for (;;) {        assert(head < DEVICE_MSG_SERIALIZED_MAX_SIZE);        ssize_t r = net_recv(receiver->control_socket, buf,                             DEVICE_MSG_SERIALIZED_MAX_SIZE - head);        if (r <= 0) {            LOGD("Receiver stopped");            break;        }        ssize_t consumed = process_msgs(buf, r);        if (consumed == -1) {            // an error occurred            break;        }        if (consumed) {            // shift the remaining data in the buffer            memmove(buf, &buf[consumed], r - consumed);            head = r - consumed;        }    }    return 0;}
recorder_push(struct recorder *recorder, const AVPacket *packet) {    mutex_lock(recorder->mutex);    SDL_assert(!recorder->stopped);    if (recorder->failed) {        // reject any new packet (this will stop the stream)        return false;    }    struct record_packet *rec = record_packet_new(packet);    if (!rec) {        LOGC("Could not allocate record packet");        return false;    }    queue_push(&recorder->queue, next, rec);    cond_signal(recorder->queue_cond);    mutex_unlock(recorder->mutex);    return true;}
recorder_open(struct recorder *recorder, const AVCodec *input_codec) {    const char *format_name = recorder_get_format_name(recorder->format);    SDL_assert(format_name);    const AVOutputFormat *format = find_muxer(format_name);    if (!format) {        LOGE("Could not find muxer");        return false;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return false;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) format;    av_dict_set(&recorder->ctx->metadata, "comment",                "Recorded by scrcpy " SCRCPY_VERSION, 0);    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return false;    }#ifdef SCRCPY_LAVF_HAS_NEW_CODEC_PARAMS_API    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return false;    }    LOGI("Recording started to %s file: %s", format_name, recorder->filename);    return true;}
recorder_push(struct recorder *recorder, const AVPacket *packet) {    mutex_lock(recorder->mutex);    assert(!recorder->stopped);    if (recorder->failed) {        // reject any new packet (this will stop the stream)        return false;    }    struct record_packet *rec = record_packet_new(packet);    if (!rec) {        LOGC("Could not allocate record packet");        return false;    }    queue_push(&recorder->queue, next, rec);    cond_signal(recorder->queue_cond);    mutex_unlock(recorder->mutex);    return true;}
recorder_open(struct recorder *recorder, const AVCodec *input_codec) {    const char *format_name = recorder_get_format_name(recorder->format);    assert(format_name);    const AVOutputFormat *format = find_muxer(format_name);    if (!format) {        LOGE("Could not find muxer");        return false;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return false;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) format;    av_dict_set(&recorder->ctx->metadata, "comment",                "Recorded by scrcpy " SCRCPY_VERSION, 0);    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return false;    }#ifdef SCRCPY_LAVF_HAS_NEW_CODEC_PARAMS_API    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return false;    }    LOGI("Recording started to %s file: %s", format_name, recorder->filename);    return true;}
get_optimal_size(struct size current_size, struct size frame_size) {    if (frame_size.width == 0 || frame_size.height == 0) {        // avoid division by 0        return current_size;    }    struct size display_size;    // 32 bits because we need to multiply two 16 bits values    uint32_t w;    uint32_t h;    if (!get_preferred_display_bounds(&display_size)) {        // could not get display bounds, do not constraint the size        w = current_size.width;        h = current_size.height;    } else {        w = MIN(current_size.width, display_size.width);        h = MIN(current_size.height, display_size.height);    }    bool keep_width = frame_size.width * h > frame_size.height * w;    if (keep_width) {        // remove black borders on top and bottom        h = frame_size.height * w / frame_size.width;    } else {        // remove black borders on left and right (or none at all if it already        // fits)        w = frame_size.width * h / frame_size.height;    }    // w and h must fit into 16 bits    SDL_assert_release(w < 0x10000 && h < 0x10000);    return (struct size) {w, h};}
screen_handle_window_event(struct screen *screen,                           const SDL_WindowEvent *event) {    switch (event->event) {        case SDL_WINDOWEVENT_EXPOSED:            screen_render(screen);            break;        case SDL_WINDOWEVENT_SIZE_CHANGED:            if (!screen->fullscreen && !screen->maximized) {                // Backup the previous size: if we receive the MAXIMIZED event,                // then the new size must be ignored (it's the maximized size).                // We could not rely on the window flags due to race conditions                // (they could be updated asynchronously, at least on X11).                screen->windowed_window_size_backup =                    screen->windowed_window_size;                // Save the windowed size, so that it is available once the                // window is maximized or fullscreen is enabled.                screen->windowed_window_size = get_window_size(screen->window);            }            screen_render(screen);            break;        case SDL_WINDOWEVENT_MAXIMIZED:            // The backup size must be non-nul.            SDL_assert(screen->windowed_window_size_backup.width);            SDL_assert(screen->windowed_window_size_backup.height);            // Revert the last size, it was updated while screen was maximized.            screen->windowed_window_size = screen->windowed_window_size_backup;#ifdef DEBUG            // Reset the backup to invalid values to detect unexpected usage            screen->windowed_window_size_backup.width = 0;            screen->windowed_window_size_backup.height = 0;#endif            screen->maximized = true;            break;        case SDL_WINDOWEVENT_RESTORED:            screen->maximized = false;            apply_windowed_size(screen);            break;    }}
get_optimal_size(struct size current_size, struct size frame_size) {    if (frame_size.width == 0 || frame_size.height == 0) {        // avoid division by 0        return current_size;    }    struct size display_size;    // 32 bits because we need to multiply two 16 bits values    uint32_t w;    uint32_t h;    if (!get_preferred_display_bounds(&display_size)) {        // could not get display bounds, do not constraint the size        w = current_size.width;        h = current_size.height;    } else {        w = MIN(current_size.width, display_size.width);        h = MIN(current_size.height, display_size.height);    }    bool keep_width = frame_size.width * h > frame_size.height * w;    if (keep_width) {        // remove black borders on top and bottom        h = frame_size.height * w / frame_size.width;    } else {        // remove black borders on left and right (or none at all if it already        // fits)        w = frame_size.width * h / frame_size.height;    }    // w and h must fit into 16 bits    assert(w < 0x10000 && h < 0x10000);    return (struct size) {w, h};}
screen_handle_window_event(struct screen *screen,                           const SDL_WindowEvent *event) {    switch (event->event) {        case SDL_WINDOWEVENT_EXPOSED:            screen_render(screen);            break;        case SDL_WINDOWEVENT_SIZE_CHANGED:            if (!screen->fullscreen && !screen->maximized) {                // Backup the previous size: if we receive the MAXIMIZED event,                // then the new size must be ignored (it's the maximized size).                // We could not rely on the window flags due to race conditions                // (they could be updated asynchronously, at least on X11).                screen->windowed_window_size_backup =                    screen->windowed_window_size;                // Save the windowed size, so that it is available once the                // window is maximized or fullscreen is enabled.                screen->windowed_window_size = get_window_size(screen->window);            }            screen_render(screen);            break;        case SDL_WINDOWEVENT_MAXIMIZED:            // The backup size must be non-nul.            assert(screen->windowed_window_size_backup.width);            assert(screen->windowed_window_size_backup.height);            // Revert the last size, it was updated while screen was maximized.            screen->windowed_window_size = screen->windowed_window_size_backup;#ifdef DEBUG            // Reset the backup to invalid values to detect unexpected usage            screen->windowed_window_size_backup.width = 0;            screen->windowed_window_size_backup.height = 0;#endif            screen->maximized = true;            break;        case SDL_WINDOWEVENT_RESTORED:            screen->maximized = false;            apply_windowed_size(screen);            break;    }}
server_stop(struct server *server) {    if (server->server_socket != INVALID_SOCKET) {        close_socket(&server->server_socket);    }    if (server->video_socket != INVALID_SOCKET) {        close_socket(&server->video_socket);    }    if (server->control_socket != INVALID_SOCKET) {        close_socket(&server->control_socket);    }    SDL_assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Could not terminate server");    }    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->tunnel_enabled) {        // ignore failure        disable_tunnel(server);    }}
close_socket(socket_t *socket) {    SDL_assert(*socket != INVALID_SOCKET);    net_shutdown(*socket, SHUT_RDWR);    if (!net_close(*socket)) {        LOGW("Could not close socket");        return;    }    *socket = INVALID_SOCKET;}
server_stop(struct server *server) {    if (server->server_socket != INVALID_SOCKET) {        close_socket(&server->server_socket);    }    if (server->video_socket != INVALID_SOCKET) {        close_socket(&server->video_socket);    }    if (server->control_socket != INVALID_SOCKET) {        close_socket(&server->control_socket);    }    assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Could not terminate server");    }    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->tunnel_enabled) {        // ignore failure        disable_tunnel(server);    }}
close_socket(socket_t *socket) {    assert(*socket != INVALID_SOCKET);    net_shutdown(*socket, SHUT_RDWR);    if (!net_close(*socket)) {        LOGW("Could not close socket");        return;    }    *socket = INVALID_SOCKET;}
stream_recv_packet(struct stream *stream, AVPacket *packet) {    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    uint8_t header[HEADER_SIZE];    ssize_t r = net_recv_all(stream->socket, header, HEADER_SIZE);    if (r < HEADER_SIZE) {        return false;    }    uint64_t pts = buffer_read64be(header);    uint32_t len = buffer_read32be(&header[8]);    SDL_assert(pts == NO_PTS || (pts & 0x8000000000000000) == 0);    SDL_assert(len);    if (av_new_packet(packet, len)) {        LOGE("Could not allocate packet");        return false;    }    r = net_recv_all(stream->socket, packet->data, len);    if (r < 0 || ((uint32_t) r) < len) {        av_packet_unref(packet);        return false;    }    packet->pts = pts != NO_PTS ? (int64_t) pts : AV_NOPTS_VALUE;    return true;}
stream_parse(struct stream *stream, AVPacket *packet) {    uint8_t *in_data = packet->data;    int in_len = packet->size;    uint8_t *out_data = NULL;    int out_len = 0;    int r = av_parser_parse2(stream->parser, stream->codec_ctx,                             &out_data, &out_len, in_data, in_len,                             AV_NOPTS_VALUE, AV_NOPTS_VALUE, -1);    // PARSER_FLAG_COMPLETE_FRAMES is set    SDL_assert(r == in_len);    SDL_assert(out_len == in_len);    if (stream->parser->key_frame == 1) {        packet->flags |= AV_PKT_FLAG_KEY;    }    bool ok = process_frame(stream, packet);    if (!ok) {        LOGE("Could not process frame");        return false;    }    return true;}
stream_recv_packet(struct stream *stream, AVPacket *packet) {    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    uint8_t header[HEADER_SIZE];    ssize_t r = net_recv_all(stream->socket, header, HEADER_SIZE);    if (r < HEADER_SIZE) {        return false;    }    uint64_t pts = buffer_read64be(header);    uint32_t len = buffer_read32be(&header[8]);    assert(pts == NO_PTS || (pts & 0x8000000000000000) == 0);    assert(len);    if (av_new_packet(packet, len)) {        LOGE("Could not allocate packet");        return false;    }    r = net_recv_all(stream->socket, packet->data, len);    if (r < 0 || ((uint32_t) r) < len) {        av_packet_unref(packet);        return false;    }    packet->pts = pts != NO_PTS ? (int64_t) pts : AV_NOPTS_VALUE;    return true;}
stream_parse(struct stream *stream, AVPacket *packet) {    uint8_t *in_data = packet->data;    int in_len = packet->size;    uint8_t *out_data = NULL;    int out_len = 0;    int r = av_parser_parse2(stream->parser, stream->codec_ctx,                             &out_data, &out_len, in_data, in_len,                             AV_NOPTS_VALUE, AV_NOPTS_VALUE, -1);    // PARSER_FLAG_COMPLETE_FRAMES is set    assert(r == in_len);    (void) r;    assert(out_len == in_len);    if (stream->parser->key_frame == 1) {        packet->flags |= AV_PKT_FLAG_KEY;    }    bool ok = process_frame(stream, packet);    if (!ok) {        LOGE("Could not process frame");        return false;    }    return true;}
read_xpm(char *xpm[]) {#ifndef NDEBUG    // patch the XPM to change the icon color in debug mode    xpm[2] = ".	c #CC00CC";#endif    char *endptr;    // *** No error handling, assume the XPM source is valid ***    // (it's in our source repo)    // Assertions are only checked in debug    int width = strtol(xpm[0], &endptr, 10);    int height = strtol(endptr + 1, &endptr, 10);    int colors = strtol(endptr + 1, &endptr, 10);    int chars = strtol(endptr + 1, &endptr, 10);    // sanity checks    SDL_assert(0 <= width && width < 256);    SDL_assert(0 <= height && height < 256);    SDL_assert(0 <= colors && colors < 256);    SDL_assert(chars == 1); // this implementation does not support more    // init index    struct index index[colors];    for (int i = 0; i < colors; ++i) {        const char *line = xpm[1+i];        index[i].c = line[0];        SDL_assert(line[1] == '\t');        SDL_assert(line[2] == 'c');        SDL_assert(line[3] == ' ');        if (line[4] == '#') {            index[i].color = 0xff000000 | strtol(&line[5], &endptr, 0x10);            SDL_assert(*endptr == '\0');        } else {            SDL_assert(!strcmp("None", &line[4]));            index[i].color = 0;        }    }    // parse image    uint32_t *pixels = SDL_malloc(4 * width * height);    if (!pixels) {        LOGE("Could not allocate icon memory");        return NULL;    }    for (int y = 0; y < height; ++y) {        const char *line = xpm[1 + colors + y];        for (int x = 0; x < width; ++x) {            char c = line[x];            uint32_t color;            bool color_found = find_color(index, colors, c, &color);            SDL_assert(color_found);            pixels[y * width + x] = color;        }    }#if SDL_BYTEORDER == SDL_BIG_ENDIAN    uint32_t amask = 0x000000ff;    uint32_t rmask = 0x0000ff00;    uint32_t gmask = 0x00ff0000;    uint32_t bmask = 0xff000000;#else // little endian, like x86    uint32_t amask = 0xff000000;    uint32_t rmask = 0x00ff0000;    uint32_t gmask = 0x0000ff00;    uint32_t bmask = 0x000000ff;#endif    SDL_Surface *surface = SDL_CreateRGBSurfaceFrom(pixels,                                                    width, height,                                                    32, 4 * width,                                                    rmask, gmask, bmask, amask);    if (!surface) {        LOGE("Could not create icon surface");        return NULL;    }    // make the surface own the raw pixels    surface->flags &= ~SDL_PREALLOC;    return surface;}
read_xpm(char *xpm[]) {#ifndef NDEBUG    // patch the XPM to change the icon color in debug mode    xpm[2] = ".	c #CC00CC";#endif    char *endptr;    // *** No error handling, assume the XPM source is valid ***    // (it's in our source repo)    // Assertions are only checked in debug    int width = strtol(xpm[0], &endptr, 10);    int height = strtol(endptr + 1, &endptr, 10);    int colors = strtol(endptr + 1, &endptr, 10);    int chars = strtol(endptr + 1, &endptr, 10);    // sanity checks    assert(0 <= width && width < 256);    assert(0 <= height && height < 256);    assert(0 <= colors && colors < 256);    assert(chars == 1); // this implementation does not support more    (void) chars;    // init index    struct index index[colors];    for (int i = 0; i < colors; ++i) {        const char *line = xpm[1+i];        index[i].c = line[0];        assert(line[1] == '\t');        assert(line[2] == 'c');        assert(line[3] == ' ');        if (line[4] == '#') {            index[i].color = 0xff000000 | strtol(&line[5], &endptr, 0x10);            assert(*endptr == '\0');        } else {            assert(!strcmp("None", &line[4]));            index[i].color = 0;        }    }    // parse image    uint32_t *pixels = SDL_malloc(4 * width * height);    if (!pixels) {        LOGE("Could not allocate icon memory");        return NULL;    }    for (int y = 0; y < height; ++y) {        const char *line = xpm[1 + colors + y];        for (int x = 0; x < width; ++x) {            char c = line[x];            uint32_t color;            bool color_found = find_color(index, colors, c, &color);            assert(color_found);            (void) color_found;            pixels[y * width + x] = color;        }    }#if SDL_BYTEORDER == SDL_BIG_ENDIAN    uint32_t amask = 0x000000ff;    uint32_t rmask = 0x0000ff00;    uint32_t gmask = 0x00ff0000;    uint32_t bmask = 0xff000000;#else // little endian, like x86    uint32_t amask = 0xff000000;    uint32_t rmask = 0x00ff0000;    uint32_t gmask = 0x0000ff00;    uint32_t bmask = 0x000000ff;#endif    SDL_Surface *surface = SDL_CreateRGBSurfaceFrom(pixels,                                                    width, height,                                                    32, 4 * width,                                                    rmask, gmask, bmask, amask);    if (!surface) {        LOGE("Could not create icon surface");        return NULL;    }    // make the surface own the raw pixels    surface->flags &= ~SDL_PREALLOC;    return surface;}
video_buffer_consume_rendered_frame(struct video_buffer *vb) {    SDL_assert(!vb->rendering_frame_consumed);    vb->rendering_frame_consumed = true;    fps_counter_add_rendered_frame(vb->fps_counter);    if (vb->render_expired_frames) {        // unblock video_buffer_offer_decoded_frame()        cond_signal(vb->rendering_frame_consumed_cond);    }    return vb->rendering_frame;}
video_buffer_consume_rendered_frame(struct video_buffer *vb) {    assert(!vb->rendering_frame_consumed);    vb->rendering_frame_consumed = true;    fps_counter_add_rendered_frame(vb->fps_counter);    if (vb->render_expired_frames) {        // unblock video_buffer_offer_decoded_frame()        cond_signal(vb->rendering_frame_consumed_cond);    }    return vb->rendering_frame;}
enable_tunnel_forward_any_port(struct server *server,                               struct sc_port_range port_range) {    server->tunnel_forward = true;    uint16_t port = port_range.first;    for (;;) {        if (enable_tunnel_forward(server->serial, port)) {            // success            server->local_port = port;            return true;        }        if (port < port_range.last) {            LOGW("Could not forward port %" PRIu16", retrying on %" PRIu16,                 port, port + 1);            port++;            continue;        }        if (port_range.first == port_range.last) {            LOGE("Could not forward port %" PRIu16, port_range.first);        } else {            LOGE("Could not forward any port in range %" PRIu16 ":%" PRIu16,                 port_range.first, port_range.last);        }        return false;    }}
enable_tunnel_forward_any_port(struct server *server,                               struct sc_port_range port_range) {    server->tunnel_forward = true;    uint16_t port = port_range.first;    for (;;) {        if (enable_tunnel_forward(server->serial, port)) {            // success            server->local_port = port;            return true;        }        if (port < port_range.last) {            LOGW("Could not forward port %" PRIu16", retrying on %" PRIu16,                 port, (uint16_t) (port + 1));            port++;            continue;        }        if (port_range.first == port_range.last) {            LOGE("Could not forward port %" PRIu16, port_range.first);        } else {            LOGE("Could not forward any port in range %" PRIu16 ":%" PRIu16,                 port_range.first, port_range.last);        }        return false;    }}
    private static MediaCodec createCodec(String encoderName) throws IOException {        if (encoderName != null) {            Ln.d("Creating encoder by name: '" + encoderName + "'");            return MediaCodec.createByCodecName(encoderName);        }        return MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_VIDEO_AVC);    }
    private static MediaCodec createCodec(String encoderName) throws IOException {        if (encoderName != null) {            Ln.d("Creating encoder by name: '" + encoderName + "'");            return MediaCodec.createByCodecName(encoderName);        }        MediaCodec codec = MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_VIDEO_AVC);        Ln.d("Using encoder: '" + codec.getName() + "'");        return codec;    }
    private static void startDeviceMessageSender(final DeviceMessageSender sender) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    sender.loop();                } catch (IOException | InterruptedException e) {                    // this is expected on close                    Ln.d("Device message sender stopped");                }            }        }).start();    }
    private static void startController(final Controller controller) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    controller.control();                } catch (IOException e) {                    // this is expected on close                    Ln.d("Controller stopped");                }            }        }).start();    }
    private static void scrcpy(Options options) throws IOException {        Ln.i("Device: " + Build.MANUFACTURER + " " + Build.MODEL + " (Android " + Build.VERSION.RELEASE + ")");        final Device device = new Device(options);        List<CodecOption> codecOptions = CodecOption.parse(options.getCodecOptions());        boolean mustDisableShowTouchesOnCleanUp = false;        int restoreStayOn = -1;        if (options.getShowTouches() || options.getStayAwake()) {            try (ContentProvider settings = Device.createSettingsProvider()) {                if (options.getShowTouches()) {                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_SYSTEM, "show_touches", "1");                    // If "show touches" was disabled, it must be disabled back on clean up                    mustDisableShowTouchesOnCleanUp = !"1".equals(oldValue);                }                if (options.getStayAwake()) {                    int stayOn = BatteryManager.BATTERY_PLUGGED_AC | BatteryManager.BATTERY_PLUGGED_USB | BatteryManager.BATTERY_PLUGGED_WIRELESS;                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_GLOBAL, "stay_on_while_plugged_in", String.valueOf(stayOn));                    try {                        restoreStayOn = Integer.parseInt(oldValue);                        if (restoreStayOn == stayOn) {                            // No need to restore                            restoreStayOn = -1;                        }                    } catch (NumberFormatException e) {                        restoreStayOn = 0;                    }                }            }        }        CleanUp.configure(mustDisableShowTouchesOnCleanUp, restoreStayOn, true);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate(), options.getMaxFps(), codecOptions,                    options.getEncoderName());            if (options.getControl()) {                final Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());                device.setClipboardListener(new Device.ClipboardListener() {                    @Override                    public void onClipboardTextChanged(String text) {                        controller.getSender().pushClipboardText(text);                    }                });            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    private static Thread startDeviceMessageSender(final DeviceMessageSender sender) {        Thread thread = new Thread(new Runnable() {            @Override            public void run() {                try {                    sender.loop();                } catch (IOException | InterruptedException e) {                    // this is expected on close                    Ln.d("Device message sender stopped");                }            }        });        thread.start();        return thread;    }
    private static Thread startController(final Controller controller) {        Thread thread = new Thread(new Runnable() {            @Override            public void run() {                try {                    controller.control();                } catch (IOException e) {                    // this is expected on close                    Ln.d("Controller stopped");                }            }        });        thread.start();        return thread;    }
    private static void scrcpy(Options options) throws IOException {        Ln.i("Device: " + Build.MANUFACTURER + " " + Build.MODEL + " (Android " + Build.VERSION.RELEASE + ")");        final Device device = new Device(options);        List<CodecOption> codecOptions = CodecOption.parse(options.getCodecOptions());        boolean mustDisableShowTouchesOnCleanUp = false;        int restoreStayOn = -1;        if (options.getShowTouches() || options.getStayAwake()) {            try (ContentProvider settings = Device.createSettingsProvider()) {                if (options.getShowTouches()) {                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_SYSTEM, "show_touches", "1");                    // If "show touches" was disabled, it must be disabled back on clean up                    mustDisableShowTouchesOnCleanUp = !"1".equals(oldValue);                }                if (options.getStayAwake()) {                    int stayOn = BatteryManager.BATTERY_PLUGGED_AC | BatteryManager.BATTERY_PLUGGED_USB | BatteryManager.BATTERY_PLUGGED_WIRELESS;                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_GLOBAL, "stay_on_while_plugged_in", String.valueOf(stayOn));                    try {                        restoreStayOn = Integer.parseInt(oldValue);                        if (restoreStayOn == stayOn) {                            // No need to restore                            restoreStayOn = -1;                        }                    } catch (NumberFormatException e) {                        restoreStayOn = 0;                    }                }            }        }        CleanUp.configure(mustDisableShowTouchesOnCleanUp, restoreStayOn, true);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate(), options.getMaxFps(), codecOptions,                    options.getEncoderName());            Thread controllerThread = null;            Thread deviceMessageSenderThread = null;            if (options.getControl()) {                final Controller controller = new Controller(device, connection);                // asynchronous                controllerThread = startController(controller);                deviceMessageSenderThread = startDeviceMessageSender(controller.getSender());                device.setClipboardListener(new Device.ClipboardListener() {                    @Override                    public void onClipboardTextChanged(String text) {                        controller.getSender().pushClipboardText(text);                    }                });            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            } finally {                if (controllerThread != null) {                    controllerThread.interrupt();                }                if (deviceMessageSenderThread != null) {                    deviceMessageSenderThread.interrupt();                }            }        }    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                if (device.supportsInputEvents()) {                    injectKeycode(msg.getAction(), msg.getKeycode(), msg.getRepeat(), msg.getMetaState());                }                break;            case ControlMessage.TYPE_INJECT_TEXT:                if (device.supportsInputEvents()) {                    injectText(msg.getText());                }                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                if (device.supportsInputEvents()) {                    injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), msg.getButtons());                }                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                if (device.supportsInputEvents()) {                    injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                }                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                if (device.supportsInputEvents()) {                    pressBackOrTurnScreenOn();                }                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                if (clipboardText != null) {                    sender.pushClipboardText(clipboardText);                }                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                boolean paste = (msg.getFlags() & ControlMessage.FLAGS_PASTE) != 0;                setClipboard(msg.getText(), paste);                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                if (device.supportsInputEvents()) {                    int mode = msg.getAction();                    boolean setPowerModeOk = device.setScreenPowerMode(mode);                    if (setPowerModeOk) {                        Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));                    }                }                break;            case ControlMessage.TYPE_ROTATE_DEVICE:                device.rotateDevice();                break;            default:                // do nothing        }    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                if (device.supportsInputEvents()) {                    injectKeycode(msg.getAction(), msg.getKeycode(), msg.getRepeat(), msg.getMetaState());                }                break;            case ControlMessage.TYPE_INJECT_TEXT:                if (device.supportsInputEvents()) {                    injectText(msg.getText());                }                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                if (device.supportsInputEvents()) {                    injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), msg.getButtons());                }                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                if (device.supportsInputEvents()) {                    injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                }                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                if (device.supportsInputEvents()) {                    pressBackOrTurnScreenOn();                }                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                if (clipboardText != null) {                    sender.pushClipboardText(clipboardText);                }                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                boolean paste = (msg.getFlags() & ControlMessage.FLAGS_PASTE) != 0;                setClipboard(msg.getText(), paste);                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                if (device.supportsInputEvents()) {                    int mode = msg.getAction();                    boolean setPowerModeOk = Device.setScreenPowerMode(mode);                    if (setPowerModeOk) {                        Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));                    }                }                break;            case ControlMessage.TYPE_ROTATE_DEVICE:                device.rotateDevice();                break;            default:                // do nothing        }    }
    public boolean setScreenPowerMode(int mode) {        IBinder d = SurfaceControl.getBuiltInDisplay();        if (d == null) {            Ln.e("Could not get built-in display");            return false;        }        return SurfaceControl.setDisplayPowerMode(d, mode);    }
    public static boolean setScreenPowerMode(int mode) {        IBinder d = SurfaceControl.getBuiltInDisplay();        if (d == null) {            Ln.e("Could not get built-in display");            return false;        }        return SurfaceControl.setDisplayPowerMode(d, mode);    }
screen_resize_to_fit(struct screen *screen) {    if (screen->fullscreen) {        return;    }    if (screen->maximized) {        SDL_RestoreWindow(screen->window);        screen->maximized = false;    }    struct size optimal_size =        get_optimal_window_size(screen, screen->content_size);    SDL_SetWindowSize(screen->window, optimal_size.width, optimal_size.height);    LOGD("Resized to optimal size: %ux%u", optimal_size.width,                                           optimal_size.height);}
screen_resize_to_fit(struct screen *screen) {    if (screen->fullscreen || screen->maximized) {        return;    }    struct size optimal_size =        get_optimal_window_size(screen, screen->content_size);    SDL_SetWindowSize(screen->window, optimal_size.width, optimal_size.height);    LOGD("Resized to optimal size: %ux%u", optimal_size.width,                                           optimal_size.height);}
                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}static boolevent_loop(bool display, bool control) {    (void) display;#ifdef CONTINUOUS_RESIZING_WORKAROUND    if (display) {        SDL_AddEventWatch(event_watcher, NULL);    }#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        enum event_result result = handle_event(&event, control);        switch (result) {            case EVENT_RESULT_STOPPED_BY_USER:                return true;
sdl_init_and_configure(bool display, const char *render_driver) {    uint32_t flags = display ? SDL_INIT_VIDEO : SDL_INIT_EVENTS;    if (SDL_Init(flags)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return false;    }    atexit(SDL_Quit);    if (!display) {        return true;    }    if (render_driver && !SDL_SetHint(SDL_HINT_RENDER_DRIVER, render_driver)) {        LOGW("Could not set render driver");    }    // Linear filtering    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        LOGW("Could not enable linear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif#ifdef SCRCPY_SDL_HAS_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR    // Disable compositor bypassing on X11    if (!SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, "0")) {        LOGW("Could not disable X11 compositor bypass");    }#endif    // Do not minimize on focus loss    if (!SDL_SetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, "0")) {        LOGW("Could not disable minimize on focus loss");    }    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return true;}
BOOL windows_ctrl_handler(DWORD ctrl_type) {    if (ctrl_type == CTRL_C_EVENT) {        SDL_Event event;        event.type = SDL_QUIT;        SDL_PushEvent(&event);        return TRUE;    }    return FALSE;}#endif // _WIN32
sdl_init_and_configure(bool display, const char *render_driver) {    uint32_t flags = display ? SDL_INIT_VIDEO : SDL_INIT_EVENTS;    if (SDL_Init(flags)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return false;    }    atexit(SDL_Quit);#ifdef _WIN32    // Clean up properly on Ctrl+C on Windows    bool ok = SetConsoleCtrlHandler(windows_ctrl_handler, TRUE);    if (!ok) {        LOGW("Could not set Ctrl+C handler");    }#endif // _WIN32    if (!display) {        return true;    }    if (render_driver && !SDL_SetHint(SDL_HINT_RENDER_DRIVER, render_driver)) {        LOGW("Could not set render driver");    }    // Linear filtering    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        LOGW("Could not enable linear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif#ifdef SCRCPY_SDL_HAS_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR    // Disable compositor bypassing on X11    if (!SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, "0")) {        LOGW("Could not disable X11 compositor bypass");    }#endif    // Do not minimize on focus loss    if (!SDL_SetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, "0")) {        LOGW("Could not disable minimize on focus loss");    }    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return true;}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"crop",                   required_argument, NULL, OPT_CROP},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"port",                   required_argument, NULL, 'p'},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"crop",                   required_argument, NULL, OPT_CROP},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"port",                   required_argument, NULL, 'p'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
    public Device(Options options) {        displayId = options.getDisplayId();        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo(displayId);        if (displayInfo == null) {            int[] displayIds = serviceManager.getDisplayManager().getDisplayIds();            throw new InvalidDisplayIdException(displayId, displayIds);        }        int displayInfoFlags = displayInfo.getFlags();        screenInfo = ScreenInfo.computeScreenInfo(displayInfo, options.getCrop(), options.getMaxSize(), options.getLockedVideoOrientation());        layerStack = displayInfo.getLayerStack();        serviceManager.getWindowManager().registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    screenInfo = screenInfo.withDeviceRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        }, displayId);        if ((displayInfoFlags & DisplayInfo.FLAG_SUPPORTS_PROTECTED_BUFFERS) == 0) {            Ln.w("Display doesn't have FLAG_SUPPORTS_PROTECTED_BUFFERS flag, mirroring can be restricted");        }        // main display or any display on Android >= Q        supportsInputEvents = displayId == 0 || Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q;        if (!supportsInputEvents) {            Ln.w("Input events are not supported for secondary displays before Android 10");        }    }
    public Device(Options options) {        displayId = options.getDisplayId();        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo(displayId);        if (displayInfo == null) {            int[] displayIds = serviceManager.getDisplayManager().getDisplayIds();            throw new InvalidDisplayIdException(displayId, displayIds);        }        int displayInfoFlags = displayInfo.getFlags();        screenInfo = ScreenInfo.computeScreenInfo(displayInfo, options.getCrop(), options.getMaxSize(), options.getLockedVideoOrientation());        layerStack = displayInfo.getLayerStack();        serviceManager.getWindowManager().registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) {                synchronized (Device.this) {                    screenInfo = screenInfo.withDeviceRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        }, displayId);        if ((displayInfoFlags & DisplayInfo.FLAG_SUPPORTS_PROTECTED_BUFFERS) == 0) {            Ln.w("Display doesn't have FLAG_SUPPORTS_PROTECTED_BUFFERS flag, mirroring can be restricted");        }        // main display or any display on Android >= Q        supportsInputEvents = displayId == 0 || Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q;        if (!supportsInputEvents) {            Ln.w("Input events are not supported for secondary displays before Android 10");        }    }
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (only supported on\n"        "        devices with Android >= 10).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
    private static MediaFormat createFormat(int bitRate, int maxFps, int iFrameInterval) {        MediaFormat format = new MediaFormat();        format.setString(MediaFormat.KEY_MIME, "video/avc");        format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);        // must be present to configure the encoder, but does not impact the actual frame rate, which is variable        format.setInteger(MediaFormat.KEY_FRAME_RATE, 60);        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iFrameInterval);        // display the very first frame, and recover from bad quality when no new frames        format.setLong(MediaFormat.KEY_REPEAT_PREVIOUS_FRAME_AFTER, REPEAT_FRAME_DELAY_US); // µs        if (maxFps > 0) {            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {                format.setFloat(MediaFormat.KEY_MAX_FPS_TO_ENCODER, maxFps);            } else {                Ln.w("Max FPS is only supported since Android 10, the option has been ignored");            }        }        return format;    }
    private static MediaFormat createFormat(int bitRate, int maxFps, int iFrameInterval) {        MediaFormat format = new MediaFormat();        format.setString(MediaFormat.KEY_MIME, "video/avc");        format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);        // must be present to configure the encoder, but does not impact the actual frame rate, which is variable        format.setInteger(MediaFormat.KEY_FRAME_RATE, 60);        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iFrameInterval);        // display the very first frame, and recover from bad quality when no new frames        format.setLong(MediaFormat.KEY_REPEAT_PREVIOUS_FRAME_AFTER, REPEAT_FRAME_DELAY_US); // µs        if (maxFps > 0) {            // The key existed privately before Android 10:            // <https://android.googlesource.com/platform/frameworks/base/+/625f0aad9f7a259b6881006ad8710adce57d1384%5E%21/>            // <https://github.com/Genymobile/scrcpy/issues/488#issuecomment-567321437>            format.setFloat(KEY_MAX_FPS_TO_ENCODER, maxFps);        }        return format;    }
control_msg_serialize(const struct control_msg *msg, unsigned char *buf) {    buf[0] = msg->type;    switch (msg->type) {        case CONTROL_MSG_TYPE_INJECT_KEYCODE:            buf[1] = msg->inject_keycode.action;            buffer_write32be(&buf[2], msg->inject_keycode.keycode);            buffer_write32be(&buf[6], msg->inject_keycode.metastate);            return 10;        case CONTROL_MSG_TYPE_INJECT_TEXT: {            size_t len = write_string(msg->inject_text.text,                                      CONTROL_MSG_TEXT_MAX_LENGTH, &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT:            buf[1] = msg->inject_touch_event.action;            buffer_write64be(&buf[2], msg->inject_touch_event.pointer_id);            write_position(&buf[10], &msg->inject_touch_event.position);            uint16_t pressure =                to_fixed_point_16(msg->inject_touch_event.pressure);            buffer_write16be(&buf[22], pressure);            buffer_write32be(&buf[24], msg->inject_touch_event.buttons);            return 28;        case CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT:            write_position(&buf[1], &msg->inject_scroll_event.position);            buffer_write32be(&buf[13],                             (uint32_t) msg->inject_scroll_event.hscroll);            buffer_write32be(&buf[17],                             (uint32_t) msg->inject_scroll_event.vscroll);            return 21;        case CONTROL_MSG_TYPE_SET_CLIPBOARD: {            size_t len = write_string(msg->inject_text.text,                                      CONTROL_MSG_CLIPBOARD_TEXT_MAX_LENGTH,                                      &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE:            buf[1] = msg->set_screen_power_mode.mode;            return 2;        case CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_GET_CLIPBOARD:        case CONTROL_MSG_TYPE_ROTATE_DEVICE:            // no additional data            return 1;        default:            LOGW("Unknown message type: %u", (unsigned) msg->type);            return 0;    }}
control_msg_serialize(const struct control_msg *msg, unsigned char *buf) {    buf[0] = msg->type;    switch (msg->type) {        case CONTROL_MSG_TYPE_INJECT_KEYCODE:            buf[1] = msg->inject_keycode.action;            buffer_write32be(&buf[2], msg->inject_keycode.keycode);            buffer_write32be(&buf[6], msg->inject_keycode.metastate);            return 10;        case CONTROL_MSG_TYPE_INJECT_TEXT: {            size_t len =                write_string(msg->inject_text.text,                             CONTROL_MSG_INJECT_TEXT_MAX_LENGTH, &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT:            buf[1] = msg->inject_touch_event.action;            buffer_write64be(&buf[2], msg->inject_touch_event.pointer_id);            write_position(&buf[10], &msg->inject_touch_event.position);            uint16_t pressure =                to_fixed_point_16(msg->inject_touch_event.pressure);            buffer_write16be(&buf[22], pressure);            buffer_write32be(&buf[24], msg->inject_touch_event.buttons);            return 28;        case CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT:            write_position(&buf[1], &msg->inject_scroll_event.position);            buffer_write32be(&buf[13],                             (uint32_t) msg->inject_scroll_event.hscroll);            buffer_write32be(&buf[17],                             (uint32_t) msg->inject_scroll_event.vscroll);            return 21;        case CONTROL_MSG_TYPE_SET_CLIPBOARD: {            size_t len = write_string(msg->inject_text.text,                                      CONTROL_MSG_CLIPBOARD_TEXT_MAX_LENGTH,                                      &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE:            buf[1] = msg->set_screen_power_mode.mode;            return 2;        case CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_GET_CLIPBOARD:        case CONTROL_MSG_TYPE_ROTATE_DEVICE:            // no additional data            return 1;        default:            LOGW("Unknown message type: %u", (unsigned) msg->type);            return 0;    }}
static void test_serialize_inject_text_long(void) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    char text[CONTROL_MSG_TEXT_MAX_LENGTH + 1];    memset(text, 'a', sizeof(text));    text[CONTROL_MSG_TEXT_MAX_LENGTH] = '\0';    msg.inject_text.text = text;    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 3 + CONTROL_MSG_TEXT_MAX_LENGTH);    unsigned char expected[3 + CONTROL_MSG_TEXT_MAX_LENGTH];    expected[0] = CONTROL_MSG_TYPE_INJECT_TEXT;    expected[1] = 0x01;    expected[2] = 0x2c; // text length (16 bits)    memset(&expected[3], 'a', CONTROL_MSG_TEXT_MAX_LENGTH);    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_inject_text_long(void) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    char text[CONTROL_MSG_INJECT_TEXT_MAX_LENGTH + 1];    memset(text, 'a', sizeof(text));    text[CONTROL_MSG_INJECT_TEXT_MAX_LENGTH] = '\0';    msg.inject_text.text = text;    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 3 + CONTROL_MSG_INJECT_TEXT_MAX_LENGTH);    unsigned char expected[3 + CONTROL_MSG_INJECT_TEXT_MAX_LENGTH];    expected[0] = CONTROL_MSG_TYPE_INJECT_TEXT;    expected[1] = 0x01;    expected[2] = 0x2c; // text length (16 bits)    memset(&expected[3], 'a', CONTROL_MSG_INJECT_TEXT_MAX_LENGTH);    assert(!memcmp(buf, expected, sizeof(expected)));}
    public void testParseLongTextEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_TEXT);        byte[] text = new byte[ControlMessageReader.TEXT_MAX_LENGTH];        Arrays.fill(text, (byte) 'a');        dos.writeShort(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_TEXT, event.getType());        Assert.assertEquals(new String(text, StandardCharsets.US_ASCII), event.getText());    }
    public void testParseLongTextEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_TEXT);        byte[] text = new byte[ControlMessageReader.INJECT_TEXT_MAX_LENGTH];        Arrays.fill(text, (byte) 'a');        dos.writeShort(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_TEXT, event.getType());        Assert.assertEquals(new String(text, StandardCharsets.US_ASCII), event.getText());    }
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .window_title = NULL,        .push_target = NULL,        .record_format = 0,        .help = false,        .version = false,        .show_touches = false,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = false,        .no_control = false,        .no_display = false,        .turn_screen_off = false,        .render_expired_frames = false,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    LOGI("scrcpy " SCRCPY_VERSION " <https://github.com/Genymobile/scrcpy>");#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .window_title = args.window_title,        .push_target = args.push_target,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,        .control = !args.no_control,        .display = !args.no_display,        .turn_screen_off = args.turn_screen_off,        .render_expired_frames = args.render_expired_frames,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, 'T'},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, 'c'},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"push-target",           required_argument, NULL,                                                 OPT_PUSH_TARGET},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, 'F'},        {"render-expired-frames", no_argument,       NULL,                                                 OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL,                                                 OPT_WINDOW_TITLE},        {NULL,                    0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return false;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = true;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return false;                }                break;            case 'n':                args->no_control = true;                break;            case 'N':                args->no_display = true;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return false;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 'S':                args->turn_screen_off = true;                break;            case 't':                args->show_touches = true;                break;            case 'T':                args->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                args->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                args->window_title = optarg;                break;            case OPT_PUSH_TARGET:                args->push_target = optarg;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (args->no_display && !args->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (args->no_display && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return false;        }    }    if (args->no_control && args->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    LOGI("scrcpy " SCRCPY_VERSION " <https://github.com/Genymobile/scrcpy>");#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    int res = scrcpy(&args.opts) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, 'T'},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, 'c'},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"push-target",           required_argument, NULL,                                                 OPT_PUSH_TARGET},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, 'F'},        {"render-expired-frames", no_argument,       NULL,                                                 OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL,                                                 OPT_WINDOW_TITLE},        {NULL,                    0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                opts->crop = optarg;                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port(optarg, &opts->port)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
    public Device(Options options) {        lockedVideoOrientation = options.getLockedVideoOrientation();        screenInfo = computeScreenInfo(options.getCrop(), options.getMaxSize());        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    screenInfo = screenInfo.withRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        });    }
    private static Size computeVideoSize(int w, int h, int maxSize) {        // Compute the video size and the padding of the content inside this video.        // Principle:        // - scale down the great side of the screen to maxSize (if necessary);        // - scale down the other side so that the aspect ratio is preserved;        // - round this value to the nearest multiple of 8 (H.264 only accepts multiples of 8)        w &= ~7; // in case it's not a multiple of 8        h &= ~7;        if (maxSize > 0) {            if (BuildConfig.DEBUG && maxSize % 8 != 0) {                throw new AssertionError("Max size must be a multiple of 8");            }            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;            if (major > maxSize) {                int minorExact = minor * maxSize / major;                // +4 to round the value to the nearest multiple of 8                minor = (minorExact + 4) & ~7;                major = maxSize;            }            w = portrait ? minor : major;            h = portrait ? major : minor;        }        return new Size(w, h);    }
    private static String formatCrop(Rect rect) {        return rect.width() + ":" + rect.height() + ":" + rect.left + ":" + rect.top;    }
    private ScreenInfo computeScreenInfo(Rect crop, int maxSize) {        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        int rotation = displayInfo.getRotation();        Size deviceSize = displayInfo.getSize();        Rect contentRect = new Rect(0, 0, deviceSize.getWidth(), deviceSize.getHeight());        if (crop != null) {            if (rotation % 2 != 0) { // 180s preserve dimensions                // the crop (provided by the user) is expressed in the natural orientation                crop = flipRect(crop);            }            if (!contentRect.intersect(crop)) {                // intersect() changes contentRect so that it is intersected with crop                Ln.w("Crop rectangle (" + formatCrop(crop) + ") does not intersect device screen (" + formatCrop(deviceSize.toRect()) + ")");                contentRect = new Rect(); // empty            }        }        Size videoSize = computeVideoSize(contentRect.width(), contentRect.height(), maxSize);        return new ScreenInfo(contentRect, videoSize, rotation);    }
    public Device(Options options) {        lockedVideoOrientation = options.getLockedVideoOrientation();        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        screenInfo = ScreenInfo.computeScreenInfo(displayInfo, options.getCrop(), options.getMaxSize());        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    screenInfo = screenInfo.withRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        });    }
        return (lockedVideoOrientation + 4 - deviceRotation) % 4;    }    public Point getPhysicalPoint(Position position) {        // it hides the field on purpose, to read it with a lock        @SuppressWarnings("checkstyle:HiddenField")        ScreenInfo screenInfo = getScreenInfo(); // read with synchronization        Size videoSize = screenInfo.getVideoSize();        int deviceRotation = screenInfo.getRotation();        int reverseVideoRotation = getReverseVideoRotation(deviceRotation);        // reverse the video rotation to apply the events        Position devicePosition = position.rotate(reverseVideoRotation);        Size clientVideoSize = devicePosition.getScreenSize();        if (!videoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event            return null;        }        Rect contentRect = screenInfo.getContentRect();        Point point = devicePosition.getPoint();        int convertedX = contentRect.left + point.getX() * contentRect.width() / videoSize.getWidth();        int convertedY = contentRect.top + point.getY() * contentRect.height() / videoSize.getHeight();        return new Point(convertedX, convertedY);    }
    private int getReverseVideoRotation(int deviceRotation) {        if (lockedVideoOrientation == -1) {            // no offset            return 0;
    /**     * Return the rotation to apply to the device rotation to get the requested locked video orientation     *     * @param deviceRotation the device rotation     * @return the rotation offset     */    public int getVideoRotation(int deviceRotation) {        if (lockedVideoOrientation == -1) {            // no offset            return 0;        }        return (deviceRotation + 4 - lockedVideoOrientation) % 4;    }    /**     * Return the rotation to apply to the requested locked video orientation to get the device rotation     *     * @param deviceRotation the device rotation     * @return the (reverse) rotation offset     */
    public ScreenInfo withRotation(int newRotation) {        if (newRotation == rotation) {            return this;        }        // true if changed between portrait and landscape        boolean orientationChanged = (rotation + newRotation) % 2 != 0;        Rect newContentRect;        Size newVideoSize;        if (orientationChanged) {            newContentRect = Device.flipRect(contentRect);            newVideoSize = videoSize.rotate();        } else {            newContentRect = contentRect;            newVideoSize = videoSize;        }        return new ScreenInfo(newContentRect, newVideoSize, newRotation);    }}
    public ScreenInfo withRotation(int newRotation) {        if (newRotation == rotation) {            return this;        }        // true if changed between portrait and landscape        boolean orientationChanged = (rotation + newRotation) % 2 != 0;        Rect newContentRect;        Size newVideoSize;        if (orientationChanged) {            newContentRect = Device.flipRect(contentRect);            newVideoSize = videoSize.rotate();        } else {            newContentRect = contentRect;            newVideoSize = videoSize;        }        return new ScreenInfo(newContentRect, newVideoSize, newRotation);    }}
    public ScreenInfo withRotation(int newRotation) {        if (newRotation == rotation) {            return this;        }        // true if changed between portrait and landscape        boolean orientationChanged = (rotation + newRotation) % 2 != 0;        Rect newContentRect;        Size newVideoSize;        if (orientationChanged) {            newContentRect = flipRect(contentRect);            newVideoSize = videoSize.rotate();        } else {            newContentRect = contentRect;            newVideoSize = videoSize;        }        return new ScreenInfo(newContentRect, newVideoSize, newRotation);    }
    private static Size computeVideoSize(int w, int h, int maxSize) {        // Compute the video size and the padding of the content inside this video.        // Principle:        // - scale down the great side of the screen to maxSize (if necessary);        // - scale down the other side so that the aspect ratio is preserved;        // - round this value to the nearest multiple of 8 (H.264 only accepts multiples of 8)        w &= ~7; // in case it's not a multiple of 8        h &= ~7;        if (maxSize > 0) {            if (BuildConfig.DEBUG && maxSize % 8 != 0) {                throw new AssertionError("Max size must be a multiple of 8");            }            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;            if (major > maxSize) {                int minorExact = minor * maxSize / major;                // +4 to round the value to the nearest multiple of 8                minor = (minorExact + 4) & ~7;                major = maxSize;            }            w = portrait ? minor : major;            h = portrait ? major : minor;        }        return new Size(w, h);    }
# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"crop",                   required_argument, NULL, OPT_CROP},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"port",                   required_argument, NULL, 'p'},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value. Values are integers in the\n"        "        range [-1..3]. Natural device orientation is 0 and each\n"        "        increment adds 90 degrees counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
parse_display_id(const char *s, uint16_t *display_id) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF, "display id");    if (!ok) {        return false;    }    *display_id = (uint16_t) value;    return true;}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"crop",                   required_argument, NULL, OPT_CROP},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"port",                   required_argument, NULL, 'p'},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value. Values are integers in the\n"        "        range [-1..3]. Natural device orientation is 0 and each\n"        "        increment adds 90 degrees counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    char max_fps_string[6];    char lock_video_orientation_string[3];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    sprintf(max_fps_string, "%"PRIu16, params->max_fps);    sprintf(lock_video_orientation_string, "%"PRIi8, params->lock_video_orientation);    const char *const cmd[] = {        "shell",        "CLASSPATH=" DEVICE_SERVER_PATH,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"# ifdef SERVER_DEBUGGER_METHOD_NEW        /* Android 9 and above */        "-XjdwpProvider:internal -XjdwpOptions:transport=dt_socket,suspend=y,server=y,address="# else        /* Android 8 and below */        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="# endif            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,        max_size_string,        bit_rate_string,        max_fps_string,        lock_video_orientation_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    char max_fps_string[6];    char lock_video_orientation_string[3];    char display_id_string[6];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    sprintf(max_fps_string, "%"PRIu16, params->max_fps);    sprintf(lock_video_orientation_string, "%"PRIi8, params->lock_video_orientation);    sprintf(display_id_string, "%"PRIu16, params->display_id);    const char *const cmd[] = {        "shell",        "CLASSPATH=" DEVICE_SERVER_PATH,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"# ifdef SERVER_DEBUGGER_METHOD_NEW        /* Android 9 and above */        "-XjdwpProvider:internal -XjdwpOptions:transport=dt_socket,suspend=y,server=y,address="# else        /* Android 8 and below */        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="# endif            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,        max_size_string,        bit_rate_string,        max_fps_string,        lock_video_orientation_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",        display_id_string,    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                break;            case ControlMessage.TYPE_INJECT_TEXT:                injectText(msg.getText());                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), msg.getButtons());                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                pressBackOrTurnScreenOn();                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                device.setClipboardText(msg.getText());                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                device.setScreenPowerMode(msg.getAction());                break;            case ControlMessage.TYPE_ROTATE_DEVICE:                device.rotateDevice();                break;            default:                // do nothing        }    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                if (device.supportsInputEvents()) {                    injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                }                break;            case ControlMessage.TYPE_INJECT_TEXT:                if (device.supportsInputEvents()) {                    injectText(msg.getText());                }                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                if (device.supportsInputEvents()) {                    injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), msg.getButtons());                }                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                if (device.supportsInputEvents()) {                    injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                }                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                if (device.supportsInputEvents()) {                    pressBackOrTurnScreenOn();                }                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                device.setClipboardText(msg.getText());                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                if (device.supportsInputEvents()) {                    device.setScreenPowerMode(msg.getAction());                }                break;            case ControlMessage.TYPE_ROTATE_DEVICE:                device.rotateDevice();                break;            default:                // do nothing        }    }
    public Device(Options options) {        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        screenInfo = ScreenInfo.computeScreenInfo(displayInfo, options.getCrop(), options.getMaxSize(), options.getLockedVideoOrientation());        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    screenInfo = screenInfo.withDeviceRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        });    }
    public boolean injectInputEvent(InputEvent inputEvent, int mode) {        return serviceManager.getInputManager().injectInputEvent(inputEvent, mode);    }
    public boolean injectInputEvent(InputEvent inputEvent, int mode) {        return serviceManager.getInputManager().injectInputEvent(inputEvent, mode);    }
    public boolean injectInputEvent(InputEvent inputEvent, int mode) {        return serviceManager.getInputManager().injectInputEvent(inputEvent, mode);    }
    public Device(Options options) {        displayId = options.getDisplayId();        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo(displayId);        if (displayInfo == null) {            int[] displayIds = serviceManager.getDisplayManager().getDisplayIds();            throw new InvalidDisplayIdException(displayId, displayIds);        }        int displayInfoFlags = displayInfo.getFlags();        screenInfo = ScreenInfo.computeScreenInfo(displayInfo, options.getCrop(), options.getMaxSize(), options.getLockedVideoOrientation());        layerStack = displayInfo.getLayerStack();        isPresentationDisplay = (displayInfoFlags & DisplayInfo.FLAG_PRESENTATION) != 0;        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    screenInfo = screenInfo.withDeviceRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        });        if ((displayInfoFlags & DisplayInfo.FLAG_SUPPORTS_PROTECTED_BUFFERS) == 0) {            Ln.w("Display doesn't have FLAG_SUPPORTS_PROTECTED_BUFFERS flag, mirroring can be restricted");        }        if (!supportsInputEvents()) {            Ln.w("Input events are not supported for displays with FLAG_PRESENTATION enabled for devices with API lower than 29");        }    }
    public boolean injectInputEvent(InputEvent inputEvent, int mode) {        if (!supportsInputEvents()) {            throw new AssertionError("Could not inject input event if !supportsInputEvents()");        }        if (displayId != 0 && !InputManager.setDisplayId(inputEvent, displayId)) {            return false;        }        return serviceManager.getInputManager().injectInputEvent(inputEvent, mode);    }
    public boolean supportsInputEvents() {        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {            return true;        }        return !isPresentationDisplay;    }
    public int getLayerStack() {        return layerStack;    }
    public DisplayInfo(Size size, int rotation) {        this.size = size;        this.rotation = rotation;    }
    public DisplayInfo(Size size, int rotation) {        this.size = size;        this.rotation = rotation;    }
    public DisplayInfo(Size size, int rotation) {        this.size = size;        this.rotation = rotation;    }
    public DisplayInfo(Size size, int rotation) {        this.size = size;        this.rotation = rotation;    }
    public DisplayInfo(Size size, int rotation) {        this.size = size;        this.rotation = rotation;    }
    private final int layerStack;    private final int flags;    public static final int FLAG_SUPPORTS_PROTECTED_BUFFERS = 0x00000001;    public static final int FLAG_PRESENTATION = 0x00000008;
    public int getLayerStack() {        return layerStack;    }
    public int getFlags() {        return flags;    }}
    public DisplayInfo(int displayId, Size size, int rotation, int layerStack, int flags) {        this.displayId = displayId;        this.size = size;        this.rotation = rotation;        this.layerStack = layerStack;        this.flags = flags;    }
    public int getDisplayId() {        return displayId;    }
    private int bitRate;    private int maxFps;    private int lockedVideoOrientation;    private boolean tunnelForward;    private Rect crop;
    private int bitRate;    private int maxFps;    private int lockedVideoOrientation;    private boolean tunnelForward;    private Rect crop;
    public int getDisplayId() {        return displayId;    }
    public void setDisplayId(int displayId) {        this.displayId = displayId;    }}
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        Workarounds.prepareMainLooper();        Workarounds.fillAppInfo();        MediaFormat format = createFormat(bitRate, maxFps, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                ScreenInfo screenInfo = device.getScreenInfo();                Rect contentRect = screenInfo.getContentRect();                // include the locked video orientation                Rect videoRect = screenInfo.getVideoSize().toRect();                // does not include the locked video orientation                Rect unlockedVideoRect = screenInfo.getUnlockedVideoSize().toRect();                int videoRotation = screenInfo.getVideoRotation();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, videoRotation, contentRect, unlockedVideoRect);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    private static void setDisplaySurface(IBinder display, Surface surface, int orientation, Rect deviceRect, Rect displayRect) {        SurfaceControl.openTransaction();        try {            SurfaceControl.setDisplaySurface(display, surface);            SurfaceControl.setDisplayProjection(display, orientation, deviceRect, displayRect);            SurfaceControl.setDisplayLayerStack(display, 0);        } finally {            SurfaceControl.closeTransaction();        }    }
    private static void setDisplaySurface(IBinder display, Surface surface, int orientation, Rect deviceRect, Rect displayRect) {        SurfaceControl.openTransaction();        try {            SurfaceControl.setDisplaySurface(display, surface);            SurfaceControl.setDisplayProjection(display, orientation, deviceRect, displayRect);            SurfaceControl.setDisplayLayerStack(display, 0);        } finally {            SurfaceControl.closeTransaction();        }    }
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        Workarounds.prepareMainLooper();        Workarounds.fillAppInfo();        MediaFormat format = createFormat(bitRate, maxFps, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                ScreenInfo screenInfo = device.getScreenInfo();                Rect contentRect = screenInfo.getContentRect();                // include the locked video orientation                Rect videoRect = screenInfo.getVideoSize().toRect();                // does not include the locked video orientation                Rect unlockedVideoRect = screenInfo.getUnlockedVideoSize().toRect();                int videoRotation = screenInfo.getVideoRotation();                int layerStack = device.getLayerStack();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, videoRotation, contentRect, unlockedVideoRect, layerStack);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    }    private static void setDisplaySurface(IBinder display, Surface surface, int orientation, Rect deviceRect, Rect displayRect, int layerStack) {        SurfaceControl.openTransaction();        try {            SurfaceControl.setDisplaySurface(display, surface);            SurfaceControl.setDisplayProjection(display, orientation, deviceRect, displayRect);            SurfaceControl.setDisplayLayerStack(display, layerStack);        } finally {            SurfaceControl.closeTransaction();        }
    private static void setDisplaySurface(IBinder display, Surface surface, int orientation, Rect deviceRect, Rect displayRect, int layerStack) {        SurfaceControl.openTransaction();        try {            SurfaceControl.setDisplaySurface(display, surface);            SurfaceControl.setDisplayProjection(display, orientation, deviceRect, displayRect);            SurfaceControl.setDisplayLayerStack(display, layerStack);        } finally {            SurfaceControl.closeTransaction();        }    }
    private static void suggestFix(Throwable e) {        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {            if (e instanceof MediaCodec.CodecException) {                MediaCodec.CodecException mce = (MediaCodec.CodecException) e;                if (mce.getErrorCode() == 0xfffffc0e) {                    Ln.e("The hardware encoder is not able to encode at the given definition.");                    Ln.e("Try with a lower definition:");                    Ln.e("    scrcpy -m 1024");                }            }        }    }
    private static Options createOptions(String... args) {        if (args.length < 1) {            throw new IllegalArgumentException("Missing client version");        }        String clientVersion = args[0];        if (!clientVersion.equals(BuildConfig.VERSION_NAME)) {            throw new IllegalArgumentException(                    "The server version (" + BuildConfig.VERSION_NAME + ") does not match the client " + "(" + clientVersion + ")");        }        if (args.length != 9) {            throw new IllegalArgumentException("Expecting 9 parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[1]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[2]);        options.setBitRate(bitRate);        int maxFps = Integer.parseInt(args[3]);        options.setMaxFps(maxFps);        int lockedVideoOrientation = Integer.parseInt(args[4]);        options.setLockedVideoOrientation(lockedVideoOrientation);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[5]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[6]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[7]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[8]);        options.setControl(control);        return options;    }
    private static void suggestFix(Throwable e) {        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {            if (e instanceof MediaCodec.CodecException) {                MediaCodec.CodecException mce = (MediaCodec.CodecException) e;                if (mce.getErrorCode() == 0xfffffc0e) {                    Ln.e("The hardware encoder is not able to encode at the given definition.");                    Ln.e("Try with a lower definition:");                    Ln.e("    scrcpy -m 1024");                }            }        }        if (e instanceof InvalidDisplayIdException) {            InvalidDisplayIdException idie = (InvalidDisplayIdException) e;            int[] displayIds = idie.getAvailableDisplayIds();            if (displayIds != null && displayIds.length > 0) {                Ln.e("Try to use one of the available display ids:");                for (int id : displayIds) {                    Ln.e("    scrcpy --display " + id);                }            }        }    }
    private static Options createOptions(String... args) {        if (args.length < 1) {            throw new IllegalArgumentException("Missing client version");        }        String clientVersion = args[0];        if (!clientVersion.equals(BuildConfig.VERSION_NAME)) {            throw new IllegalArgumentException(                    "The server version (" + BuildConfig.VERSION_NAME + ") does not match the client " + "(" + clientVersion + ")");        }        if (args.length != 10) {            throw new IllegalArgumentException("Expecting 10 parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[1]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[2]);        options.setBitRate(bitRate);        int maxFps = Integer.parseInt(args[3]);        options.setMaxFps(maxFps);        int lockedVideoOrientation = Integer.parseInt(args[4]);        options.setLockedVideoOrientation(lockedVideoOrientation);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[5]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[6]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[7]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[8]);        options.setControl(control);        int displayId = Integer.parseInt(args[9]);        options.setDisplayId(displayId);        return options;    }
    public DisplayInfo getDisplayInfo() {        try {            Object displayInfo = manager.getClass().getMethod("getDisplayInfo", int.class).invoke(manager, 0);            Class<?> cls = displayInfo.getClass();            // width and height already take the rotation into account            int width = cls.getDeclaredField("logicalWidth").getInt(displayInfo);            int height = cls.getDeclaredField("logicalHeight").getInt(displayInfo);            int rotation = cls.getDeclaredField("rotation").getInt(displayInfo);            return new DisplayInfo(new Size(width, height), rotation);        } catch (Exception e) {            throw new AssertionError(e);        }    }}
    public DisplayInfo getDisplayInfo() {        try {            Object displayInfo = manager.getClass().getMethod("getDisplayInfo", int.class).invoke(manager, 0);            Class<?> cls = displayInfo.getClass();            // width and height already take the rotation into account            int width = cls.getDeclaredField("logicalWidth").getInt(displayInfo);            int height = cls.getDeclaredField("logicalHeight").getInt(displayInfo);            int rotation = cls.getDeclaredField("rotation").getInt(displayInfo);            return new DisplayInfo(new Size(width, height), rotation);        } catch (Exception e) {            throw new AssertionError(e);        }    }}
    public DisplayInfo getDisplayInfo(int displayId) {        try {            Object displayInfo = manager.getClass().getMethod("getDisplayInfo", int.class).invoke(manager, displayId);            if (displayInfo == null) {                return null;            }            Class<?> cls = displayInfo.getClass();            // width and height already take the rotation into account            int width = cls.getDeclaredField("logicalWidth").getInt(displayInfo);            int height = cls.getDeclaredField("logicalHeight").getInt(displayInfo);            int rotation = cls.getDeclaredField("rotation").getInt(displayInfo);            int layerStack = cls.getDeclaredField("layerStack").getInt(displayInfo);            int flags = cls.getDeclaredField("flags").getInt(displayInfo);            return new DisplayInfo(displayId, new Size(width, height), rotation, layerStack, flags);
    public DisplayInfo getDisplayInfo(int displayId) {        try {            Object displayInfo = manager.getClass().getMethod("getDisplayInfo", int.class).invoke(manager, displayId);            if (displayInfo == null) {                return null;            }            Class<?> cls = displayInfo.getClass();            // width and height already take the rotation into account            int width = cls.getDeclaredField("logicalWidth").getInt(displayInfo);            int height = cls.getDeclaredField("logicalHeight").getInt(displayInfo);            int rotation = cls.getDeclaredField("rotation").getInt(displayInfo);            int layerStack = cls.getDeclaredField("layerStack").getInt(displayInfo);            int flags = cls.getDeclaredField("flags").getInt(displayInfo);            return new DisplayInfo(displayId, new Size(width, height), rotation, layerStack, flags);        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public static final int INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH = 2;    private final IInterface manager;    private Method injectInputEventMethod;    public InputManager(IInterface manager) {        this.manager = manager;    }    private Method getInjectInputEventMethod() throws NoSuchMethodException {        if (injectInputEventMethod == null) {            injectInputEventMethod = manager.getClass().getMethod("injectInputEvent", InputEvent.class, int.class);        }        return injectInputEventMethod;
    public static final int INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH = 2;    private final IInterface manager;    private Method injectInputEventMethod;    public InputManager(IInterface manager) {        this.manager = manager;    }    private Method getInjectInputEventMethod() throws NoSuchMethodException {        if (injectInputEventMethod == null) {            injectInputEventMethod = manager.getClass().getMethod("injectInputEvent", InputEvent.class, int.class);        }        return injectInputEventMethod;
    public static boolean setDisplayId(InputEvent inputEvent, int displayId) {        try {            Method method = getSetDisplayIdMethod();            method.invoke(inputEvent, displayId);            return true;        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            // just a warning, it might happen on old devices            Ln.w("Cannot associate a display id to the input event");            return false;        }    }}
    private static Method getSetDisplayIdMethod() throws NoSuchMethodException {        if (setDisplayIdMethod == null) {            setDisplayIdMethod = InputEvent.class.getMethod("setDisplayId", int.class);        }        return setDisplayIdMethod;    }
    public boolean setClipboardText(String text) {        ClipboardManager clipboardManager = serviceManager.getClipboardManager();        if (clipboardManager == null) {            return false;        }        String currentClipboard = getClipboardText();        if (currentClipboard == null || currentClipboard.equals(text)) {            // The clipboard already contains the requested text.            // Since pasting text from the computer involves setting the device clipboard, it could be set twice on a copy-paste. This would cause            // the clipboard listeners to be notified twice, and that would flood the Android keyboard clipboard history. To workaround this            // problem, do not explicitly set the clipboard text if it already contains the expected content.            return false;        }        isSettingClipboard.set(true);        boolean ok = clipboardManager.setText(text);        isSettingClipboard.set(false);        return ok;    }
    public boolean setClipboardText(String text) {        ClipboardManager clipboardManager = serviceManager.getClipboardManager();        if (clipboardManager == null) {            return false;        }        String currentClipboard = getClipboardText();        if (currentClipboard != null && currentClipboard.equals(text)) {            // The clipboard already contains the requested text.            // Since pasting text from the computer involves setting the device clipboard, it could be set twice on a copy-paste. This would cause            // the clipboard listeners to be notified twice, and that would flood the Android keyboard clipboard history. To workaround this            // problem, do not explicitly set the clipboard text if it already contains the expected content.            return false;        }        isSettingClipboard.set(true);        boolean ok = clipboardManager.setText(text);        isSettingClipboard.set(false);        return ok;    }
parse_window_dimension(char *s, uint16_t *dimension) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF,                                "window dimension");    if (!ok) {        return false;    }    *dimension = (uint16_t) value;    return true;}
parse_port(char *s, uint16_t *port) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF, "port");    if (!ok) {        return false;    }    *port = (uint16_t) value;    return true;}
parse_window_position(char *s, int16_t *position) {    long value;    bool ok = parse_integer_arg(s, &value, false, -1, 0x7FFF,                                "window position");    if (!ok) {        return false;    }    *position = (int16_t) value;    return true;}
parse_port(char *s, uint16_t *port) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF, "port");    if (!ok) {        return false;    }    *port = (uint16_t) value;    return true;}
parse_max_size(char *s, uint16_t *max_size) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF, "max size");    if (!ok) {        return false;    }    *max_size = (uint16_t) value;    return true;}
parse_window_position(char *s, int16_t *position) {    long value;    bool ok = parse_integer_arg(s, &value, false, -1, 0x7FFF,                                "window position");    if (!ok) {        return false;    }    *position = (int16_t) value;    return true;}
parse_window_dimension(char *s, uint16_t *dimension) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF,                                "window dimension");    if (!ok) {        return false;    }    *dimension = (uint16_t) value;    return true;}
parse_max_size(char *s, uint16_t *max_size) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF, "max size");    if (!ok) {        return false;    }    *max_size = (uint16_t) value;    return true;}
parse_window_dimension(const char *s, uint16_t *dimension) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF,                                "window dimension");    if (!ok) {        return false;    }    *dimension = (uint16_t) value;    return true;}
parse_port(const char *s, uint16_t *port) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF, "port");    if (!ok) {        return false;    }    *port = (uint16_t) value;    return true;}
parse_window_position(const char *s, int16_t *position) {    long value;    bool ok = parse_integer_arg(s, &value, false, -1, 0x7FFF,                                "window position");    if (!ok) {        return false;    }    *position = (int16_t) value;    return true;}
parse_port(const char *s, uint16_t *port) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF, "port");    if (!ok) {        return false;    }    *port = (uint16_t) value;    return true;}
parse_max_size(const char *s, uint16_t *max_size) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF, "max size");    if (!ok) {        return false;    }    *max_size = (uint16_t) value;    return true;}
parse_window_position(const char *s, int16_t *position) {    long value;    bool ok = parse_integer_arg(s, &value, false, -1, 0x7FFF,                                "window position");    if (!ok) {        return false;    }    *position = (int16_t) value;    return true;}
parse_window_dimension(const char *s, uint16_t *dimension) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF,                                "window dimension");    if (!ok) {        return false;    }    *dimension = (uint16_t) value;    return true;}
parse_max_size(const char *s, uint16_t *max_size) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF, "max size");    if (!ok) {        return false;    }    *max_size = (uint16_t) value;    return true;}
convert_mouse_motion(const SDL_MouseMotionEvent *from, struct size screen_size,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    to->inject_touch_event.action = AMOTION_EVENT_ACTION_MOVE;    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen_size;    to->inject_touch_event.position.point.x = from->x;    to->inject_touch_event.position.point.y = from->y;    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons = convert_mouse_buttons(from->state);    return true;}
input_manager_process_touch(struct input_manager *im,                            const SDL_TouchFingerEvent *event) {    struct control_msg msg;    if (convert_touch(event, im->screen->frame_size, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject touch event'");        }    }}
convert_touch(const SDL_TouchFingerEvent *from, struct size screen_size,              struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_touch_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = from->fingerId;    to->inject_touch_event.position.screen_size = screen_size;    // SDL touch event coordinates are normalized in the range [0; 1]    to->inject_touch_event.position.point.x = from->x * screen_size.width;    to->inject_touch_event.position.point.y = from->y * screen_size.height;    to->inject_touch_event.pressure = from->pressure;    to->inject_touch_event.buttons = 0;    return true;}
input_manager_process_mouse_button(struct input_manager *im,                                   const SDL_MouseButtonEvent *event,                                   bool control) {    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (control && event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(im->controller);            return;        }        if (control && event->button == SDL_BUTTON_MIDDLE) {            action_home(im->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            bool outside =                is_outside_device_screen(im, event->x, event->y);            if (outside) {                screen_resize_to_fit(im->screen);                return;            }        }        // otherwise, send the click event to the device    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_mouse_button(event, im->screen->frame_size, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject mouse button event'");        }    }}
convert_mouse_button(const SDL_MouseButtonEvent *from, struct size screen_size,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_mouse_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen_size;    to->inject_touch_event.position.point.x = from->x;    to->inject_touch_event.position.point.y = from->y;    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons =        convert_mouse_buttons(SDL_BUTTON(from->button));    return true;}
convert_mouse_wheel(const SDL_MouseWheelEvent *from, struct position position,                    struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT;    to->inject_scroll_event.position = position;    int mul = from->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    // SDL behavior seems inconsistent between horizontal and vertical scrolling    // so reverse the horizontal    // <https://wiki.libsdl.org/SDL_MouseWheelEvent#Remarks>    to->inject_scroll_event.hscroll = -mul * from->x;    to->inject_scroll_event.vscroll = mul * from->y;    return true;}
input_manager_process_mouse_motion(struct input_manager *im,                                   const SDL_MouseMotionEvent *event) {    if (!event->state) {        // do not send motion events when no button is pressed        return;    }    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    struct control_msg msg;    if (convert_mouse_motion(event, im->screen->frame_size, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject mouse motion event'");        }    }}
convert_touch(const SDL_TouchFingerEvent *from, struct size screen_size,              struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_touch_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = from->fingerId;    to->inject_touch_event.position.screen_size = screen_size;    // SDL touch event coordinates are normalized in the range [0; 1]    to->inject_touch_event.position.point.x = from->x * screen_size.width;    to->inject_touch_event.position.point.y = from->y * screen_size.height;    to->inject_touch_event.pressure = from->pressure;    to->inject_touch_event.buttons = 0;    return true;}
input_manager_process_mouse_wheel(struct input_manager *im,                                  const SDL_MouseWheelEvent *event) {    struct position position = {        .screen_size = im->screen->frame_size,        .point = get_mouse_point(im->screen),    };    struct control_msg msg;    if (convert_mouse_wheel(event, position, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject mouse wheel event'");        }    }}
convert_mouse_wheel(const SDL_MouseWheelEvent *from, struct position position,                    struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT;    to->inject_scroll_event.position = position;    int mul = from->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    // SDL behavior seems inconsistent between horizontal and vertical scrolling    // so reverse the horizontal    // <https://wiki.libsdl.org/SDL_MouseWheelEvent#Remarks>    to->inject_scroll_event.hscroll = -mul * from->x;    to->inject_scroll_event.vscroll = mul * from->y;    return true;}
convert_mouse_button(const SDL_MouseButtonEvent *from, struct size screen_size,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_mouse_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen_size;    to->inject_touch_event.position.point.x = from->x;    to->inject_touch_event.position.point.y = from->y;    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons =        convert_mouse_buttons(SDL_BUTTON(from->button));    return true;}
convert_mouse_motion(const SDL_MouseMotionEvent *from, struct size screen_size,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    to->inject_touch_event.action = AMOTION_EVENT_ACTION_MOVE;    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen_size;    to->inject_touch_event.position.point.x = from->x;    to->inject_touch_event.position.point.y = from->y;    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons = convert_mouse_buttons(from->state);    return true;}
convert_mouse_motion(const SDL_MouseMotionEvent *from, struct screen *screen,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    to->inject_touch_event.action = AMOTION_EVENT_ACTION_MOVE;    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen->frame_size;    to->inject_touch_event.position.point.x = from->x;    to->inject_touch_event.position.point.y = from->y;    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons = convert_mouse_buttons(from->state);    return true;}
input_manager_process_touch(struct input_manager *im,                            const SDL_TouchFingerEvent *event) {    struct control_msg msg;    if (convert_touch(event, im->screen, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject touch event'");        }    }}
convert_touch(const SDL_TouchFingerEvent *from, struct screen *screen,              struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_touch_action(from->type, &to->inject_touch_event.action)) {        return false;    }    struct size frame_size = screen->frame_size;    to->inject_touch_event.pointer_id = from->fingerId;    to->inject_touch_event.position.screen_size = frame_size;    // SDL touch event coordinates are normalized in the range [0; 1]    to->inject_touch_event.position.point.x = from->x * frame_size.width;    to->inject_touch_event.position.point.y = from->y * frame_size.height;    to->inject_touch_event.pressure = from->pressure;    to->inject_touch_event.buttons = 0;    return true;
input_manager_process_mouse_button(struct input_manager *im,                                   const SDL_MouseButtonEvent *event,                                   bool control) {    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (control && event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(im->controller);            return;        }        if (control && event->button == SDL_BUTTON_MIDDLE) {            action_home(im->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            bool outside =                is_outside_device_screen(im, event->x, event->y);            if (outside) {                screen_resize_to_fit(im->screen);                return;            }        }        // otherwise, send the click event to the device    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_mouse_button(event, im->screen, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject mouse button event'");        }    }}
convert_mouse_button(const SDL_MouseButtonEvent *from, struct screen *screen,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_mouse_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen->frame_size;    to->inject_touch_event.position.point.x = from->x;    to->inject_touch_event.position.point.y = from->y;    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons =        convert_mouse_buttons(SDL_BUTTON(from->button));    return true;}
static boolconvert_mouse_wheel(const SDL_MouseWheelEvent *from, struct screen *screen,                    struct control_msg *to) {    struct position position = {        .screen_size = screen->frame_size,        .point = get_mouse_point(screen),    };    to->type = CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT;    to->inject_scroll_event.position = position;    int mul = from->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    // SDL behavior seems inconsistent between horizontal and vertical scrolling    // so reverse the horizontal
input_manager_process_mouse_motion(struct input_manager *im,                                   const SDL_MouseMotionEvent *event) {    if (!event->state) {        // do not send motion events when no button is pressed        return;    }    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    struct control_msg msg;    if (convert_mouse_motion(event, im->screen, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject mouse motion event'");        }    }}
convert_touch(const SDL_TouchFingerEvent *from, struct screen *screen,              struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_touch_action(from->type, &to->inject_touch_event.action)) {        return false;    }    struct size frame_size = screen->frame_size;    to->inject_touch_event.pointer_id = from->fingerId;    to->inject_touch_event.position.screen_size = frame_size;    // SDL touch event coordinates are normalized in the range [0; 1]    to->inject_touch_event.position.point.x = from->x * frame_size.width;    to->inject_touch_event.position.point.y = from->y * frame_size.height;    to->inject_touch_event.pressure = from->pressure;    to->inject_touch_event.buttons = 0;    return true;}
input_manager_process_mouse_wheel(struct input_manager *im,                                  const SDL_MouseWheelEvent *event) {    struct control_msg msg;    if (convert_mouse_wheel(event, im->screen, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject mouse wheel event'");        }    }}
convert_mouse_wheel(const SDL_MouseWheelEvent *from, struct screen *screen,                    struct control_msg *to) {    struct position position = {        .screen_size = screen->frame_size,        .point = get_mouse_point(screen),    };    to->type = CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT;    to->inject_scroll_event.position = position;    int mul = from->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    // SDL behavior seems inconsistent between horizontal and vertical scrolling    // so reverse the horizontal    // <https://wiki.libsdl.org/SDL_MouseWheelEvent#Remarks>    to->inject_scroll_event.hscroll = -mul * from->x;    to->inject_scroll_event.vscroll = mul * from->y;    return true;}
static boolconvert_mouse_button(const SDL_MouseButtonEvent *from, struct screen *screen,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_mouse_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen->frame_size;    to->inject_touch_event.position.point.x = from->x;    to->inject_touch_event.position.point.y = from->y;    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons =        convert_mouse_buttons(SDL_BUTTON(from->button));    return true;
convert_mouse_motion(const SDL_MouseMotionEvent *from, struct screen *screen,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    to->inject_touch_event.action = AMOTION_EVENT_ACTION_MOVE;    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen->frame_size;    to->inject_touch_event.position.point.x = from->x;    to->inject_touch_event.position.point.y = from->y;    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons = convert_mouse_buttons(from->state);    return true;}
enable_tunnel_reverse_any_port(struct server *server,                               struct port_range port_range) {    uint16_t port = port_range.first;    for (;;) {        if (!enable_tunnel_reverse(server->serial, port)) {            // the command itself failed, it will fail on any port            return false;        }        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(port);        if (server->server_socket != INVALID_SOCKET) {            // success            server->local_port = port;            return true;        }        // failure, disable tunnel and try another port        if (!disable_tunnel_reverse(server->serial)) {            LOGW("Could not remove reverse tunnel on port %" PRIu16, port);        }        // check before incrementing to avoid overflow on port 65535        if (port < port_range.last) {            LOGW("Could not listen on port %" PRIu16", retrying on %" PRIu16,                 port, port + 1);            port++;            continue;        }        if (port_range.first == port_range.last) {            LOGE("Could not listen on port %" PRIu16, port_range.first);        } else {            LOGE("Could not listen on any port in range %" PRIu16 ":%" PRIu16,                 port_range.first, port_range.last);        }        return false;    }}
enable_tunnel_reverse_any_port(struct server *server,                               struct port_range port_range) {    uint16_t port = port_range.first;    for (;;) {        if (!enable_tunnel_reverse(server->serial, port)) {            // the command itself failed, it will fail on any port            return false;        }        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(port);        if (server->server_socket != INVALID_SOCKET) {            // success            server->local_port = port;            return true;        }        // failure, disable tunnel and try another port        if (!disable_tunnel_reverse(server->serial)) {            LOGW("Could not remove reverse tunnel on port %" PRIu16, port);        }        // check before incrementing to avoid overflow on port 65535        if (port < port_range.last) {            LOGW("Could not listen on port %" PRIu16", retrying on %" PRIu16,                 port, (uint16_t) (port + 1));            port++;            continue;        }        if (port_range.first == port_range.last) {            LOGE("Could not listen on port %" PRIu16, port_range.first);        } else {            LOGE("Could not listen on any port in range %" PRIu16 ":%" PRIu16,                 port_range.first, port_range.last);        }        return false;    }}
convert_log_level_to_sdl(enum sc_log_level level) {    switch (level) {        case SC_LOG_LEVEL_DEBUG:            return SDL_LOG_PRIORITY_DEBUG;        case SC_LOG_LEVEL_INFO:            return SDL_LOG_PRIORITY_INFO;        case SC_LOG_LEVEL_WARN:            return SDL_LOG_PRIORITY_WARN;        case SC_LOG_LEVEL_ERROR:            return SDL_LOG_PRIORITY_ERROR;        default:            assert(!"unexpected log level");            return SC_LOG_LEVEL_INFO;    }}
convert_log_level_to_sdl(enum sc_log_level level) {    switch (level) {        case SC_LOG_LEVEL_DEBUG:            return SDL_LOG_PRIORITY_DEBUG;        case SC_LOG_LEVEL_INFO:            return SDL_LOG_PRIORITY_INFO;        case SC_LOG_LEVEL_WARN:            return SDL_LOG_PRIORITY_WARN;        case SC_LOG_LEVEL_ERROR:            return SDL_LOG_PRIORITY_ERROR;        default:            assert(!"unexpected log level");            return SDL_LOG_PRIORITY_INFO;    }}
event_watcher(void *data, SDL_Event *event) {    (void) data;    if (event->type == SDL_WINDOWEVENT            && event->window.event == SDL_WINDOWEVENT_SIZE_CHANGED) {        // In practice, it seems to always be called from the same thread in        // that specific case. Anyway, it's just a workaround.        screen_handle_window_event(&screen, &event->window);    }    return 0;}#endif
event_watcher(void *data, SDL_Event *event) {    (void) data;    if (event->type == SDL_WINDOWEVENT            && event->window.event == SDL_WINDOWEVENT_RESIZED) {        // In practice, it seems to always be called from the same thread in        // that specific case. Anyway, it's just a workaround.        screen_render(&screen);    }    return 0;}#endif
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"crop",                   required_argument, NULL, OPT_CROP},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"port",                   required_argument, NULL, 'p'},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"crop",                   required_argument, NULL, OPT_CROP},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"port",                   required_argument, NULL, 'p'},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options-> mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size = get_rotated_size(frame_size, screen->rotation);    screen->content_size = content_size;    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_RendererInfo renderer_info;    int r = SDL_GetRendererInfo(screen->renderer, &renderer_info);    const char *renderer_name = r ? NULL : renderer_info.name;    LOGI("Renderer: %s", renderer_name ? renderer_name : "(unknown)");    if (SDL_RenderSetLogicalSize(screen->renderer, content_size.width,                                 content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    // stats with "opengl"    screen->use_opengl = renderer_name && !strncmp(renderer_name, "opengl", 6);    if (screen->use_opengl) {        struct sc_opengl *gl = &screen->gl;        sc_opengl_init(gl);        LOGI("OpenGL version: %s", gl->version);        bool supports_mipmaps =            sc_opengl_version_at_least(gl, 3, 0, /* OpenGL 3.0+ */                                           2, 0  /* OpenGL ES 2.0+ */);        if (supports_mipmaps) {            LOGI("Trilinear filtering enabled");            screen->mipmaps = true;        } else {            LOGW("Trilinear filtering disabled "                 "(OpenGL 3.0+ or ES 2.0+ required)");        }    } else {        LOGW("Trilinear filtering disabled (not an OpenGL renderer)");    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size = get_rotated_size(frame_size, screen->rotation);    screen->content_size = content_size;    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_RendererInfo renderer_info;    int r = SDL_GetRendererInfo(screen->renderer, &renderer_info);    const char *renderer_name = r ? NULL : renderer_info.name;    LOGI("Renderer: %s", renderer_name ? renderer_name : "(unknown)");    if (SDL_RenderSetLogicalSize(screen->renderer, content_size.width,                                 content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    // stats with "opengl"    screen->use_opengl = renderer_name && !strncmp(renderer_name, "opengl", 6);    if (screen->use_opengl) {        struct sc_opengl *gl = &screen->gl;        sc_opengl_init(gl);        LOGI("OpenGL version: %s", gl->version);        bool supports_mipmaps =            sc_opengl_version_at_least(gl, 3, 0, /* OpenGL 3.0+ */                                           2, 0  /* OpenGL ES 2.0+ */);        if (supports_mipmaps) {            LOGI("Trilinear filtering enabled");            screen->mipmaps = true;        } else {            LOGW("Trilinear filtering disabled "                 "(OpenGL 3.0+ or ES 2.0+ required)");        }    } else {        LOGW("Trilinear filtering disabled (not an OpenGL renderer)");    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation, bool mipmaps) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size = get_rotated_size(frame_size, screen->rotation);    screen->content_size = content_size;    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_RendererInfo renderer_info;    int r = SDL_GetRendererInfo(screen->renderer, &renderer_info);    const char *renderer_name = r ? NULL : renderer_info.name;    LOGI("Renderer: %s", renderer_name ? renderer_name : "(unknown)");    if (SDL_RenderSetLogicalSize(screen->renderer, content_size.width,                                 content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    // stats with "opengl"    screen->use_opengl = renderer_name && !strncmp(renderer_name, "opengl", 6);    if (screen->use_opengl) {        struct sc_opengl *gl = &screen->gl;        sc_opengl_init(gl);        LOGI("OpenGL version: %s", gl->version);        if (mipmaps) {            bool supports_mipmaps =                sc_opengl_version_at_least(gl, 3, 0, /* OpenGL 3.0+ */                                               2, 0  /* OpenGL ES 2.0+ */);            if (supports_mipmaps) {                LOGI("Trilinear filtering enabled");                screen->mipmaps = true;            } else {                LOGW("Trilinear filtering disabled "                     "(OpenGL 3.0+ or ES 2.0+ required)");            }        } else {            LOGI("Trilinear filtering disabled");        }    } else {        LOGW("Trilinear filtering disabled (not an OpenGL renderer)");    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation, bool mipmaps) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size = get_rotated_size(frame_size, screen->rotation);    screen->content_size = content_size;    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_RendererInfo renderer_info;    int r = SDL_GetRendererInfo(screen->renderer, &renderer_info);    const char *renderer_name = r ? NULL : renderer_info.name;    LOGI("Renderer: %s", renderer_name ? renderer_name : "(unknown)");    if (SDL_RenderSetLogicalSize(screen->renderer, content_size.width,                                 content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    // stats with "opengl"    screen->use_opengl = renderer_name && !strncmp(renderer_name, "opengl", 6);    if (screen->use_opengl) {        struct sc_opengl *gl = &screen->gl;        sc_opengl_init(gl);        LOGI("OpenGL version: %s", gl->version);        if (mipmaps) {            bool supports_mipmaps =                sc_opengl_version_at_least(gl, 3, 0, /* OpenGL 3.0+ */                                               2, 0  /* OpenGL ES 2.0+ */);            if (supports_mipmaps) {                LOGI("Trilinear filtering enabled");                screen->mipmaps = true;            } else {                LOGW("Trilinear filtering disabled "                     "(OpenGL 3.0+ or ES 2.0+ required)");            }        } else {            LOGI("Trilinear filtering disabled");        }    } else {        LOGW("Trilinear filtering disabled (not an OpenGL renderer)");    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
    public boolean setClipboardText(String text) {        ClipboardManager clipboardManager = serviceManager.getClipboardManager();        if (clipboardManager == null) {            return false;        }        isSettingClipboard.set(true);        boolean ok = clipboardManager.setText(text);        isSettingClipboard.set(false);        return ok;    }
    public boolean setClipboardText(String text) {        ClipboardManager clipboardManager = serviceManager.getClipboardManager();        if (clipboardManager == null) {            return false;        }        String currentClipboard = getClipboardText();        if (currentClipboard == null || currentClipboard.equals(text)) {            // The clipboard already contains the requested text.            // Since pasting text from the computer involves setting the device clipboard, it could be set twice on a copy-paste. This would cause            // the clipboard listeners to be notified twice, and that would flood the Android keyboard clipboard history. To workaround this            // problem, do not explicitly set the clipboard text if it already contains the expected content.            return false;        }        isSettingClipboard.set(true);        boolean ok = clipboardManager.setText(text);        isSettingClipboard.set(false);        return ok;    }
screen_handle_window_event(struct screen *screen,                           const SDL_WindowEvent *event) {    switch (event->event) {        case SDL_WINDOWEVENT_EXPOSED:            screen_render(screen);            break;        case SDL_WINDOWEVENT_SIZE_CHANGED:            screen_render(screen);            break;        case SDL_WINDOWEVENT_MAXIMIZED:            screen->maximized = true;            break;        case SDL_WINDOWEVENT_RESTORED:            screen->maximized = false;            apply_pending_resize(screen);            break;    }}
screen_handle_window_event(struct screen *screen,                           const SDL_WindowEvent *event) {    switch (event->event) {        case SDL_WINDOWEVENT_EXPOSED:            screen_render(screen);            break;        case SDL_WINDOWEVENT_SIZE_CHANGED:            screen_render(screen);            break;        case SDL_WINDOWEVENT_MAXIMIZED:            screen->maximized = true;            break;        case SDL_WINDOWEVENT_RESTORED:            if (screen->fullscreen) {                // On Windows, in maximized+fullscreen, disabling fullscreen                // mode unexpectedly triggers the "restored" then "maximized"                // events, leaving the window in a weird state (maximized                // according to the events, but not maximized visually).                break;            }            screen->maximized = false;            apply_pending_resize(screen);            break;    }}
get_optimal_size(struct size current_size, struct size content_size) {    if (content_size.width == 0 || content_size.height == 0) {        // avoid division by 0        return current_size;    }    struct size display_size;    // 32 bits because we need to multiply two 16 bits values    uint32_t w;    uint32_t h;    if (!get_preferred_display_bounds(&display_size)) {        // could not get display bounds, do not constraint the size        w = current_size.width;        h = current_size.height;    } else {        w = MIN(current_size.width, display_size.width);        h = MIN(current_size.height, display_size.height);    }    bool keep_width = content_size.width * h > content_size.height * w;    if (keep_width) {        // remove black borders on top and bottom        h = content_size.height * w / content_size.width;    } else {        // remove black borders on left and right (or none at all if it already        // fits)        w = content_size.width * h / content_size.height;    }    // w and h must fit into 16 bits    assert(w < 0x10000 && h < 0x10000);    return (struct size) {w, h};}
get_optimal_size(struct size current_size, struct size content_size) {    if (content_size.width == 0 || content_size.height == 0) {        // avoid division by 0        return current_size;    }    struct size display_size;    // 32 bits because we need to multiply two 16 bits values    uint32_t w;    uint32_t h;    if (!get_preferred_display_bounds(&display_size)) {        // could not get display bounds, do not constraint the size        w = current_size.width;        h = current_size.height;    } else {        w = MIN(current_size.width, display_size.width);        h = MIN(current_size.height, display_size.height);    }    if (h == w * content_size.height / content_size.width     || w == h * content_size.width / content_size.height) {        // The size is already optimal, if we ignore rounding errors due to        // integer window dimensions        return (struct size) {w, h};    }    bool keep_width = content_size.width * h > content_size.height * w;    if (keep_width) {        // remove black borders on top and bottom        h = content_size.height * w / content_size.width;    } else {        // remove black borders on left and right (or none at all if it already        // fits)        w = content_size.width * h / content_size.height;    }    // w and h must fit into 16 bits    assert(w < 0x10000 && h < 0x10000);    return (struct size) {w, h};}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"crop",                   required_argument, NULL, OPT_CROP},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"port",                   required_argument, NULL, 'p'},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"crop",                   required_argument, NULL, OPT_CROP},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"port",                   required_argument, NULL, 'p'},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"show-touches",           no_argument,       NULL, 't'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
    public void registerRotationWatcher(IRotationWatcher rotationWatcher, int displayId) {        serviceManager.getWindowManager().registerRotationWatcher(rotationWatcher, displayId);    }
    public Device(Options options) {        displayId = options.getDisplayId();        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo(displayId);        if (displayInfo == null) {            int[] displayIds = serviceManager.getDisplayManager().getDisplayIds();            throw new InvalidDisplayIdException(displayId, displayIds);        }        int displayInfoFlags = displayInfo.getFlags();        screenInfo = ScreenInfo.computeScreenInfo(displayInfo, options.getCrop(), options.getMaxSize(), options.getLockedVideoOrientation());        layerStack = displayInfo.getLayerStack();        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    screenInfo = screenInfo.withDeviceRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        }, displayId);        if ((displayInfoFlags & DisplayInfo.FLAG_SUPPORTS_PROTECTED_BUFFERS) == 0) {            Ln.w("Display doesn't have FLAG_SUPPORTS_PROTECTED_BUFFERS flag, mirroring can be restricted");        }        // main display or any display on Android >= Q        supportsInputEvents = displayId == 0 || Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q;        if (!supportsInputEvents) {            Ln.w("Input events are not supported for secondary displays before Android 10");        }    }
    public synchronized void setRotationListener(RotationListener rotationListener) {        this.rotationListener = rotationListener;    }
    public Device(Options options) {        displayId = options.getDisplayId();        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo(displayId);        if (displayInfo == null) {            int[] displayIds = serviceManager.getDisplayManager().getDisplayIds();            throw new InvalidDisplayIdException(displayId, displayIds);        }        int displayInfoFlags = displayInfo.getFlags();        screenInfo = ScreenInfo.computeScreenInfo(displayInfo, options.getCrop(), options.getMaxSize(), options.getLockedVideoOrientation());        layerStack = displayInfo.getLayerStack();        serviceManager.getWindowManager().registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    screenInfo = screenInfo.withDeviceRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        }, displayId);        if ((displayInfoFlags & DisplayInfo.FLAG_SUPPORTS_PROTECTED_BUFFERS) == 0) {            Ln.w("Display doesn't have FLAG_SUPPORTS_PROTECTED_BUFFERS flag, mirroring can be restricted");        }        // main display or any display on Android >= Q        supportsInputEvents = displayId == 0 || Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q;        if (!supportsInputEvents) {            Ln.w("Input events are not supported for secondary displays before Android 10");        }    }
    public void testParseTouchEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_TOUCH_EVENT);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeLong(-42); // pointerId        dos.writeInt(100);        dos.writeInt(200);        dos.writeShort(1080);        dos.writeShort(1920);        dos.writeShort(0xffff); // pressure        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_TOUCH_EVENT, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(-42, event.getPointerId());        Assert.assertEquals(100, event.getPosition().getPoint().getX());        Assert.assertEquals(200, event.getPosition().getPoint().getY());        Assert.assertEquals(1080, event.getPosition().getScreenSize().getWidth());        Assert.assertEquals(1920, event.getPosition().getScreenSize().getHeight());        Assert.assertEquals(1f, event.getPressure(), 0f); // must be exact        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getButtons());    }
    public void testParseSetScreenPowerMode() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_SET_SCREEN_POWER_MODE);        dos.writeByte(Device.POWER_MODE_NORMAL);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_SET_SCREEN_POWER_MODE, event.getType());        Assert.assertEquals(Device.POWER_MODE_NORMAL, event.getAction());    }
    public void testParseScrollEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_SCROLL_EVENT);        dos.writeInt(260);        dos.writeInt(1026);        dos.writeShort(1080);        dos.writeShort(1920);        dos.writeInt(1);        dos.writeInt(-1);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_SCROLL_EVENT, event.getType());        Assert.assertEquals(260, event.getPosition().getPoint().getX());        Assert.assertEquals(1026, event.getPosition().getPoint().getY());        Assert.assertEquals(1080, event.getPosition().getScreenSize().getWidth());        Assert.assertEquals(1920, event.getPosition().getScreenSize().getHeight());        Assert.assertEquals(1, event.getHScroll());        Assert.assertEquals(-1, event.getVScroll());    }
    public void testParseKeycodeEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(KeyEvent.ACTION_UP, event.getAction());        Assert.assertEquals(KeyEvent.KEYCODE_ENTER, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }
    public void testParseTouchEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_TOUCH_EVENT);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeLong(-42); // pointerId        dos.writeInt(100);        dos.writeInt(200);        dos.writeShort(1080);        dos.writeShort(1920);        dos.writeShort(0xffff); // pressure        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        byte[] packet = bos.toByteArray();        // The message type (1 byte) does not count        Assert.assertEquals(ControlMessageReader.INJECT_TOUCH_EVENT_PAYLOAD_LENGTH, packet.length - 1);        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_TOUCH_EVENT, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(-42, event.getPointerId());        Assert.assertEquals(100, event.getPosition().getPoint().getX());        Assert.assertEquals(200, event.getPosition().getPoint().getY());        Assert.assertEquals(1080, event.getPosition().getScreenSize().getWidth());        Assert.assertEquals(1920, event.getPosition().getScreenSize().getHeight());        Assert.assertEquals(1f, event.getPressure(), 0f); // must be exact        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getButtons());    }
    public void testParseSetScreenPowerMode() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_SET_SCREEN_POWER_MODE);        dos.writeByte(Device.POWER_MODE_NORMAL);        byte[] packet = bos.toByteArray();        // The message type (1 byte) does not count        Assert.assertEquals(ControlMessageReader.SET_SCREEN_POWER_MODE_PAYLOAD_LENGTH, packet.length - 1);        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_SET_SCREEN_POWER_MODE, event.getType());        Assert.assertEquals(Device.POWER_MODE_NORMAL, event.getAction());    }
    public void testParseScrollEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_SCROLL_EVENT);        dos.writeInt(260);        dos.writeInt(1026);        dos.writeShort(1080);        dos.writeShort(1920);        dos.writeInt(1);        dos.writeInt(-1);        byte[] packet = bos.toByteArray();        // The message type (1 byte) does not count        Assert.assertEquals(ControlMessageReader.INJECT_SCROLL_EVENT_PAYLOAD_LENGTH, packet.length - 1);        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_SCROLL_EVENT, event.getType());        Assert.assertEquals(260, event.getPosition().getPoint().getX());        Assert.assertEquals(1026, event.getPosition().getPoint().getY());        Assert.assertEquals(1080, event.getPosition().getScreenSize().getWidth());        Assert.assertEquals(1920, event.getPosition().getScreenSize().getHeight());        Assert.assertEquals(1, event.getHScroll());        Assert.assertEquals(-1, event.getVScroll());    }
    public void testParseKeycodeEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        // The message type (1 byte) does not count        Assert.assertEquals(ControlMessageReader.INJECT_KEYCODE_PAYLOAD_LENGTH, packet.length - 1);        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(KeyEvent.ACTION_UP, event.getAction());        Assert.assertEquals(KeyEvent.KEYCODE_ENTER, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }
convert_input_key(const SDL_KeyboardEvent *from, struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_KEYCODE;    if (!convert_keycode_action(from->type, &to->inject_keycode.action)) {        return false;    }    uint16_t mod = from->keysym.mod;    if (!convert_keycode(from->keysym.sym, &to->inject_keycode.keycode, mod)) {        return false;    }    to->inject_keycode.metastate = convert_meta_state(mod);    return true;}
convert_mouse_action(SDL_EventType from, enum android_motionevent_action *to) {    switch (from) {        MAP(SDL_MOUSEBUTTONDOWN, AMOTION_EVENT_ACTION_DOWN);        MAP(SDL_MOUSEBUTTONUP,   AMOTION_EVENT_ACTION_UP);        FAIL;    }}boolconvert_touch_action(SDL_EventType from, enum android_motionevent_action *to) {    switch (from) {        MAP(SDL_FINGERMOTION, AMOTION_EVENT_ACTION_MOVE);        MAP(SDL_FINGERDOWN,   AMOTION_EVENT_ACTION_DOWN);        MAP(SDL_FINGERUP,     AMOTION_EVENT_ACTION_UP);        FAIL;    }}
        // empty text        SDL_free(text);        return;    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    msg.inject_text.text = text;    if (!controller_push_msg(controller, &msg)) {        SDL_free(text);        LOGW("Could not request 'paste clipboard'");    }}
        // empty text        SDL_free(text);        return;    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    msg.inject_text.text = text;    if (!controller_push_msg(controller, &msg)) {        SDL_free(text);        LOGW("Could not request 'paste clipboard'");    }}
        // empty text        SDL_free(text);        return;    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    msg.inject_text.text = text;    if (!controller_push_msg(controller, &msg)) {        SDL_free(text);        LOGW("Could not request 'paste clipboard'");    }}
        // empty text        SDL_free(text);        return;    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    msg.inject_text.text = text;    if (!controller_push_msg(controller, &msg)) {        SDL_free(text);        LOGW("Could not request 'paste clipboard'");    }}
        // empty text        SDL_free(text);        return;    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    msg.inject_text.text = text;    if (!controller_push_msg(controller, &msg)) {        SDL_free(text);        LOGW("Could not request 'paste clipboard'");    }}
convert_input_key(const SDL_KeyboardEvent *from, struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_KEYCODE;    if (!convert_keycode_action(from->type, &to->inject_keycode.action)) {        return false;    }    uint16_t mod = from->keysym.mod;    if (!convert_keycode(from->keysym.sym, &to->inject_keycode.keycode, mod)) {        return false;    }    to->inject_keycode.metastate = convert_meta_state(mod);    return true;}
convert_touch(const SDL_TouchFingerEvent *from, struct size screen_size,              struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_touch_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = from->fingerId;    to->inject_touch_event.position.screen_size = screen_size;    // SDL touch event coordinates are normalized in the range [0; 1]    to->inject_touch_event.position.point.x = from->x * screen_size.width;    to->inject_touch_event.position.point.y = from->y * screen_size.height;    to->inject_touch_event.pressure = from->pressure;    to->inject_touch_event.buttons = 0;    return true;}
convert_mouse_wheel(const SDL_MouseWheelEvent *from, struct position position,                    struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT;    to->inject_scroll_event.position = position;    int mul = from->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    // SDL behavior seems inconsistent between horizontal and vertical scrolling    // so reverse the horizontal    // <https://wiki.libsdl.org/SDL_MouseWheelEvent#Remarks>    to->inject_scroll_event.hscroll = -mul * from->x;    to->inject_scroll_event.vscroll = mul * from->y;    return true;}
convert_mouse_button(const SDL_MouseButtonEvent *from, struct size screen_size,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_mouse_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen_size;    to->inject_touch_event.position.point.x = from->x;    to->inject_touch_event.position.point.y = from->y;    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons =        convert_mouse_buttons(SDL_BUTTON(from->button));    return true;}
convert_mouse_motion(const SDL_MouseMotionEvent *from, struct size screen_size,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    to->inject_touch_event.action = AMOTION_EVENT_ACTION_MOVE;    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen_size;    to->inject_touch_event.position.point.x = from->x;    to->inject_touch_event.position.point.y = from->y;    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons = convert_mouse_buttons(from->state);    return true;}
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        Workarounds.prepareMainLooper();        Workarounds.fillAppInfo();        MediaFormat format = createFormat(bitRate, maxFps, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                Rect contentRect = device.getScreenInfo().getContentRect();                Rect videoRect = device.getScreenInfo().getVideoSize().toRect();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, contentRect, videoRect);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        Workarounds.prepareMainLooper();        Workarounds.fillAppInfo();        MediaFormat format = createFormat(bitRate, maxFps, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                ScreenInfo screenInfo = device.getScreenInfo();                Rect contentRect = screenInfo.getContentRect();                Rect videoRect = screenInfo.getVideoSize().toRect();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, contentRect, videoRect);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"codec-options",          required_argument, NULL, OPT_CODEC_OPTIONS},        {"crop",                   required_argument, NULL, OPT_CROP},        {"disable-screensaver",    no_argument,       NULL,                                                  OPT_DISABLE_SCREENSAVER},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"force-adb-forward",      no_argument,       NULL,                                                  OPT_FORCE_ADB_FORWARD},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-key-repeat",          no_argument,       NULL, OPT_NO_KEY_REPEAT},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"port",                   required_argument, NULL, 'p'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"shortcut-mod",           required_argument, NULL, OPT_SHORTCUT_MOD},        {"show-touches",           no_argument,       NULL, 't'},        {"stay-awake",             no_argument,       NULL, 'w'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"verbosity",              required_argument, NULL, 'V'},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTvV:w",                            long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case 'V':                if (!parse_log_level(optarg, &opts->log_level)) {                    return false;                }                break;            case 'w':                opts->stay_awake = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            case OPT_NO_KEY_REPEAT:                opts->forward_key_repeat = false;                break;            case OPT_CODEC_OPTIONS:                opts->codec_options = optarg;                break;            case OPT_FORCE_ADB_FORWARD:                opts->force_adb_forward = true;                break;            case OPT_DISABLE_SCREENSAVER:                opts->disable_screensaver = true;                break;            case OPT_SHORTCUT_MOD:                if (!parse_shortcut_mods(optarg, &opts->shortcut_mods)) {                    return false;                }                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    if (!opts->control && opts->stay_awake) {        LOGE("Could not request to stay awake if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-key-repeat\n"        "        Do not forward repeated key events when a key is held down.\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    --shortcut-mod key[+...]][,...]\n"        "        Specify the modifiers to use for scrcpy shortcuts.\n"        "        Possible keys are \"lctrl\", \"rctrl\", \"lalt\", \"ralt\",\n"        "        \"lsuper\" and \"rsuper\".\n"        "\n"        "        A shortcut can consist in several keys, separated by '+'.\n"        "        Several shortcuts can be specified, separated by ','.\n"        "\n"        "        For example, to use either LCtrl+LAlt or LSuper for scrcpy\n"        "        shortcuts, pass \"lctrl+lalt,lsuper\".\n"        "\n"        "        Default is \"lalt,lsuper\" (left-Alt or left-Super).\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    In the following list, MOD is the shortcut modifier. By default,\n"        "    it's (left) Alt or (left) Super, but it can be configured by\n"        "    --shortcut-mod (see above).\n"        "\n"        "    MOD+f\n"        "        Switch fullscreen mode\n"        "\n"        "    MOD+Left\n"        "        Rotate display left\n"        "\n"        "    MOD+Right\n"        "        Rotate display right\n"        "\n"        "    MOD+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    MOD+w\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    MOD+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    MOD+b\n"        "    MOD+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    MOD+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    MOD+m\n"        "        Click on MENU\n"        "\n"        "    MOD+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    MOD+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    MOD+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    MOD+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    MOD+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    MOD+r\n"        "        Rotate device screen\n"        "\n"        "    MOD+n\n"        "        Expand notification panel\n"        "\n"        "    MOD+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    MOD+c\n"        "        Copy to clipboard (inject COPY keycode, Android >= 7 only)\n"        "\n"        "    MOD+x\n"        "        Cut to clipboard (inject CUT keycode, Android >= 7 only)\n"        "\n"        "    MOD+v\n"        "        Copy computer clipboard to device, then paste (inject PASTE\n"        "        keycode, Android >= 7 only)\n"        "\n"        "    MOD+Shift+v\n"        "        Inject computer clipboard text as a sequence of key events\n"        "\n"        "    MOD+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Ctrl+click-and-move\n"        "        Pinch-to-zoom from the center of the screen\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"codec-options",          required_argument, NULL, OPT_CODEC_OPTIONS},        {"crop",                   required_argument, NULL, OPT_CROP},        {"disable-screensaver",    no_argument,       NULL,                                                  OPT_DISABLE_SCREENSAVER},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"force-adb-forward",      no_argument,       NULL,                                                  OPT_FORCE_ADB_FORWARD},        {"forward-all-clicks",     no_argument,       NULL,                                                  OPT_FORWARD_ALL_CLICKS},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-key-repeat",          no_argument,       NULL, OPT_NO_KEY_REPEAT},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"port",                   required_argument, NULL, 'p'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"shortcut-mod",           required_argument, NULL, OPT_SHORTCUT_MOD},        {"show-touches",           no_argument,       NULL, 't'},        {"stay-awake",             no_argument,       NULL, 'w'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"verbosity",              required_argument, NULL, 'V'},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTvV:w",                            long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case 'V':                if (!parse_log_level(optarg, &opts->log_level)) {                    return false;                }                break;            case 'w':                opts->stay_awake = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            case OPT_NO_KEY_REPEAT:                opts->forward_key_repeat = false;                break;            case OPT_CODEC_OPTIONS:                opts->codec_options = optarg;                break;            case OPT_FORCE_ADB_FORWARD:                opts->force_adb_forward = true;                break;            case OPT_DISABLE_SCREENSAVER:                opts->disable_screensaver = true;                break;            case OPT_SHORTCUT_MOD:                if (!parse_shortcut_mods(optarg, &opts->shortcut_mods)) {                    return false;                }                break;            case OPT_FORWARD_ALL_CLICKS:                opts->forward_all_clicks = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    if (!opts->control && opts->stay_awake) {        LOGE("Could not request to stay awake if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    --forward-all-clicks\n"        "        By default, right-click triggers BACK (or POWER on) and\n"        "        middle-click triggers HOME. This option disables these\n"        "        shortcuts and forward the clicks to the device instead.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-key-repeat\n"        "        Do not forward repeated key events when a key is held down.\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    --shortcut-mod key[+...]][,...]\n"        "        Specify the modifiers to use for scrcpy shortcuts.\n"        "        Possible keys are \"lctrl\", \"rctrl\", \"lalt\", \"ralt\",\n"        "        \"lsuper\" and \"rsuper\".\n"        "\n"        "        A shortcut can consist in several keys, separated by '+'.\n"        "        Several shortcuts can be specified, separated by ','.\n"        "\n"        "        For example, to use either LCtrl+LAlt or LSuper for scrcpy\n"        "        shortcuts, pass \"lctrl+lalt,lsuper\".\n"        "\n"        "        Default is \"lalt,lsuper\" (left-Alt or left-Super).\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    In the following list, MOD is the shortcut modifier. By default,\n"        "    it's (left) Alt or (left) Super, but it can be configured by\n"        "    --shortcut-mod (see above).\n"        "\n"        "    MOD+f\n"        "        Switch fullscreen mode\n"        "\n"        "    MOD+Left\n"        "        Rotate display left\n"        "\n"        "    MOD+Right\n"        "        Rotate display right\n"        "\n"        "    MOD+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    MOD+w\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    MOD+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    MOD+b\n"        "    MOD+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    MOD+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    MOD+m\n"        "        Click on MENU\n"        "\n"        "    MOD+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    MOD+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    MOD+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    MOD+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    MOD+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    MOD+r\n"        "        Rotate device screen\n"        "\n"        "    MOD+n\n"        "        Expand notification panel\n"        "\n"        "    MOD+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    MOD+c\n"        "        Copy to clipboard (inject COPY keycode, Android >= 7 only)\n"        "\n"        "    MOD+x\n"        "        Cut to clipboard (inject CUT keycode, Android >= 7 only)\n"        "\n"        "    MOD+v\n"        "        Copy computer clipboard to device, then paste (inject PASTE\n"        "        keycode, Android >= 7 only)\n"        "\n"        "    MOD+Shift+v\n"        "        Inject computer clipboard text as a sequence of key events\n"        "\n"        "    MOD+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Ctrl+click-and-move\n"        "        Pinch-to-zoom from the center of the screen\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
input_manager_init(struct input_manager *im,                   const struct scrcpy_options *options){    im->control = options->control;    im->forward_key_repeat = options->forward_key_repeat;    im->prefer_text = options->prefer_text;    const struct sc_shortcut_mods *shortcut_mods = &options->shortcut_mods;    assert(shortcut_mods->count);    assert(shortcut_mods->count < SC_MAX_SHORTCUT_MODS);    for (unsigned i = 0; i < shortcut_mods->count; ++i) {        uint16_t sdl_mod = to_sdl_mod(shortcut_mods->data[i]);        assert(sdl_mod);        im->sdl_shortcut_mods.data[i] = sdl_mod;    }    im->sdl_shortcut_mods.count = shortcut_mods->count;    im->vfinger_down = false;}
input_manager_process_mouse_button(struct input_manager *im,                                   const SDL_MouseButtonEvent *event) {    bool control = im->control;    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    bool down = event->type == SDL_MOUSEBUTTONDOWN;    if (down) {        if (control && event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(im->controller);            return;        }        if (control && event->button == SDL_BUTTON_MIDDLE) {            action_home(im->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            int32_t x = event->x;            int32_t y = event->y;            screen_hidpi_scale_coords(im->screen, &x, &y);            SDL_Rect *r = &im->screen->rect;            bool outside = x < r->x || x >= r->x + r->w                        || y < r->y || y >= r->y + r->h;            if (outside) {                screen_resize_to_fit(im->screen);                return;            }        }        // otherwise, send the click event to the device    }    if (!control) {        return;    }    struct control_msg msg;    if (!convert_mouse_button(event, im->screen, &msg)) {        return;    }    if (!controller_push_msg(im->controller, &msg)) {        LOGW("Could not request 'inject mouse button event'");        return;    }    // Pinch-to-zoom simulation.    //    // If Ctrl is hold when the left-click button is pressed, then    // pinch-to-zoom mode is enabled: on every mouse event until the left-click    // button is released, an additional "virtual finger" event is generated,    // having a position inverted through the center of the screen.    //    // In other words, the center of the rotation/scaling is the center of the    // screen.#define CTRL_PRESSED (SDL_GetModState() & (KMOD_LCTRL | KMOD_RCTRL))    if ((down && !im->vfinger_down && CTRL_PRESSED)            || (!down && im->vfinger_down)) {        struct point mouse = msg.inject_touch_event.position.point;        struct point vfinger = inverse_point(mouse, im->screen->frame_size);        enum android_motionevent_action action = down                                               ? AMOTION_EVENT_ACTION_DOWN                                               : AMOTION_EVENT_ACTION_UP;        if (!simulate_virtual_finger(im, action, vfinger)) {            return;        }        im->vfinger_down = down;    }}
input_manager_init(struct input_manager *im,                   const struct scrcpy_options *options){    im->control = options->control;    im->forward_key_repeat = options->forward_key_repeat;    im->prefer_text = options->prefer_text;    im->forward_all_clicks = options->forward_all_clicks;    const struct sc_shortcut_mods *shortcut_mods = &options->shortcut_mods;    assert(shortcut_mods->count);    assert(shortcut_mods->count < SC_MAX_SHORTCUT_MODS);    for (unsigned i = 0; i < shortcut_mods->count; ++i) {        uint16_t sdl_mod = to_sdl_mod(shortcut_mods->data[i]);        assert(sdl_mod);        im->sdl_shortcut_mods.data[i] = sdl_mod;    }    im->sdl_shortcut_mods.count = shortcut_mods->count;    im->vfinger_down = false;}
input_manager_process_mouse_button(struct input_manager *im,                                   const SDL_MouseButtonEvent *event) {    bool control = im->control;    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    bool down = event->type == SDL_MOUSEBUTTONDOWN;    if (!im->forward_all_clicks && down) {        if (control && event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(im->controller);            return;        }        if (control && event->button == SDL_BUTTON_MIDDLE) {            action_home(im->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            int32_t x = event->x;            int32_t y = event->y;            screen_hidpi_scale_coords(im->screen, &x, &y);            SDL_Rect *r = &im->screen->rect;            bool outside = x < r->x || x >= r->x + r->w                        || y < r->y || y >= r->y + r->h;            if (outside) {                screen_resize_to_fit(im->screen);                return;            }        }        // otherwise, send the click event to the device    }    if (!control) {        return;    }    struct control_msg msg;    if (!convert_mouse_button(event, im->screen, &msg)) {        return;    }    if (!controller_push_msg(im->controller, &msg)) {        LOGW("Could not request 'inject mouse button event'");        return;    }    // Pinch-to-zoom simulation.    //    // If Ctrl is hold when the left-click button is pressed, then    // pinch-to-zoom mode is enabled: on every mouse event until the left-click    // button is released, an additional "virtual finger" event is generated,    // having a position inverted through the center of the screen.    //    // In other words, the center of the rotation/scaling is the center of the    // screen.#define CTRL_PRESSED (SDL_GetModState() & (KMOD_LCTRL | KMOD_RCTRL))    if ((down && !im->vfinger_down && CTRL_PRESSED)            || (!down && im->vfinger_down)) {        struct point mouse = msg.inject_touch_event.position.point;        struct point vfinger = inverse_point(mouse, im->screen->frame_size);        enum android_motionevent_action action = down                                               ? AMOTION_EVENT_ACTION_DOWN                                               : AMOTION_EVENT_ACTION_UP;        if (!simulate_virtual_finger(im, action, vfinger)) {            return;        }        im->vfinger_down = down;    }}
    private boolean injectTouch(int action, long pointerId, Position position, float pressure, int buttons) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            Ln.w("Ignore touch event, it was generated for a different device size");            return false;        }        int pointerIndex = pointersState.getPointerIndex(pointerId);        if (pointerIndex == -1) {            Ln.w("Too many pointers for touch event");            return false;        }        Pointer pointer = pointersState.get(pointerIndex);        pointer.setPoint(point);        pointer.setPressure(pressure);        pointer.setUp(action == MotionEvent.ACTION_UP);        int pointerCount = pointersState.update(pointerProperties, pointerCoords);        if (pointerCount == 1) {            if (action == MotionEvent.ACTION_DOWN) {                lastTouchDown = now;            }        } else {            // secondary pointers must use ACTION_POINTER_* ORed with the pointerIndex            if (action == MotionEvent.ACTION_UP) {                action = MotionEvent.ACTION_POINTER_UP | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            } else if (action == MotionEvent.ACTION_DOWN) {                action = MotionEvent.ACTION_POINTER_DOWN | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            }        }        MotionEvent event = MotionEvent                .obtain(lastTouchDown, now, action, pointerCount, pointerProperties, pointerCoords, 0, buttons, 1f, 1f, DEVICE_ID_VIRTUAL, 0,                        InputDevice.SOURCE_TOUCHSCREEN, 0);        return device.injectEvent(event);    }
    private boolean injectTouch(int action, long pointerId, Position position, float pressure, int buttons) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            Ln.w("Ignore touch event, it was generated for a different device size");            return false;        }        int pointerIndex = pointersState.getPointerIndex(pointerId);        if (pointerIndex == -1) {            Ln.w("Too many pointers for touch event");            return false;        }        Pointer pointer = pointersState.get(pointerIndex);        pointer.setPoint(point);        pointer.setPressure(pressure);        pointer.setUp(action == MotionEvent.ACTION_UP);        int pointerCount = pointersState.update(pointerProperties, pointerCoords);        if (pointerCount == 1) {            if (action == MotionEvent.ACTION_DOWN) {                lastTouchDown = now;            }        } else {            // secondary pointers must use ACTION_POINTER_* ORed with the pointerIndex            if (action == MotionEvent.ACTION_UP) {                action = MotionEvent.ACTION_POINTER_UP | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            } else if (action == MotionEvent.ACTION_DOWN) {                action = MotionEvent.ACTION_POINTER_DOWN | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            }        }        // Right-click and middle-click only work if the source is a mouse        boolean nonPrimaryButtonPressed = (buttons & ~MotionEvent.BUTTON_PRIMARY) != 0;        int source = nonPrimaryButtonPressed ? InputDevice.SOURCE_MOUSE : InputDevice.SOURCE_TOUCHSCREEN;        MotionEvent event = MotionEvent                .obtain(lastTouchDown, now, action, pointerCount, pointerProperties, pointerCoords, 0, buttons, 1f, 1f, DEVICE_ID_VIRTUAL, 0, source,                        0);        return device.injectEvent(event);    }
    private void internalStreamScreen(Device device, FileDescriptor fd) throws IOException {        MediaFormat format = createFormat(bitRate, maxFps, DEFAULT_I_FRAME_INTERVAL);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                ScreenInfo screenInfo = device.getScreenInfo();                Rect contentRect = screenInfo.getContentRect();                // include the locked video orientation                Rect videoRect = screenInfo.getVideoSize().toRect();                // does not include the locked video orientation                Rect unlockedVideoRect = screenInfo.getUnlockedVideoSize().toRect();                int videoRotation = screenInfo.getVideoRotation();                int layerStack = device.getLayerStack();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, videoRotation, contentRect, unlockedVideoRect, layerStack);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    private static MediaFormat createFormat(int bitRate, int maxFps, int iFrameInterval) {        MediaFormat format = new MediaFormat();        format.setString(MediaFormat.KEY_MIME, MediaFormat.MIMETYPE_VIDEO_AVC);        format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);        // must be present to configure the encoder, but does not impact the actual frame rate, which is variable        format.setInteger(MediaFormat.KEY_FRAME_RATE, 60);        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iFrameInterval);        // display the very first frame, and recover from bad quality when no new frames        format.setLong(MediaFormat.KEY_REPEAT_PREVIOUS_FRAME_AFTER, REPEAT_FRAME_DELAY_US); // µs        if (maxFps > 0) {            // The key existed privately before Android 10:            // <https://android.googlesource.com/platform/frameworks/base/+/625f0aad9f7a259b6881006ad8710adce57d1384%5E%21/>            // <https://github.com/Genymobile/scrcpy/issues/488#issuecomment-567321437>            format.setFloat(KEY_MAX_FPS_TO_ENCODER, maxFps);        }        return format;    }
    private static MediaFormat createFormat(int bitRate, int maxFps, int iFrameInterval) {        MediaFormat format = new MediaFormat();        format.setString(MediaFormat.KEY_MIME, MediaFormat.MIMETYPE_VIDEO_AVC);        format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);        // must be present to configure the encoder, but does not impact the actual frame rate, which is variable        format.setInteger(MediaFormat.KEY_FRAME_RATE, 60);        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iFrameInterval);        // display the very first frame, and recover from bad quality when no new frames        format.setLong(MediaFormat.KEY_REPEAT_PREVIOUS_FRAME_AFTER, REPEAT_FRAME_DELAY_US); // µs        if (maxFps > 0) {            // The key existed privately before Android 10:            // <https://android.googlesource.com/platform/frameworks/base/+/625f0aad9f7a259b6881006ad8710adce57d1384%5E%21/>            // <https://github.com/Genymobile/scrcpy/issues/488#issuecomment-567321437>            format.setFloat(KEY_MAX_FPS_TO_ENCODER, maxFps);        }        return format;    }
    private void internalStreamScreen(Device device, FileDescriptor fd) throws IOException {        MediaFormat format = createFormat(bitRate, maxFps);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                ScreenInfo screenInfo = device.getScreenInfo();                Rect contentRect = screenInfo.getContentRect();                // include the locked video orientation                Rect videoRect = screenInfo.getVideoSize().toRect();                // does not include the locked video orientation                Rect unlockedVideoRect = screenInfo.getUnlockedVideoSize().toRect();                int videoRotation = screenInfo.getVideoRotation();                int layerStack = device.getLayerStack();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, videoRotation, contentRect, unlockedVideoRect, layerStack);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    private static MediaFormat createFormat(int bitRate, int maxFps) {        MediaFormat format = new MediaFormat();        format.setString(MediaFormat.KEY_MIME, MediaFormat.MIMETYPE_VIDEO_AVC);        format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);        // must be present to configure the encoder, but does not impact the actual frame rate, which is variable        format.setInteger(MediaFormat.KEY_FRAME_RATE, 60);        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, DEFAULT_I_FRAME_INTERVAL);        // display the very first frame, and recover from bad quality when no new frames        format.setLong(MediaFormat.KEY_REPEAT_PREVIOUS_FRAME_AFTER, REPEAT_FRAME_DELAY_US); // µs        if (maxFps > 0) {            // The key existed privately before Android 10:            // <https://android.googlesource.com/platform/frameworks/base/+/625f0aad9f7a259b6881006ad8710adce57d1384%5E%21/>            // <https://github.com/Genymobile/scrcpy/issues/488#issuecomment-567321437>            format.setFloat(KEY_MAX_FPS_TO_ENCODER, maxFps);        }        return format;    }
    private static MediaFormat createFormat(int bitRate, int maxFps) {        MediaFormat format = new MediaFormat();        format.setString(MediaFormat.KEY_MIME, MediaFormat.MIMETYPE_VIDEO_AVC);        format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);        // must be present to configure the encoder, but does not impact the actual frame rate, which is variable        format.setInteger(MediaFormat.KEY_FRAME_RATE, 60);        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, DEFAULT_I_FRAME_INTERVAL);        // display the very first frame, and recover from bad quality when no new frames        format.setLong(MediaFormat.KEY_REPEAT_PREVIOUS_FRAME_AFTER, REPEAT_FRAME_DELAY_US); // µs        if (maxFps > 0) {            // The key existed privately before Android 10:            // <https://android.googlesource.com/platform/frameworks/base/+/625f0aad9f7a259b6881006ad8710adce57d1384%5E%21/>            // <https://github.com/Genymobile/scrcpy/issues/488#issuecomment-567321437>            format.setFloat(KEY_MAX_FPS_TO_ENCODER, maxFps);        }        return format;    }
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    --no-key-repeat\n"        "        Do not forward repeated key events when a key is held down.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    --shortcut-mod key[+...]][,...]\n"        "        Specify the modifiers to use for scrcpy shortcuts.\n"        "        Possible keys are \"lctrl\", \"rctrl\", \"lalt\", \"ralt\",\n"        "        \"lsuper\" and \"rsuper\".\n"        "\n"        "        A shortcut can consist in several keys, separated by '+'.\n"        "        Several shortcuts can be specified, separated by ','.\n"        "\n"        "        For example, to use either LCtrl+LAlt or LSuper for scrcpy\n"        "        shortcuts, pass \"lctrl+lalt,lsuper\".\n"        "\n"        "        Default is \"lalt,lsuper\" (left-Alt or left-Super).\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    In the following list, MOD is the shortcut modifier. By default,\n"        "    it's (left) Alt or (left) Super, but it can be configured by\n"        "    --shortcut-mod.\n"        "\n"        "    MOD+f\n"        "        Switch fullscreen mode\n"        "\n"        "    MOD+Left\n"        "        Rotate display left\n"        "\n"        "    MOD+Right\n"        "        Rotate display right\n"        "\n"        "    MOD+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    MOD+w\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    MOD+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    MOD+b\n"        "    MOD+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    MOD+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    MOD+m\n"        "        Click on MENU\n"        "\n"        "    MOD+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    MOD+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    MOD+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    MOD+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    MOD+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    MOD+r\n"        "        Rotate device screen\n"        "\n"        "    MOD+n\n"        "        Expand notification panel\n"        "\n"        "    MOD+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    MOD+c\n"        "        Copy to clipboard (inject COPY keycode, Android >= 7 only)\n"        "\n"        "    MOD+x\n"        "        Cut to clipboard (inject CUT keycode, Android >= 7 only)\n"        "\n"        "    MOD+v\n"        "        Copy computer clipboard to device, then paste (inject PASTE\n"        "        keycode, Android >= 7 only)\n"        "\n"        "    MOD+Shift+v\n"        "        Inject computer clipboard text as a sequence of key events\n"        "\n"        "    MOD+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Ctrl+click-and-move\n"        "        Pinch-to-zoom from the center of the screen\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    --no-key-repeat\n"        "        Do not forward repeated key events when a key is held down.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    --shortcut-mod key[+...]][,...]\n"        "        Specify the modifiers to use for scrcpy shortcuts.\n"        "        Possible keys are \"lctrl\", \"rctrl\", \"lalt\", \"ralt\",\n"        "        \"lsuper\" and \"rsuper\".\n"        "\n"        "        A shortcut can consist in several keys, separated by '+'.\n"        "        Several shortcuts can be specified, separated by ','.\n"        "\n"        "        For example, to use either LCtrl+LAlt or LSuper for scrcpy\n"        "        shortcuts, pass \"lctrl+lalt,lsuper\".\n"        "\n"        "        Default is \"lalt,lsuper\" (left-Alt or left-Super).\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    In the following list, MOD is the shortcut modifier. By default,\n"        "    it's (left) Alt or (left) Super, but it can be configured by\n"        "    --shortcut-mod (see above).\n"        "\n"        "    MOD+f\n"        "        Switch fullscreen mode\n"        "\n"        "    MOD+Left\n"        "        Rotate display left\n"        "\n"        "    MOD+Right\n"        "        Rotate display right\n"        "\n"        "    MOD+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    MOD+w\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    MOD+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    MOD+b\n"        "    MOD+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    MOD+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    MOD+m\n"        "        Click on MENU\n"        "\n"        "    MOD+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    MOD+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    MOD+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    MOD+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    MOD+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    MOD+r\n"        "        Rotate device screen\n"        "\n"        "    MOD+n\n"        "        Expand notification panel\n"        "\n"        "    MOD+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    MOD+c\n"        "        Copy to clipboard (inject COPY keycode, Android >= 7 only)\n"        "\n"        "    MOD+x\n"        "        Cut to clipboard (inject CUT keycode, Android >= 7 only)\n"        "\n"        "    MOD+v\n"        "        Copy computer clipboard to device, then paste (inject PASTE\n"        "        keycode, Android >= 7 only)\n"        "\n"        "    MOD+Shift+v\n"        "        Inject computer clipboard text as a sequence of key events\n"        "\n"        "    MOD+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Ctrl+click-and-move\n"        "        Pinch-to-zoom from the center of the screen\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
    public static void main(String... args) {        unlinkSelf();        try {            // Wait for the server to die            System.in.read();        } catch (IOException e) {            // Expected when the server is dead        }        Ln.i("Cleaning up");        boolean disableShowTouches = Boolean.parseBoolean(args[0]);        int restoreStayOn = Integer.parseInt(args[1]);        boolean restoreNormalPowerMode = Boolean.parseBoolean(args[2]);        if (disableShowTouches || restoreStayOn != -1) {            ServiceManager serviceManager = new ServiceManager();            try (ContentProvider settings = serviceManager.getActivityManager().createSettingsProvider()) {                if (disableShowTouches) {                    Ln.i("Disabling \"show touches\"");                    settings.putValue(ContentProvider.TABLE_SYSTEM, "show_touches", "0");                }                if (restoreStayOn != -1) {                    Ln.i("Restoring \"stay awake\"");                    settings.putValue(ContentProvider.TABLE_GLOBAL, "stay_on_while_plugged_in", String.valueOf(restoreStayOn));                }            }        }        if (restoreNormalPowerMode) {            Ln.i("Restoring normal power mode");            Device.setScreenPowerMode(Device.POWER_MODE_NORMAL);        }    }}
    public static void main(String... args) {        unlinkSelf();        try {            // Wait for the server to die            System.in.read();        } catch (IOException e) {            // Expected when the server is dead        }        Ln.i("Cleaning up");        boolean disableShowTouches = Boolean.parseBoolean(args[0]);        int restoreStayOn = Integer.parseInt(args[1]);        boolean restoreNormalPowerMode = Boolean.parseBoolean(args[2]);        if (disableShowTouches || restoreStayOn != -1) {            ServiceManager serviceManager = new ServiceManager();            try (ContentProvider settings = serviceManager.getActivityManager().createSettingsProvider()) {                if (disableShowTouches) {                    Ln.i("Disabling \"show touches\"");                    settings.putValue(ContentProvider.TABLE_SYSTEM, "show_touches", "0");                }                if (restoreStayOn != -1) {                    Ln.i("Restoring \"stay awake\"");                    settings.putValue(ContentProvider.TABLE_GLOBAL, "stay_on_while_plugged_in", String.valueOf(restoreStayOn));                }            }        }        if (restoreNormalPowerMode) {            Ln.i("Restoring normal power mode");            if (Device.isScreenOn()) {                Device.setScreenPowerMode(Device.POWER_MODE_NORMAL);            }        }    }}
    public void control() throws IOException {        // on start, power on the device        if (!device.isScreenOn()) {            device.injectKeycode(KeyEvent.KEYCODE_POWER);            // dirty hack            // After POWER is injected, the device is powered on asynchronously.            // To turn the device screen off while mirroring, the client will send a message that            // would be handled before the device is actually powered on, so its effect would            // be "canceled" once the device is turned back on.            // Adding this delay prevents to handle the message before the device is actually            // powered on.            SystemClock.sleep(500);        }        while (true) {            handleEvent();        }    }
    private boolean pressBackOrTurnScreenOn() {        int keycode = device.isScreenOn() ? KeyEvent.KEYCODE_BACK : KeyEvent.KEYCODE_POWER;        if (keepPowerModeOff && keycode == KeyEvent.KEYCODE_POWER) {            schedulePowerModeOff();        }        return device.injectKeycode(keycode);    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                if (device.supportsInputEvents()) {                    injectKeycode(msg.getAction(), msg.getKeycode(), msg.getRepeat(), msg.getMetaState());                }                break;            case ControlMessage.TYPE_INJECT_TEXT:                if (device.supportsInputEvents()) {                    injectText(msg.getText());                }                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                if (device.supportsInputEvents()) {                    injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), msg.getButtons());                }                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                if (device.supportsInputEvents()) {                    injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                }                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                if (device.supportsInputEvents()) {                    pressBackOrTurnScreenOn();                }                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                if (clipboardText != null) {                    sender.pushClipboardText(clipboardText);                }                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                setClipboard(msg.getText(), msg.getPaste());                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                if (device.supportsInputEvents()) {                    int mode = msg.getAction();                    boolean setPowerModeOk = Device.setScreenPowerMode(mode);                    if (setPowerModeOk) {                        keepPowerModeOff = mode == Device.POWER_MODE_OFF;                        Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));                    }                }                break;            case ControlMessage.TYPE_ROTATE_DEVICE:                device.rotateDevice();                break;            default:                // do nothing        }    }
    public void control() throws IOException {        // on start, power on the device        if (!Device.isScreenOn()) {            device.injectKeycode(KeyEvent.KEYCODE_POWER);            // dirty hack            // After POWER is injected, the device is powered on asynchronously.            // To turn the device screen off while mirroring, the client will send a message that            // would be handled before the device is actually powered on, so its effect would            // be "canceled" once the device is turned back on.            // Adding this delay prevents to handle the message before the device is actually            // powered on.            SystemClock.sleep(500);        }        while (true) {            handleEvent();        }    }
    private boolean pressBackOrTurnScreenOn() {        int keycode = Device.isScreenOn() ? KeyEvent.KEYCODE_BACK : KeyEvent.KEYCODE_POWER;        if (keepPowerModeOff && keycode == KeyEvent.KEYCODE_POWER) {            schedulePowerModeOff();        }        return device.injectKeycode(keycode);    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                if (device.supportsInputEvents()) {                    injectKeycode(msg.getAction(), msg.getKeycode(), msg.getRepeat(), msg.getMetaState());                }                break;            case ControlMessage.TYPE_INJECT_TEXT:                if (device.supportsInputEvents()) {                    injectText(msg.getText());                }                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                if (device.supportsInputEvents()) {                    injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), msg.getButtons());                }                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                if (device.supportsInputEvents()) {                    injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                }                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                if (device.supportsInputEvents()) {                    pressBackOrTurnScreenOn();                }                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                Device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                Device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = Device.getClipboardText();                if (clipboardText != null) {                    sender.pushClipboardText(clipboardText);                }                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                setClipboard(msg.getText(), msg.getPaste());                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                if (device.supportsInputEvents()) {                    int mode = msg.getAction();                    boolean setPowerModeOk = Device.setScreenPowerMode(mode);                    if (setPowerModeOk) {                        keepPowerModeOff = mode == Device.POWER_MODE_OFF;                        Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));                    }                }                break;            case ControlMessage.TYPE_ROTATE_DEVICE:                Device.rotateDevice();                break;            default:                // do nothing        }    }
    public Device(Options options) {        displayId = options.getDisplayId();        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo(displayId);        if (displayInfo == null) {            int[] displayIds = serviceManager.getDisplayManager().getDisplayIds();            throw new InvalidDisplayIdException(displayId, displayIds);        }        int displayInfoFlags = displayInfo.getFlags();        screenInfo = ScreenInfo.computeScreenInfo(displayInfo, options.getCrop(), options.getMaxSize(), options.getLockedVideoOrientation());        layerStack = displayInfo.getLayerStack();        serviceManager.getWindowManager().registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) {                synchronized (Device.this) {                    screenInfo = screenInfo.withDeviceRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        }, displayId);        if (options.getControl()) {            // If control is enabled, synchronize Android clipboard to the computer automatically            ClipboardManager clipboardManager = serviceManager.getClipboardManager();            if (clipboardManager != null) {                clipboardManager.addPrimaryClipChangedListener(new IOnPrimaryClipChangedListener.Stub() {                    @Override                    public void dispatchPrimaryClipChanged() {                        if (isSettingClipboard.get()) {                            // This is a notification for the change we are currently applying, ignore it                            return;                        }                        synchronized (Device.this) {                            if (clipboardListener != null) {                                String text = getClipboardText();                                if (text != null) {                                    clipboardListener.onClipboardTextChanged(text);                                }                            }                        }                    }                });            } else {                Ln.w("No clipboard manager, copy-paste between device and computer will not work");            }        }        if ((displayInfoFlags & DisplayInfo.FLAG_SUPPORTS_PROTECTED_BUFFERS) == 0) {            Ln.w("Display doesn't have FLAG_SUPPORTS_PROTECTED_BUFFERS flag, mirroring can be restricted");        }        // main display or any display on Android >= Q        supportsInputEvents = displayId == 0 || Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q;        if (!supportsInputEvents) {            Ln.w("Input events are not supported for secondary displays before Android 10");        }    }
    public String getClipboardText() {        ClipboardManager clipboardManager = serviceManager.getClipboardManager();        if (clipboardManager == null) {            return null;        }        CharSequence s = clipboardManager.getText();        if (s == null) {            return null;        }        return s.toString();    }
    public boolean setClipboardText(String text) {        ClipboardManager clipboardManager = serviceManager.getClipboardManager();        if (clipboardManager == null) {            return false;        }        String currentClipboard = getClipboardText();        if (currentClipboard != null && currentClipboard.equals(text)) {            // The clipboard already contains the requested text.            // Since pasting text from the computer involves setting the device clipboard, it could be set twice on a copy-paste. This would cause            // the clipboard listeners to be notified twice, and that would flood the Android keyboard clipboard history. To workaround this            // problem, do not explicitly set the clipboard text if it already contains the expected content.            return false;        }        isSettingClipboard.set(true);        boolean ok = clipboardManager.setText(text);        isSettingClipboard.set(false);        return ok;    }
    public void expandNotificationPanel() {        serviceManager.getStatusBarManager().expandNotificationsPanel();    }
    public void collapsePanels() {        serviceManager.getStatusBarManager().collapsePanels();    }
    public boolean injectEvent(InputEvent inputEvent, int mode) {        if (!supportsInputEvents()) {            throw new AssertionError("Could not inject input event if !supportsInputEvents()");        }        if (displayId != 0 && !InputManager.setDisplayId(inputEvent, displayId)) {            return false;        }        return serviceManager.getInputManager().injectInputEvent(inputEvent, mode);    }
    public ContentProvider createSettingsProvider() {        return serviceManager.getActivityManager().createSettingsProvider();    }}
    public void rotateDevice() {        WindowManager wm = serviceManager.getWindowManager();        boolean accelerometerRotation = !wm.isRotationFrozen();        int currentRotation = wm.getRotation();        int newRotation = (currentRotation & 1) ^ 1; // 0->1, 1->0, 2->1, 3->0        String newRotationString = newRotation == 0 ? "portrait" : "landscape";        Ln.i("Device rotation requested: " + newRotationString);        wm.freezeRotation(newRotation);        // restore auto-rotate if necessary        if (accelerometerRotation) {            wm.thawRotation();        }    }
    public boolean isScreenOn() {        return serviceManager.getPowerManager().isScreenOn();    }
    public Device(Options options) {        displayId = options.getDisplayId();        DisplayInfo displayInfo = SERVICE_MANAGER.getDisplayManager().getDisplayInfo(displayId);        if (displayInfo == null) {            int[] displayIds = SERVICE_MANAGER.getDisplayManager().getDisplayIds();            throw new InvalidDisplayIdException(displayId, displayIds);        }        int displayInfoFlags = displayInfo.getFlags();        screenInfo = ScreenInfo.computeScreenInfo(displayInfo, options.getCrop(), options.getMaxSize(), options.getLockedVideoOrientation());        layerStack = displayInfo.getLayerStack();        SERVICE_MANAGER.getWindowManager().registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) {                synchronized (Device.this) {                    screenInfo = screenInfo.withDeviceRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        }, displayId);        if (options.getControl()) {            // If control is enabled, synchronize Android clipboard to the computer automatically            ClipboardManager clipboardManager = SERVICE_MANAGER.getClipboardManager();            if (clipboardManager != null) {                clipboardManager.addPrimaryClipChangedListener(new IOnPrimaryClipChangedListener.Stub() {                    @Override                    public void dispatchPrimaryClipChanged() {                        if (isSettingClipboard.get()) {                            // This is a notification for the change we are currently applying, ignore it                            return;                        }                        synchronized (Device.this) {                            if (clipboardListener != null) {                                String text = getClipboardText();                                if (text != null) {                                    clipboardListener.onClipboardTextChanged(text);                                }                            }                        }                    }                });            } else {                Ln.w("No clipboard manager, copy-paste between device and computer will not work");            }        }        if ((displayInfoFlags & DisplayInfo.FLAG_SUPPORTS_PROTECTED_BUFFERS) == 0) {            Ln.w("Display doesn't have FLAG_SUPPORTS_PROTECTED_BUFFERS flag, mirroring can be restricted");        }        // main display or any display on Android >= Q        supportsInputEvents = displayId == 0 || Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q;        if (!supportsInputEvents) {            Ln.w("Input events are not supported for secondary displays before Android 10");        }    }
    public static String getClipboardText() {        ClipboardManager clipboardManager = SERVICE_MANAGER.getClipboardManager();        if (clipboardManager == null) {            return null;        }        CharSequence s = clipboardManager.getText();        if (s == null) {            return null;        }        return s.toString();    }
    public boolean setClipboardText(String text) {        ClipboardManager clipboardManager = SERVICE_MANAGER.getClipboardManager();        if (clipboardManager == null) {            return false;        }        String currentClipboard = getClipboardText();        if (currentClipboard != null && currentClipboard.equals(text)) {            // The clipboard already contains the requested text.            // Since pasting text from the computer involves setting the device clipboard, it could be set twice on a copy-paste. This would cause            // the clipboard listeners to be notified twice, and that would flood the Android keyboard clipboard history. To workaround this            // problem, do not explicitly set the clipboard text if it already contains the expected content.            return false;        }        isSettingClipboard.set(true);        boolean ok = clipboardManager.setText(text);        isSettingClipboard.set(false);        return ok;    }
    public static void expandNotificationPanel() {        SERVICE_MANAGER.getStatusBarManager().expandNotificationsPanel();    }
    public static void collapsePanels() {        SERVICE_MANAGER.getStatusBarManager().collapsePanels();    }
    public boolean injectEvent(InputEvent inputEvent, int mode) {        if (!supportsInputEvents()) {            throw new AssertionError("Could not inject input event if !supportsInputEvents()");        }        if (displayId != 0 && !InputManager.setDisplayId(inputEvent, displayId)) {            return false;        }        return SERVICE_MANAGER.getInputManager().injectInputEvent(inputEvent, mode);    }
    public static ContentProvider createSettingsProvider() {        return SERVICE_MANAGER.getActivityManager().createSettingsProvider();    }}
    public static void rotateDevice() {        WindowManager wm = SERVICE_MANAGER.getWindowManager();        boolean accelerometerRotation = !wm.isRotationFrozen();        int currentRotation = wm.getRotation();        int newRotation = (currentRotation & 1) ^ 1; // 0->1, 1->0, 2->1, 3->0        String newRotationString = newRotation == 0 ? "portrait" : "landscape";        Ln.i("Device rotation requested: " + newRotationString);        wm.freezeRotation(newRotation);        // restore auto-rotate if necessary        if (accelerometerRotation) {            wm.thawRotation();        }    }
    public static boolean isScreenOn() {        return SERVICE_MANAGER.getPowerManager().isScreenOn();    }
    private static void scrcpy(Options options) throws IOException {        Ln.i("Device: " + Build.MANUFACTURER + " " + Build.MODEL + " (Android " + Build.VERSION.RELEASE + ")");        final Device device = new Device(options);        List<CodecOption> codecOptions = CodecOption.parse(options.getCodecOptions());        boolean mustDisableShowTouchesOnCleanUp = false;        int restoreStayOn = -1;        if (options.getShowTouches() || options.getStayAwake()) {            try (ContentProvider settings = device.createSettingsProvider()) {                if (options.getShowTouches()) {                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_SYSTEM, "show_touches", "1");                    // If "show touches" was disabled, it must be disabled back on clean up                    mustDisableShowTouchesOnCleanUp = !"1".equals(oldValue);                }                if (options.getStayAwake()) {                    int stayOn = BatteryManager.BATTERY_PLUGGED_AC | BatteryManager.BATTERY_PLUGGED_USB | BatteryManager.BATTERY_PLUGGED_WIRELESS;                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_GLOBAL, "stay_on_while_plugged_in", String.valueOf(stayOn));                    try {                        restoreStayOn = Integer.parseInt(oldValue);                        if (restoreStayOn == stayOn) {                            // No need to restore                            restoreStayOn = -1;                        }                    } catch (NumberFormatException e) {                        restoreStayOn = 0;                    }                }            }        }        CleanUp.configure(mustDisableShowTouchesOnCleanUp, restoreStayOn, true);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate(), options.getMaxFps(), codecOptions);            if (options.getControl()) {                final Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());                device.setClipboardListener(new Device.ClipboardListener() {                    @Override                    public void onClipboardTextChanged(String text) {                        controller.getSender().pushClipboardText(text);                    }                });            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    private static void scrcpy(Options options) throws IOException {        Ln.i("Device: " + Build.MANUFACTURER + " " + Build.MODEL + " (Android " + Build.VERSION.RELEASE + ")");        final Device device = new Device(options);        List<CodecOption> codecOptions = CodecOption.parse(options.getCodecOptions());        boolean mustDisableShowTouchesOnCleanUp = false;        int restoreStayOn = -1;        if (options.getShowTouches() || options.getStayAwake()) {            try (ContentProvider settings = Device.createSettingsProvider()) {                if (options.getShowTouches()) {                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_SYSTEM, "show_touches", "1");                    // If "show touches" was disabled, it must be disabled back on clean up                    mustDisableShowTouchesOnCleanUp = !"1".equals(oldValue);                }                if (options.getStayAwake()) {                    int stayOn = BatteryManager.BATTERY_PLUGGED_AC | BatteryManager.BATTERY_PLUGGED_USB | BatteryManager.BATTERY_PLUGGED_WIRELESS;                    String oldValue = settings.getAndPutValue(ContentProvider.TABLE_GLOBAL, "stay_on_while_plugged_in", String.valueOf(stayOn));                    try {                        restoreStayOn = Integer.parseInt(oldValue);                        if (restoreStayOn == stayOn) {                            // No need to restore                            restoreStayOn = -1;                        }                    } catch (NumberFormatException e) {                        restoreStayOn = 0;                    }                }            }        }        CleanUp.configure(mustDisableShowTouchesOnCleanUp, restoreStayOn, true);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate(), options.getMaxFps(), codecOptions);            if (options.getControl()) {                final Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());                device.setClipboardListener(new Device.ClipboardListener() {                    @Override                    public void onClipboardTextChanged(String text) {                        controller.getSender().pushClipboardText(text);                    }                });            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    if (!control) {        return;    }    struct control_msg msg;    if (input_key_from_sdl_to_android(event, &msg)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}voidinput_manager_process_mouse_motion(struct input_manager *input_manager,                                   const SDL_MouseMotionEvent *event) {
input_manager_process_key(struct input_manager *input_manager,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = input_manager->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && !shift && down) {                    set_screen_power_mode(controller, SCREEN_POWER_MODE_OFF);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard                        set_device_clipboard(controller);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && cmd && !repeat && down) {                    screen_switch_fullscreen(input_manager->screen);                }                return;            case SDLK_x:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_fit(input_manager->screen);                }                return;            case SDLK_g:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_pixel_perfect(input_manager->screen);                }                return;            case SDLK_i:                if (!shift && cmd && !repeat && down) {                    struct fps_counter *fps_counter =                        input_manager->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;        }        return;    }    if (!control) {        return;    }    struct control_msg msg;    if (input_key_from_sdl_to_android(event, &msg)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    Ctrl+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+c\n"        "        copy device clipboard to computer\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
cmd_simple_wait(HANDLE handle, DWORD *exit_code) {    DWORD code;    if (WaitForSingleObject(handle, INFINITE) != WAIT_OBJECT_0            || !GetExitCodeProcess(handle, &code)) {        // could not wait or retrieve the exit code        code = -1; // max value, it's unsigned    }    if (exit_code) {        *exit_code = code;    }    return !code;}
cmd_terminate(HANDLE handle) {    return TerminateProcess(handle, 1) && CloseHandle(handle);}
cmd_simple_wait(HANDLE handle, DWORD *exit_code) {    DWORD code;    if (WaitForSingleObject(handle, INFINITE) != WAIT_OBJECT_0            || !GetExitCodeProcess(handle, &code)) {        // could not wait or retrieve the exit code        code = -1; // max value, it's unsigned    }    if (exit_code) {        *exit_code = code;    }    CloseHandle(handle);    return !code;}
cmd_terminate(HANDLE handle) {    return TerminateProcess(handle, 1);}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation, bool mipmaps) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size = get_rotated_size(frame_size, screen->rotation);    screen->content_size = content_size;    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_RendererInfo renderer_info;    int r = SDL_GetRendererInfo(screen->renderer, &renderer_info);    const char *renderer_name = r ? NULL : renderer_info.name;    LOGI("Renderer: %s", renderer_name ? renderer_name : "(unknown)");    if (SDL_RenderSetLogicalSize(screen->renderer, content_size.width,                                 content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    // stats with "opengl"    screen->use_opengl = renderer_name && !strncmp(renderer_name, "opengl", 6);    if (screen->use_opengl) {        struct sc_opengl *gl = &screen->gl;        sc_opengl_init(gl);        LOGI("OpenGL version: %s", gl->version);        if (mipmaps) {            bool supports_mipmaps =                sc_opengl_version_at_least(gl, 3, 0, /* OpenGL 3.0+ */                                               2, 0  /* OpenGL ES 2.0+ */);            if (supports_mipmaps) {                LOGI("Trilinear filtering enabled");                screen->mipmaps = true;            } else {                LOGW("Trilinear filtering disabled "                     "(OpenGL 3.0+ or ES 2.0+ required)");            }        } else {            LOGI("Trilinear filtering disabled");        }    } else {        LOGW("Trilinear filtering disabled (not an OpenGL renderer)");    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless,                      uint8_t rotation, bool mipmaps) {    screen->frame_size = frame_size;    screen->rotation = rotation;    if (rotation) {        LOGI("Initial display rotation set to %u", rotation);    }    struct size content_size = get_rotated_size(frame_size, screen->rotation);    screen->content_size = content_size;    struct size window_size =        get_initial_optimal_size(content_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_RendererInfo renderer_info;    int r = SDL_GetRendererInfo(screen->renderer, &renderer_info);    const char *renderer_name = r ? NULL : renderer_info.name;    LOGI("Renderer: %s", renderer_name ? renderer_name : "(unknown)");    if (SDL_RenderSetLogicalSize(screen->renderer, content_size.width,                                 content_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    // starts with "opengl"    screen->use_opengl = renderer_name && !strncmp(renderer_name, "opengl", 6);    if (screen->use_opengl) {        struct sc_opengl *gl = &screen->gl;        sc_opengl_init(gl);        LOGI("OpenGL version: %s", gl->version);        if (mipmaps) {            bool supports_mipmaps =                sc_opengl_version_at_least(gl, 3, 0, /* OpenGL 3.0+ */                                               2, 0  /* OpenGL ES 2.0+ */);            if (supports_mipmaps) {                LOGI("Trilinear filtering enabled");                screen->mipmaps = true;            } else {                LOGW("Trilinear filtering disabled "                     "(OpenGL 3.0+ or ES 2.0+ required)");            }        } else {            LOGI("Trilinear filtering disabled");        }    } else {        LOGW("Trilinear filtering disabled (not an OpenGL renderer)");    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
process_msgs(struct receiver *receiver, const unsigned char *buf, size_t len) {    size_t head = 0;    for (;;) {        struct device_msg msg;        ssize_t r = device_msg_deserialize(&buf[head], len - head, &msg);        if (r == -1) {            return -1;        }        if (r == 0) {            return head;        }        process_msg(receiver, &msg);        device_msg_destroy(&msg);        head += r;        SDL_assert(head <= len);        if (head == len) {            return head;        }    }}
process_msgs(struct receiver *receiver, const unsigned char *buf, size_t len) {    size_t head = 0;    for (;;) {        struct device_msg msg;        ssize_t r = device_msg_deserialize(&buf[head], len - head, &msg);        if (r == -1) {            return -1;        }        if (r == 0) {            return head;        }        process_msg(receiver, &msg);        device_msg_destroy(&msg);        head += r;        SDL_assert(head <= len);        if (head == len) {            return head;        }    }}
process_msg(struct receiver *receiver, struct device_msg *msg) {    switch (msg->type) {        case DEVICE_MSG_TYPE_CLIPBOARD:            LOGI("Device clipboard copied");            SDL_SetClipboardText(msg->clipboard.text);            break;    }}
run_receiver(void *data) {    struct receiver *receiver = data;    unsigned char buf[DEVICE_MSG_SERIALIZED_MAX_SIZE];    size_t head = 0;    for (;;) {        SDL_assert(head < DEVICE_MSG_SERIALIZED_MAX_SIZE);        ssize_t r = net_recv(receiver->control_socket, buf,                             DEVICE_MSG_SERIALIZED_MAX_SIZE - head);        if (r <= 0) {            LOGD("Receiver stopped");            break;        }        ssize_t consumed = process_msgs(receiver, buf, r);        if (consumed == -1) {            // an error occurred            break;        }        if (consumed) {            // shift the remaining data in the buffer            memmove(buf, &buf[consumed], r - consumed);            head = r - consumed;        }    }    return 0;}
process_msg(struct receiver *receiver, struct device_msg *msg) {    switch (msg->type) {        case DEVICE_MSG_TYPE_CLIPBOARD:            LOGI("Device clipboard copied");            SDL_SetClipboardText(msg->clipboard.text);            break;    }}
process_msgs(const unsigned char *buf, size_t len) {    size_t head = 0;    for (;;) {        struct device_msg msg;        ssize_t r = device_msg_deserialize(&buf[head], len - head, &msg);        if (r == -1) {            return -1;        }        if (r == 0) {            return head;        }        process_msg(&msg);        device_msg_destroy(&msg);        head += r;        SDL_assert(head <= len);        if (head == len) {            return head;        }    }}
process_msgs(const unsigned char *buf, size_t len) {    size_t head = 0;    for (;;) {        struct device_msg msg;        ssize_t r = device_msg_deserialize(&buf[head], len - head, &msg);        if (r == -1) {            return -1;        }        if (r == 0) {            return head;        }        process_msg(&msg);        device_msg_destroy(&msg);        head += r;        SDL_assert(head <= len);        if (head == len) {            return head;        }    }}
process_msg(struct device_msg *msg) {    switch (msg->type) {        case DEVICE_MSG_TYPE_CLIPBOARD:            LOGI("Device clipboard copied");            SDL_SetClipboardText(msg->clipboard.text);            break;    }}
run_receiver(void *data) {    struct receiver *receiver = data;    unsigned char buf[DEVICE_MSG_SERIALIZED_MAX_SIZE];    size_t head = 0;    for (;;) {        SDL_assert(head < DEVICE_MSG_SERIALIZED_MAX_SIZE);        ssize_t r = net_recv(receiver->control_socket, buf,                             DEVICE_MSG_SERIALIZED_MAX_SIZE - head);        if (r <= 0) {            LOGD("Receiver stopped");            break;        }        ssize_t consumed = process_msgs(buf, r);        if (consumed == -1) {            // an error occurred            break;        }        if (consumed) {            // shift the remaining data in the buffer            memmove(buf, &buf[consumed], r - consumed);            head = r - consumed;        }    }    return 0;}
process_msg(struct device_msg *msg) {    switch (msg->type) {        case DEVICE_MSG_TYPE_CLIPBOARD:            LOGI("Device clipboard copied");            SDL_SetClipboardText(msg->clipboard.text);            break;    }}
av_log_callback(void *avcl, int level, const char *fmt, va_list vl) {    SDL_LogPriority priority = sdl_priority_from_av_level(level);    if (priority == 0) {        return;    }    char *local_fmt = SDL_malloc(strlen(fmt) + 10);    if (!local_fmt) {        LOGC("Could not allocate string");        return;    }    // strcpy is safe here, the destination is large enough    strcpy(local_fmt, "[FFmpeg] ");    strcpy(local_fmt + 9, fmt);    SDL_LogMessageV(SDL_LOG_CATEGORY_VIDEO, priority, local_fmt, vl);    SDL_free(local_fmt);}
event_loop(bool display, bool control) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    if (display) {        SDL_AddEventWatch(event_watcher, NULL);    }#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        enum event_result result = handle_event(&event, control);        switch (result) {            case EVENT_RESULT_STOPPED_BY_USER:                return true;            case EVENT_RESULT_STOPPED_BY_EOS:                LOGW("Device disconnected");                return false;            case EVENT_RESULT_CONTINUE:                break;        }    }    return false;}
av_log_callback(void *avcl, int level, const char *fmt, va_list vl) {    (void) avcl;    SDL_LogPriority priority = sdl_priority_from_av_level(level);    if (priority == 0) {        return;    }    char *local_fmt = SDL_malloc(strlen(fmt) + 10);    if (!local_fmt) {        LOGC("Could not allocate string");        return;    }    // strcpy is safe here, the destination is large enough    strcpy(local_fmt, "[FFmpeg] ");    strcpy(local_fmt + 9, fmt);    SDL_LogMessageV(SDL_LOG_CATEGORY_VIDEO, priority, local_fmt, vl);    SDL_free(local_fmt);}
event_loop(bool display, bool control) {    (void) display;#ifdef CONTINUOUS_RESIZING_WORKAROUND    if (display) {        SDL_AddEventWatch(event_watcher, NULL);    }#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        enum event_result result = handle_event(&event, control);        switch (result) {            case EVENT_RESULT_STOPPED_BY_USER:                return true;            case EVENT_RESULT_STOPPED_BY_EOS:                LOGW("Device disconnected");                return false;            case EVENT_RESULT_CONTINUE:                break;        }    }    return false;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless) {    screen->frame_size = frame_size;    struct size window_size =        get_initial_optimal_size(frame_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != -1 ? window_x : SDL_WINDOWPOS_UNDEFINED;    int y = window_y != -1 ? window_y : SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless) {    screen->frame_size = frame_size;    struct size window_size =        get_initial_optimal_size(frame_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != -1 ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != -1 ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
    @Test    public void testParseKeycodeEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        // The message type (1 byte) does not count        Assert.assertEquals(ControlMessageReader.INJECT_KEYCODE_PAYLOAD_LENGTH, packet.length - 1);        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(KeyEvent.ACTION_UP, event.getAction());        Assert.assertEquals(KeyEvent.KEYCODE_ENTER, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }    @Test    public void testParseTextEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_TEXT);        byte[] text = "testé".getBytes(StandardCharsets.UTF_8);        dos.writeShort(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_TEXT, event.getType());        Assert.assertEquals("testé", event.getText());    }    @Test    public void testParseLongTextEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_TEXT);        byte[] text = new byte[ControlMessageReader.INJECT_TEXT_MAX_LENGTH];        Arrays.fill(text, (byte) 'a');        dos.writeShort(text.length);        dos.write(text);
    public void testParseBigSetClipboardEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_SET_CLIPBOARD);        byte[] rawText = new byte[ControlMessageReader.CLIPBOARD_TEXT_MAX_LENGTH];        Arrays.fill(rawText, (byte) 'a');        String text = new String(rawText, 0, rawText.length);        dos.writeShort(rawText.length);        dos.write(rawText);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_SET_CLIPBOARD, event.getType());        Assert.assertEquals(text, event.getText());    }
handle_event(SDL_Event *event, bool control) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = true;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return EVENT_RESULT_CONTINUE;            }            break;        case SDL_WINDOWEVENT:            switch (event->window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;            }            break;        case SDL_TEXTINPUT:            if (!control) {                break;            }            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            // some key events do not interact with the device, so process the            // event even if control is disabled            input_manager_process_key(&input_manager, &event->key, control);            break;        case SDL_MOUSEMOTION:            if (!control) {                break;            }            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            if (!control) {                break;            }            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            // some mouse events do not interact with the device, so process            // the event even if control is disabled            input_manager_process_mouse_button(&input_manager, &event->button,                                               control);            break;        case SDL_FINGERMOTION:        case SDL_FINGERDOWN:        case SDL_FINGERUP:            input_manager_process_touch(&input_manager, &event->tfinger);            break;        case SDL_DROPFILE: {            if (!control) {                break;            }            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
handle_event(SDL_Event *event, bool control) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = true;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return EVENT_RESULT_CONTINUE;            }            break;        case SDL_WINDOWEVENT:            screen_handle_window_event(&screen, &event->window);            break;        case SDL_TEXTINPUT:            if (!control) {                break;            }            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            // some key events do not interact with the device, so process the            // event even if control is disabled            input_manager_process_key(&input_manager, &event->key, control);            break;        case SDL_MOUSEMOTION:            if (!control) {                break;            }            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            if (!control) {                break;            }            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            // some mouse events do not interact with the device, so process            // the event even if control is disabled            input_manager_process_mouse_button(&input_manager, &event->button,                                               control);            break;        case SDL_FINGERMOTION:        case SDL_FINGERDOWN:        case SDL_FINGERUP:            input_manager_process_touch(&input_manager, &event->tfinger);            break;        case SDL_DROPFILE: {            if (!control) {                break;            }            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
}static inline SDL_Texture *create_texture(SDL_Renderer *renderer, struct size frame_size) {    return SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12,                             SDL_TEXTUREACCESS_STREAMING,                             frame_size.width, frame_size.height);}boolscreen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    screen->window = SDL_CreateWindow(window_title, SDL_WINDOWPOS_UNDEFINED,                                      SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    return true;}voidscreen_show_window(struct screen *screen) {    SDL_ShowWindow(screen->window);}voidscreen_destroy(struct screen *screen) {
screen_handle_window_event(struct screen *screen,                           const SDL_WindowEvent *event) {    switch (event->event) {        case SDL_WINDOWEVENT_EXPOSED:        case SDL_WINDOWEVENT_SIZE_CHANGED:            screen_render(screen);            break;    }}
static void test_options(void) {    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    char *argv[] = {        "scrcpy",        "--always-on-top",        "--bit-rate", "5M",        "--crop", "100:200:300:400",        "--fullscreen",        "--max-fps", "30",        "--max-size", "1024",        "--lock-video-orientation", "2",        // "--no-control" is not compatible with "--turn-screen-off"        // "--no-display" is not compatible with "--fulscreen"        "--port", "1234:1236",        "--push-target", "/sdcard/Movies",        "--record", "file",        "--record-format", "mkv",        "--render-expired-frames",        "--serial", "0123456789abcdef",        "--show-touches",        "--turn-screen-off",        "--prefer-text",        "--window-title", "my device",        "--window-x", "100",        "--window-y", "-1",        "--window-width", "600",        "--window-height", "0",        "--window-borderless",    };    bool ok = scrcpy_parse_args(&args, ARRAY_LEN(argv), argv);    assert(ok);    const struct scrcpy_options *opts = &args.opts;    assert(opts->always_on_top);    fprintf(stderr, "%d\n", (int) opts->bit_rate);    assert(opts->bit_rate == 5000000);    assert(!strcmp(opts->crop, "100:200:300:400"));    assert(opts->fullscreen);    assert(opts->max_fps == 30);    assert(opts->max_size == 1024);    assert(opts->lock_video_orientation == 2);    assert(opts->port_range.first == 1234);    assert(opts->port_range.last == 1236);    assert(!strcmp(opts->push_target, "/sdcard/Movies"));    assert(!strcmp(opts->record_filename, "file"));    assert(opts->record_format == RECORDER_FORMAT_MKV);    assert(opts->render_expired_frames);    assert(!strcmp(opts->serial, "0123456789abcdef"));    assert(opts->show_touches);    assert(opts->turn_screen_off);    assert(opts->prefer_text);    assert(!strcmp(opts->window_title, "my device"));    assert(opts->window_x == 100);    assert(opts->window_y == -1);    assert(opts->window_width == 600);    assert(opts->window_height == 0);    assert(opts->window_borderless);}
static void test_options(void) {    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    char *argv[] = {        "scrcpy",        "--always-on-top",        "--bit-rate", "5M",        "--crop", "100:200:300:400",        "--fullscreen",        "--max-fps", "30",        "--max-size", "1024",        "--lock-video-orientation", "2",        // "--no-control" is not compatible with "--turn-screen-off"        // "--no-display" is not compatible with "--fulscreen"        "--port", "1234:1236",        "--push-target", "/sdcard/Movies",        "--record", "file",        "--record-format", "mkv",        "--render-expired-frames",        "--serial", "0123456789abcdef",        "--show-touches",        "--turn-screen-off",        "--prefer-text",        "--window-title", "my device",        "--window-x", "100",        "--window-y", "-1",        "--window-width", "600",        "--window-height", "0",        "--window-borderless",    };    bool ok = scrcpy_parse_args(&args, ARRAY_LEN(argv), argv);    assert(ok);    const struct scrcpy_options *opts = &args.opts;    assert(opts->always_on_top);    assert(opts->bit_rate == 5000000);    assert(!strcmp(opts->crop, "100:200:300:400"));    assert(opts->fullscreen);    assert(opts->max_fps == 30);    assert(opts->max_size == 1024);    assert(opts->lock_video_orientation == 2);    assert(opts->port_range.first == 1234);    assert(opts->port_range.last == 1236);    assert(!strcmp(opts->push_target, "/sdcard/Movies"));    assert(!strcmp(opts->record_filename, "file"));    assert(opts->record_format == RECORDER_FORMAT_MKV);    assert(opts->render_expired_frames);    assert(!strcmp(opts->serial, "0123456789abcdef"));    assert(opts->show_touches);    assert(opts->turn_screen_off);    assert(opts->prefer_text);    assert(!strcmp(opts->window_title, "my device"));    assert(opts->window_x == 100);    assert(opts->window_y == -1);    assert(opts->window_width == 600);    assert(opts->window_height == 0);    assert(opts->window_borderless);}static void test_options2(void) {
    public static boolean isEnabled(Level level) {        return level.ordinal() >= THRESHOLD.ordinal();    }
    public static void initLogLevel(Level level) {        THRESHOLD = level;    }
    public static boolean isEnabled(Level level) {        return level.ordinal() >= threshold.ordinal();    }
    public static void initLogLevel(Level level) {        threshold = level;    }
    private int getReverseVideoRotation(int deviceRotation) {        if (lockedVideoOrientation == -1) {            // no offset            return 0;        }        return (lockedVideoOrientation + 4 - deviceRotation) % 4;    }
    public Device(Options options) {        lockedVideoOrientation = options.getLockedVideoOrientation();        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        screenInfo = ScreenInfo.computeScreenInfo(displayInfo, options.getCrop(), options.getMaxSize());        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    screenInfo = screenInfo.withDeviceRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        });    }
    public int getVideoRotation(int deviceRotation) {        if (lockedVideoOrientation == -1) {            // no offset            return 0;        }        return (deviceRotation + 4 - lockedVideoOrientation) % 4;    }
    public Point getPhysicalPoint(Position position) {        // it hides the field on purpose, to read it with a lock        @SuppressWarnings("checkstyle:HiddenField")        ScreenInfo screenInfo = getScreenInfo(); // read with synchronization        Size videoSize = screenInfo.getVideoSize();        int deviceRotation = screenInfo.getDeviceRotation();        int reverseVideoRotation = getReverseVideoRotation(deviceRotation);        // reverse the video rotation to apply the events        Position devicePosition = position.rotate(reverseVideoRotation);        Size clientVideoSize = devicePosition.getScreenSize();        if (!videoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event            return null;        }        Rect contentRect = screenInfo.getContentRect();        Point point = devicePosition.getPoint();        int convertedX = contentRect.left + point.getX() * contentRect.width() / videoSize.getWidth();        int convertedY = contentRect.top + point.getY() * contentRect.height() / videoSize.getHeight();        return new Point(convertedX, convertedY);    }
        return new Point(convertedX, convertedY);    }    public static String getDeviceName() {        return Build.MODEL;    }    public boolean injectInputEvent(InputEvent inputEvent, int mode) {
    public Device(Options options) {        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        screenInfo = ScreenInfo.computeScreenInfo(displayInfo, options.getCrop(), options.getMaxSize(), options.getLockedVideoOrientation());        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    screenInfo = screenInfo.withDeviceRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        });    }
        int reverseVideoRotation = screenInfo.getReverseVideoRotation();        // reverse the video rotation to apply the events        Position devicePosition = position.rotate(reverseVideoRotation);        Size clientVideoSize = devicePosition.getScreenSize();        if (!unlockedVideoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event
    public Point getPhysicalPoint(Position position) {        // it hides the field on purpose, to read it with a lock        @SuppressWarnings("checkstyle:HiddenField")        ScreenInfo screenInfo = getScreenInfo(); // read with synchronization        // ignore the locked video orientation, the events will apply in coordinates considered in the physical device orientation        Size unlockedVideoSize = screenInfo.getUnlockedVideoSize();        int reverseVideoRotation = screenInfo.getReverseVideoRotation();        // reverse the video rotation to apply the events        Position devicePosition = position.rotate(reverseVideoRotation);        Size clientVideoSize = devicePosition.getScreenSize();        if (!unlockedVideoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event            return null;        }        Rect contentRect = screenInfo.getContentRect();        Point point = devicePosition.getPoint();        int convertedX = contentRect.left + point.getX() * contentRect.width() / unlockedVideoSize.getWidth();        int convertedY = contentRect.top + point.getY() * contentRect.height() / unlockedVideoSize.getHeight();        return new Point(convertedX, convertedY);    }
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        Workarounds.prepareMainLooper();        Workarounds.fillAppInfo();        MediaFormat format = createFormat(bitRate, maxFps, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                ScreenInfo screenInfo = device.getScreenInfo();                Rect contentRect = screenInfo.getContentRect();                Rect videoRect = screenInfo.getVideoSize().toRect();                int videoRotation = device.getVideoRotation(screenInfo.getDeviceRotation());                setSize(format, videoRotation, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, videoRotation, contentRect, videoRect);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    private static void setSize(MediaFormat format, int orientation, int width, int height) {        if (orientation % 2 == 0) {            format.setInteger(MediaFormat.KEY_WIDTH, width);            format.setInteger(MediaFormat.KEY_HEIGHT, height);            return;        }        format.setInteger(MediaFormat.KEY_WIDTH, height);        format.setInteger(MediaFormat.KEY_HEIGHT, width);    }
    private static void setSize(MediaFormat format, int orientation, int width, int height) {        if (orientation % 2 == 0) {            format.setInteger(MediaFormat.KEY_WIDTH, width);            format.setInteger(MediaFormat.KEY_HEIGHT, height);            return;        }        format.setInteger(MediaFormat.KEY_WIDTH, height);        format.setInteger(MediaFormat.KEY_HEIGHT, width);    }
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        Workarounds.prepareMainLooper();        Workarounds.fillAppInfo();        MediaFormat format = createFormat(bitRate, maxFps, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                ScreenInfo screenInfo = device.getScreenInfo();                Rect contentRect = screenInfo.getContentRect();                // include the locked video orientation                Rect videoRect = screenInfo.getVideoSize().toRect();                // does not include the locked video orientation                Rect unlockedVideoRect = screenInfo.getUnlockedVideoSize().toRect();                int videoRotation = screenInfo.getVideoRotation();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, videoRotation, contentRect, unlockedVideoRect);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    private static void setSize(MediaFormat format, int width, int height) {        format.setInteger(MediaFormat.KEY_WIDTH, width);        format.setInteger(MediaFormat.KEY_HEIGHT, height);    }
        codec.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);    }    private static void setSize(MediaFormat format, int width, int height) {        format.setInteger(MediaFormat.KEY_WIDTH, width);        format.setInteger(MediaFormat.KEY_HEIGHT, height);    }    private static void setDisplaySurface(IBinder display, Surface surface, int orientation, Rect deviceRect, Rect displayRect) {        SurfaceControl.openTransaction();
    public Size getVideoSize() {        return videoSize;    }
    public Size getVideoSize() {        return videoSize;    }
    public Size getVideoSize() {        return videoSize;    }
    public Size getVideoSize() {        return videoSize;    }
    public ScreenInfo(Rect contentRect, Size videoSize, int deviceRotation) {        this.contentRect = contentRect;        this.videoSize = videoSize;        this.deviceRotation = deviceRotation;    }
    public ScreenInfo(Rect contentRect, Size videoSize, int deviceRotation) {        this.contentRect = contentRect;        this.videoSize = videoSize;        this.deviceRotation = deviceRotation;    }
    public ScreenInfo withDeviceRotation(int newDeviceRotation) {        if (newDeviceRotation == deviceRotation) {            return this;        }        // true if changed between portrait and landscape        boolean orientationChanged = (deviceRotation + newDeviceRotation) % 2 != 0;        Rect newContentRect;        Size newVideoSize;        if (orientationChanged) {            newContentRect = flipRect(contentRect);            newVideoSize = videoSize.rotate();        } else {            newContentRect = contentRect;            newVideoSize = videoSize;        }        return new ScreenInfo(newContentRect, newVideoSize, newDeviceRotation);    }
    public static ScreenInfo computeScreenInfo(DisplayInfo displayInfo, Rect crop, int maxSize) {        int rotation = displayInfo.getRotation();        Size deviceSize = displayInfo.getSize();        Rect contentRect = new Rect(0, 0, deviceSize.getWidth(), deviceSize.getHeight());        if (crop != null) {            if (rotation % 2 != 0) { // 180s preserve dimensions                // the crop (provided by the user) is expressed in the natural orientation                crop = flipRect(crop);            }            if (!contentRect.intersect(crop)) {                // intersect() changes contentRect so that it is intersected with crop                Ln.w("Crop rectangle (" + formatCrop(crop) + ") does not intersect device screen (" + formatCrop(deviceSize.toRect()) + ")");                contentRect = new Rect(); // empty            }        }        Size videoSize = computeVideoSize(contentRect.width(), contentRect.height(), maxSize);        return new ScreenInfo(contentRect, videoSize, rotation);    }
    public static ScreenInfo computeScreenInfo(DisplayInfo displayInfo, Rect crop, int maxSize) {        int rotation = displayInfo.getRotation();        Size deviceSize = displayInfo.getSize();        Rect contentRect = new Rect(0, 0, deviceSize.getWidth(), deviceSize.getHeight());        if (crop != null) {            if (rotation % 2 != 0) { // 180s preserve dimensions                // the crop (provided by the user) is expressed in the natural orientation                crop = flipRect(crop);            }            if (!contentRect.intersect(crop)) {                // intersect() changes contentRect so that it is intersected with crop                Ln.w("Crop rectangle (" + formatCrop(crop) + ") does not intersect device screen (" + formatCrop(deviceSize.toRect()) + ")");                contentRect = new Rect(); // empty            }        }        Size videoSize = computeVideoSize(contentRect.width(), contentRect.height(), maxSize);        return new ScreenInfo(contentRect, videoSize, rotation);    }
    public Size getVideoSize() {        if (getVideoRotation() % 2 == 0) {            return unlockedVideoSize;        }        return unlockedVideoSize.rotate();    }
    public int getReverseVideoRotation() {        if (lockedVideoOrientation == -1) {            // no offset            return 0;        }        return (lockedVideoOrientation + 4 - deviceRotation) % 4;    }}
    public int getVideoRotation() {        if (lockedVideoOrientation == -1) {            // no offset            return 0;        }        return (deviceRotation + 4 - lockedVideoOrientation) % 4;    }
    public Size getUnlockedVideoSize() {        return unlockedVideoSize;    }
    private final int deviceRotation;    /**     * The locked video orientation (-1: disabled, 0: normal, 1: 90° CCW, 2: 180°, 3: 90° CW)     */    private final int lockedVideoOrientation;
    public ScreenInfo(Rect contentRect, Size unlockedVideoSize, int deviceRotation, int lockedVideoOrientation) {        this.contentRect = contentRect;        this.unlockedVideoSize = unlockedVideoSize;        this.deviceRotation = deviceRotation;        this.lockedVideoOrientation = lockedVideoOrientation;    }
    public ScreenInfo withDeviceRotation(int newDeviceRotation) {        if (newDeviceRotation == deviceRotation) {            return this;        }        // true if changed between portrait and landscape        boolean orientationChanged = (deviceRotation + newDeviceRotation) % 2 != 0;        Rect newContentRect;        Size newUnlockedVideoSize;        if (orientationChanged) {            newContentRect = flipRect(contentRect);            newUnlockedVideoSize = unlockedVideoSize.rotate();        } else {            newContentRect = contentRect;            newUnlockedVideoSize = unlockedVideoSize;        }        return new ScreenInfo(newContentRect, newUnlockedVideoSize, newDeviceRotation, lockedVideoOrientation);    }
        return unlockedVideoSize.rotate();    }    public int getDeviceRotation() {        return deviceRotation;    }    public ScreenInfo withDeviceRotation(int newDeviceRotation) {        if (newDeviceRotation == deviceRotation) {            return this;        }        // true if changed between portrait and landscape        boolean orientationChanged = (deviceRotation + newDeviceRotation) % 2 != 0;        Rect newContentRect;        Size newUnlockedVideoSize;        if (orientationChanged) {            newContentRect = flipRect(contentRect);            newUnlockedVideoSize = unlockedVideoSize.rotate();        } else {
    public static ScreenInfo computeScreenInfo(DisplayInfo displayInfo, Rect crop, int maxSize, int lockedVideoOrientation) {        int rotation = displayInfo.getRotation();        Size deviceSize = displayInfo.getSize();        Rect contentRect = new Rect(0, 0, deviceSize.getWidth(), deviceSize.getHeight());        if (crop != null) {            if (rotation % 2 != 0) { // 180s preserve dimensions                // the crop (provided by the user) is expressed in the natural orientation                crop = flipRect(crop);            }            if (!contentRect.intersect(crop)) {                // intersect() changes contentRect so that it is intersected with crop                Ln.w("Crop rectangle (" + formatCrop(crop) + ") does not intersect device screen (" + formatCrop(deviceSize.toRect()) + ")");                contentRect = new Rect(); // empty            }        }        Size videoSize = computeVideoSize(contentRect.width(), contentRect.height(), maxSize);        return new ScreenInfo(contentRect, videoSize, rotation, lockedVideoOrientation);    }
convert_keycode(SDL_Keycode from, enum android_keycode *to, uint16_t mod,                bool prefer_text) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_HOME,         AKEYCODE_MOVE_HOME);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);    }    if (!(mod & (KMOD_NUM | KMOD_SHIFT))) {        // Handle Numpad events when Num Lock is disabled        // If SHIFT is pressed, a text event will be sent instead        switch(from) {            MAP(SDLK_KP_0,            AKEYCODE_INSERT);            MAP(SDLK_KP_1,            AKEYCODE_MOVE_END);            MAP(SDLK_KP_2,            AKEYCODE_DPAD_DOWN);            MAP(SDLK_KP_3,            AKEYCODE_PAGE_DOWN);            MAP(SDLK_KP_4,            AKEYCODE_DPAD_LEFT);            MAP(SDLK_KP_6,            AKEYCODE_DPAD_RIGHT);            MAP(SDLK_KP_7,            AKEYCODE_MOVE_HOME);            MAP(SDLK_KP_8,            AKEYCODE_DPAD_UP);            MAP(SDLK_KP_9,            AKEYCODE_PAGE_UP);            MAP(SDLK_KP_PERIOD,       AKEYCODE_FORWARD_DEL);        }    }    if (prefer_text) {        // do not forward alpha and space key events        return false;    }    if (mod & (KMOD_LALT | KMOD_RALT | KMOD_LGUI | KMOD_RGUI)) {        return false;    }    // if ALT and META are not pressed, also handle letters and space    switch (from) {        MAP(SDLK_a,            AKEYCODE_A);        MAP(SDLK_b,            AKEYCODE_B);        MAP(SDLK_c,            AKEYCODE_C);        MAP(SDLK_d,            AKEYCODE_D);        MAP(SDLK_e,            AKEYCODE_E);        MAP(SDLK_f,            AKEYCODE_F);        MAP(SDLK_g,            AKEYCODE_G);        MAP(SDLK_h,            AKEYCODE_H);        MAP(SDLK_i,            AKEYCODE_I);        MAP(SDLK_j,            AKEYCODE_J);        MAP(SDLK_k,            AKEYCODE_K);        MAP(SDLK_l,            AKEYCODE_L);        MAP(SDLK_m,            AKEYCODE_M);        MAP(SDLK_n,            AKEYCODE_N);        MAP(SDLK_o,            AKEYCODE_O);        MAP(SDLK_p,            AKEYCODE_P);        MAP(SDLK_q,            AKEYCODE_Q);        MAP(SDLK_r,            AKEYCODE_R);        MAP(SDLK_s,            AKEYCODE_S);        MAP(SDLK_t,            AKEYCODE_T);        MAP(SDLK_u,            AKEYCODE_U);        MAP(SDLK_v,            AKEYCODE_V);        MAP(SDLK_w,            AKEYCODE_W);        MAP(SDLK_x,            AKEYCODE_X);        MAP(SDLK_y,            AKEYCODE_Y);        MAP(SDLK_z,            AKEYCODE_Z);        MAP(SDLK_SPACE,        AKEYCODE_SPACE);        FAIL;    }}
convert_keycode(SDL_Keycode from, enum android_keycode *to, uint16_t mod,                bool prefer_text) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_HOME,         AKEYCODE_MOVE_HOME);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);        MAP(SDLK_LCTRL,        AKEYCODE_CTRL_LEFT);        MAP(SDLK_RCTRL,        AKEYCODE_CTRL_RIGHT);    }    if (!(mod & (KMOD_NUM | KMOD_SHIFT))) {        // Handle Numpad events when Num Lock is disabled        // If SHIFT is pressed, a text event will be sent instead        switch(from) {            MAP(SDLK_KP_0,            AKEYCODE_INSERT);            MAP(SDLK_KP_1,            AKEYCODE_MOVE_END);            MAP(SDLK_KP_2,            AKEYCODE_DPAD_DOWN);            MAP(SDLK_KP_3,            AKEYCODE_PAGE_DOWN);            MAP(SDLK_KP_4,            AKEYCODE_DPAD_LEFT);            MAP(SDLK_KP_6,            AKEYCODE_DPAD_RIGHT);            MAP(SDLK_KP_7,            AKEYCODE_MOVE_HOME);            MAP(SDLK_KP_8,            AKEYCODE_DPAD_UP);            MAP(SDLK_KP_9,            AKEYCODE_PAGE_UP);            MAP(SDLK_KP_PERIOD,       AKEYCODE_FORWARD_DEL);        }    }    if (prefer_text && !(mod & KMOD_CTRL)) {        // do not forward alpha and space key events (unless Ctrl is pressed)        return false;    }    if (mod & (KMOD_LALT | KMOD_RALT | KMOD_LGUI | KMOD_RGUI)) {        return false;    }    // if ALT and META are not pressed, also handle letters and space    switch (from) {        MAP(SDLK_a,            AKEYCODE_A);        MAP(SDLK_b,            AKEYCODE_B);        MAP(SDLK_c,            AKEYCODE_C);        MAP(SDLK_d,            AKEYCODE_D);        MAP(SDLK_e,            AKEYCODE_E);        MAP(SDLK_f,            AKEYCODE_F);        MAP(SDLK_g,            AKEYCODE_G);        MAP(SDLK_h,            AKEYCODE_H);        MAP(SDLK_i,            AKEYCODE_I);        MAP(SDLK_j,            AKEYCODE_J);        MAP(SDLK_k,            AKEYCODE_K);        MAP(SDLK_l,            AKEYCODE_L);        MAP(SDLK_m,            AKEYCODE_M);        MAP(SDLK_n,            AKEYCODE_N);        MAP(SDLK_o,            AKEYCODE_O);        MAP(SDLK_p,            AKEYCODE_P);        MAP(SDLK_q,            AKEYCODE_Q);        MAP(SDLK_r,            AKEYCODE_R);        MAP(SDLK_s,            AKEYCODE_S);        MAP(SDLK_t,            AKEYCODE_T);        MAP(SDLK_u,            AKEYCODE_U);        MAP(SDLK_v,            AKEYCODE_V);        MAP(SDLK_w,            AKEYCODE_W);        MAP(SDLK_x,            AKEYCODE_X);        MAP(SDLK_y,            AKEYCODE_Y);        MAP(SDLK_z,            AKEYCODE_Z);        MAP(SDLK_SPACE,        AKEYCODE_SPACE);        FAIL;    }}
disable_tunnel(struct server *server) {    if (server->tunnel_forward) {        return disable_tunnel_forward(server->serial, server->local_port);    }    return disable_tunnel_reverse(server->serial);}
listen_on_port(uint16_t port) {    return net_listen(IPV4_LOCALHOST, port, 1);}
disable_tunnel(struct server *server) {    if (server->tunnel_forward) {        return disable_tunnel_forward(server->serial, server->local_port);    }    return disable_tunnel_reverse(server->serial);}
listen_on_port(uint16_t port) {#define IPV4_LOCALHOST 0x7F000001    return net_listen(IPV4_LOCALHOST, port, 1);}
    private boolean injectKeycode(int action, int keycode, int repeat, int metaState) {        return device.injectKeyEvent(action, keycode, repeat, metaState);    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                if (device.supportsInputEvents()) {                    injectKeycode(msg.getAction(), msg.getKeycode(), msg.getRepeat(), msg.getMetaState());                }                break;            case ControlMessage.TYPE_INJECT_TEXT:                if (device.supportsInputEvents()) {                    injectText(msg.getText());                }                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                if (device.supportsInputEvents()) {                    injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), msg.getButtons());                }                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                if (device.supportsInputEvents()) {                    injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                }                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                if (device.supportsInputEvents()) {                    pressBackOrTurnScreenOn();                }                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                if (clipboardText != null) {                    sender.pushClipboardText(clipboardText);                }                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                setClipboard(msg.getText(), msg.getPaste());                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                if (device.supportsInputEvents()) {                    int mode = msg.getAction();                    boolean setPowerModeOk = Device.setScreenPowerMode(mode);                    if (setPowerModeOk) {                        Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));                    }                }                break;            case ControlMessage.TYPE_ROTATE_DEVICE:                device.rotateDevice();                break;            default:                // do nothing        }    }
    private boolean pressBackOrTurnScreenOn() {        int keycode = device.isScreenOn() ? KeyEvent.KEYCODE_BACK : KeyEvent.KEYCODE_WAKEUP;        return device.injectKeycode(keycode);    }
    private boolean pressBackOrTurnScreenOn() {        int keycode = device.isScreenOn() ? KeyEvent.KEYCODE_BACK : KeyEvent.KEYCODE_WAKEUP;        return device.injectKeycode(keycode);    }
    private boolean injectKeycode(int action, int keycode, int repeat, int metaState) {        if (keepPowerModeOff && action == KeyEvent.ACTION_UP && (keycode == KeyEvent.KEYCODE_POWER || keycode == KeyEvent.KEYCODE_WAKEUP)) {            schedulePowerModeOff();        }        return device.injectKeyEvent(action, keycode, repeat, metaState);    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                if (device.supportsInputEvents()) {                    injectKeycode(msg.getAction(), msg.getKeycode(), msg.getRepeat(), msg.getMetaState());                }                break;            case ControlMessage.TYPE_INJECT_TEXT:                if (device.supportsInputEvents()) {                    injectText(msg.getText());                }                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                if (device.supportsInputEvents()) {                    injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), msg.getButtons());                }                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                if (device.supportsInputEvents()) {                    injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                }                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                if (device.supportsInputEvents()) {                    pressBackOrTurnScreenOn();                }                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                if (clipboardText != null) {                    sender.pushClipboardText(clipboardText);                }                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                setClipboard(msg.getText(), msg.getPaste());                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                if (device.supportsInputEvents()) {                    int mode = msg.getAction();                    boolean setPowerModeOk = Device.setScreenPowerMode(mode);                    if (setPowerModeOk) {                        keepPowerModeOff = mode == Device.POWER_MODE_OFF;                        Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));                    }                }                break;            case ControlMessage.TYPE_ROTATE_DEVICE:                device.rotateDevice();                break;            default:                // do nothing        }    }
    private boolean pressBackOrTurnScreenOn() {        int keycode = device.isScreenOn() ? KeyEvent.KEYCODE_BACK : KeyEvent.KEYCODE_WAKEUP;        if (keepPowerModeOff && keycode == KeyEvent.KEYCODE_WAKEUP) {            schedulePowerModeOff();        }        return device.injectKeycode(keycode);    }
    private static void schedulePowerModeOff() {        EXECUTOR.schedule(new Runnable() {            @Override            public void run() {                Ln.i("Forcing screen off");                Device.setScreenPowerMode(Device.POWER_MODE_OFF);            }        }, 200, TimeUnit.MILLISECONDS);    }
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value. Values are integers in the\n"        "        range [-1..3]. Natural device orientation is 0 and each\n"        "        increment adds 90 degrees counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
parse_window_position(const char *s, int16_t *position) {    long value;    bool ok = parse_integer_arg(s, &value, false, -1, 0x7FFF,                                "window position");    if (!ok) {        return false;    }    *position = (int16_t) value;    return true;}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value. Values are integers in the\n"        "        range [-1..3]. Natural device orientation is 0 and each\n"        "        increment adds 90 degrees counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
parse_window_position(const char *s, int16_t *position) {    // special value for "auto"    static_assert(WINDOW_POSITION_UNDEFINED == -0x8000);    if (!strcmp(s, "auto")) {        *position = WINDOW_POSITION_UNDEFINED;        return true;    }    long value;    bool ok = parse_integer_arg(s, &value, false, -0x7FFF, 0x7FFF,                                "window position");    if (!ok) {        return false;    }    *position = (int16_t) value;    return true;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless) {    screen->frame_size = frame_size;    struct size window_size =        get_initial_optimal_size(frame_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != -1 ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != -1 ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless) {    screen->frame_size = frame_size;    struct size window_size =        get_initial_optimal_size(frame_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != WINDOW_POSITION_UNDEFINED          ? window_x : (int) SDL_WINDOWPOS_UNDEFINED;    int y = window_y != WINDOW_POSITION_UNDEFINED          ? window_y : (int) SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    if (!scrcpy_parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        scrcpy_print_usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    LOGI("scrcpy " SCRCPY_VERSION " <https://github.com/Genymobile/scrcpy>");#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifndef NDEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    int res = scrcpy(&args.opts) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif#ifndef NDEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    if (!scrcpy_parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        scrcpy_print_usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    LOGI("scrcpy " SCRCPY_VERSION " <https://github.com/Genymobile/scrcpy>");#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }    int res = scrcpy(&args.opts) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };#ifndef NDEBUG    args.opts.log_level = SC_LOG_LEVEL_DEBUG;#endif    if (!scrcpy_parse_args(&args, argc, argv)) {        return 1;    }    SDL_LogPriority sdl_log = convert_log_level_to_sdl(args.opts.log_level);    SDL_LogSetPriority(SDL_LOG_CATEGORY_APPLICATION, sdl_log);    if (args.help) {        scrcpy_print_usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    LOGI("scrcpy " SCRCPY_VERSION " <https://github.com/Genymobile/scrcpy>");#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }    int res = scrcpy(&args.opts) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };#ifndef NDEBUG    args.opts.log_level = SC_LOG_LEVEL_DEBUG;#endif    if (!scrcpy_parse_args(&args, argc, argv)) {        return 1;    }    SDL_LogPriority sdl_log = convert_log_level_to_sdl(args.opts.log_level);    SDL_LogSetPriority(SDL_LOG_CATEGORY_APPLICATION, sdl_log);    if (args.help) {        scrcpy_print_usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    LOGI("scrcpy " SCRCPY_VERSION " <https://github.com/Genymobile/scrcpy>");#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }    int res = scrcpy(&args.opts) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press Enter to continue...\n");        getchar();    }#endif    return res;}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"codec-options",          required_argument, NULL, OPT_CODEC_OPTIONS},        {"crop",                   required_argument, NULL, OPT_CROP},        {"disable-screensaver",    no_argument,       NULL,                                                  OPT_DISABLE_SCREENSAVER},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"force-adb-forward",      no_argument,       NULL,                                                  OPT_FORCE_ADB_FORWARD},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"port",                   required_argument, NULL, 'p'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"shortcut-mod",           required_argument, NULL, OPT_SHORTCUT_MOD},        {"show-touches",           no_argument,       NULL, 't'},        {"stay-awake",             no_argument,       NULL, 'w'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"verbosity",              required_argument, NULL, 'V'},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTvV:w",                            long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case 'V':                if (!parse_log_level(optarg, &opts->log_level)) {                    return false;                }                break;            case 'w':                opts->stay_awake = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            case OPT_CODEC_OPTIONS:                opts->codec_options = optarg;                break;            case OPT_FORCE_ADB_FORWARD:                opts->force_adb_forward = true;                break;            case OPT_DISABLE_SCREENSAVER:                opts->disable_screensaver = true;                break;            case OPT_SHORTCUT_MOD:                if (!parse_shortcut_mods(optarg, &opts->shortcut_mods)) {                    return false;                }                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    if (!opts->control && opts->stay_awake) {        LOGE("Could not request to stay awake if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    --shortcut-mod key[+...]][,...]\n"        "        Specify the modifiers to use for scrcpy shortcuts.\n"        "        Possible keys are \"lctrl\", \"rctrl\", \"lalt\", \"ralt\",\n"        "        \"lsuper\" and \"rsuper\".\n"        "\n"        "        A shortcut can consist in several keys, separated by '+'.\n"        "        Several shortcuts can be specified, separated by ','.\n"        "\n"        "        For example, to use either LCtrl+LAlt or LSuper for scrcpy\n"        "        shortcuts, pass \"lctrl+lalt,lsuper\".\n"        "\n"        "        Default is \"lalt,lsuper\" (left-Alt or left-Super).\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    In the following list, MOD is the shortcut modifier. By default,\n"        "    it's (left) Alt or (left) Super, but it can be configured by\n"        "    --shortcut-mod.\n"        "\n"        "    MOD+f\n"        "        Switch fullscreen mode\n"        "\n"        "    MOD+Left\n"        "        Rotate display left\n"        "\n"        "    MOD+Right\n"        "        Rotate display right\n"        "\n"        "    MOD+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    MOD+w\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    MOD+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    MOD+b\n"        "    MOD+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    MOD+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    MOD+m\n"        "        Click on MENU\n"        "\n"        "    MOD+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    MOD+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    MOD+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    MOD+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    MOD+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    MOD+r\n"        "        Rotate device screen\n"        "\n"        "    MOD+n\n"        "        Expand notification panel\n"        "\n"        "    MOD+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    MOD+c\n"        "        Copy to clipboard (inject COPY keycode, Android >= 7 only)\n"        "\n"        "    MOD+x\n"        "        Cut to clipboard (inject CUT keycode, Android >= 7 only)\n"        "\n"        "    MOD+v\n"        "        Copy computer clipboard to device, then paste (inject PASTE\n"        "        keycode, Android >= 7 only)\n"        "\n"        "    MOD+Shift+v\n"        "        Inject computer clipboard text as a sequence of key events\n"        "\n"        "    MOD+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_parse_args(struct scrcpy_cli_args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",          no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",               required_argument, NULL, 'b'},        {"codec-options",          required_argument, NULL, OPT_CODEC_OPTIONS},        {"crop",                   required_argument, NULL, OPT_CROP},        {"disable-screensaver",    no_argument,       NULL,                                                  OPT_DISABLE_SCREENSAVER},        {"display",                required_argument, NULL, OPT_DISPLAY_ID},        {"force-adb-forward",      no_argument,       NULL,                                                  OPT_FORCE_ADB_FORWARD},        {"fullscreen",             no_argument,       NULL, 'f'},        {"help",                   no_argument,       NULL, 'h'},        {"lock-video-orientation", required_argument, NULL,                                                  OPT_LOCK_VIDEO_ORIENTATION},        {"max-fps",                required_argument, NULL, OPT_MAX_FPS},        {"max-size",               required_argument, NULL, 'm'},        {"no-control",             no_argument,       NULL, 'n'},        {"no-display",             no_argument,       NULL, 'N'},        {"no-mipmaps",             no_argument,       NULL, OPT_NO_MIPMAPS},        {"no-key-repeat",          no_argument,       NULL, OPT_NO_KEY_REPEAT},        {"port",                   required_argument, NULL, 'p'},        {"prefer-text",            no_argument,       NULL, OPT_PREFER_TEXT},        {"push-target",            required_argument, NULL, OPT_PUSH_TARGET},        {"record",                 required_argument, NULL, 'r'},        {"record-format",          required_argument, NULL, OPT_RECORD_FORMAT},        {"render-driver",          required_argument, NULL, OPT_RENDER_DRIVER},        {"render-expired-frames",  no_argument,       NULL,                                                  OPT_RENDER_EXPIRED_FRAMES},        {"rotation",               required_argument, NULL, OPT_ROTATION},        {"serial",                 required_argument, NULL, 's'},        {"shortcut-mod",           required_argument, NULL, OPT_SHORTCUT_MOD},        {"show-touches",           no_argument,       NULL, 't'},        {"stay-awake",             no_argument,       NULL, 'w'},        {"turn-screen-off",        no_argument,       NULL, 'S'},        {"verbosity",              required_argument, NULL, 'V'},        {"version",                no_argument,       NULL, 'v'},        {"window-title",           required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",               required_argument, NULL, OPT_WINDOW_X},        {"window-y",               required_argument, NULL, OPT_WINDOW_Y},        {"window-width",           required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",          required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",      no_argument,       NULL,                                                  OPT_WINDOW_BORDERLESS},        {NULL,                     0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    optind = 0; // reset to start from the first argument in tests    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTvV:w",                            long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case OPT_DISPLAY_ID:                if (!parse_display_id(optarg, &opts->display_id)) {                    return false;                }                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case OPT_LOCK_VIDEO_ORIENTATION:                if (!parse_lock_video_orientation(optarg, &opts->lock_video_orientation)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port_range(optarg, &opts->port_range)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case 'V':                if (!parse_log_level(optarg, &opts->log_level)) {                    return false;                }                break;            case 'w':                opts->stay_awake = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            case OPT_ROTATION:                if (!parse_rotation(optarg, &opts->rotation)) {                    return false;                }                break;            case OPT_RENDER_DRIVER:                opts->render_driver = optarg;                break;            case OPT_NO_MIPMAPS:                opts->mipmaps = false;                break;            case OPT_NO_KEY_REPEAT:                opts->forward_key_repeat = false;                break;            case OPT_CODEC_OPTIONS:                opts->codec_options = optarg;                break;            case OPT_FORCE_ADB_FORWARD:                opts->force_adb_forward = true;                break;            case OPT_DISABLE_SCREENSAVER:                opts->disable_screensaver = true;                break;            case OPT_SHORTCUT_MOD:                if (!parse_shortcut_mods(optarg, &opts->shortcut_mods)) {                    return false;                }                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    if (!opts->control && opts->stay_awake) {        LOGE("Could not request to stay awake if control is disabled");        return false;    }    return true;}
scrcpy_print_usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --codec-options key[:type]=value[,...]\n"        "        Set a list of comma-separated key:type=value options for the\n"        "        device encoder.\n"        "        The possible values for 'type' are 'int' (default), 'long',\n"        "        'float' and 'string'.\n"        "        The list of possible codec options is available in the\n"        "        Android documentation:\n"        "        <https://d.android.com/reference/android/media/MediaFormat>\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --disable-screensaver\n"        "        Disable screensaver while scrcpy is running.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    --force-adb-forward\n"        "        Do not attempt to use \"adb reverse\" to connect to the\n"        "        the device.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    --no-mipmaps\n"        "        If the renderer is OpenGL 3.0+ or OpenGL ES 2.0+, then\n"        "        mipmaps are automatically generated to improve downscaling\n"        "        quality. This option disables the generation of mipmaps.\n"        "\n"        "    --no-key-repeat\n"        "        Do not forward repeated key events when a key is held down.\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-driver name\n"        "        Request SDL to use the given render driver (this is just a\n"        "        hint).\n"        "        Supported names are currently \"direct3d\", \"opengl\",\n"        "        \"opengles2\", \"opengles\", \"metal\" and \"software\".\n"        "        <https://wiki.libsdl.org/SDL_HINT_RENDER_DRIVER>\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    --shortcut-mod key[+...]][,...]\n"        "        Specify the modifiers to use for scrcpy shortcuts.\n"        "        Possible keys are \"lctrl\", \"rctrl\", \"lalt\", \"ralt\",\n"        "        \"lsuper\" and \"rsuper\".\n"        "\n"        "        A shortcut can consist in several keys, separated by '+'.\n"        "        Several shortcuts can be specified, separated by ','.\n"        "\n"        "        For example, to use either LCtrl+LAlt or LSuper for scrcpy\n"        "        shortcuts, pass \"lctrl+lalt,lsuper\".\n"        "\n"        "        Default is \"lalt,lsuper\" (left-Alt or left-Super).\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, restore the initial value\n"        "        on exit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    -V, --verbosity value\n"        "        Set the log level (debug, info, warn or error).\n"#ifndef NDEBUG        "        Default is debug.\n"#else        "        Default is info.\n"#endif        "\n"        "    -w, --stay-awake\n"        "        Keep the device on while scrcpy is running, when the device\n"        "        is plugged in.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    In the following list, MOD is the shortcut modifier. By default,\n"        "    it's (left) Alt or (left) Super, but it can be configured by\n"        "    --shortcut-mod.\n"        "\n"        "    MOD+f\n"        "        Switch fullscreen mode\n"        "\n"        "    MOD+Left\n"        "        Rotate display left\n"        "\n"        "    MOD+Right\n"        "        Rotate display right\n"        "\n"        "    MOD+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    MOD+w\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    MOD+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    MOD+b\n"        "    MOD+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    MOD+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    MOD+m\n"        "        Click on MENU\n"        "\n"        "    MOD+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    MOD+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    MOD+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    MOD+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    MOD+Shift+o\n"        "        Turn device screen on\n"        "\n"        "    MOD+r\n"        "        Rotate device screen\n"        "\n"        "    MOD+n\n"        "        Expand notification panel\n"        "\n"        "    MOD+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    MOD+c\n"        "        Copy to clipboard (inject COPY keycode, Android >= 7 only)\n"        "\n"        "    MOD+x\n"        "        Cut to clipboard (inject CUT keycode, Android >= 7 only)\n"        "\n"        "    MOD+v\n"        "        Copy computer clipboard to device, then paste (inject PASTE\n"        "        keycode, Android >= 7 only)\n"        "\n"        "    MOD+Shift+v\n"        "        Inject computer clipboard text as a sequence of key events\n"        "\n"        "    MOD+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event) {    // control: indicates the state of the command-line option --no-control    bool control = im->control;    bool smod = is_shortcut_mod(im, event->keysym.mod);    struct controller *controller = im->controller;    SDL_Keycode keycode = event->keysym.sym;    bool down = event->type == SDL_KEYDOWN;    bool ctrl = event->keysym.mod & KMOD_CTRL;    bool shift = event->keysym.mod & KMOD_SHIFT;    bool repeat = event->repeat;    // The shortcut modifier is pressed    if (smod) {        int action = down ? ACTION_DOWN : ACTION_UP;        switch (keycode) {            case SDLK_h:                if (control && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                if (control && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (!shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (!shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && !shift && !repeat) {                    action_copy(controller, action);                }                return;            case SDLK_x:                if (control && !shift && !repeat) {                    action_cut(controller, action);                }                return;            case SDLK_v:                if (control && !repeat && down) {                    if (shift) {                        // inject the text as input events                        clipboard_paste(controller);                    } else {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    }                }                return;            case SDLK_f:                if (!shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_w:                if (!shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    if (ctrl && !shift && keycode == SDLK_v && down && !repeat) {        // Synchronize the computer clipboard to the device clipboard before        // sending Ctrl+v, to allow seamless copy-paste.        set_device_clipboard(controller, false);    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_init(struct input_manager *im,                   const struct scrcpy_options *options){    im->control = options->control;    im->prefer_text = options->prefer_text;    const struct sc_shortcut_mods *shortcut_mods = &options->shortcut_mods;    assert(shortcut_mods->count);    assert(shortcut_mods->count < SC_MAX_SHORTCUT_MODS);    for (unsigned i = 0; i < shortcut_mods->count; ++i) {        uint16_t sdl_mod = to_sdl_mod(shortcut_mods->data[i]);        assert(sdl_mod);        im->sdl_shortcut_mods.data[i] = sdl_mod;    }    im->sdl_shortcut_mods.count = shortcut_mods->count;}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event) {    // control: indicates the state of the command-line option --no-control    bool control = im->control;    bool smod = is_shortcut_mod(im, event->keysym.mod);    struct controller *controller = im->controller;    SDL_Keycode keycode = event->keysym.sym;    bool down = event->type == SDL_KEYDOWN;    bool ctrl = event->keysym.mod & KMOD_CTRL;    bool shift = event->keysym.mod & KMOD_SHIFT;    bool repeat = event->repeat;    // The shortcut modifier is pressed    if (smod) {        int action = down ? ACTION_DOWN : ACTION_UP;        switch (keycode) {            case SDLK_h:                if (control && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                if (control && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (!shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (!shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && !shift && !repeat) {                    action_copy(controller, action);                }                return;            case SDLK_x:                if (control && !shift && !repeat) {                    action_cut(controller, action);                }                return;            case SDLK_v:                if (control && !repeat && down) {                    if (shift) {                        // inject the text as input events                        clipboard_paste(controller);                    } else {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    }                }                return;            case SDLK_f:                if (!shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_w:                if (!shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        if (!im->forward_key_repeat) {            return;        }        ++im->repeat;    } else {        im->repeat = 0;    }    if (ctrl && !shift && keycode == SDLK_v && down && !repeat) {        // Synchronize the computer clipboard to the device clipboard before        // sending Ctrl+v, to allow seamless copy-paste.        set_device_clipboard(controller, false);    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_init(struct input_manager *im,                   const struct scrcpy_options *options){    im->control = options->control;    im->forward_key_repeat = options->forward_key_repeat;    im->prefer_text = options->prefer_text;    const struct sc_shortcut_mods *shortcut_mods = &options->shortcut_mods;    assert(shortcut_mods->count);    assert(shortcut_mods->count < SC_MAX_SHORTCUT_MODS);    for (unsigned i = 0; i < shortcut_mods->count; ++i) {        uint16_t sdl_mod = to_sdl_mod(shortcut_mods->data[i]);        assert(sdl_mod);        im->sdl_shortcut_mods.data[i] = sdl_mod;    }    im->sdl_shortcut_mods.count = shortcut_mods->count;}
        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}static voidprint_version(void) {    fprintf(stderr, "scrcpy %s\n\n", SCRCPY_VERSION);    fprintf(stderr, "dependencies:\n");    fprintf(stderr, " - SDL %d.%d.%d\n", SDL_MAJOR_VERSION, SDL_MINOR_VERSION,                                         SDL_PATCHLEVEL);    fprintf(stderr, " - libavcodec %d.%d.%d\n", LIBAVCODEC_VERSION_MAJOR,                                                LIBAVCODEC_VERSION_MINOR,                                                LIBAVCODEC_VERSION_MICRO);    fprintf(stderr, " - libavformat %d.%d.%d\n", LIBAVFORMAT_VERSION_MAJOR,                                                 LIBAVFORMAT_VERSION_MINOR,                                                 LIBAVFORMAT_VERSION_MICRO);    fprintf(stderr, " - libavutil %d.%d.%d\n", LIBAVUTIL_VERSION_MAJOR,                                               LIBAVUTIL_VERSION_MINOR,                                               LIBAVUTIL_VERSION_MICRO);}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, OPT_CROP},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"push-target",           required_argument, NULL, OPT_PUSH_TARGET},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, OPT_RECORD_FORMAT},        {"render-expired-frames", no_argument,       NULL,                                                     OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"prefer-text",           no_argument,       NULL, OPT_PREFER_TEXT},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",              required_argument, NULL, OPT_WINDOW_X},        {"window-y",              required_argument, NULL, OPT_WINDOW_Y},        {NULL,                    0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port(optarg, &opts->port)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
static void usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is -1 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
parse_window_dimension(char *optarg, uint16_t *dimension) {    char *endptr;    if (*optarg == '\0') {        LOGE("Window dimension parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid window dimension: %s", optarg);        return false;    }    if (value & ~0xffff) {        LOGE("Window position must be between 0 and 65535: %ld", value);        return false;    }    *dimension = (uint16_t) value;    return true;}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, OPT_CROP},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"push-target",           required_argument, NULL, OPT_PUSH_TARGET},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, OPT_RECORD_FORMAT},        {"render-expired-frames", no_argument,       NULL,                                                     OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"prefer-text",           no_argument,       NULL, OPT_PREFER_TEXT},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",              required_argument, NULL, OPT_WINDOW_X},        {"window-y",              required_argument, NULL, OPT_WINDOW_Y},        {"window-width",          required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",         required_argument, NULL, OPT_WINDOW_HEIGHT},        {NULL,                    0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port(optarg, &opts->port)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
static void usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is -1 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
get_initial_optimal_size(struct size frame_size) {    return get_optimal_size(frame_size, frame_size);}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    int x = window_x != -1 ? window_x : SDL_WINDOWPOS_UNDEFINED;    int y = window_y != -1 ? window_y : SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    int x = window_x != -1 ? window_x : SDL_WINDOWPOS_UNDEFINED;    int y = window_y != -1 ? window_y : SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
get_initial_optimal_size(struct size frame_size) {    return get_optimal_size(frame_size, frame_size);}
get_initial_optimal_size(struct size frame_size, uint16_t req_width,                         uint16_t req_height) {    struct size window_size;    if (!req_width && !req_height) {        window_size = get_optimal_size(frame_size, frame_size);    } else {        if (req_width) {            window_size.width = req_width;        } else {            // compute from the requested height            window_size.width = (uint32_t) req_height * frame_size.width                              / frame_size.height;        }        if (req_height) {            window_size.height = req_height;        } else {            // compute from the requested width            window_size.height = (uint32_t) req_width * frame_size.height                               / frame_size.width;        }    }    return window_size;}
            // compute from the requested width            window_size.height = (uint32_t) req_width * frame_size.height                               / frame_size.width;        }    }    return window_size;}voidscreen_init(struct screen *screen) {    *screen = (struct screen) SCREEN_INITIALIZER;}static inline SDL_Texture *create_texture(SDL_Renderer *renderer, struct size frame_size) {    return SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12,                             SDL_TEXTUREACCESS_STREAMING,                             frame_size.width, frame_size.height);}boolscreen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height) {    screen->frame_size = frame_size;    struct size window_size =        get_initial_optimal_size(frame_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    int x = window_x != -1 ? window_x : SDL_WINDOWPOS_UNDEFINED;    int y = window_y != -1 ? window_y : SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height) {    screen->frame_size = frame_size;    struct size window_size =        get_initial_optimal_size(frame_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    int x = window_x != -1 ? window_x : SDL_WINDOWPOS_UNDEFINED;    int y = window_y != -1 ? window_y : SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
static inline struct sizeget_initial_optimal_size(struct size frame_size, uint16_t req_width,                         uint16_t req_height) {    struct size window_size;
control_msg_serialize(const struct control_msg *msg, unsigned char *buf) {    buf[0] = msg->type;    switch (msg->type) {        case CONTROL_MSG_TYPE_INJECT_KEYCODE:            buf[1] = msg->inject_keycode.action;            buffer_write32be(&buf[2], msg->inject_keycode.keycode);            buffer_write32be(&buf[6], msg->inject_keycode.metastate);            return 10;        case CONTROL_MSG_TYPE_INJECT_TEXT: {            size_t len = write_string(msg->inject_text.text,                                      CONTROL_MSG_TEXT_MAX_LENGTH, &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT:            buf[1] = msg->inject_touch_event.action;            buffer_write64be(&buf[2], msg->inject_touch_event.pointer_id);            write_position(&buf[10], &msg->inject_touch_event.position);            uint16_t pressure =                to_fixed_point_16(msg->inject_touch_event.pressure);            buffer_write16be(&buf[22], pressure);            buffer_write32be(&buf[24], msg->inject_touch_event.buttons);            return 28;        case CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT:            write_position(&buf[1], &msg->inject_scroll_event.position);            buffer_write32be(&buf[13],                             (uint32_t) msg->inject_scroll_event.hscroll);            buffer_write32be(&buf[17],                             (uint32_t) msg->inject_scroll_event.vscroll);            return 21;        case CONTROL_MSG_TYPE_SET_CLIPBOARD: {            size_t len = write_string(msg->inject_text.text,                                      CONTROL_MSG_CLIPBOARD_TEXT_MAX_LENGTH,                                      &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE:            buf[1] = msg->set_screen_power_mode.mode;            return 2;        case CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_GET_CLIPBOARD:            // no additional data            return 1;        default:            LOGW("Unknown message type: %u", (unsigned) msg->type);            return 0;    }}
control_msg_serialize(const struct control_msg *msg, unsigned char *buf) {    buf[0] = msg->type;    switch (msg->type) {        case CONTROL_MSG_TYPE_INJECT_KEYCODE:            buf[1] = msg->inject_keycode.action;            buffer_write32be(&buf[2], msg->inject_keycode.keycode);            buffer_write32be(&buf[6], msg->inject_keycode.metastate);            return 10;        case CONTROL_MSG_TYPE_INJECT_TEXT: {            size_t len = write_string(msg->inject_text.text,                                      CONTROL_MSG_TEXT_MAX_LENGTH, &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT:            buf[1] = msg->inject_touch_event.action;            buffer_write64be(&buf[2], msg->inject_touch_event.pointer_id);            write_position(&buf[10], &msg->inject_touch_event.position);            uint16_t pressure =                to_fixed_point_16(msg->inject_touch_event.pressure);            buffer_write16be(&buf[22], pressure);            buffer_write32be(&buf[24], msg->inject_touch_event.buttons);            return 28;        case CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT:            write_position(&buf[1], &msg->inject_scroll_event.position);            buffer_write32be(&buf[13],                             (uint32_t) msg->inject_scroll_event.hscroll);            buffer_write32be(&buf[17],                             (uint32_t) msg->inject_scroll_event.vscroll);            return 21;        case CONTROL_MSG_TYPE_SET_CLIPBOARD: {            size_t len = write_string(msg->inject_text.text,                                      CONTROL_MSG_CLIPBOARD_TEXT_MAX_LENGTH,                                      &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE:            buf[1] = msg->set_screen_power_mode.mode;            return 2;        case CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_GET_CLIPBOARD:        case CONTROL_MSG_TYPE_ROTATE_DEVICE:            // no additional data            return 1;        default:            LOGW("Unknown message type: %u", (unsigned) msg->type);            return 0;    }}
static voidsend_keycode(struct controller *controller, enum android_keycode keycode,             int actions, const char *name) {    // send DOWN event    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_KEYCODE;    msg.inject_keycode.keycode = keycode;    msg.inject_keycode.metastate = 0;    if (actions & ACTION_DOWN) {        msg.inject_keycode.action = AKEY_EVENT_ACTION_DOWN;        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject %s (DOWN)'", name);            return;        }    }    if (actions & ACTION_UP) {        msg.inject_keycode.action = AKEY_EVENT_ACTION_UP;        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject %s (UP)'", name);        }    }}static inline voidaction_home(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_HOME, actions, "HOME");}static inline voidaction_back(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_BACK, actions, "BACK");}static inline voidaction_app_switch(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_APP_SWITCH, actions, "APP_SWITCH");}static inline voidaction_power(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_POWER, actions, "POWER");}static inline voidaction_volume_up(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_VOLUME_UP, actions, "VOLUME_UP");}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = im->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && !shift && down) {                    set_screen_power_mode(controller, SCREEN_POWER_MODE_OFF);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard                        set_device_clipboard(controller);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && cmd && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && cmd && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;        }        return;    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
rotate_device(struct controller *controller) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_ROTATE_DEVICE;    if (!controller_push_msg(controller, &msg)) {        LOGW("Could not request device rotation");    }}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = im->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && !shift && down) {                    set_screen_power_mode(controller, SCREEN_POWER_MODE_OFF);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard                        set_device_clipboard(controller);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && cmd && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && cmd && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && cmd && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
static void usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (only supported on\n"        "        devices with Android >= 10).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (only supported on\n"        "        devices with Android >= 10).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
        0x01, // AKEY_EVENT_ACTION_UP        0x00, 0x00, 0x00, 0x42, // AKEYCODE_ENTER        0x00, 0x00, 0x00, 0x41, // AMETA_SHIFT_ON | AMETA_SHIFT_LEFT_ON    };    assert(!memcmp(buf, expected, sizeof(expected)));}static void test_serialize_inject_text(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_INJECT_TEXT,        .inject_text = {            .text = "hello, world!",        },    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 16);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_INJECT_TEXT,        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}static void test_serialize_inject_text_long(void) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    char text[CONTROL_MSG_TEXT_MAX_LENGTH + 1];    memset(text, 'a', sizeof(text));    text[CONTROL_MSG_TEXT_MAX_LENGTH] = '\0';    msg.inject_text.text = text;    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 3 + CONTROL_MSG_TEXT_MAX_LENGTH);    unsigned char expected[3 + CONTROL_MSG_TEXT_MAX_LENGTH];    expected[0] = CONTROL_MSG_TYPE_INJECT_TEXT;    expected[1] = 0x01;    expected[2] = 0x2c; // text length (16 bits)    memset(&expected[3], 'a', CONTROL_MSG_TEXT_MAX_LENGTH);    assert(!memcmp(buf, expected, sizeof(expected)));}static void test_serialize_inject_touch_event(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT,        .inject_touch_event = {            .action = AMOTION_EVENT_ACTION_DOWN,            .pointer_id = 0x1234567887654321L,            .position = {                .point = {                    .x = 100,                    .y = 200,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },            .pressure = 1.0f,            .buttons = AMOTION_EVENT_BUTTON_PRIMARY,        },    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 28);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT,        0x00, // AKEY_EVENT_ACTION_DOWN        0x12, 0x34, 0x56, 0x78, 0x87, 0x65, 0x43, 0x21, // pointer id        0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0xc8, // 100 200        0x04, 0x38, 0x07, 0x80, // 1080 1920        0xff, 0xff, // pressure        0x00, 0x00, 0x00, 0x01 // AMOTION_EVENT_BUTTON_PRIMARY    };    assert(!memcmp(buf, expected, sizeof(expected)));}static void test_serialize_inject_scroll_event(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT,        .inject_scroll_event = {            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },            .hscroll = 1,            .vscroll = -1,        },    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 21);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT,        0x00, 0x00, 0x01, 0x04, 0x00, 0x00, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920        0x00, 0x00, 0x00, 0x01, // 1        0xFF, 0xFF, 0xFF, 0xFF, // -1    };    assert(!memcmp(buf, expected, sizeof(expected)));}static void test_serialize_back_or_screen_on(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON,    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 1);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON,    };    assert(!memcmp(buf, expected, sizeof(expected)));}static void test_serialize_expand_notification_panel(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL,    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 1);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL,    };    assert(!memcmp(buf, expected, sizeof(expected)));}static void test_serialize_collapse_notification_panel(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL,    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 1);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL,    };    assert(!memcmp(buf, expected, sizeof(expected)));}static void test_serialize_get_clipboard(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_GET_CLIPBOARD,    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 1);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_GET_CLIPBOARD,    };    assert(!memcmp(buf, expected, sizeof(expected)));}static void test_serialize_set_clipboard(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_SET_CLIPBOARD,        .inject_text = {            .text = "hello, world!",
int main(void) {    test_serialize_inject_keycode();    test_serialize_inject_text();    test_serialize_inject_text_long();    test_serialize_inject_touch_event();    test_serialize_inject_scroll_event();    test_serialize_back_or_screen_on();    test_serialize_expand_notification_panel();    test_serialize_collapse_notification_panel();    test_serialize_get_clipboard();    test_serialize_set_clipboard();    test_serialize_set_screen_power_mode();    return 0;}
static void test_serialize_rotate_device(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_ROTATE_DEVICE,    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 1);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_ROTATE_DEVICE,    };    assert(!memcmp(buf, expected, sizeof(expected)));}
int main(void) {    test_serialize_inject_keycode();    test_serialize_inject_text();    test_serialize_inject_text_long();    test_serialize_inject_touch_event();    test_serialize_inject_scroll_event();    test_serialize_back_or_screen_on();    test_serialize_expand_notification_panel();    test_serialize_collapse_notification_panel();    test_serialize_get_clipboard();    test_serialize_set_clipboard();    test_serialize_set_screen_power_mode();    test_serialize_rotate_device();    return 0;}
    public ControlMessage next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        ControlMessage msg;        switch (type) {            case ControlMessage.TYPE_INJECT_KEYCODE:                msg = parseInjectKeycode();                break;            case ControlMessage.TYPE_INJECT_TEXT:                msg = parseInjectText();                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                msg = parseInjectTouchEvent();                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                msg = parseInjectScrollEvent();                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                msg = parseSetClipboard();                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                msg = parseSetScreenPowerMode();                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:            case ControlMessage.TYPE_GET_CLIPBOARD:                msg = ControlMessage.createEmpty(type);                break;            default:                Ln.w("Unknown event type: " + type);                msg = null;                break;        }        if (msg == null) {            // failure, reset savedPosition            buffer.position(savedPosition);        }        return msg;    }
    public ControlMessage next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        ControlMessage msg;        switch (type) {            case ControlMessage.TYPE_INJECT_KEYCODE:                msg = parseInjectKeycode();                break;            case ControlMessage.TYPE_INJECT_TEXT:                msg = parseInjectText();                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                msg = parseInjectTouchEvent();                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                msg = parseInjectScrollEvent();                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                msg = parseSetClipboard();                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                msg = parseSetScreenPowerMode();                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:            case ControlMessage.TYPE_GET_CLIPBOARD:            case ControlMessage.TYPE_ROTATE_DEVICE:                msg = ControlMessage.createEmpty(type);                break;            default:                Ln.w("Unknown event type: " + type);                msg = null;                break;        }        if (msg == null) {            // failure, reset savedPosition            buffer.position(savedPosition);        }        return msg;    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                break;            case ControlMessage.TYPE_INJECT_TEXT:                injectText(msg.getText());                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), msg.getButtons());                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                pressBackOrTurnScreenOn();                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                device.setClipboardText(msg.getText());                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                device.setScreenPowerMode(msg.getAction());                break;            default:                // do nothing        }    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                break;            case ControlMessage.TYPE_INJECT_TEXT:                injectText(msg.getText());                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), msg.getButtons());                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                pressBackOrTurnScreenOn();                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                device.setClipboardText(msg.getText());                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                device.setScreenPowerMode(msg.getAction());                break;            case ControlMessage.TYPE_ROTATE_DEVICE:                device.rotateDevice();                break;            default:                // do nothing        }    }
        // Compute the video size and the padding of the content inside this video.        // Principle:        // - scale down the great side of the screen to maxSize (if necessary);        // - scale down the other side so that the aspect ratio is preserved;        // - round this value to the nearest multiple of 8 (H.264 only accepts multiples of 8)        w &= ~7; // in case it's not a multiple of 8        h &= ~7;        if (maxSize > 0) {            if (BuildConfig.DEBUG && maxSize % 8 != 0) {                throw new AssertionError("Max size must be a multiple of 8");            }            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;            if (major > maxSize) {                int minorExact = minor * maxSize / major;                // +4 to round the value to the nearest multiple of 8                minor = (minorExact + 4) & ~7;                major = maxSize;            }            w = portrait ? minor : major;            h = portrait ? major : minor;        }        return new Size(w, h);    }    public Point getPhysicalPoint(Position position) {        // it hides the field on purpose, to read it with a lock        @SuppressWarnings("checkstyle:HiddenField")        ScreenInfo screenInfo = getScreenInfo(); // read with synchronization        Size videoSize = screenInfo.getVideoSize();        Size clientVideoSize = position.getScreenSize();        if (!videoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event            return null;        }        Rect contentRect = screenInfo.getContentRect();        Point point = position.getPoint();
    public void rotateDevice() {        WindowManager wm = serviceManager.getWindowManager();        boolean accelerometerRotation = !wm.isRotationFrozen();        int currentRotation = wm.getRotation();        int newRotation = (currentRotation & 1) ^ 1; // 0->1, 1->0, 2->1, 3->0        String newRotationString = newRotation == 0 ? "portrait" : "landscape";        Ln.i("Device rotation requested: " + newRotationString);        wm.freezeRotation(newRotation);        // restore auto-rotate if necessary        if (accelerometerRotation) {            wm.thawRotation();        }    }
    public int getRotation() {        try {            Class<?> cls = manager.getClass();            try {                // method changed since this commit:                // https://android.googlesource.com/platform/frameworks/base/+/8ee7285128c3843401d4c4d0412cd66e86ba49e3%5E%21/#F2                return (Integer) cls.getMethod("getDefaultDisplayRotation").invoke(manager);            } catch (NoSuchMethodException e) {                // old version                return (Integer) cls.getMethod("getRotation").invoke(manager);            }        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public int getRotation() {        try {            Class<?> cls = manager.getClass();            try {                // method changed since this commit:                // https://android.googlesource.com/platform/frameworks/base/+/8ee7285128c3843401d4c4d0412cd66e86ba49e3%5E%21/#F2                return (Integer) cls.getMethod("getDefaultDisplayRotation").invoke(manager);            } catch (NoSuchMethodException e) {                // old version                return (Integer) cls.getMethod("getRotation").invoke(manager);            }        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public int getRotation() {        try {            Class<?> cls = manager.getClass();            try {                // method changed since this commit:                // https://android.googlesource.com/platform/frameworks/base/+/8ee7285128c3843401d4c4d0412cd66e86ba49e3%5E%21/#F2                return (Integer) cls.getMethod("getDefaultDisplayRotation").invoke(manager);            } catch (NoSuchMethodException e) {                // old version                return (Integer) cls.getMethod("getRotation").invoke(manager);            }        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public int getRotation() {        try {            Class<?> cls = manager.getClass();            try {                // method changed since this commit:                // https://android.googlesource.com/platform/frameworks/base/+/8ee7285128c3843401d4c4d0412cd66e86ba49e3%5E%21/#F2                return (Integer) cls.getMethod("getDefaultDisplayRotation").invoke(manager);            } catch (NoSuchMethodException e) {                // old version                return (Integer) cls.getMethod("getRotation").invoke(manager);            }        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public int getRotation() {        try {            Class<?> cls = manager.getClass();            try {                // method changed since this commit:                // https://android.googlesource.com/platform/frameworks/base/+/8ee7285128c3843401d4c4d0412cd66e86ba49e3%5E%21/#F2                return (Integer) cls.getMethod("getDefaultDisplayRotation").invoke(manager);            } catch (NoSuchMethodException e) {                // old version                return (Integer) cls.getMethod("getRotation").invoke(manager);            }        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public int getRotation() {        try {            Class<?> cls = manager.getClass();            try {                // method changed since this commit:                // https://android.googlesource.com/platform/frameworks/base/+/8ee7285128c3843401d4c4d0412cd66e86ba49e3%5E%21/#F2                return (Integer) cls.getMethod("getDefaultDisplayRotation").invoke(manager);            } catch (NoSuchMethodException e) {                // old version                return (Integer) cls.getMethod("getRotation").invoke(manager);            }        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public int getRotation() {        try {            Class<?> cls = manager.getClass();            try {                // method changed since this commit:                // https://android.googlesource.com/platform/frameworks/base/+/8ee7285128c3843401d4c4d0412cd66e86ba49e3%5E%21/#F2                return (Integer) cls.getMethod("getDefaultDisplayRotation").invoke(manager);            } catch (NoSuchMethodException e) {                // old version                return (Integer) cls.getMethod("getRotation").invoke(manager);            }        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public int getRotation() {        try {            Class<?> cls = manager.getClass();            try {                // method changed since this commit:                // https://android.googlesource.com/platform/frameworks/base/+/8ee7285128c3843401d4c4d0412cd66e86ba49e3%5E%21/#F2                return (Integer) cls.getMethod("getDefaultDisplayRotation").invoke(manager);            } catch (NoSuchMethodException e) {                // old version                return (Integer) cls.getMethod("getRotation").invoke(manager);            }        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public int getRotation() {        try {            Method method = getGetRotationMethod();            return (int) method.invoke(manager);        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            Ln.e("Could not invoke method", e);            return 0;        }    }
    public boolean isRotationFrozen() {        try {            Method method = getIsRotationFrozenMethod();            return (boolean) method.invoke(manager);        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            Ln.e("Could not invoke method", e);            return false;        }    }
    private Method getGetRotationMethod() throws NoSuchMethodException {        if (getRotationMethod == null) {            Class<?> cls = manager.getClass();            try {                // method changed since this commit:                // https://android.googlesource.com/platform/frameworks/base/+/8ee7285128c3843401d4c4d0412cd66e86ba49e3%5E%21/#F2                getRotationMethod = cls.getMethod("getDefaultDisplayRotation");            } catch (NoSuchMethodException e) {                // old version                getRotationMethod = cls.getMethod("getRotation");            }        }        return getRotationMethod;    }
    private Method getFreezeRotationMethod() throws NoSuchMethodException {        if (freezeRotationMethod == null) {            freezeRotationMethod = manager.getClass().getMethod("freezeRotation", int.class);        }        return freezeRotationMethod;    }
    public void freezeRotation(int rotation) {        try {            Method method = getFreezeRotationMethod();            method.invoke(manager, rotation);        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            Ln.e("Could not invoke method", e);        }    }
    private Method getThawRotationMethod() throws NoSuchMethodException {        if (thawRotationMethod == null) {            thawRotationMethod = manager.getClass().getMethod("thawRotation");        }        return thawRotationMethod;    }
    public void thawRotation() {        try {            Method method = getThawRotationMethod();            method.invoke(manager);        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            Ln.e("Could not invoke method", e);        }    }
    private Method getIsRotationFrozenMethod() throws NoSuchMethodException {        if (isRotationFrozenMethod == null) {            isRotationFrozenMethod = manager.getClass().getMethod("isRotationFrozen");        }        return isRotationFrozenMethod;    }
import java.nio.charset.StandardCharsets;import java.util.Arrays;public class ControlMessageReaderTest {    @Test    public void testParseKeycodeEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(KeyEvent.META_CTRL_ON);
    public void testParseRotateDevice() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_ROTATE_DEVICE);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_ROTATE_DEVICE, event.getType());    }
server_start(struct server *server, const char *serial,             const struct server_params *params) {    server->local_port = params->local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        SDL_free(server->serial);        return false;    }    if (!enable_tunnel(server)) {        SDL_free(server->serial);        return false;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(params->local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, params->local_port);            disable_tunnel(server);            SDL_free(server->serial);            return false;        }    }    // server will connect to our server socket    server->process = execute_server(server, params);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free(server->serial);        return false;    }    server->tunnel_enabled = true;    return true;}
enable_tunnel(struct server *server) {    if (enable_tunnel_reverse(server->serial, server->local_port)) {        return true;    }    LOGW("'adb reverse' failed, fallback to 'adb forward'");    server->tunnel_forward = true;    return enable_tunnel_forward(server->serial, server->local_port);}
    assert(*socket != INVALID_SOCKET);    net_shutdown(*socket, SHUT_RDWR);    if (!net_close(*socket)) {        LOGW("Could not close socket");        return;    }    *socket = INVALID_SOCKET;}voidserver_init(struct server *server) {    *server = (struct server) SERVER_INITIALIZER;}boolserver_start(struct server *server, const char *serial,             const struct server_params *params) {    server->local_port = params->local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        SDL_free(server->serial);        return false;    }    if (!enable_tunnel(server)) {        SDL_free(server->serial);        return false;    }    // server will connect to our server socket    server->process = execute_server(server, params);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free(server->serial);        return false;    }    server->tunnel_enabled = true;    return true;}boolserver_connect_to(struct server *server) {    if (!server->tunnel_forward) {        server->video_socket = net_accept(server->server_socket);
enable_tunnel(struct server *server) {    if (enable_tunnel_reverse(server->serial, server->local_port)) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(server->local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, server->local_port);            disable_tunnel(server);            return false;        }        return true;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    LOGW("'adb reverse' failed, fallback to 'adb forward'");    server->tunnel_forward = true;    return enable_tunnel_forward(server->serial, server->local_port);}
server_start(struct server *server, const char *serial,             const struct server_params *params) {    server->port_range = params->port_range;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        SDL_free(server->serial);        return false;    }    if (!enable_tunnel_any_port(server, params->port_range)) {        SDL_free(server->serial);        return false;    }    // server will connect to our server socket    server->process = execute_server(server, params);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free(server->serial);        return false;    }    server->tunnel_enabled = true;    return true;}
server_start(struct server *server, const char *serial,             const struct server_params *params) {    server->port_range = params->port_range;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        goto error1;    }    if (!enable_tunnel_any_port(server, params->port_range)) {        goto error1;    }    // server will connect to our server socket    server->process = execute_server(server, params);    if (server->process == PROCESS_NONE) {        goto error2;    }    server->tunnel_enabled = true;    return true;error2:    if (!server->tunnel_forward) {        close_socket(&server->server_socket);    }    disable_tunnel(server);error1:    SDL_free(server->serial);    return false;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .log_level = options->log_level,        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,        .show_touches = options->show_touches,        .stay_awake = options->stay_awake,        .codec_options = options->codec_options,        .force_adb_forward = options->force_adb_forward,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver,                                options->disable_screensaver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options-> mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    input_manager_init(&input_manager, options);    ret = event_loop(options);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .log_level = options->log_level,        .crop = options->crop,        .port_range = options->port_range,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .lock_video_orientation = options->lock_video_orientation,        .control = options->control,        .display_id = options->display_id,        .show_touches = options->show_touches,        .stay_awake = options->stay_awake,        .codec_options = options->codec_options,        .force_adb_forward = options->force_adb_forward,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display, options->render_driver,                                options->disable_screensaver)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless,                                   options->rotation, options->mipmaps)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    input_manager_init(&input_manager, options);    ret = event_loop(options);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    server_destroy(&server);    return ret;}
    private boolean pressBackOrTurnScreenOn() {        int keycode = device.isScreenOn() ? KeyEvent.KEYCODE_BACK : KeyEvent.KEYCODE_POWER;        return device.injectKeycode(keycode);    }
    public void control() throws IOException {        // on start, power on the device        if (!device.isScreenOn()) {            device.injectKeycode(KeyEvent.KEYCODE_POWER);            // dirty hack            // After POWER is injected, the device is powered on asynchronously.            // To turn the device screen off while mirroring, the client will send a message that            // would be handled before the device is actually powered on, so its effect would            // be "canceled" once the device is turned back on.            // Adding this delay prevents to handle the message before the device is actually            // powered on.            SystemClock.sleep(500);        }        while (true) {            handleEvent();        }    }
    private boolean pressBackOrTurnScreenOn() {        int keycode = device.isScreenOn() ? KeyEvent.KEYCODE_BACK : KeyEvent.KEYCODE_WAKEUP;        return device.injectKeycode(keycode);    }
    public void control() throws IOException {        // on start, power on the device        if (!device.isScreenOn()) {            device.injectKeycode(KeyEvent.KEYCODE_WAKEUP);            // dirty hack            // After the keycode is injected, the device is powered on asynchronously.            // To turn the device screen off while mirroring, the client will send a message that            // would be handled before the device is actually powered on, so its effect would            // be "canceled" once the device is turned back on.            // Adding this delay prevents to handle the message before the device is actually            // powered on.            SystemClock.sleep(500);        }        while (true) {            handleEvent();        }    }
    recorder->header_written = false;    return true;}voidrecorder_destroy(struct recorder *recorder) {    SDL_free(recorder->filename);}static const char *recorder_get_format_name(enum recorder_format format) {    switch (format) {        case RECORDER_FORMAT_MP4: return "mp4";        case RECORDER_FORMAT_MKV: return "matroska";        default: return NULL;
    recorder->header_written = false;    return true;}voidrecorder_destroy(struct recorder *recorder) {    SDL_free(recorder->filename);}static const char *recorder_get_format_name(enum recorder_format format) {    switch (format) {        case RECORDER_FORMAT_MP4: return "mp4";        case RECORDER_FORMAT_MKV: return "matroska";        default: return NULL;
    recorder->header_written = false;    return true;}voidrecorder_destroy(struct recorder *recorder) {    SDL_free(recorder->filename);}static const char *recorder_get_format_name(enum recorder_format format) {    switch (format) {        case RECORDER_FORMAT_MP4: return "mp4";        case RECORDER_FORMAT_MKV: return "matroska";        default: return NULL;
    recorder->header_written = false;    return true;}voidrecorder_destroy(struct recorder *recorder) {    SDL_free(recorder->filename);}static const char *recorder_get_format_name(enum recorder_format format) {    switch (format) {        case RECORDER_FORMAT_MP4: return "mp4";        case RECORDER_FORMAT_MKV: return "matroska";        default: return NULL;
recorder_init(struct recorder *recorder,              const char *filename,              enum recorder_format format,              struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Could not strdup filename");        return false;    }    recorder->format = format;    recorder->declared_frame_size = declared_frame_size;    recorder->header_written = false;    return true;}
recorder_init(struct recorder *recorder,              const char *filename,              enum recorder_format format,              struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Could not strdup filename");        return false;    }    recorder->format = format;    recorder->declared_frame_size = declared_frame_size;    recorder->header_written = false;    return true;}
recorder_destroy(struct recorder *recorder) {    SDL_free(recorder->filename);}
recorder_destroy(struct recorder *recorder) {    SDL_free(recorder->filename);}
recorder_destroy(struct recorder *recorder) {    SDL_free(recorder->filename);}
recorder_destroy(struct recorder *recorder) {    SDL_free(recorder->filename);}
recorder_destroy(struct recorder *recorder) {    SDL_free(recorder->filename);}
recorder_destroy(struct recorder *recorder) {    SDL_free(recorder->filename);}
recorder_destroy(struct recorder *recorder) {    SDL_free(recorder->filename);}
recorder_destroy(struct recorder *recorder) {    SDL_free(recorder->filename);}
recorder_stop(struct recorder *recorder) {    mutex_lock(recorder->mutex);    recorder->stopped = true;    cond_signal(recorder->queue_cond);    mutex_unlock(recorder->mutex);}
record_packet_delete(struct record_packet *rec) {    av_packet_unref(&rec->packet);    SDL_free(rec);}
recorder_queue_clear(struct recorder_queue *queue) {    struct record_packet *rec = queue->first;    while (rec) {        struct record_packet *current = rec;        rec = rec->next;        record_packet_delete(current);    }    queue->first = NULL;}
run_recorder(void *data) {    struct recorder *recorder = data;    for (;;) {        mutex_lock(recorder->mutex);        while (!recorder->stopped &&                recorder_queue_is_empty(&recorder->queue)) {            cond_wait(recorder->queue_cond, recorder->mutex);        }        // if stopped is set, continue to process the remaining events (to        // finish the recording) before actually stopping        if (recorder->stopped && recorder_queue_is_empty(&recorder->queue)) {            mutex_unlock(recorder->mutex);            break;        }        struct record_packet *rec = recorder_queue_take(&recorder->queue);        mutex_unlock(recorder->mutex);        bool ok = recorder_write(recorder, &rec->packet);        record_packet_delete(rec);        if (!ok) {            LOGE("Could not record packet");            mutex_lock(recorder->mutex);            recorder->failed = true;            // discard pending packets            recorder_queue_clear(&recorder->queue);            mutex_unlock(recorder->mutex);            break;        }    }    LOGD("Recorder thread ended");    return 0;}
recorder_init(struct recorder *recorder,              const char *filename,              enum recorder_format format,              struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Could not strdup filename");        return false;    }    recorder->mutex = SDL_CreateMutex();    if (!recorder->mutex) {        LOGC("Could not create mutex");        SDL_free(recorder->filename);        return false;    }    recorder->queue_cond = SDL_CreateCond();    if (!recorder->queue_cond) {        LOGC("Could not create cond");        SDL_DestroyMutex(recorder->mutex);        SDL_free(recorder->filename);        return false;    }    recorder_queue_init(&recorder->queue);    recorder->stopped = false;    recorder->failed = false;    recorder->format = format;    recorder->declared_frame_size = declared_frame_size;    recorder->header_written = false;    return true;}
recorder_start(struct recorder *recorder) {    LOGD("Starting recorder thread");    recorder->thread = SDL_CreateThread(run_recorder, "recorder", recorder);    if (!recorder->thread) {        LOGC("Could not start recorder thread");        return false;    }    return true;}
recorder_destroy(struct recorder *recorder) {    SDL_DestroyCond(recorder->queue_cond);    SDL_DestroyMutex(recorder->mutex);    SDL_free(recorder->filename);}
recorder_queue_take(struct recorder_queue *queue) {    SDL_assert(!recorder_queue_is_empty(queue));    struct record_packet *rec = queue->first;    SDL_assert(rec);    queue->first = rec->next;    // no need to update queue->last if the queue is left empty:    // queue->last is undefined if queue->first == NULL    return rec;}
recorder_join(struct recorder *recorder) {    SDL_WaitThread(recorder->thread, NULL);}
record_packet_new(const AVPacket *packet) {    struct record_packet *rec = SDL_malloc(sizeof(*rec));    if (!rec) {        return NULL;    }    if (av_packet_ref(&rec->packet, packet)) {        SDL_free(rec);        return NULL;    }    rec->next = NULL;    return rec;}
recorder_queue_init(struct recorder_queue *queue) {    queue->first = NULL;    // queue->last is undefined if queue->first == NULL}
recorder_queue_push(struct recorder_queue *queue, const AVPacket *packet) {    struct record_packet *rec = record_packet_new(packet);    if (!rec) {        LOGC("Could not allocate record packet");        return false;    }    rec->next = NULL;    if (recorder_queue_is_empty(queue)) {        queue->first = queue->last = rec;    } else {        // chain rec after the (current) last packet        queue->last->next = rec;        // the last packet is now rec        queue->last = rec;    }    return true;}
recorder_push(struct recorder *recorder, const AVPacket *packet) {    mutex_lock(recorder->mutex);    SDL_assert(!recorder->stopped);    if (recorder->failed) {        // reject any new packet (this will stop the stream)        return false;    }    bool ok = recorder_queue_push(&recorder->queue, packet);    cond_signal(recorder->queue_cond);    mutex_unlock(recorder->mutex);    return ok;}
recorder_queue_is_empty(struct recorder_queue *queue) {    return !queue->first;}
process_frame(struct stream *stream, AVPacket *packet) {    if (stream->decoder && !decoder_push(stream->decoder, packet)) {        return false;    }    if (stream->recorder) {        packet->dts = packet->pts;        if (!recorder_write(stream->recorder, packet)) {            LOGE("Could not write frame to output file");            return false;        }    }    return true;}
run_stream(void *data) {    struct stream *stream = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto end;    }    stream->codec_ctx = avcodec_alloc_context3(codec);    if (!stream->codec_ctx) {        LOGC("Could not allocate codec context");        goto end;    }    if (stream->decoder && !decoder_open(stream->decoder, codec)) {        LOGE("Could not open decoder");        goto finally_free_codec_ctx;    }    if (stream->recorder && !recorder_open(stream->recorder, codec)) {        LOGE("Could not open recorder");        goto finally_close_decoder;    }    stream->parser = av_parser_init(AV_CODEC_ID_H264);    if (!stream->parser) {        LOGE("Could not initialize parser");        goto finally_close_recorder;    }    // We must only pass complete frames to av_parser_parse2()!    // It's more complicated, but this allows to reduce the latency by 1 frame!    stream->parser->flags |= PARSER_FLAG_COMPLETE_FRAMES;    for (;;) {        AVPacket packet;        bool ok = stream_recv_packet(stream, &packet);        if (!ok) {            // end of stream            break;        }        ok = stream_push_packet(stream, &packet);        av_packet_unref(&packet);        if (!ok) {            // cannot process packet (error already logged)            break;        }    }    LOGD("End of frames");    if (stream->has_pending) {        av_packet_unref(&stream->pending);    }    av_parser_close(stream->parser);finally_close_recorder:    if (stream->recorder) {        recorder_close(stream->recorder);    }finally_close_decoder:    if (stream->decoder) {        decoder_close(stream->decoder);    }finally_free_codec_ctx:    avcodec_free_context(&stream->codec_ctx);end:    notify_stopped();    return 0;}
process_config_packet(struct stream *stream, AVPacket *packet) {    if (stream->recorder && !recorder_write(stream->recorder, packet)) {        LOGE("Could not send config packet to recorder");        return false;    }    return true;}
process_frame(struct stream *stream, AVPacket *packet) {    if (stream->decoder && !decoder_push(stream->decoder, packet)) {        return false;    }    if (stream->recorder) {        packet->dts = packet->pts;        if (!recorder_push(stream->recorder, packet)) {            LOGE("Could not send packet to recorder");            return false;        }    }    return true;}
run_stream(void *data) {    struct stream *stream = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto end;    }    stream->codec_ctx = avcodec_alloc_context3(codec);    if (!stream->codec_ctx) {        LOGC("Could not allocate codec context");        goto end;    }    if (stream->decoder && !decoder_open(stream->decoder, codec)) {        LOGE("Could not open decoder");        goto finally_free_codec_ctx;    }    if (stream->recorder) {        if (!recorder_open(stream->recorder, codec)) {            LOGE("Could not open recorder");            goto finally_close_decoder;        }        if (!recorder_start(stream->recorder)) {            LOGE("Could not start recorder");            goto finally_close_recorder;        }    }    stream->parser = av_parser_init(AV_CODEC_ID_H264);    if (!stream->parser) {        LOGE("Could not initialize parser");        goto finally_stop_and_join_recorder;    }    // We must only pass complete frames to av_parser_parse2()!    // It's more complicated, but this allows to reduce the latency by 1 frame!    stream->parser->flags |= PARSER_FLAG_COMPLETE_FRAMES;    for (;;) {        AVPacket packet;        bool ok = stream_recv_packet(stream, &packet);        if (!ok) {            // end of stream            break;        }        ok = stream_push_packet(stream, &packet);        av_packet_unref(&packet);        if (!ok) {            // cannot process packet (error already logged)            break;        }    }    LOGD("End of frames");    if (stream->has_pending) {        av_packet_unref(&stream->pending);    }    av_parser_close(stream->parser);finally_stop_and_join_recorder:    if (stream->recorder) {        recorder_stop(stream->recorder);        LOGI("Finishing recording...");        recorder_join(stream->recorder);    }finally_close_recorder:    if (stream->recorder) {        recorder_close(stream->recorder);    }finally_close_decoder:    if (stream->decoder) {        decoder_close(stream->decoder);    }finally_free_codec_ctx:    avcodec_free_context(&stream->codec_ctx);end:    notify_stopped();    return 0;}
process_config_packet(struct stream *stream, AVPacket *packet) {    if (stream->recorder && !recorder_push(stream->recorder, packet)) {        LOGE("Could not send config packet to recorder");        return false;    }    return true;}
write_string(const char *utf8, size_t max_len, unsigned char *buf) {    size_t len = utf8_truncation_index(utf8, max_len);    buffer_write16be(buf, (uint16_t) len);    memcpy(&buf[2], utf8, len);    return 2 + len;}
write_string(const char *utf8, size_t max_len, unsigned char *buf) {    size_t len = utf8_truncation_index(utf8, max_len);    buffer_write32be(buf, len);    memcpy(&buf[4], utf8, len);    return 4 + len;}
device_msg_deserialize(const unsigned char *buf, size_t len,                       struct device_msg *msg) {    if (len < 3) {        // at least type + empty string length        return 0; // not available    }    msg->type = buf[0];    switch (msg->type) {        case DEVICE_MSG_TYPE_CLIPBOARD: {            uint16_t clipboard_len = buffer_read16be(&buf[1]);            if (clipboard_len > len - 3) {                return 0; // not available            }            char *text = SDL_malloc(clipboard_len + 1);            if (!text) {                LOGW("Could not allocate text for clipboard");                return -1;            }            if (clipboard_len) {                memcpy(text, &buf[3], clipboard_len);            }            text[clipboard_len] = '\0';            msg->clipboard.text = text;            return 3 + clipboard_len;        }        default:            LOGW("Unknown device message type: %d", (int) msg->type);            return -1; // error, we cannot recover    }}
device_msg_deserialize(const unsigned char *buf, size_t len,                       struct device_msg *msg) {    if (len < 5) {        // at least type + empty string length        return 0; // not available    }    msg->type = buf[0];    switch (msg->type) {        case DEVICE_MSG_TYPE_CLIPBOARD: {            size_t clipboard_len = buffer_read32be(&buf[1]);            if (clipboard_len > len - 5) {                return 0; // not available            }            char *text = SDL_malloc(clipboard_len + 1);            if (!text) {                LOGW("Could not allocate text for clipboard");                return -1;            }            if (clipboard_len) {                memcpy(text, &buf[5], clipboard_len);            }            text[clipboard_len] = '\0';            msg->clipboard.text = text;            return 5 + clipboard_len;        }        default:            LOGW("Unknown device message type: %d", (int) msg->type);            return -1; // error, we cannot recover    }}
static void test_serialize_inject_text_long(void) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    char text[CONTROL_MSG_INJECT_TEXT_MAX_LENGTH + 1];    memset(text, 'a', sizeof(text));    text[CONTROL_MSG_INJECT_TEXT_MAX_LENGTH] = '\0';    msg.inject_text.text = text;    unsigned char buf[CONTROL_MSG_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 3 + CONTROL_MSG_INJECT_TEXT_MAX_LENGTH);    unsigned char expected[3 + CONTROL_MSG_INJECT_TEXT_MAX_LENGTH];    expected[0] = CONTROL_MSG_TYPE_INJECT_TEXT;    expected[1] = 0x01;    expected[2] = 0x2c; // text length (16 bits)    memset(&expected[3], 'a', CONTROL_MSG_INJECT_TEXT_MAX_LENGTH);    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_set_clipboard(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_SET_CLIPBOARD,        .set_clipboard = {            .paste = true,            .text = "hello, world!",        },    };    unsigned char buf[CONTROL_MSG_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 17);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_SET_CLIPBOARD,        1, // paste        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_inject_text(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_INJECT_TEXT,        .inject_text = {            .text = "hello, world!",        },    };    unsigned char buf[CONTROL_MSG_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 16);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_INJECT_TEXT,        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_inject_text_long(void) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    char text[CONTROL_MSG_INJECT_TEXT_MAX_LENGTH + 1];    memset(text, 'a', sizeof(text));    text[CONTROL_MSG_INJECT_TEXT_MAX_LENGTH] = '\0';    msg.inject_text.text = text;    unsigned char buf[CONTROL_MSG_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 5 + CONTROL_MSG_INJECT_TEXT_MAX_LENGTH);    unsigned char expected[5 + CONTROL_MSG_INJECT_TEXT_MAX_LENGTH];    expected[0] = CONTROL_MSG_TYPE_INJECT_TEXT;    expected[1] = 0x00;    expected[2] = 0x00;    expected[3] = 0x01;    expected[4] = 0x2c; // text length (32 bits)    memset(&expected[5], 'a', CONTROL_MSG_INJECT_TEXT_MAX_LENGTH);    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_set_clipboard(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_SET_CLIPBOARD,        .set_clipboard = {            .paste = true,            .text = "hello, world!",        },    };    unsigned char buf[CONTROL_MSG_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 19);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_SET_CLIPBOARD,        1, // paste        0x00, 0x00, 0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_inject_text(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_INJECT_TEXT,        .inject_text = {            .text = "hello, world!",        },    };    unsigned char buf[CONTROL_MSG_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 18);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_INJECT_TEXT,        0x00, 0x00, 0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_deserialize_clipboard(void) {    const unsigned char input[] = {        DEVICE_MSG_TYPE_CLIPBOARD,        0x00, 0x03, // text length        0x41, 0x42, 0x43, // "ABC"    };    struct device_msg msg;    ssize_t r = device_msg_deserialize(input, sizeof(input), &msg);    assert(r == 6);    assert(msg.type == DEVICE_MSG_TYPE_CLIPBOARD);    assert(msg.clipboard.text);    assert(!strcmp("ABC", msg.clipboard.text));    device_msg_destroy(&msg);}
static void test_deserialize_clipboard_big(void) {    unsigned char input[DEVICE_MSG_MAX_SIZE];    input[0] = DEVICE_MSG_TYPE_CLIPBOARD;    input[1] = DEVICE_MSG_TEXT_MAX_LENGTH >> 8; // MSB    input[2] = DEVICE_MSG_TEXT_MAX_LENGTH & 0xff; // LSB    memset(input + 3, 'a', DEVICE_MSG_TEXT_MAX_LENGTH);    struct device_msg msg;    ssize_t r = device_msg_deserialize(input, sizeof(input), &msg);    assert(r == DEVICE_MSG_MAX_SIZE);    assert(msg.type == DEVICE_MSG_TYPE_CLIPBOARD);    assert(msg.clipboard.text);    assert(strlen(msg.clipboard.text) == DEVICE_MSG_TEXT_MAX_LENGTH);    assert(msg.clipboard.text[0] == 'a');    device_msg_destroy(&msg);}
static void test_deserialize_clipboard(void) {    const unsigned char input[] = {        DEVICE_MSG_TYPE_CLIPBOARD,        0x00, 0x00, 0x00, 0x03, // text length        0x41, 0x42, 0x43, // "ABC"    };    struct device_msg msg;    ssize_t r = device_msg_deserialize(input, sizeof(input), &msg);    assert(r == 8);    assert(msg.type == DEVICE_MSG_TYPE_CLIPBOARD);    assert(msg.clipboard.text);    assert(!strcmp("ABC", msg.clipboard.text));    device_msg_destroy(&msg);}
static void test_deserialize_clipboard_big(void) {    unsigned char input[DEVICE_MSG_MAX_SIZE];    input[0] = DEVICE_MSG_TYPE_CLIPBOARD;    input[1] = (DEVICE_MSG_TEXT_MAX_LENGTH & 0xff000000u) >> 24;    input[2] = (DEVICE_MSG_TEXT_MAX_LENGTH & 0x00ff0000u) >> 16;    input[3] = (DEVICE_MSG_TEXT_MAX_LENGTH & 0x0000ff00u) >> 8;    input[4] =  DEVICE_MSG_TEXT_MAX_LENGTH & 0x000000ffu;    memset(input + 5, 'a', DEVICE_MSG_TEXT_MAX_LENGTH);    struct device_msg msg;    ssize_t r = device_msg_deserialize(input, sizeof(input), &msg);    assert(r == DEVICE_MSG_MAX_SIZE);    assert(msg.type == DEVICE_MSG_TYPE_CLIPBOARD);    assert(msg.clipboard.text);    assert(strlen(msg.clipboard.text) == DEVICE_MSG_TEXT_MAX_LENGTH);    assert(msg.clipboard.text[0] == 'a');    device_msg_destroy(&msg);}
    private String parseString() {        if (buffer.remaining() < 2) {            return null;        }        int len = toUnsigned(buffer.getShort());        if (buffer.remaining() < len) {            return null;        }        int position = buffer.position();        // Move the buffer position to consume the text        buffer.position(position + len);        return new String(rawBuffer, position, len, StandardCharsets.UTF_8);    }
    private String parseString() {        if (buffer.remaining() < 4) {            return null;        }        int len = buffer.getInt();        if (buffer.remaining() < len) {            return null;        }        int position = buffer.position();        // Move the buffer position to consume the text        buffer.position(position + len);        return new String(rawBuffer, position, len, StandardCharsets.UTF_8);    }
    public void writeTo(DeviceMessage msg, OutputStream output) throws IOException {        buffer.clear();        buffer.put((byte) DeviceMessage.TYPE_CLIPBOARD);        switch (msg.getType()) {            case DeviceMessage.TYPE_CLIPBOARD:                String text = msg.getText();                byte[] raw = text.getBytes(StandardCharsets.UTF_8);                int len = StringUtils.getUtf8TruncationIndex(raw, CLIPBOARD_TEXT_MAX_LENGTH);                buffer.putShort((short) len);                buffer.put(raw, 0, len);                output.write(rawBuffer, 0, buffer.position());                break;            default:                Ln.w("Unknown device message: " + msg.getType());                break;        }    }}
    public void writeTo(DeviceMessage msg, OutputStream output) throws IOException {        buffer.clear();        buffer.put((byte) DeviceMessage.TYPE_CLIPBOARD);        switch (msg.getType()) {            case DeviceMessage.TYPE_CLIPBOARD:                String text = msg.getText();                byte[] raw = text.getBytes(StandardCharsets.UTF_8);                int len = StringUtils.getUtf8TruncationIndex(raw, CLIPBOARD_TEXT_MAX_LENGTH);                buffer.putInt(len);                buffer.put(raw, 0, len);                output.write(rawBuffer, 0, buffer.position());                break;            default:                Ln.w("Unknown device message: " + msg.getType());                break;        }    }}
    public void testParseTextEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_TEXT);        byte[] text = "testé".getBytes(StandardCharsets.UTF_8);        dos.writeShort(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_TEXT, event.getType());        Assert.assertEquals("testé", event.getText());    }
    public void testParseSetClipboardEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_SET_CLIPBOARD);        dos.writeByte(1); // paste        byte[] text = "testé".getBytes(StandardCharsets.UTF_8);        dos.writeShort(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_SET_CLIPBOARD, event.getType());        Assert.assertEquals("testé", event.getText());        boolean parse = (event.getFlags() & ControlMessage.FLAGS_PASTE) != 0;        Assert.assertTrue(parse);    }
    public void testParseBigSetClipboardEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_SET_CLIPBOARD);        byte[] rawText = new byte[ControlMessageReader.CLIPBOARD_TEXT_MAX_LENGTH];        dos.writeByte(1); // paste        Arrays.fill(rawText, (byte) 'a');        String text = new String(rawText, 0, rawText.length);        dos.writeShort(rawText.length);        dos.write(rawText);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_SET_CLIPBOARD, event.getType());        Assert.assertEquals(text, event.getText());        boolean parse = (event.getFlags() & ControlMessage.FLAGS_PASTE) != 0;        Assert.assertTrue(parse);    }
    public void testParseLongTextEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_TEXT);        byte[] text = new byte[ControlMessageReader.INJECT_TEXT_MAX_LENGTH];        Arrays.fill(text, (byte) 'a');        dos.writeShort(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_TEXT, event.getType());        Assert.assertEquals(new String(text, StandardCharsets.US_ASCII), event.getText());    }
    public void testParseTextEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_TEXT);        byte[] text = "testé".getBytes(StandardCharsets.UTF_8);        dos.writeInt(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_TEXT, event.getType());        Assert.assertEquals("testé", event.getText());    }
    public void testParseSetClipboardEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_SET_CLIPBOARD);        dos.writeByte(1); // paste        byte[] text = "testé".getBytes(StandardCharsets.UTF_8);        dos.writeInt(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_SET_CLIPBOARD, event.getType());        Assert.assertEquals("testé", event.getText());        boolean parse = (event.getFlags() & ControlMessage.FLAGS_PASTE) != 0;        Assert.assertTrue(parse);    }
    public void testParseBigSetClipboardEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_SET_CLIPBOARD);        byte[] rawText = new byte[ControlMessageReader.CLIPBOARD_TEXT_MAX_LENGTH];        dos.writeByte(1); // paste        Arrays.fill(rawText, (byte) 'a');        String text = new String(rawText, 0, rawText.length);        dos.writeInt(rawText.length);        dos.write(rawText);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_SET_CLIPBOARD, event.getType());        Assert.assertEquals(text, event.getText());        boolean parse = (event.getFlags() & ControlMessage.FLAGS_PASTE) != 0;        Assert.assertTrue(parse);    }
    public void testParseLongTextEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_TEXT);        byte[] text = new byte[ControlMessageReader.INJECT_TEXT_MAX_LENGTH];        Arrays.fill(text, (byte) 'a');        dos.writeInt(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_TEXT, event.getType());        Assert.assertEquals(new String(text, StandardCharsets.US_ASCII), event.getText());    }
    public void testSerializeClipboard() throws IOException {        DeviceMessageWriter writer = new DeviceMessageWriter();        String text = "aéûoç";        byte[] data = text.getBytes(StandardCharsets.UTF_8);        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(DeviceMessage.TYPE_CLIPBOARD);        dos.writeShort(data.length);        dos.write(data);        byte[] expected = bos.toByteArray();        DeviceMessage msg = DeviceMessage.createClipboard(text);        bos = new ByteArrayOutputStream();        writer.writeTo(msg, bos);        byte[] actual = bos.toByteArray();        Assert.assertArrayEquals(expected, actual);    }}
    public void testSerializeClipboard() throws IOException {        DeviceMessageWriter writer = new DeviceMessageWriter();        String text = "aéûoç";        byte[] data = text.getBytes(StandardCharsets.UTF_8);        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(DeviceMessage.TYPE_CLIPBOARD);        dos.writeInt(data.length);        dos.write(data);        byte[] expected = bos.toByteArray();        DeviceMessage msg = DeviceMessage.createClipboard(text);        bos = new ByteArrayOutputStream();        writer.writeTo(msg, bos);        byte[] actual = bos.toByteArray();        Assert.assertArrayEquals(expected, actual);    }}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = im->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (cmd && !shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (cmd && !shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && cmd && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && cmd && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && cmd && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = im->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && !repeat && down) {                    enum screen_power_mode mode = shift                                                ? SCREEN_POWER_MODE_NORMAL                                                : SCREEN_POWER_MODE_OFF;                    set_screen_power_mode(controller, mode);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_LEFT:                if (cmd && !shift && !repeat && down) {                    rotate_client_left(im->screen);                }                return;            case SDLK_RIGHT:                if (cmd && !shift && !repeat && down) {                    rotate_client_right(im->screen);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard and paste                        set_device_clipboard(controller, true);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (cmd && !shift && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (cmd && !shift && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (cmd && !shift && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (cmd && !shift && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;            case SDLK_r:                if (control && cmd && !shift && !repeat && down) {                    rotate_device(controller);                }                return;        }        return;    }    if (!control) {        return;    }    if (event->repeat) {        ++im->repeat;    } else {        im->repeat = 0;    }    struct control_msg msg;    if (convert_input_key(event, &msg, im->prefer_text, im->repeat)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
    private String parseString() {        if (buffer.remaining() < 2) {            return null;        }        int len = toUnsigned(buffer.getShort());        if (buffer.remaining() < len) {            return null;        }        buffer.get(textBuffer, 0, len);        return new String(textBuffer, 0, len, StandardCharsets.UTF_8);    }
    private String parseString() {        if (buffer.remaining() < 2) {            return null;        }        int len = toUnsigned(buffer.getShort());        if (buffer.remaining() < len) {            return null;        }        int position = buffer.position();        // Move the buffer position to consume the text        buffer.position(position + len);        return new String(rawBuffer, position, len, StandardCharsets.UTF_8);    }
get_server_path(void) {    const char *server_path_env = getenv("SCRCPY_SERVER_PATH");    if (server_path_env) {        // if the envvar is set, use it        char *server_path = SDL_strdup(server_path_env);        if (!server_path) {            LOGE("Could not allocate memory");            return NULL;        }        LOGD("Using SCRCPY_SERVER_PATH: %s", server_path);        return server_path;    }#ifndef PORTABLE    LOGD("Using server: " DEFAULT_SERVER_PATH);    char *server_path = SDL_strdup(DEFAULT_SERVER_PATH);    if (!server_path) {        LOGE("Could not allocate memory");        return NULL;    }    // the absolute path is hardcoded    return server_path;#else    // use scrcpy-server in the same directory as the executable    char *executable_path = get_executable_path();    if (!executable_path) {        LOGE("Could not get executable path, "             "using " SERVER_FILENAME " from current directory");        // not found, use current directory        return SERVER_FILENAME;    }    char *dir = dirname(executable_path);    size_t dirlen = strlen(dir);    // sizeof(SERVER_FILENAME) gives statically the size including the null byte    size_t len = dirlen + 1 + sizeof(SERVER_FILENAME);    char *server_path = SDL_malloc(len);    if (!server_path) {        LOGE("Could not alloc server path string, "             "using " SERVER_FILENAME " from current directory");        SDL_free(executable_path);        return SERVER_FILENAME;    }    memcpy(server_path, dir, dirlen);    server_path[dirlen] = PATH_SEPARATOR;    memcpy(&server_path[dirlen + 1], SERVER_FILENAME, sizeof(SERVER_FILENAME));    // the final null byte has been copied with SERVER_FILENAME    SDL_free(executable_path);    LOGD("Using server (portable): %s", server_path);    return server_path;#endif}
get_server_path(void) {#ifdef __WINDOWS__    const wchar_t *server_path_env = _wgetenv(L"SCRCPY_SERVER_PATH");#else    const char *server_path_env = getenv("SCRCPY_SERVER_PATH");#endif    if (server_path_env) {        // if the envvar is set, use it#ifdef __WINDOWS__        char *server_path = utf8_from_wide_char(server_path_env);#else        char *server_path = SDL_strdup(server_path_env);#endif        if (!server_path) {            LOGE("Could not allocate memory");            return NULL;        }        LOGD("Using SCRCPY_SERVER_PATH: %s", server_path);        return server_path;    }#ifndef PORTABLE    LOGD("Using server: " DEFAULT_SERVER_PATH);    char *server_path = SDL_strdup(DEFAULT_SERVER_PATH);    if (!server_path) {        LOGE("Could not allocate memory");        return NULL;    }    // the absolute path is hardcoded    return server_path;#else    // use scrcpy-server in the same directory as the executable    char *executable_path = get_executable_path();    if (!executable_path) {        LOGE("Could not get executable path, "             "using " SERVER_FILENAME " from current directory");        // not found, use current directory        return SERVER_FILENAME;    }    char *dir = dirname(executable_path);    size_t dirlen = strlen(dir);    // sizeof(SERVER_FILENAME) gives statically the size including the null byte    size_t len = dirlen + 1 + sizeof(SERVER_FILENAME);    char *server_path = SDL_malloc(len);    if (!server_path) {        LOGE("Could not alloc server path string, "             "using " SERVER_FILENAME " from current directory");        SDL_free(executable_path);        return SERVER_FILENAME;    }    memcpy(server_path, dir, dirlen);    server_path[dirlen] = PATH_SEPARATOR;    memcpy(&server_path[dirlen + 1], SERVER_FILENAME, sizeof(SERVER_FILENAME));    // the final null byte has been copied with SERVER_FILENAME    SDL_free(executable_path);    LOGD("Using server (portable): %s", server_path);    return server_path;#endif}
    public void control() throws IOException {        // on start, power on the device        if (!device.isScreenOn()) {            device.injectKeycode(KeyEvent.KEYCODE_WAKEUP);            // dirty hack            // After the keycode is injected, the device is powered on asynchronously.            // To turn the device screen off while mirroring, the client will send a message that            // would be handled before the device is actually powered on, so its effect would            // be "canceled" once the device is turned back on.            // Adding this delay prevents to handle the message before the device is actually            // powered on.            SystemClock.sleep(500);        }        while (true) {            handleEvent();        }    }
    private boolean pressBackOrTurnScreenOn() {        int keycode = device.isScreenOn() ? KeyEvent.KEYCODE_BACK : KeyEvent.KEYCODE_WAKEUP;        if (keepPowerModeOff && keycode == KeyEvent.KEYCODE_WAKEUP) {            schedulePowerModeOff();        }        return device.injectKeycode(keycode);    }
    public void control() throws IOException {        // on start, power on the device        if (!device.isScreenOn()) {            device.injectKeycode(KeyEvent.KEYCODE_POWER);            // dirty hack            // After POWER is injected, the device is powered on asynchronously.            // To turn the device screen off while mirroring, the client will send a message that            // would be handled before the device is actually powered on, so its effect would            // be "canceled" once the device is turned back on.            // Adding this delay prevents to handle the message before the device is actually            // powered on.            SystemClock.sleep(500);        }        while (true) {            handleEvent();        }    }
    private boolean pressBackOrTurnScreenOn() {        int keycode = device.isScreenOn() ? KeyEvent.KEYCODE_BACK : KeyEvent.KEYCODE_POWER;        if (keepPowerModeOff && keycode == KeyEvent.KEYCODE_POWER) {            schedulePowerModeOff();        }        return device.injectKeycode(keycode);    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                if (device.supportsInputEvents()) {                    injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                }                break;            case ControlMessage.TYPE_INJECT_TEXT:                if (device.supportsInputEvents()) {                    injectText(msg.getText());                }                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                if (device.supportsInputEvents()) {                    injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), msg.getButtons());                }                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                if (device.supportsInputEvents()) {                    injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                }                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                if (device.supportsInputEvents()) {                    pressBackOrTurnScreenOn();                }                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                device.setClipboardText(msg.getText());                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                if (device.supportsInputEvents()) {                    device.setScreenPowerMode(msg.getAction());                }                break;            case ControlMessage.TYPE_ROTATE_DEVICE:                device.rotateDevice();                break;            default:                // do nothing        }    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                if (device.supportsInputEvents()) {                    injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                }                break;            case ControlMessage.TYPE_INJECT_TEXT:                if (device.supportsInputEvents()) {                    injectText(msg.getText());                }                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                if (device.supportsInputEvents()) {                    injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), msg.getButtons());                }                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                if (device.supportsInputEvents()) {                    injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                }                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                if (device.supportsInputEvents()) {                    pressBackOrTurnScreenOn();                }                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                boolean setClipboardOk = device.setClipboardText(msg.getText());                if (setClipboardOk) {                    Ln.i("Device clipboard set");                }                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                if (device.supportsInputEvents()) {                    int mode = msg.getAction();                    boolean setPowerModeOk = device.setScreenPowerMode(mode);                    if (setPowerModeOk) {                        Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));                    }                }                break;            case ControlMessage.TYPE_ROTATE_DEVICE:                device.rotateDevice();                break;            default:                // do nothing        }    }
    public void setClipboardText(String text) {        boolean ok = serviceManager.getClipboardManager().setText(text);        if (ok) {            Ln.i("Device clipboard set");        }    }
    public void setScreenPowerMode(int mode) {        IBinder d = SurfaceControl.getBuiltInDisplay();        if (d == null) {            Ln.e("Could not get built-in display");            return;        }        boolean ok = SurfaceControl.setDisplayPowerMode(d, mode);        if (ok) {            Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));        }    }
    public boolean setClipboardText(String text) {        return serviceManager.getClipboardManager().setText(text);    }
    public boolean setScreenPowerMode(int mode) {        IBinder d = SurfaceControl.getBuiltInDisplay();        if (d == null) {            Ln.e("Could not get built-in display");            return false;        }        return SurfaceControl.setDisplayPowerMode(d, mode);    }
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    char max_fps_string[6];    char lock_video_orientation_string[3];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    sprintf(max_fps_string, "%"PRIu16, params->max_fps);    sprintf(lock_video_orientation_string, "%"PRIi8, params->lock_video_orientation);    const char *const cmd[] = {        "shell",        "CLASSPATH=" DEVICE_SERVER_PATH,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,        max_size_string,        bit_rate_string,        max_fps_string,        lock_video_orientation_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    char max_fps_string[6];    char lock_video_orientation_string[3];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    sprintf(max_fps_string, "%"PRIu16, params->max_fps);    sprintf(lock_video_orientation_string, "%"PRIi8, params->lock_video_orientation);    const char *const cmd[] = {        "shell",        "CLASSPATH=" DEVICE_SERVER_PATH,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"# ifdef SERVER_DEBUGGER_METHOD_NEW        /* Android 9 and above */        "-XjdwpProvider:internal -XjdwpOptions:transport=dt_socket,suspend=y,server=y,address="# else        /* Android 8 and below */        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="# endif            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,        max_size_string,        bit_rate_string,        max_fps_string,        lock_video_orientation_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };#ifndef NDEBUG    args.opts.log_level = SC_LOG_LEVEL_DEBUG;#endif    if (!scrcpy_parse_args(&args, argc, argv)) {        return 1;    }    SDL_LogPriority sdl_log = convert_log_level_to_sdl(args.opts.log_level);    SDL_LogSetAllPriority(sdl_log);    if (args.help) {        scrcpy_print_usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    LOGI("scrcpy " SCRCPY_VERSION " <https://github.com/Genymobile/scrcpy>");#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }    int res = scrcpy(&args.opts) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };#ifndef NDEBUG    args.opts.log_level = SC_LOG_LEVEL_DEBUG;#endif    if (!scrcpy_parse_args(&args, argc, argv)) {        return 1;    }    SDL_LogPriority sdl_log = convert_log_level_to_sdl(args.opts.log_level);    SDL_LogSetPriority(SDL_LOG_CATEGORY_APPLICATION, sdl_log);    if (args.help) {        scrcpy_print_usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    LOGI("scrcpy " SCRCPY_VERSION " <https://github.com/Genymobile/scrcpy>");#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }    int res = scrcpy(&args.opts) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
parse_bit_rate(char *optarg, uint32_t *bit_rate) {    char *endptr;    if (*optarg == '\0') {        LOGE("Bit-rate parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    int mul = 1;    if (*endptr != '\0') {        if (optarg == endptr) {            LOGE("Invalid bit-rate: %s", optarg);            return false;        }        if ((*endptr == 'M' || *endptr == 'm') && endptr[1] == '\0') {            mul = 1000000;        } else if ((*endptr == 'K' || *endptr == 'k') && endptr[1] == '\0') {            mul = 1000;        } else {            LOGE("Invalid bit-rate unit: %s", optarg);            return false;        }    }    if (value < 0 || ((uint32_t) -1) / mul < value) {        LOGE("Bitrate must be positive and less than 2^32: %s", optarg);        return false;    }    *bit_rate = (uint32_t) value * mul;    return true;}
parse_bit_rate(char *optarg, uint32_t *bit_rate) {    char *endptr;    if (*optarg == '\0') {        LOGE("Bit-rate parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    int mul = 1;    if (*endptr != '\0') {        if (optarg == endptr) {            LOGE("Invalid bit-rate: %s", optarg);            return false;        }        if ((*endptr == 'M' || *endptr == 'm') && endptr[1] == '\0') {            mul = 1000000;        } else if ((*endptr == 'K' || *endptr == 'k') && endptr[1] == '\0') {            mul = 1000;        } else {            LOGE("Invalid bit-rate unit: %s", optarg);            return false;        }    }    if (value < 0 || ((uint32_t) -1) / mul < (unsigned long) value) {        LOGE("Bitrate must be positive and less than 2^32: %s", optarg);        return false;    }    *bit_rate = (uint32_t) value * mul;    return true;}
event_watcher(void *data, SDL_Event *event) {    if (event->type == SDL_WINDOWEVENT            && event->window.event == SDL_WINDOWEVENT_RESIZED) {        // called from another thread, not very safe, but it's a workaround!        screen_render(&screen);    }    return 0;}#endif
event_watcher(void *data, SDL_Event *event) {    (void) data;    if (event->type == SDL_WINDOWEVENT            && event->window.event == SDL_WINDOWEVENT_RESIZED) {        // called from another thread, not very safe, but it's a workaround!        screen_render(&screen);    }    return 0;}#endif
stream_recv_packet(struct stream *stream, AVPacket *packet) {    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    uint8_t header[HEADER_SIZE];    ssize_t r = net_recv_all(stream->socket, header, HEADER_SIZE);    if (r < HEADER_SIZE) {        return false;    }    uint64_t pts = buffer_read64be(header);    uint32_t len = buffer_read32be(&header[8]);    SDL_assert(len);    if (av_new_packet(packet, len)) {        LOGE("Could not allocate packet");        return false;    }    r = net_recv_all(stream->socket, packet->data, len);    if (r < len) {        av_packet_unref(packet);        return false;    }    packet->pts = pts != NO_PTS ? pts : AV_NOPTS_VALUE;    return true;}
stream_recv_packet(struct stream *stream, AVPacket *packet) {    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    uint8_t header[HEADER_SIZE];    ssize_t r = net_recv_all(stream->socket, header, HEADER_SIZE);    if (r < HEADER_SIZE) {        return false;    }    uint64_t pts = buffer_read64be(header);    uint32_t len = buffer_read32be(&header[8]);    SDL_assert(pts == NO_PTS || (pts & 0x8000000000000000) == 0);    SDL_assert(len);    if (av_new_packet(packet, len)) {        LOGE("Could not allocate packet");        return false;    }    r = net_recv_all(stream->socket, packet->data, len);    if (r < 0 || ((uint32_t) r) < len) {        av_packet_unref(packet);        return false;    }    packet->pts = pts != NO_PTS ? (int64_t) pts : AV_NOPTS_VALUE;    return true;}
cmd_execute(const char *path, const char *const argv[], HANDLE *handle) {    STARTUPINFOW si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    char cmd[256];    if (build_cmd(cmd, sizeof(cmd), argv)) {        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }    wchar_t *wide = utf8_to_wide_char(cmd);    if (!wide) {        LOGC("Could not allocate wide char string");        return PROCESS_ERROR_GENERIC;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcessW(NULL, wide, NULL, NULL, FALSE, flags, NULL, NULL, &si,                        &pi)) {        SDL_free(wide);        *handle = NULL;        if (GetLastError() == ERROR_FILE_NOT_FOUND) {            return PROCESS_ERROR_MISSING_BINARY;        }        return PROCESS_ERROR_GENERIC;    }    SDL_free(wide);    *handle = pi.hProcess;    return PROCESS_SUCCESS;}
cmd_execute(const char *path, const char *const argv[], HANDLE *handle) {    (void) path;    STARTUPINFOW si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    char cmd[256];    if (build_cmd(cmd, sizeof(cmd), argv)) {        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }    wchar_t *wide = utf8_to_wide_char(cmd);    if (!wide) {        LOGC("Could not allocate wide char string");        return PROCESS_ERROR_GENERIC;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcessW(NULL, wide, NULL, NULL, FALSE, flags, NULL, NULL, &si,                        &pi)) {        SDL_free(wide);        *handle = NULL;        if (GetLastError() == ERROR_FILE_NOT_FOUND) {            return PROCESS_ERROR_MISSING_BINARY;        }        return PROCESS_ERROR_GENERIC;    }    SDL_free(wide);    *handle = pi.hProcess;    return PROCESS_SUCCESS;}
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                if (device.supportsInputEvents()) {                    injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                }                break;            case ControlMessage.TYPE_INJECT_TEXT:                if (device.supportsInputEvents()) {                    injectText(msg.getText());                }                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                if (device.supportsInputEvents()) {                    injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), msg.getButtons());                }                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                if (device.supportsInputEvents()) {                    injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                }                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                if (device.supportsInputEvents()) {                    pressBackOrTurnScreenOn();                }                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                boolean paste = (msg.getFlags() & ControlMessage.FLAGS_PASTE) != 0;                setClipboard(msg.getText(), paste);                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                if (device.supportsInputEvents()) {                    int mode = msg.getAction();                    boolean setPowerModeOk = device.setScreenPowerMode(mode);                    if (setPowerModeOk) {                        Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));                    }                }                break;            case ControlMessage.TYPE_ROTATE_DEVICE:                device.rotateDevice();                break;            default:                // do nothing        }    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                if (device.supportsInputEvents()) {                    injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                }                break;            case ControlMessage.TYPE_INJECT_TEXT:                if (device.supportsInputEvents()) {                    injectText(msg.getText());                }                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                if (device.supportsInputEvents()) {                    injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), msg.getButtons());                }                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                if (device.supportsInputEvents()) {                    injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                }                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                if (device.supportsInputEvents()) {                    pressBackOrTurnScreenOn();                }                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                if (clipboardText != null) {                    sender.pushClipboardText(clipboardText);                }                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                boolean paste = (msg.getFlags() & ControlMessage.FLAGS_PASTE) != 0;                setClipboard(msg.getText(), paste);                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                if (device.supportsInputEvents()) {                    int mode = msg.getAction();                    boolean setPowerModeOk = device.setScreenPowerMode(mode);                    if (setPowerModeOk) {                        Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));                    }                }                break;            case ControlMessage.TYPE_ROTATE_DEVICE:                device.rotateDevice();                break;            default:                // do nothing        }    }
    private static ClipData getPrimaryClip(Method method, IInterface manager) throws InvocationTargetException, IllegalAccessException {        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {            return (ClipData) method.invoke(manager, PACKAGE_NAME);        }        return (ClipData) method.invoke(manager, PACKAGE_NAME, USER_ID);    }
    private static void setPrimaryClip(Method method, IInterface manager, ClipData clipData)            throws InvocationTargetException, IllegalAccessException {        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {            method.invoke(manager, clipData, PACKAGE_NAME);        } else {            method.invoke(manager, clipData, PACKAGE_NAME, USER_ID);        }    }
    private static ClipData getPrimaryClip(Method method, IInterface manager) throws InvocationTargetException, IllegalAccessException {        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {            return (ClipData) method.invoke(manager, ServiceManager.PACKAGE_NAME);        }        return (ClipData) method.invoke(manager, ServiceManager.PACKAGE_NAME, ServiceManager.USER_ID);    }
    private static void setPrimaryClip(Method method, IInterface manager, ClipData clipData)            throws InvocationTargetException, IllegalAccessException {        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {            method.invoke(manager, clipData, ServiceManager.PACKAGE_NAME);        } else {            method.invoke(manager, clipData, ServiceManager.PACKAGE_NAME, ServiceManager.USER_ID);        }    }
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    char max_fps_string[6];    char lock_video_orientation_string[3];    char display_id_string[6];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    sprintf(max_fps_string, "%"PRIu16, params->max_fps);    sprintf(lock_video_orientation_string, "%"PRIi8, params->lock_video_orientation);    sprintf(display_id_string, "%"PRIu16, params->display_id);    const char *const cmd[] = {        "shell",        "CLASSPATH=" DEVICE_SERVER_PATH,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"# ifdef SERVER_DEBUGGER_METHOD_NEW        /* Android 9 and above */        "-XjdwpProvider:internal -XjdwpOptions:transport=dt_socket,suspend=y,server=y,address="# else        /* Android 8 and below */        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="# endif            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,        max_size_string,        bit_rate_string,        max_fps_string,        lock_video_orientation_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",        display_id_string,        params->show_touches ? "true" : "false",        params->stay_awake ? "true" : "false",        params->codec_options ? params->codec_options : "-",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    char max_fps_string[6];    char lock_video_orientation_string[5];    char display_id_string[6];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    sprintf(max_fps_string, "%"PRIu16, params->max_fps);    sprintf(lock_video_orientation_string, "%"PRIi8, params->lock_video_orientation);    sprintf(display_id_string, "%"PRIu16, params->display_id);    const char *const cmd[] = {        "shell",        "CLASSPATH=" DEVICE_SERVER_PATH,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"# ifdef SERVER_DEBUGGER_METHOD_NEW        /* Android 9 and above */        "-XjdwpProvider:internal -XjdwpOptions:transport=dt_socket,suspend=y,server=y,address="# else        /* Android 8 and below */        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="# endif            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,        max_size_string,        bit_rate_string,        max_fps_string,        lock_video_orientation_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",        display_id_string,        params->show_touches ? "true" : "false",        params->stay_awake ? "true" : "false",        params->codec_options ? params->codec_options : "-",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value. Values are integers in the\n"        "        range [-1..3]. Natural device orientation is 0 and each\n"        "        increment adds 90 degrees counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
scrcpy_print_usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    --display id\n"        "        Specify the display id to mirror.\n"        "\n"        "        The list of possible display ids can be listed by:\n"        "            adb shell dumpsys display\n"        "        (search \"mDisplayId=\" in the output)\n"        "\n"        "        Default is 0.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --lock-video-orientation value\n"        "        Lock video orientation to value.\n"        "        Possible values are -1 (unlocked), 0, 1, 2 and 3.\n"        "        Natural device orientation is 0, and each increment adds a\n"        "        90 degrees rotation counterclockwise.\n"        "        Default is %d%s.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (officially supported\n"        "        since Android 10, but may work on earlier versions).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port[:port]\n"        "        Set the TCP port (range) used by the client to listen.\n"        "        Default is %d:%d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    --rotation value\n"        "        Set the initial display rotation.\n"        "        Possibles values are 0, 1, 2 and 3. Each increment adds a 90\n"        "        degrees rotation counterclockwise.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is \"auto\".\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        Switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+Left\n"        "        Rotate display left\n"        "\n"        "    " CTRL_OR_CMD "+Right\n"        "        Rotate display right\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        Resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        Resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        Click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        Click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        Click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        Click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        Click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        Click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        Click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        Power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        Turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        Rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "        Expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "        Collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        Copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        Paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        Copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        Enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        Install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_LOCK_VIDEO_ORIENTATION, DEFAULT_LOCK_VIDEO_ORIENTATION >= 0 ? "" : " (unlocked)",        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT_RANGE_FIRST, DEFAULT_LOCAL_PORT_RANGE_LAST);}
static void usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (only supported on\n"        "        devices with Android >= 10).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+r\n"        "        rotate device screen\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    LOGI("scrcpy " SCRCPY_VERSION " <https://github.com/Genymobile/scrcpy>");#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifndef NDEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    int res = scrcpy(&args.opts) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
                                                LIBAVCODEC_VERSION_MICRO);    fprintf(stderr, " - libavformat %d.%d.%d\n", LIBAVFORMAT_VERSION_MAJOR,                                                 LIBAVFORMAT_VERSION_MINOR,                                                 LIBAVFORMAT_VERSION_MICRO);    fprintf(stderr, " - libavutil %d.%d.%d\n", LIBAVUTIL_VERSION_MAJOR,                                               LIBAVUTIL_VERSION_MINOR,                                               LIBAVUTIL_VERSION_MICRO);}intmain(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    if (!scrcpy_parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        scrcpy_print_usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    LOGI("scrcpy " SCRCPY_VERSION " <https://github.com/Genymobile/scrcpy>");#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifndef NDEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    int res = scrcpy(&args.opts) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    if (!scrcpy_parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        scrcpy_print_usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    LOGI("scrcpy " SCRCPY_VERSION " <https://github.com/Genymobile/scrcpy>");#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifndef NDEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    int res = scrcpy(&args.opts) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
input_manager_process_mouse_button(struct input_manager *input_manager,                                   const SDL_MouseButtonEvent *event,                                   bool control) {    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (control && event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(input_manager->controller);            return;        }        if (control && event->button == SDL_BUTTON_MIDDLE) {            action_home(input_manager->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            bool outside =                is_outside_device_screen(input_manager, event->x, event->y);            if (outside) {                screen_resize_to_fit(input_manager->screen);                return;            }        }        // otherwise, send the click event to the device    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_mouse_button(event, input_manager->screen->frame_size, &msg)) {        if (!controller_push_msg(input_manager->controller, &msg)) {            LOGW("Could not request 'inject mouse button event'");        }    }}
is_outside_device_screen(struct input_manager *input_manager, int x, int y){    return x < 0 || x >= input_manager->screen->frame_size.width ||           y < 0 || y >= input_manager->screen->frame_size.height;}
input_manager_process_key(struct input_manager *input_manager,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = input_manager->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && !shift && down) {                    set_screen_power_mode(controller, SCREEN_POWER_MODE_OFF);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard                        set_device_clipboard(controller);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && cmd && !repeat && down) {                    screen_switch_fullscreen(input_manager->screen);                }                return;            case SDLK_x:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_fit(input_manager->screen);                }                return;            case SDLK_g:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_pixel_perfect(input_manager->screen);                }                return;            case SDLK_i:                if (!shift && cmd && !repeat && down) {                    struct fps_counter *fps_counter =                        input_manager->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;        }        return;    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_input_key(event, &msg)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_process_touch(struct input_manager *input_manager,                            const SDL_TouchFingerEvent *event) {    struct control_msg msg;    if (convert_touch(event, input_manager->screen->frame_size, &msg)) {        if (!controller_push_msg(input_manager->controller, &msg)) {            LOGW("Could not request 'inject touch event'");        }    }}
input_manager_process_text_input(struct input_manager *input_manager,                                 const SDL_TextInputEvent *event) {    char c = event->text[0];    if (isalpha(c) || c == ' ') {        SDL_assert(event->text[1] == '\0');        // letters and space are handled as raw key event        return;    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    msg.inject_text.text = SDL_strdup(event->text);    if (!msg.inject_text.text) {        LOGW("Could not strdup input text");        return;    }    if (!controller_push_msg(input_manager->controller, &msg)) {        SDL_free(msg.inject_text.text);        LOGW("Could not request 'inject text'");    }}
input_manager_process_text_input(struct input_manager *input_manager,                                 const SDL_TextInputEvent *event) {    char c = event->text[0];    if (isalpha(c) || c == ' ') {        SDL_assert(event->text[1] == '\0');        // letters and space are handled as raw key event        return;    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    msg.inject_text.text = SDL_strdup(event->text);    if (!msg.inject_text.text) {        LOGW("Could not strdup input text");        return;    }    if (!controller_push_msg(input_manager->controller, &msg)) {        SDL_free(msg.inject_text.text);        LOGW("Could not request 'inject text'");    }}
input_manager_process_mouse_button(struct input_manager *input_manager,                                   const SDL_MouseButtonEvent *event,                                   bool control) {    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (control && event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(input_manager->controller);            return;        }        if (control && event->button == SDL_BUTTON_MIDDLE) {            action_home(input_manager->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            bool outside =                is_outside_device_screen(input_manager, event->x, event->y);            if (outside) {                screen_resize_to_fit(input_manager->screen);                return;            }        }        // otherwise, send the click event to the device    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_mouse_button(event, input_manager->screen->frame_size, &msg)) {        if (!controller_push_msg(input_manager->controller, &msg)) {            LOGW("Could not request 'inject mouse button event'");        }    }}
input_manager_process_key(struct input_manager *input_manager,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = input_manager->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && !shift && down) {                    set_screen_power_mode(controller, SCREEN_POWER_MODE_OFF);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard                        set_device_clipboard(controller);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && cmd && !repeat && down) {                    screen_switch_fullscreen(input_manager->screen);                }                return;            case SDLK_x:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_fit(input_manager->screen);                }                return;            case SDLK_g:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_pixel_perfect(input_manager->screen);                }                return;            case SDLK_i:                if (!shift && cmd && !repeat && down) {                    struct fps_counter *fps_counter =                        input_manager->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;        }        return;    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_input_key(event, &msg)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_process_mouse_motion(struct input_manager *input_manager,                                   const SDL_MouseMotionEvent *event) {    if (!event->state) {        // do not send motion events when no button is pressed        return;    }    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    struct control_msg msg;    if (convert_mouse_motion(event, input_manager->screen->frame_size, &msg)) {        if (!controller_push_msg(input_manager->controller, &msg)) {            LOGW("Could not request 'inject mouse motion event'");        }    }}
is_outside_device_screen(struct input_manager *input_manager, int x, int y){    return x < 0 || x >= input_manager->screen->frame_size.width ||           y < 0 || y >= input_manager->screen->frame_size.height;}
input_manager_process_mouse_motion(struct input_manager *input_manager,                                   const SDL_MouseMotionEvent *event) {    if (!event->state) {        // do not send motion events when no button is pressed        return;    }    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    struct control_msg msg;    if (convert_mouse_motion(event, input_manager->screen->frame_size, &msg)) {        if (!controller_push_msg(input_manager->controller, &msg)) {            LOGW("Could not request 'inject mouse motion event'");        }    }}
input_manager_process_mouse_wheel(struct input_manager *input_manager,                                  const SDL_MouseWheelEvent *event) {    struct position position = {        .screen_size = input_manager->screen->frame_size,        .point = get_mouse_point(input_manager->screen),    };    struct control_msg msg;    if (convert_mouse_wheel(event, position, &msg)) {        if (!controller_push_msg(input_manager->controller, &msg)) {            LOGW("Could not request 'inject mouse wheel event'");        }    }}
input_manager_process_mouse_wheel(struct input_manager *input_manager,                                  const SDL_MouseWheelEvent *event) {    struct position position = {        .screen_size = input_manager->screen->frame_size,        .point = get_mouse_point(input_manager->screen),    };    struct control_msg msg;    if (convert_mouse_wheel(event, position, &msg)) {        if (!controller_push_msg(input_manager->controller, &msg)) {            LOGW("Could not request 'inject mouse wheel event'");        }    }}
input_manager_process_touch(struct input_manager *input_manager,                            const SDL_TouchFingerEvent *event) {    struct control_msg msg;    if (convert_touch(event, input_manager->screen->frame_size, &msg)) {        if (!controller_push_msg(input_manager->controller, &msg)) {            LOGW("Could not request 'inject touch event'");        }    }}
input_manager_process_mouse_button(struct input_manager *im,                                   const SDL_MouseButtonEvent *event,                                   bool control) {    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (control && event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(im->controller);            return;        }        if (control && event->button == SDL_BUTTON_MIDDLE) {            action_home(im->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            bool outside =                is_outside_device_screen(im, event->x, event->y);            if (outside) {                screen_resize_to_fit(im->screen);                return;            }        }        // otherwise, send the click event to the device    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_mouse_button(event, im->screen->frame_size, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject mouse button event'");        }    }}
is_outside_device_screen(struct input_manager *im, int x, int y){    return x < 0 || x >= im->screen->frame_size.width ||           y < 0 || y >= im->screen->frame_size.height;}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = im->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && !shift && down) {                    set_screen_power_mode(controller, SCREEN_POWER_MODE_OFF);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard                        set_device_clipboard(controller);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && cmd && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && cmd && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;        }        return;    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_input_key(event, &msg)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_process_touch(struct input_manager *im,                            const SDL_TouchFingerEvent *event) {    struct control_msg msg;    if (convert_touch(event, im->screen->frame_size, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject touch event'");        }    }}
input_manager_process_text_input(struct input_manager *im,                                 const SDL_TextInputEvent *event) {    char c = event->text[0];    if (isalpha(c) || c == ' ') {        SDL_assert(event->text[1] == '\0');        // letters and space are handled as raw key event        return;    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    msg.inject_text.text = SDL_strdup(event->text);    if (!msg.inject_text.text) {        LOGW("Could not strdup input text");        return;    }    if (!controller_push_msg(im->controller, &msg)) {        SDL_free(msg.inject_text.text);        LOGW("Could not request 'inject text'");    }}
input_manager_process_text_input(struct input_manager *im,                                 const SDL_TextInputEvent *event) {    char c = event->text[0];    if (isalpha(c) || c == ' ') {        SDL_assert(event->text[1] == '\0');        // letters and space are handled as raw key event        return;    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    msg.inject_text.text = SDL_strdup(event->text);    if (!msg.inject_text.text) {        LOGW("Could not strdup input text");        return;    }    if (!controller_push_msg(im->controller, &msg)) {        SDL_free(msg.inject_text.text);        LOGW("Could not request 'inject text'");    }}
input_manager_process_mouse_button(struct input_manager *im,                                   const SDL_MouseButtonEvent *event,                                   bool control) {    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (control && event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(im->controller);            return;        }        if (control && event->button == SDL_BUTTON_MIDDLE) {            action_home(im->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            bool outside =                is_outside_device_screen(im, event->x, event->y);            if (outside) {                screen_resize_to_fit(im->screen);                return;            }        }        // otherwise, send the click event to the device    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_mouse_button(event, im->screen->frame_size, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject mouse button event'");        }    }}
input_manager_process_key(struct input_manager *im,                          const SDL_KeyboardEvent *event,                          bool control) {    // control: indicates the state of the command-line option --no-control    // ctrl: the Ctrl key    bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    // use Cmd on macOS, Ctrl on other platforms#ifdef __APPLE__    bool cmd = !ctrl && meta;#else    if (meta) {        // no shortcuts involve Meta on platforms other than macOS, and it must        // not be forwarded to the device        return;    }    bool cmd = ctrl; // && !meta, already guaranteed#endif    if (alt) {        // no shortcuts involve Alt, and it must not be forwarded to the device        return;    }    struct controller *controller = im->controller;    // capture all Ctrl events    if (ctrl || cmd) {        SDL_Keycode keycode = event->keysym.sym;        bool down = event->type == SDL_KEYDOWN;        int action = down ? ACTION_DOWN : ACTION_UP;        bool repeat = event->repeat;        bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        switch (keycode) {            case SDLK_h:                // Ctrl+h on all platform, since Cmd+h is already captured by                // the system on macOS to hide the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_home(controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (control && cmd && !shift && !repeat) {                    action_back(controller, action);                }                return;            case SDLK_s:                if (control && cmd && !shift && !repeat) {                    action_app_switch(controller, action);                }                return;            case SDLK_m:                // Ctrl+m on all platform, since Cmd+m is already captured by                // the system on macOS to minimize the window                if (control && ctrl && !meta && !shift && !repeat) {                    action_menu(controller, action);                }                return;            case SDLK_p:                if (control && cmd && !shift && !repeat) {                    action_power(controller, action);                }                return;            case SDLK_o:                if (control && cmd && !shift && down) {                    set_screen_power_mode(controller, SCREEN_POWER_MODE_OFF);                }                return;            case SDLK_DOWN:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_down(controller, action);                }                return;            case SDLK_UP:                if (control && cmd && !shift) {                    // forward repeated events                    action_volume_up(controller, action);                }                return;            case SDLK_c:                if (control && cmd && !shift && !repeat && down) {                    request_device_clipboard(controller);                }                return;            case SDLK_v:                if (control && cmd && !repeat && down) {                    if (shift) {                        // store the text in the device clipboard                        set_device_clipboard(controller);                    } else {                        // inject the text as input events                        clipboard_paste(controller);                    }                }                return;            case SDLK_f:                if (!shift && cmd && !repeat && down) {                    screen_switch_fullscreen(im->screen);                }                return;            case SDLK_x:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_fit(im->screen);                }                return;            case SDLK_g:                if (!shift && cmd && !repeat && down) {                    screen_resize_to_pixel_perfect(im->screen);                }                return;            case SDLK_i:                if (!shift && cmd && !repeat && down) {                    struct fps_counter *fps_counter =                        im->video_buffer->fps_counter;                    switch_fps_counter_state(fps_counter);                }                return;            case SDLK_n:                if (control && cmd && !repeat && down) {                    if (shift) {                        collapse_notification_panel(controller);                    } else {                        expand_notification_panel(controller);                    }                }                return;        }        return;    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_input_key(event, &msg)) {        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject keycode'");        }    }}
input_manager_process_mouse_motion(struct input_manager *im,                                   const SDL_MouseMotionEvent *event) {    if (!event->state) {        // do not send motion events when no button is pressed        return;    }    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    struct control_msg msg;    if (convert_mouse_motion(event, im->screen->frame_size, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject mouse motion event'");        }    }}
is_outside_device_screen(struct input_manager *im, int x, int y){    return x < 0 || x >= im->screen->frame_size.width ||           y < 0 || y >= im->screen->frame_size.height;}
input_manager_process_mouse_motion(struct input_manager *im,                                   const SDL_MouseMotionEvent *event) {    if (!event->state) {        // do not send motion events when no button is pressed        return;    }    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    struct control_msg msg;    if (convert_mouse_motion(event, im->screen->frame_size, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject mouse motion event'");        }    }}
input_manager_process_mouse_wheel(struct input_manager *im,                                  const SDL_MouseWheelEvent *event) {    struct position position = {        .screen_size = im->screen->frame_size,        .point = get_mouse_point(im->screen),    };    struct control_msg msg;    if (convert_mouse_wheel(event, position, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject mouse wheel event'");        }    }}
input_manager_process_mouse_wheel(struct input_manager *im,                                  const SDL_MouseWheelEvent *event) {    struct position position = {        .screen_size = im->screen->frame_size,        .point = get_mouse_point(im->screen),    };    struct control_msg msg;    if (convert_mouse_wheel(event, position, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject mouse wheel event'");        }    }}
input_manager_process_touch(struct input_manager *im,                            const SDL_TouchFingerEvent *event) {    struct control_msg msg;    if (convert_touch(event, im->screen->frame_size, &msg)) {        if (!controller_push_msg(im->controller, &msg)) {            LOGW("Could not request 'inject touch event'");        }    }}

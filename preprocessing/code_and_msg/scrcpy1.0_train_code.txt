    private static IBinder createDisplay() {        return SurfaceControl.createDisplay("scrcpy", false);    }
    private static IBinder createDisplay() {        return SurfaceControl.createDisplay("scrcpy", true);    }
static int read_packet(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    uint8_t header[HEADER_SIZE];    int remaining;    int ret;    remaining = decoder->remaining;    if (remaining == 0) {        // FIXME what if only part of the header is available?        ret = net_recv(decoder->video_socket, header, HEADER_SIZE);        if (ret <= 0)            return ret;        decoder->pts = from_be(header, 8);        remaining = from_be(header + 12, 4);    }    if (buf_size > remaining)        buf_size = remaining;    ret = net_recv(decoder->video_socket, buf, buf_size);    if (ret <= 0)        return ret;    remaining -= ret;    decoder->remaining = remaining;    return ret;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {        if (decoder->recorder) {            packet.pts = decoder->pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(decoder->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto run_quit;            }        }// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static int read_packet(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    uint8_t header[HEADER_SIZE];    int remaining;    int ret;    remaining = decoder->remaining;    if (remaining == 0) {        // FIXME what if only part of the header is available?        ret = net_recv(decoder->video_socket, header, HEADER_SIZE);        if (ret <= 0)            return ret;        decoder->pts = from_be(header, 8);        decoder->buffer_info_flags = from_be(header + 8, 4);        remaining = from_be(header + 12, 4);    }    if (buf_size > remaining)        buf_size = remaining;    ret = net_recv(decoder->video_socket, buf, buf_size);    if (ret <= 0)        return ret;    remaining -= ret;    decoder->remaining = remaining;    return ret;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {        if (decoder->recorder) {            // do not record configuration packets            // (they contain no media data and have no PTS/DTS)            // FIXME do not use MediaCodec specific flags            if (!(decoder->buffer_info_flags & MEDIA_CODEC_FLAG_CONFIG)) {                packet.pts = decoder->pts;                packet.dts = decoder->pts;                // no need to rescale with av_packet_rescale_ts(), the timestamps                // are in microseconds both in input and output                if (!recorder_write(decoder->recorder, &packet)) {                    LOGE("Could not write frame to output file");                    av_packet_unref(&packet);                    goto run_quit;                }            }        }// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
    private boolean encode(MediaCodec codec, FileDescriptor fd) throws IOException {        boolean eof = false;        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();        ByteBuffer bBuffer = ByteBuffer.allocate(16);        while (!consumeRotationChange() && !eof) {            int outputBufferId = codec.dequeueOutputBuffer(bufferInfo, -1);            eof = (bufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;            try {                if (consumeRotationChange()) {                    // must restart encoding with new size                    break;                }                if (outputBufferId >= 0) {                    ByteBuffer codecBuffer = codec.getOutputBuffer(outputBufferId);                    bBuffer.position(0);                    bBuffer.putLong(bufferInfo.presentationTimeUs);                    bBuffer.putInt(bufferInfo.flags);                    bBuffer.putInt(codecBuffer.remaining());                    bBuffer.position(0);                    IO.writeFully(fd, bBuffer);                    IO.writeFully(fd, codecBuffer);                }            } finally {                if (outputBufferId >= 0) {                    codec.releaseOutputBuffer(outputBufferId, false);                }            }        }        return !eof;    }
    private boolean encode(MediaCodec codec, FileDescriptor fd) throws IOException {        boolean eof = false;        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();        ByteBuffer bBuffer = ByteBuffer.allocate(16);        while (!consumeRotationChange() && !eof) {            int outputBufferId = codec.dequeueOutputBuffer(bufferInfo, -1);            eof = (bufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;            try {                if (consumeRotationChange()) {                    // must restart encoding with new size                    break;                }                if (outputBufferId >= 0) {                    ByteBuffer codecBuffer = codec.getOutputBuffer(outputBufferId);                    bBuffer.clear();                    long pts;                    if ((bufferInfo.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {                        pts = 0; // non-media data packet                    } else {                        if (ptsOrigin == 0) {                            ptsOrigin = bufferInfo.presentationTimeUs;                        }                        pts = bufferInfo.presentationTimeUs - ptsOrigin;                    }                    bBuffer.putLong(pts);                    bBuffer.putInt(bufferInfo.flags);                    bBuffer.putInt(codecBuffer.remaining());                    bBuffer.flip();                    IO.writeFully(fd, bBuffer);                    IO.writeFully(fd, codecBuffer);                }            } finally {                if (outputBufferId >= 0) {                    codec.releaseOutputBuffer(outputBufferId, false);                }            }        }        return !eof;    }
SDL_bool recorder_open(struct recorder *recorder, AVCodec *input_codec) {    const AVOutputFormat *mp4 = find_mp4_muxer();    if (!mp4) {        LOGE("Could not find mp4 muxer");        return SDL_FALSE;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return SDL_FALSE;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) mp4;    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;    ostream->time_base = (AVRational) {1, 1000000}; // timestamps in us    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    ret = avformat_write_header(recorder->ctx, NULL);    if (ret < 0) {        LOGE("Failed to write header to %s", recorder->filename);        avio_closep(&recorder->ctx->pb);        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    return SDL_TRUE;}
SDL_bool recorder_open(struct recorder *recorder, AVCodec *input_codec) {    const AVOutputFormat *mp4 = find_mp4_muxer();    if (!mp4) {        LOGE("Could not find mp4 muxer");        return SDL_FALSE;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return SDL_FALSE;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) mp4;    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }// In ffmpeg/doc/APIchanges:// 2016-04-11 - 6f69f7a / 9200514 - lavf 57.33.100 / 57.5.0 - avformat.h//   Add AVStream.codecpar, deprecate AVStream.codec.#if    (LIBAVFORMAT_VERSION_MICRO >= 100 /* FFmpeg */ && \        LIBAVFORMAT_VERSION_INT >= AV_VERSION_INT(57, 33, 100)) \    || (LIBAVFORMAT_VERSION_MICRO < 100 && /* Libav */ \        LIBAVFORMAT_VERSION_INT >= AV_VERSION_INT(57, 5, 0))    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    ostream->time_base = (AVRational) {1, 1000000}; // timestamps in us    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    ret = avformat_write_header(recorder->ctx, NULL);    if (ret < 0) {        LOGE("Failed to write header to %s", recorder->filename);        avio_closep(&recorder->ctx->pb);        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    return SDL_TRUE;}
sdl_init_and_configure(bool display) {    uint32_t flags = display ? SDL_INIT_VIDEO : SDL_INIT_EVENTS;    if (SDL_Init(flags)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return false;    }    atexit(SDL_Quit);    if (!display) {        return true;    }    // Use the best available scale quality    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "2")) {        LOGW("Could not enable bilinear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return true;}
sdl_init_and_configure(bool display) {    uint32_t flags = display ? SDL_INIT_VIDEO : SDL_INIT_EVENTS;    if (SDL_Init(flags)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return false;    }    atexit(SDL_Quit);    if (!display) {        return true;    }    // Use the best available scale quality    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "2")) {        LOGW("Could not enable bilinear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif#ifdef SCRCPY_SDL_HAS_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR    // Disable compositor bypassing on X11    if (!SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, "0")) {        LOGW("Could not disable X11 compositor bypass");    }#endif    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return true;}
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        switch (keycode) {            case SDLK_f:                handle_shortcut('f');                return;            case SDLK_x:                handle_shortcut('x');                return;            case SDLK_g:                handle_shortcut('g');                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                handle_shortcut('b');                return;            case SDLK_m:                handle_shortcut('m');                return;            case SDLK_p:                handle_shortcut('p');                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        switch (keycode) {            case SDLK_f:                handle_shortcut('f');                return;            case SDLK_x:                handle_shortcut('x');                return;            case SDLK_g:                handle_shortcut('g');                return;            case SDLK_h:                handle_shortcut('h');                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                handle_shortcut('b');                return;            case SDLK_m:                handle_shortcut('m');                return;            case SDLK_p:                handle_shortcut('p');                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
file_handler_init(struct file_handler *file_handler, const char *serial) {    cbuf_init(&file_handler->queue);    if (!(file_handler->mutex = SDL_CreateMutex())) {        return false;    }    if (!(file_handler->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(file_handler->mutex);        return false;    }    if (serial) {        file_handler->serial = SDL_strdup(serial);        if (!file_handler->serial) {            LOGW("Could not strdup serial");            SDL_DestroyCond(file_handler->event_cond);            SDL_DestroyMutex(file_handler->mutex);            return false;        }    } else {        file_handler->serial = NULL;    }    // lazy initialization    file_handler->initialized = false;    file_handler->stopped = false;    file_handler->current_process = PROCESS_NONE;    return true;}
file_handler_init(struct file_handler *file_handler, const char *serial) {    cbuf_init(&file_handler->queue);    if (!(file_handler->mutex = SDL_CreateMutex())) {        return false;    }    if (!(file_handler->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(file_handler->mutex);        return false;    }    if (serial) {        file_handler->serial = SDL_strdup(serial);        if (!file_handler->serial) {            LOGW("Could not strdup serial");            SDL_DestroyCond(file_handler->event_cond);            SDL_DestroyMutex(file_handler->mutex);            return false;        }    } else {        file_handler->serial = NULL;    }    // lazy initialization    file_handler->initialized = false;    file_handler->stopped = false;    file_handler->current_process = PROCESS_NONE;    return true;}
push_file(const char *serial, const char *file) {    return adb_push(serial, file, DEVICE_SDCARD_PATH);}
run_file_handler(void *data) {    struct file_handler *file_handler = data;    for (;;) {        mutex_lock(file_handler->mutex);        file_handler->current_process = PROCESS_NONE;        while (!file_handler->stopped && cbuf_is_empty(&file_handler->queue)) {            cond_wait(file_handler->event_cond, file_handler->mutex);        }        if (file_handler->stopped) {            // stop immediately, do not process further events            mutex_unlock(file_handler->mutex);            break;        }        struct file_handler_request req;        bool non_empty = cbuf_take(&file_handler->queue, &req);        SDL_assert(non_empty);        process_t process;        if (req.action == ACTION_INSTALL_APK) {            LOGI("Installing %s...", req.file);            process = install_apk(file_handler->serial, req.file);        } else {            LOGI("Pushing %s...", req.file);            process = push_file(file_handler->serial, req.file);        }        file_handler->current_process = process;        mutex_unlock(file_handler->mutex);        if (req.action == ACTION_INSTALL_APK) {            if (process_check_success(process, "adb install")) {                LOGI("%s successfully installed", req.file);            } else {                LOGE("Failed to install %s", req.file);            }        } else {            if (process_check_success(process, "adb push")) {                LOGI("%s successfully pushed to /sdcard/", req.file);            } else {                LOGE("Failed to push %s to /sdcard/", req.file);            }        }        file_handler_request_destroy(&req);    }    return 0;}
push_file(const char *serial, const char *file) {    return adb_push(serial, file, DEVICE_SDCARD_PATH);}
boolfile_handler_init(struct file_handler *file_handler, const char *serial,                  const char *push_target) {    cbuf_init(&file_handler->queue);    if (!(file_handler->mutex = SDL_CreateMutex())) {        return false;    }    if (!(file_handler->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(file_handler->mutex);        return false;    }    if (serial) {        file_handler->serial = SDL_strdup(serial);        if (!file_handler->serial) {            LOGW("Could not strdup serial");            SDL_DestroyCond(file_handler->event_cond);            SDL_DestroyMutex(file_handler->mutex);            return false;        }    } else {        file_handler->serial = NULL;    }    // lazy initialization    file_handler->initialized = false;    file_handler->stopped = false;    file_handler->current_process = PROCESS_NONE;    file_handler->push_target = push_target ? push_target : DEFAULT_PUSH_TARGET;
file_handler_init(struct file_handler *file_handler, const char *serial,                  const char *push_target) {    cbuf_init(&file_handler->queue);    if (!(file_handler->mutex = SDL_CreateMutex())) {        return false;    }    if (!(file_handler->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(file_handler->mutex);        return false;    }    if (serial) {        file_handler->serial = SDL_strdup(serial);        if (!file_handler->serial) {            LOGW("Could not strdup serial");            SDL_DestroyCond(file_handler->event_cond);            SDL_DestroyMutex(file_handler->mutex);            return false;        }    } else {        file_handler->serial = NULL;    }    // lazy initialization    file_handler->initialized = false;    file_handler->stopped = false;    file_handler->current_process = PROCESS_NONE;    file_handler->push_target = push_target ? push_target : DEFAULT_PUSH_TARGET;    return true;}
    return adb_install(serial, file);}static process_t
run_file_handler(void *data) {    struct file_handler *file_handler = data;    for (;;) {        mutex_lock(file_handler->mutex);        file_handler->current_process = PROCESS_NONE;        while (!file_handler->stopped && cbuf_is_empty(&file_handler->queue)) {            cond_wait(file_handler->event_cond, file_handler->mutex);        }        if (file_handler->stopped) {            // stop immediately, do not process further events            mutex_unlock(file_handler->mutex);            break;        }        struct file_handler_request req;        bool non_empty = cbuf_take(&file_handler->queue, &req);        SDL_assert(non_empty);        process_t process;        if (req.action == ACTION_INSTALL_APK) {            LOGI("Installing %s...", req.file);            process = install_apk(file_handler->serial, req.file);        } else {            LOGI("Pushing %s...", req.file);            process = push_file(file_handler->serial, req.file,                                file_handler->push_target);        }        file_handler->current_process = process;        mutex_unlock(file_handler->mutex);        if (req.action == ACTION_INSTALL_APK) {            if (process_check_success(process, "adb install")) {                LOGI("%s successfully installed", req.file);            } else {                LOGE("Failed to install %s", req.file);            }        } else {            if (process_check_success(process, "adb push")) {                LOGI("%s successfully pushed to %s", req.file,                                                     file_handler->push_target);            } else {                LOGE("Failed to push %s to %s", req.file,                                                file_handler->push_target);            }        }        file_handler_request_destroy(&req);    }    return 0;}
push_file(const char *serial, const char *file, const char *push_target) {    return adb_push(serial, file, push_target);}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .window_title = NULL,        .record_format = 0,        .help = false,        .version = false,        .show_touches = false,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = false,        .no_control = false,        .no_display = false,        .turn_screen_off = false,        .render_expired_frames = false,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .window_title = args.window_title,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,        .control = !args.no_control,        .display = !args.no_display,        .turn_screen_off = args.turn_screen_off,        .render_expired_frames = args.render_expired_frames,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    Ctrl+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+c\n"        "        copy device clipboard to computer\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, 'T'},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, 'c'},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, 'f'},        {"render-expired-frames", no_argument,       NULL,                                                 OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL,                                                 OPT_WINDOW_TITLE},        {NULL,                    0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return false;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = true;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return false;                }                break;            case 'n':                args->no_control = true;                break;            case 'N':                args->no_display = true;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return false;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 'S':                args->turn_screen_off = true;                break;            case 't':                args->show_touches = true;                break;            case 'T':                args->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                args->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                args->window_title = optarg;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (args->no_display && !args->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (args->no_display && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return false;        }    }    if (args->no_control && args->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .window_title = NULL,        .push_target = NULL,        .record_format = 0,        .help = false,        .version = false,        .show_touches = false,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = false,        .no_control = false,        .no_display = false,        .turn_screen_off = false,        .render_expired_frames = false,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .window_title = args.window_title,        .push_target = args.push_target,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,        .control = !args.no_control,        .display = !args.no_display,        .turn_screen_off = args.turn_screen_off,        .render_expired_frames = args.render_expired_frames,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    Ctrl+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+c\n"        "        copy device clipboard to computer\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, 'T'},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, 'c'},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"push-target",           required_argument, NULL,                                                 OPT_PUSH_TARGET},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, 'f'},        {"render-expired-frames", no_argument,       NULL,                                                 OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL,                                                 OPT_WINDOW_TITLE},        {NULL,                    0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return false;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = true;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return false;                }                break;            case 'n':                args->no_control = true;                break;            case 'N':                args->no_display = true;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return false;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 'S':                args->turn_screen_off = true;                break;            case 't':                args->show_touches = true;                break;            case 'T':                args->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                args->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                args->window_title = optarg;                break;            case OPT_PUSH_TARGET:                args->push_target = optarg;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (args->no_display && !args->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (args->no_display && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return false;        }    }    if (args->no_control && args->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .send_frame_meta = record,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .send_frame_meta = record,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
static SDL_bool process_event(struct controller *controller, const struct control_event *event) {    unsigned char serialized_event[SERIALIZED_EVENT_MAX_SIZE];    int length = control_event_serialize(event, serialized_event);    if (!length) {        return SDL_FALSE;    }    int w = net_send(controller->video_socket, serialized_event, length);    return w == length;}
static SDL_bool process_event(struct controller *controller, const struct control_event *event) {    unsigned char serialized_event[SERIALIZED_EVENT_MAX_SIZE];    int length = control_event_serialize(event, serialized_event);    if (!length) {        return SDL_FALSE;    }    int w = net_send_all(controller->video_socket, serialized_event, length);    return w == length;}
SDL_bool device_read_info(socket_t device_socket, char *device_name, struct size *size) {    unsigned char buf[DEVICE_NAME_FIELD_LENGTH + 4];    int r = net_recv(device_socket, buf, sizeof(buf));    if (r < DEVICE_NAME_FIELD_LENGTH + 4) {        LOGE("Could not retrieve device information");        return SDL_FALSE;    }    buf[DEVICE_NAME_FIELD_LENGTH - 1] = '\0'; // in case the client sends garbage    // strcpy is safe here, since name contains at least DEVICE_NAME_FIELD_LENGTH bytes    // and strlen(buf) < DEVICE_NAME_FIELD_LENGTH    strcpy(device_name, (char *) buf);    size->width = (buf[DEVICE_NAME_FIELD_LENGTH] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 1];    size->height = (buf[DEVICE_NAME_FIELD_LENGTH + 2] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 3];    return SDL_TRUE;}
SDL_bool device_read_info(socket_t device_socket, char *device_name, struct size *size) {    unsigned char buf[DEVICE_NAME_FIELD_LENGTH + 4];    int r = net_recv_all(device_socket, buf, sizeof(buf));    if (r < DEVICE_NAME_FIELD_LENGTH + 4) {        LOGE("Could not retrieve device information");        return SDL_FALSE;    }    buf[DEVICE_NAME_FIELD_LENGTH - 1] = '\0'; // in case the client sends garbage    // strcpy is safe here, since name contains at least DEVICE_NAME_FIELD_LENGTH bytes    // and strlen(buf) < DEVICE_NAME_FIELD_LENGTH    strcpy(device_name, (char *) buf);    size->width = (buf[DEVICE_NAME_FIELD_LENGTH] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 1];    size->height = (buf[DEVICE_NAME_FIELD_LENGTH + 2] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 3];    return SDL_TRUE;}
#ifdef __WINDOWS__  typedef int socklen_t;#else# include <sys/types.h># include <sys/socket.h># include <netinet/in.h># include <arpa/inet.h># include <unistd.h># define SOCKET_ERROR -1  typedef struct sockaddr_in SOCKADDR_IN;  typedef struct sockaddr SOCKADDR;  typedef struct in_addr IN_ADDR;#endifsocket_t net_listen(Uint32 addr, Uint16 port, int backlog) {
#ifdef __WINDOWS__  typedef int socklen_t;#else# include <sys/types.h># include <sys/socket.h># include <netinet/in.h># include <arpa/inet.h># include <unistd.h># define SOCKET_ERROR -1  typedef struct sockaddr_in SOCKADDR_IN;  typedef struct sockaddr SOCKADDR;  typedef struct in_addr IN_ADDR;#endifsocket_t net_listen(Uint32 addr, Uint16 port, int backlog) {
ssize_t net_send_all(socket_t socket, void *buf, size_t len) {    ssize_t w;    while (len > 0) {        w = send(socket, buf, len, 0);        if (w == -1) {            return -1;        }        len -= w;        buf += w;    }    return w;}
ssize_t net_recv_all(socket_t socket, void *buf, size_t len) {    return recv(socket, buf, len, MSG_WAITALL);}
show_adb_err_msg(enum process_result err, const char *const argv[]) {    char buf[512];    switch (err) {        case PROCESS_ERROR_GENERIC:            argv_to_string(argv, buf, sizeof(buf));            LOGE("Failed to execute: %s", buf);            break;        case PROCESS_ERROR_MISSING_BINARY:            argv_to_string(argv, buf, sizeof(buf));            LOGE("Command not found: %s", buf);            LOGE("(make 'adb' accessible from your PATH or define its full"                 "path in the ADB environment variable)");            break;        case PROCESS_SUCCESS:            /* do nothing */            break;    }}
show_adb_err_msg(enum process_result err, const char *const argv[]) {    char buf[512];    switch (err) {        case PROCESS_ERROR_GENERIC:            argv_to_string(argv, buf, sizeof(buf));            LOGE("Failed to execute: %s", buf);            break;        case PROCESS_ERROR_MISSING_BINARY:            argv_to_string(argv, buf, sizeof(buf));            LOGE("Command not found: %s", buf);            LOGE("(make 'adb' accessible from your PATH or define its full"                 "path in the ADB environment variable)");            break;        case PROCESS_SUCCESS:            // do nothing            break;    }}
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    SDL_bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    if (alt | meta) {        // no shortcut involves Alt or Meta, and they should not be forwarded        // to the device        return;    }    // capture all Ctrl events    if (ctrl) {        SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        if (shift) {            // currently, there is no shortcut involving SHIFT            return;        }        SDL_Keycode keycode = event->keysym.sym;        int action = event->type == SDL_KEYDOWN ? ACTION_DOWN : ACTION_UP;        SDL_bool repeat = event->repeat;        switch (keycode) {            case SDLK_h:                if (!repeat) {                    action_home(input_manager->controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (!repeat) {                    action_back(input_manager->controller, action);                }                return;            case SDLK_s:                if (!repeat) {                    action_app_switch(input_manager->controller, action);                }                return;            case SDLK_m:                if (!repeat) {                    action_menu(input_manager->controller, action);                }                return;            case SDLK_p:                if (!repeat) {                    action_power(input_manager->controller, action);                }                return;            case SDLK_DOWN:                // forward repeated events                action_volume_down(input_manager->controller, action);                return;            case SDLK_UP:                // forward repeated events                action_volume_up(input_manager->controller, action);                return;            case SDLK_v:                if (!repeat && event->type == SDL_KEYDOWN) {                    clipboard_paste(input_manager->controller);                }                return;            case SDLK_f:                if (!repeat && event->type == SDL_KEYDOWN) {                    screen_switch_fullscreen(input_manager->screen);                }                return;            case SDLK_x:                if (!repeat && event->type == SDL_KEYDOWN) {                    screen_resize_to_fit(input_manager->screen);                }                return;            case SDLK_g:                if (!repeat && event->type == SDL_KEYDOWN) {                    screen_resize_to_pixel_perfect(input_manager->screen);                }                return;            case SDLK_i:                if (!repeat && event->type == SDL_KEYDOWN) {                    switch_fps_counter_state(input_manager->frames);                }                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    SDL_bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    if (alt) {        // no shortcut involves Alt or Meta, and they should not be forwarded        // to the device        return;    }    // capture all Ctrl events    if (ctrl | meta) {        SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        if (shift) {            // currently, there is no shortcut involving SHIFT            return;        }        SDL_Keycode keycode = event->keysym.sym;        int action = event->type == SDL_KEYDOWN ? ACTION_DOWN : ACTION_UP;        SDL_bool repeat = event->repeat;        switch (keycode) {            case SDLK_h:                if (ctrl && !meta && !repeat) {                    action_home(input_manager->controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (ctrl && !meta && !repeat) {                    action_back(input_manager->controller, action);                }                return;            case SDLK_s:                if (ctrl && !meta && !repeat) {                    action_app_switch(input_manager->controller, action);                }                return;            case SDLK_m:                if (ctrl && !meta && !repeat) {                    action_menu(input_manager->controller, action);                }                return;            case SDLK_p:                if (ctrl && !meta && !repeat) {                    action_power(input_manager->controller, action);                }                return;            case SDLK_DOWN:                if (ctrl && !meta) {                    // forward repeated events                    action_volume_down(input_manager->controller, action);                }                return;            case SDLK_UP:                if (ctrl && !meta) {                    // forward repeated events                    action_volume_up(input_manager->controller, action);                }                return;            case SDLK_v:                if (ctrl && !meta && !repeat && event->type == SDL_KEYDOWN) {                    clipboard_paste(input_manager->controller);                }                return;            case SDLK_f:                if (ctrl && !meta && !repeat && event->type == SDL_KEYDOWN) {                    screen_switch_fullscreen(input_manager->screen);                }                return;            case SDLK_x:                if (ctrl && !meta && !repeat && event->type == SDL_KEYDOWN) {                    screen_resize_to_fit(input_manager->screen);                }                return;            case SDLK_g:                if (ctrl && !meta && !repeat && event->type == SDL_KEYDOWN) {                    screen_resize_to_pixel_perfect(input_manager->screen);                }                return;            case SDLK_i:                if (ctrl && !meta && !repeat && event->type == SDL_KEYDOWN) {                    switch_fps_counter_state(input_manager->frames);                }                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
SDL_bool show_screen(const char *serial, Uint16 local_port) {    SDL_bool ret = 0;    const char *server_jar_path = getenv("SCRCPY_SERVER_JAR");    if (!server_jar_path) {        server_jar_path = "scrcpy-server.jar";    }    process_t push_proc = adb_push(serial, server_jar_path, "/data/local/tmp/");    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = adb_reverse(serial, SOCKET_NAME, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = adb_reverse_remove(serial, SOCKET_NAME);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool show_screen(const char *serial, Uint16 local_port) {    SDL_bool ret = 0;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}static void
SDL_bool sdl_init_and_configure(void) {    if (SDL_Init(SDL_INIT_VIDEO)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return SDL_FALSE;    }    atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        LOGW("Could not enable bilinear filtering");    }#if SDL_VERSION_ATLEAST(2, 0, 5)    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif    return SDL_TRUE;}
SDL_bool sdl_init_and_configure(void) {    if (SDL_Init(SDL_INIT_VIDEO)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return SDL_FALSE;    }    atexit(SDL_Quit);    // Use the best available scale quality    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "2")) {        LOGW("Could not enable bilinear filtering");    }#if SDL_VERSION_ATLEAST(2, 0, 5)    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif    return SDL_TRUE;}
mutex_unlock(SDL_mutex *mutex) {    if (SDL_UnlockMutex(mutex)) {        LOGC("Could not unlock mutex");        abort();    }}
cond_signal(SDL_cond *cond) {    if (SDL_CondSignal(cond)) {        LOGC("Could not signal a condition");        abort();    }}
cond_wait_timeout(SDL_cond *cond, SDL_mutex *mutex, uint32_t ms) {    int r = SDL_CondWaitTimeout(cond, mutex, ms);    if (r < 0) {        LOGC("Could not wait on condition with timeout");        abort();    }    return r;}
cond_wait(SDL_cond *cond, SDL_mutex *mutex) {    if (SDL_CondWait(cond, mutex)) {        LOGC("Could not wait on condition");        abort();    }}
mutex_lock(SDL_mutex *mutex) {    if (SDL_LockMutex(mutex)) {        LOGC("Could not lock mutex");        abort();    }}
mutex_unlock(SDL_mutex *mutex) {    int r = SDL_UnlockMutex(mutex);#ifndef NDEBUG    if (r) {        LOGC("Could not unlock mutex: %s", SDL_GetError());        abort();    }#else    (void) r;#endif}
cond_signal(SDL_cond *cond) {    int r = SDL_CondSignal(cond);#ifndef NDEBUG    if (r) {        LOGC("Could not signal a condition: %s", SDL_GetError());        abort();    }#else    (void) r;#endif}
cond_wait_timeout(SDL_cond *cond, SDL_mutex *mutex, uint32_t ms) {    int r = SDL_CondWaitTimeout(cond, mutex, ms);#ifndef NDEBUG    if (r < 0) {        LOGC("Could not wait on condition with timeout: %s", SDL_GetError());        abort();    }#endif    return r;}
cond_wait(SDL_cond *cond, SDL_mutex *mutex) {    int r = SDL_CondWait(cond, mutex);#ifndef NDEBUG    if (r) {        LOGC("Could not wait on condition: %s", SDL_GetError());        abort();    }#else    (void) r;#endif}
mutex_lock(SDL_mutex *mutex) {    int r = SDL_LockMutex(mutex);#ifndef NDEBUG    if (r) {        LOGC("Could not lock mutex: %s", SDL_GetError());        abort();    }#else    (void) r;#endif}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    // SDL initialization replace the signal handler for SIGTERM, so Ctrl+C is    // managed by the event loop. This blocking call blocks the event loop, so    // timeout the connection not to block indefinitely in case of SIGTERM.#define SERVER_CONNECT_TIMEOUT_MS 2000    socket_t device_socket = server_connect_to(&server, SERVER_CONNECT_TIMEOUT_MS);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
socket_t server_connect_to(struct server *server, Uint32 timeout_ms) {    if (!server->tunnel_forward) {        server->device_socket = net_accept(server->server_socket);    } else {        Uint32 attempts = 50;        Uint32 delay = 100; // ms        server->device_socket = connect_to_server(server->local_port, attempts, delay);    }    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    if (!server->tunnel_forward) {        // we don't need the server socket anymore        close_socket(&server->server_socket);    }    // the server is started, we can clean up the jar from the temporary folder    remove_server(server->serial); // ignore failure    server->server_copied_to_device = SDL_FALSE;    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = SDL_FALSE;    return server->device_socket;}
socket_t server_connect_to(struct server *server, Uint32 timeout_ms) {    if (!server->tunnel_forward) {        server->device_socket = net_accept(server->server_socket);    } else {        Uint32 attempts = 50;        Uint32 delay = 100; // ms        server->device_socket = connect_to_server(server->local_port, attempts, delay);    }    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    if (!server->tunnel_forward) {        // we don't need the server socket anymore        close_socket(&server->server_socket);    }    // the server is started, we can clean up the jar from the temporary folder    remove_server(server->serial); // ignore failure    server->server_copied_to_device = SDL_FALSE;    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = SDL_FALSE;    return server->device_socket;}
socket_t server_connect_to(struct server *server) {    if (!server->tunnel_forward) {        server->device_socket = net_accept(server->server_socket);    } else {        Uint32 attempts = 50;        Uint32 delay = 100; // ms        server->device_socket = connect_to_server(server->local_port, attempts, delay);    }    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    if (!server->tunnel_forward) {        // we don't need the server socket anymore        close_socket(&server->server_socket);    }    // the server is started, we can clean up the jar from the temporary folder    remove_server(server->serial); // ignore failure    server->server_copied_to_device = SDL_FALSE;    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = SDL_FALSE;    return server->device_socket;}
socket_t server_connect_to(struct server *server) {    if (!server->tunnel_forward) {        server->device_socket = net_accept(server->server_socket);    } else {        Uint32 attempts = 50;        Uint32 delay = 100; // ms        server->device_socket = connect_to_server(server->local_port, attempts, delay);    }    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    if (!server->tunnel_forward) {        // we don't need the server socket anymore        close_socket(&server->server_socket);    }    // the server is started, we can clean up the jar from the temporary folder    remove_server(server->serial); // ignore failure    server->server_copied_to_device = SDL_FALSE;    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = SDL_FALSE;    return server->device_socket;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    struct recorder *rec = NULL;    if (options->out_filename) {        if (!recorder_init(&recorder, options->out_filename, frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    decoder_init(&decoder, &frames, device_socket, rec);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_recorder:    if (options->out_filename) {        recorder_destroy(&recorder);    }finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    struct recorder *rec = NULL;    if (options->out_filename) {        if (!recorder_init(&recorder, options->out_filename, frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    decoder_init(&decoder, &frames, device_socket, rec);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_recorder:    if (options->out_filename) {        recorder_destroy(&recorder);    }finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .record_format = 0,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = SDL_FALSE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,        .no_window = args.no_window,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .record_format = 0,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = SDL_FALSE,        .no_window = SDL_FALSE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,        .no_window = args.no_window,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = true;    bool display = !options->no_display;    bool control = !options->no_control;    if (!sdl_init_and_configure(display)) {        ret = false;        goto finally_destroy_server;    }    if (!server_connect_to(&server)) {        server_stop(&server);        ret = false;        goto finally_destroy_server;    }    socket_t device_socket = server.device_socket;    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = false;        goto finally_destroy_server;    }    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            server_stop(&server);            ret = false;            goto finally_destroy_server;        }        if (control && !file_handler_init(&file_handler, server.serial)) {            ret = false;            server_stop(&server);            goto finally_destroy_video_buffer;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = false;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        ret = false;        server_stop(&server);        goto finally_destroy_recorder;    }    if (display) {        if (control) {            if (!controller_init(&controller, device_socket)) {                ret = false;                goto finally_stop_stream;            }            if (!controller_start(&controller)) {                ret = false;                goto finally_destroy_controller;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            ret = false;            goto finally_stop_and_join_controller;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(display, control);    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    if (display && control) {        controller_stop(&controller);        controller_join(&controller);    }finally_destroy_controller:    if (display && control) {        controller_destroy(&controller);    }finally_stop_stream:    stream_stop(&stream);    // stop the server before stream_join() to wake up the stream    server_stop(&server);    stream_join(&stream);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    if (display && control) {        file_handler_stop(&file_handler);        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }finally_destroy_video_buffer:    if (display) {        video_buffer_destroy(&video_buffer);    }finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    bool display = !options->no_display;    bool control = !options->no_control;    if (!sdl_init_and_configure(display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    socket_t device_socket = server.device_socket;    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            goto end;        }        video_buffer_initialized = true;        if (control) {            if (!file_handler_init(&file_handler, server.serial)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (display) {        if (control) {            if (!controller_init(&controller, device_socket)) {                goto end;            }            if (!controller_start(&controller)) {                goto end;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(display, control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
static void push_frame(struct decoder *decoder) {    struct frames *frames = decoder->frames;    lock_mutex(frames->mutex);    if (!decoder->skip_frames) {        while (!frames->rendering_frame_consumed) {            SDL_CondWait(frames->rendering_frame_consumed_cond, frames->mutex);        }    } else if (!frames->rendering_frame_consumed) {        SDL_LogInfo(SDL_LOG_CATEGORY_RENDER, "Skip frame");    }    frames_swap(frames);    frames->rendering_frame_consumed = SDL_FALSE;    unlock_mutex(frames->mutex);    static SDL_Event new_frame_event = {        .type = EVENT_NEW_FRAME,    };    SDL_PushEvent(&new_frame_event);}
static void push_frame(struct decoder *decoder) {    struct frames *frames = decoder->frames;    mutex_lock(frames->mutex);    if (!decoder->skip_frames) {        while (!frames->rendering_frame_consumed) {            SDL_CondWait(frames->rendering_frame_consumed_cond, frames->mutex);        }    } else if (!frames->rendering_frame_consumed) {        SDL_LogInfo(SDL_LOG_CATEGORY_RENDER, "Skip frame");    }    frames_swap(frames);    frames->rendering_frame_consumed = SDL_FALSE;    mutex_unlock(frames->mutex);    static SDL_Event new_frame_event = {        .type = EVENT_NEW_FRAME,    };    SDL_PushEvent(&new_frame_event);}
static inline void unlock_mutex(SDL_mutex *mutex) {    if (SDL_UnlockMutex(mutex)) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not unlock mutex");        exit(1);    }}
static inline void unlock_mutex(SDL_mutex *mutex) {    if (SDL_UnlockMutex(mutex)) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not unlock mutex");        exit(1);    }}
static inline void unlock_mutex(SDL_mutex *mutex) {    if (SDL_UnlockMutex(mutex)) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not unlock mutex");        exit(1);    }}
static inline void lock_mutex(SDL_mutex *mutex) {    if (SDL_LockMutex(mutex)) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not lock mutex");        exit(1);    }}
        exit(1);    }}static inline void mutex_unlock(SDL_mutex *mutex) {    if (SDL_UnlockMutex(mutex)) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not unlock mutex");
static inline void mutex_unlock(SDL_mutex *mutex) {    if (SDL_UnlockMutex(mutex)) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not unlock mutex");        exit(1);    }}
static inline void mutex_lock(SDL_mutex *mutex) {    if (SDL_LockMutex(mutex)) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not lock mutex");        exit(1);    }}
#include <stdlib.h>#include <SDL2/SDL_log.h>#include <SDL2/SDL_mutex.h>static inline void mutex_lock(SDL_mutex *mutex) {    if (SDL_LockMutex(mutex)) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not lock mutex");
SDL_bool show_screen(const char *serial, Uint16 local_port) {    SDL_bool ret = 0;    const char *server_jar_path = getenv("SCRCPY_SERVER_JAR");    if (!server_jar_path) {        server_jar_path = "scrcpy-server.jar";    }    process_t push_proc = adb_push(serial, server_jar_path, "/data/local/tmp/");    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = adb_reverse(serial, SOCKET_NAME, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    struct size frame_size;    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the width and height values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    SDL_Window *window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    SDL_Texture *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    long ts = timestamp_ms();    int nbframes = 0;    SDL_bool texture_empty = SDL_TRUE;    SDL_bool fullscreen = SDL_FALSE;    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            goto screen_quit;        case EVENT_NEW_FRAME:            lock_mutex(frames.mutex);            AVFrame *frame = frames.rendering_frame;            frames.rendering_frame_consumed = SDL_TRUE;            if (!decoder.skip_frames) {                SDL_CondSignal(frames.rendering_frame_consumed_cond);            }            struct size current_frame_size = {frame->width, frame->height};            if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {                goto screen_quit;            }            frame_size = current_frame_size;            update_texture(frame, texture);            unlock_mutex(frames.mutex);            texture_empty = SDL_FALSE;            long now = timestamp_ms();            ++nbframes;            if (now - ts > 1000) {                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "%d fps", nbframes);                ts = now;                nbframes = 0;            }            render(renderer, texture);            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_KEYDOWN: {            SDL_bool ctrl = SDL_GetModState() & (KMOD_LCTRL | KMOD_RCTRL);            SDL_bool shift = SDL_GetModState() & (KMOD_LSHIFT | KMOD_RSHIFT);            SDL_bool repeat = event.key.repeat;            switch (event.key.keysym.sym) {            case SDLK_x:                if (!repeat && ctrl && !shift) {                    // Ctrl+x                    struct size optimal_size = get_optimal_window_size(window, frame_size);                    SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                }                break;            case SDLK_f:                if (!repeat && ctrl && !shift) {                    // Ctrl+f                    Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;                    if (!SDL_SetWindowFullscreen(window, new_mode)) {                        fullscreen = !fullscreen;                        render(renderer, texture_empty ? NULL : texture);                    } else {                        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());                    }                }                break;            }            break;        }        }    }screen_quit:    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = adb_reverse_remove(serial, SOCKET_NAME);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool show_screen(const char *serial, Uint16 local_port) {    SDL_bool ret = 0;    const char *server_jar_path = getenv("SCRCPY_SERVER_JAR");    if (!server_jar_path) {        server_jar_path = "scrcpy-server.jar";    }    process_t push_proc = adb_push(serial, server_jar_path, "/data/local/tmp/");    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = adb_reverse(serial, SOCKET_NAME, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    struct size frame_size;    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the width and height values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    SDL_Window *window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    SDL_Texture *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    long ts = timestamp_ms();    int nbframes = 0;    SDL_bool texture_empty = SDL_TRUE;    SDL_bool fullscreen = SDL_FALSE;    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            goto screen_quit;        case EVENT_NEW_FRAME:            mutex_lock(frames.mutex);            AVFrame *frame = frames.rendering_frame;            frames.rendering_frame_consumed = SDL_TRUE;            if (!decoder.skip_frames) {                SDL_CondSignal(frames.rendering_frame_consumed_cond);            }            struct size current_frame_size = {frame->width, frame->height};            if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {                goto screen_quit;            }            frame_size = current_frame_size;            update_texture(frame, texture);            mutex_unlock(frames.mutex);            texture_empty = SDL_FALSE;            long now = timestamp_ms();            ++nbframes;            if (now - ts > 1000) {                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "%d fps", nbframes);                ts = now;                nbframes = 0;            }            render(renderer, texture);            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_KEYDOWN: {            SDL_bool ctrl = SDL_GetModState() & (KMOD_LCTRL | KMOD_RCTRL);            SDL_bool shift = SDL_GetModState() & (KMOD_LSHIFT | KMOD_RSHIFT);            SDL_bool repeat = event.key.repeat;            switch (event.key.keysym.sym) {            case SDLK_x:                if (!repeat && ctrl && !shift) {                    // Ctrl+x                    struct size optimal_size = get_optimal_window_size(window, frame_size);                    SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                }                break;            case SDLK_f:                if (!repeat && ctrl && !shift) {                    // Ctrl+f                    Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;                    if (!SDL_SetWindowFullscreen(window, new_mode)) {                        fullscreen = !fullscreen;                        render(renderer, texture_empty ? NULL : texture);                    } else {                        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());                    }                }                break;            }            break;        }        }    }screen_quit:    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = adb_reverse_remove(serial, SOCKET_NAME);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, 'T'},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, 'c'},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"push-target",           required_argument, NULL, OPT_PUSH_TARGET},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, 'F'},        {"render-expired-frames", no_argument,       NULL,                                                     OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL,                                                     OPT_WINDOW_TITLE},        {NULL,                    0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                opts->crop = optarg;                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port(optarg, &opts->port)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, OPT_CROP},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"push-target",           required_argument, NULL, OPT_PUSH_TARGET},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, OPT_RECORD_FORMAT},        {"render-expired-frames", no_argument,       NULL,                                                     OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL,                                                     OPT_WINDOW_TITLE},        {NULL,                    0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port(optarg, &opts->port)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
server_connect_to(struct server *server) {    if (!server->tunnel_forward) {        server->video_socket = net_accept(server->server_socket);        if (server->video_socket == INVALID_SOCKET) {            return false;        }        server->control_socket = net_accept(server->server_socket);        if (server->control_socket == INVALID_SOCKET) {            // the video_socket will be clean up on destroy            return false;        }        // we don't need the server socket anymore        close_socket(&server->server_socket);    } else {        uint32_t attempts = 100;        uint32_t delay = 100; // ms        server->video_socket =            connect_to_server(server->local_port, attempts, delay);        if (server->video_socket == INVALID_SOCKET) {            return false;        }        // we know that the device is listening, we don't need several attempts        server->control_socket =            net_connect(IPV4_LOCALHOST, server->local_port);        if (server->control_socket == INVALID_SOCKET) {            return false;        }    }    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = false;    return true;}
server_connect_to(struct server *server) {    if (!server->tunnel_forward) {        server->video_socket = net_accept(server->server_socket);        if (server->video_socket == INVALID_SOCKET) {            return false;        }        server->control_socket = net_accept(server->server_socket);        if (server->control_socket == INVALID_SOCKET) {            // the video_socket will be cleaned up on destroy            return false;        }        // we don't need the server socket anymore        close_socket(&server->server_socket);    } else {        uint32_t attempts = 100;        uint32_t delay = 100; // ms        server->video_socket =            connect_to_server(server->local_port, attempts, delay);        if (server->video_socket == INVALID_SOCKET) {            return false;        }        // we know that the device is listening, we don't need several attempts        server->control_socket =            net_connect(IPV4_LOCALHOST, server->local_port);        if (server->control_socket == INVALID_SOCKET) {            return false;        }    }    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = false;    return true;}
process_t adb_execute(const char *serial, const char *const adb_cmd[], int len) {    const char *cmd[len + 4];    int i;    cmd[0] = "adb";    if (serial) {        cmd[1] = "-s";        cmd[2] = serial;        i = 3;    } else {        i = 1;    }    memcpy(&cmd[i], adb_cmd, len * sizeof(const char *));    cmd[len + i] = NULL;    return cmd_execute(cmd[0], cmd);}
process_t adb_execute(const char *serial, const char *const adb_cmd[], int len) {    const char *cmd[len + 4];    int i;    cmd[0] = get_adb_command();    if (serial) {        cmd[1] = "-s";        cmd[2] = serial;        i = 3;    } else {        i = 1;    }    memcpy(&cmd[i], adb_cmd, len * sizeof(const char *));    cmd[len + i] = NULL;    return cmd_execute(cmd[0], cmd);}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = true;    bool display = !options->no_display;    bool control = !options->no_control;    if (!sdl_init_and_configure(display)) {        ret = false;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = false;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = false;        goto finally_destroy_server;    }    input_manager.control = control;    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            server_stop(&server);            ret = false;            goto finally_destroy_server;        }        if (control && !file_handler_init(&file_handler, server.serial)) {            ret = false;            server_stop(&server);            goto finally_destroy_video_buffer;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = false;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        ret = false;        server_stop(&server);        goto finally_destroy_recorder;    }    if (display) {        if (control) {            if (!controller_init(&controller, device_socket)) {                ret = false;                goto finally_stop_stream;            }            if (!controller_start(&controller)) {                ret = false;                goto finally_destroy_controller;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            ret = false;            goto finally_stop_and_join_controller;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(display, control);    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    if (display && control) {        controller_stop(&controller);        controller_join(&controller);    }finally_destroy_controller:    if (display && control) {        controller_destroy(&controller);    }finally_stop_stream:    stream_stop(&stream);    // stop the server before stream_join() to wake up the stream    server_stop(&server);    stream_join(&stream);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    if (display && control) {        file_handler_stop(&file_handler);        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }finally_destroy_video_buffer:    if (display) {        video_buffer_destroy(&video_buffer);    }finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial,                                                     false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
handle_event(SDL_Event *event, bool control) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = true;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return false;            }            break;        case SDL_WINDOWEVENT:            switch (event->window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;            }            break;        case SDL_TEXTINPUT:            if (!control) {                break;            }            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            // some key events do not interact with the device, so process the            // event even if control is disabled            input_manager_process_key(&input_manager, &event->key);            break;        case SDL_MOUSEMOTION:            if (!control) {                break;            }            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            if (!control) {                break;            }            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            // some mouse events do not interact with the device, so process            // the event even if control is disabled            input_manager_process_mouse_button(&input_manager, &event->button);            break;        case SDL_DROPFILE: {            if (!control) {                break;            }            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = true;    bool display = !options->no_display;    bool control = !options->no_control;    if (!sdl_init_and_configure(display)) {        ret = false;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = false;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = false;        goto finally_destroy_server;    }    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            server_stop(&server);            ret = false;            goto finally_destroy_server;        }        if (control && !file_handler_init(&file_handler, server.serial)) {            ret = false;            server_stop(&server);            goto finally_destroy_video_buffer;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = false;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        ret = false;        server_stop(&server);        goto finally_destroy_recorder;    }    if (display) {        if (control) {            if (!controller_init(&controller, device_socket)) {                ret = false;                goto finally_stop_stream;            }            if (!controller_start(&controller)) {                ret = false;                goto finally_destroy_controller;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            ret = false;            goto finally_stop_and_join_controller;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(display, control);    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    if (display && control) {        controller_stop(&controller);        controller_join(&controller);    }finally_destroy_controller:    if (display && control) {        controller_destroy(&controller);    }finally_stop_stream:    stream_stop(&stream);    // stop the server before stream_join() to wake up the stream    server_stop(&server);    stream_join(&stream);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    if (display && control) {        file_handler_stop(&file_handler);        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }finally_destroy_video_buffer:    if (display) {        video_buffer_destroy(&video_buffer);    }finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial,                                                     false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
handle_event(SDL_Event *event, bool control) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = true;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return false;            }            break;        case SDL_WINDOWEVENT:            switch (event->window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;            }            break;        case SDL_TEXTINPUT:            if (!control) {                break;            }            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            // some key events do not interact with the device, so process the            // event even if control is disabled            input_manager_process_key(&input_manager, &event->key, control);            break;        case SDL_MOUSEMOTION:            if (!control) {                break;            }            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            if (!control) {                break;            }            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            // some mouse events do not interact with the device, so process            // the event even if control is disabled            input_manager_process_mouse_button(&input_manager, &event->button,                                               control);            break;        case SDL_DROPFILE: {            if (!control) {                break;            }            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_HOME,         AKEYCODE_MOVE_HOME);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);    }    if (mod & (KMOD_LALT | KMOD_RALT | KMOD_LGUI | KMOD_RGUI)) {        return false;    }    // if ALT and META are not pressed, also handle letters and space    switch (from) {        MAP(SDLK_a,            AKEYCODE_A);        MAP(SDLK_b,            AKEYCODE_B);        MAP(SDLK_c,            AKEYCODE_C);        MAP(SDLK_d,            AKEYCODE_D);        MAP(SDLK_e,            AKEYCODE_E);        MAP(SDLK_f,            AKEYCODE_F);        MAP(SDLK_g,            AKEYCODE_G);        MAP(SDLK_h,            AKEYCODE_H);        MAP(SDLK_i,            AKEYCODE_I);        MAP(SDLK_j,            AKEYCODE_J);        MAP(SDLK_k,            AKEYCODE_K);        MAP(SDLK_l,            AKEYCODE_L);        MAP(SDLK_m,            AKEYCODE_M);        MAP(SDLK_n,            AKEYCODE_N);        MAP(SDLK_o,            AKEYCODE_O);        MAP(SDLK_p,            AKEYCODE_P);        MAP(SDLK_q,            AKEYCODE_Q);        MAP(SDLK_r,            AKEYCODE_R);        MAP(SDLK_s,            AKEYCODE_S);        MAP(SDLK_t,            AKEYCODE_T);
        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_HOME,         AKEYCODE_MOVE_HOME);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);    }    if (mod & (KMOD_LALT | KMOD_RALT | KMOD_LGUI | KMOD_RGUI)) {        return false;    }    // if ALT and META are not pressed, also handle letters and space    switch (from) {        MAP(SDLK_a,            AKEYCODE_A);        MAP(SDLK_b,            AKEYCODE_B);        MAP(SDLK_c,            AKEYCODE_C);        MAP(SDLK_d,            AKEYCODE_D);        MAP(SDLK_e,            AKEYCODE_E);        MAP(SDLK_f,            AKEYCODE_F);        MAP(SDLK_g,            AKEYCODE_G);        MAP(SDLK_h,            AKEYCODE_H);        MAP(SDLK_i,            AKEYCODE_I);        MAP(SDLK_j,            AKEYCODE_J);        MAP(SDLK_k,            AKEYCODE_K);        MAP(SDLK_l,            AKEYCODE_L);        MAP(SDLK_m,            AKEYCODE_M);        MAP(SDLK_n,            AKEYCODE_N);        MAP(SDLK_o,            AKEYCODE_O);        MAP(SDLK_p,            AKEYCODE_P);        MAP(SDLK_q,            AKEYCODE_Q);        MAP(SDLK_r,            AKEYCODE_R);        MAP(SDLK_s,            AKEYCODE_S);        MAP(SDLK_t,            AKEYCODE_T);
convert_touch_action(SDL_EventType from, enum android_motionevent_action *to) {    switch (from) {        MAP(SDL_FINGERMOTION, AMOTION_EVENT_ACTION_MOVE);        MAP(SDL_FINGERDOWN,   AMOTION_EVENT_ACTION_DOWN);        MAP(SDL_FINGERUP,     AMOTION_EVENT_ACTION_UP);        FAIL;    }}
convert_touch(const SDL_TouchFingerEvent *from, struct size screen_size,              struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_touch_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = from->fingerId;    to->inject_touch_event.position.screen_size = screen_size;    // SDL touch event coordinates are normalized in the range [0; 1]    to->inject_touch_event.position.point.x = from->x * screen_size.width;    to->inject_touch_event.position.point.y = from->y * screen_size.height;    to->inject_touch_event.pressure = from->pressure;    return true;}
action_power(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_POWER, actions, "POWER");}static inline voidaction_volume_up(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_VOLUME_UP, actions, "VOLUME_UP");}static inline voidaction_volume_down(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_VOLUME_DOWN, actions, "VOLUME_DOWN");}static inline voidaction_menu(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_MENU, actions, "MENU");}// turn the screen on if it was off, press BACK otherwisestatic voidpress_back_or_turn_screen_on(struct controller *controller) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON;    if (!controller_push_msg(controller, &msg)) {        LOGW("Could not request 'press back or turn screen on'");    }}static voidexpand_notification_panel(struct controller *controller) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL;    if (!controller_push_msg(controller, &msg)) {        LOGW("Could not request 'expand notification panel'");    }}
input_manager_process_touch(struct input_manager *input_manager,                            const SDL_TouchFingerEvent *event) {    struct control_msg msg;    if (convert_touch(event, input_manager->screen->frame_size, &msg)) {        if (!controller_push_msg(input_manager->controller, &msg)) {            LOGW("Could not request 'inject touch event'");        }    }}
handle_event(SDL_Event *event, bool control) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = true;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return EVENT_RESULT_CONTINUE;            }            break;        case SDL_WINDOWEVENT:            switch (event->window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;            }            break;        case SDL_TEXTINPUT:            if (!control) {                break;            }            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            // some key events do not interact with the device, so process the            // event even if control is disabled            input_manager_process_key(&input_manager, &event->key, control);            break;        case SDL_MOUSEMOTION:            if (!control) {                break;            }            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            if (!control) {                break;            }            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            // some mouse events do not interact with the device, so process            // the event even if control is disabled            input_manager_process_mouse_button(&input_manager, &event->button,                                               control);            break;        case SDL_DROPFILE: {            if (!control) {                break;            }            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
handle_event(SDL_Event *event, bool control) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = true;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return EVENT_RESULT_CONTINUE;            }            break;        case SDL_WINDOWEVENT:            switch (event->window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;            }            break;        case SDL_TEXTINPUT:            if (!control) {                break;            }            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            // some key events do not interact with the device, so process the            // event even if control is disabled            input_manager_process_key(&input_manager, &event->key, control);            break;        case SDL_MOUSEMOTION:            if (!control) {                break;            }            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            if (!control) {                break;            }            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            // some mouse events do not interact with the device, so process            // the event even if control is disabled            input_manager_process_mouse_button(&input_manager, &event->button,                                               control);            break;        case SDL_FINGERMOTION:        case SDL_FINGERDOWN:        case SDL_FINGERUP:            input_manager_process_touch(&input_manager, &event->tfinger);            break;        case SDL_DROPFILE: {            if (!control) {                break;            }            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
controller_destroy(struct controller *controller) {    SDL_DestroyCond(controller->event_cond);    SDL_DestroyMutex(controller->mutex);    control_event_queue_destroy(&controller->queue);}
controller_push_event(struct controller *controller,                      const struct control_event *event) {    bool res;    mutex_lock(controller->mutex);    bool was_empty = control_event_queue_is_empty(&controller->queue);    res = control_event_queue_push(&controller->queue, event);    if (was_empty) {        cond_signal(controller->event_cond);    }    mutex_unlock(controller->mutex);    return res;}
run_controller(void *data) {    struct controller *controller = data;    for (;;) {        mutex_lock(controller->mutex);        while (!controller->stopped                && control_event_queue_is_empty(&controller->queue)) {            cond_wait(controller->event_cond, controller->mutex);        }        if (controller->stopped) {            // stop immediately, do not process further events            mutex_unlock(controller->mutex);            break;        }        struct control_event event;        bool non_empty = control_event_queue_take(&controller->queue,                                                      &event);        SDL_assert(non_empty);        mutex_unlock(controller->mutex);        bool ok = process_event(controller, &event);        control_event_destroy(&event);        if (!ok) {            LOGD("Cannot write event to socket");            break;        }    }    return 0;}
controller_init(struct controller *controller, socket_t video_socket) {    if (!control_event_queue_init(&controller->queue)) {        return false;    }    if (!(controller->mutex = SDL_CreateMutex())) {        return false;    }    if (!(controller->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(controller->mutex);        return false;    }    controller->video_socket = video_socket;    controller->stopped = false;    return true;}
controller_destroy(struct controller *controller) {    SDL_DestroyCond(controller->event_cond);    SDL_DestroyMutex(controller->mutex);    struct control_event event;    while (cbuf_take(&controller->queue, &event)) {        control_event_destroy(&event);    }}
controller_push_event(struct controller *controller,                      const struct control_event *event) {    mutex_lock(controller->mutex);    bool was_empty = cbuf_is_empty(&controller->queue);    bool res = cbuf_push(&controller->queue, *event);    if (was_empty) {        cond_signal(controller->event_cond);    }    mutex_unlock(controller->mutex);    return res;}
run_controller(void *data) {    struct controller *controller = data;    for (;;) {        mutex_lock(controller->mutex);        while (!controller->stopped && cbuf_is_empty(&controller->queue)) {            cond_wait(controller->event_cond, controller->mutex);        }        if (controller->stopped) {            // stop immediately, do not process further events            mutex_unlock(controller->mutex);            break;        }        struct control_event event;        bool non_empty = cbuf_take(&controller->queue, &event);        SDL_assert(non_empty);        mutex_unlock(controller->mutex);        bool ok = process_event(controller, &event);        control_event_destroy(&event);        if (!ok) {            LOGD("Cannot write event to socket");            break;        }    }    return 0;}
controller_init(struct controller *controller, socket_t video_socket) {    cbuf_init(&controller->queue);    if (!(controller->mutex = SDL_CreateMutex())) {        return false;    }    if (!(controller->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(controller->mutex);        return false;    }    controller->video_socket = video_socket;    controller->stopped = false;    return true;}
    private ControlEvent parseTextControlEvent() {        if (buffer.remaining() < 2) {            return null;        }        int len = toUnsigned(buffer.getShort());        if (buffer.remaining() < len) {            return null;        }        buffer.get(textBuffer, 0, len);        String text = new String(textBuffer, 0, len, StandardCharsets.UTF_8);        return ControlEvent.createTextControlEvent(text);    }
    private ControlEvent parseTextControlEvent() {        if (buffer.remaining() < 2) {            return null;        }        int len = toUnsigned(buffer.getShort());        if (buffer.remaining() < len) {            return null;        }        buffer.get(textBuffer, 0, len);        String text = new String(textBuffer, 0, len, StandardCharsets.UTF_8);        return ControlEvent.createTextControlEvent(text);    }
    private ControlEvent parseTextControlEvent() {        String text = parseString();        if (text == null) {            return null;        }        return ControlEvent.createTextControlEvent(text);    }
    private String parseString() {        if (buffer.remaining() < 2) {            return null;        }        int len = toUnsigned(buffer.getShort());        if (buffer.remaining() < len) {            return null;        }        buffer.get(textBuffer, 0, len);        return new String(textBuffer, 0, len, StandardCharsets.UTF_8);    }
net_listen(uint32_t addr, uint16_t port, int backlog) {    socket_t sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        perror("socket");        return INVALID_SOCKET;    }    int reuse = 1;    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (const void *) &reuse,                   sizeof(reuse)) == -1) {        perror("setsockopt(SO_REUSEADDR)");    }    SOCKADDR_IN sin;    sin.sin_family = AF_INET;    sin.sin_addr.s_addr = htonl(addr); // htonl() harmless on INADDR_ANY    sin.sin_port = htons(port);    if (bind(sock, (SOCKADDR *) &sin, sizeof(sin)) == SOCKET_ERROR) {        perror("bind");        close(sock);        return INVALID_SOCKET;    }    if (listen(sock, backlog) == SOCKET_ERROR) {        perror("listen");        close(sock);        return INVALID_SOCKET;    }    return sock;}
net_connect(uint32_t addr, uint16_t port) {    socket_t sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        perror("socket");        return INVALID_SOCKET;    }    SOCKADDR_IN sin;    sin.sin_family = AF_INET;    sin.sin_addr.s_addr = htonl(addr);    sin.sin_port = htons(port);    if (connect(sock, (SOCKADDR *) &sin, sizeof(sin)) == SOCKET_ERROR) {        perror("connect");        close(sock);        return INVALID_SOCKET;    }    return sock;}
net_listen(uint32_t addr, uint16_t port, int backlog) {    socket_t sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        perror("socket");        return INVALID_SOCKET;    }    int reuse = 1;    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (const void *) &reuse,                   sizeof(reuse)) == -1) {        perror("setsockopt(SO_REUSEADDR)");    }    SOCKADDR_IN sin;    sin.sin_family = AF_INET;    sin.sin_addr.s_addr = htonl(addr); // htonl() harmless on INADDR_ANY    sin.sin_port = htons(port);    if (bind(sock, (SOCKADDR *) &sin, sizeof(sin)) == SOCKET_ERROR) {        perror("bind");        net_close(sock);        return INVALID_SOCKET;    }    if (listen(sock, backlog) == SOCKET_ERROR) {        perror("listen");        net_close(sock);        return INVALID_SOCKET;    }    return sock;}
net_connect(uint32_t addr, uint16_t port) {    socket_t sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        perror("socket");        return INVALID_SOCKET;    }    SOCKADDR_IN sin;    sin.sin_family = AF_INET;    sin.sin_addr.s_addr = htonl(addr);    sin.sin_port = htons(port);    if (connect(sock, (SOCKADDR *) &sin, sizeof(sin)) == SOCKET_ERROR) {        perror("connect");        net_close(sock);        return INVALID_SOCKET;    }    return sock;}
                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;
    private void initPointer() {        MotionEvent.PointerProperties props = pointerProperties[0];        props.id = 0;        props.toolType = MotionEvent.TOOL_TYPE_FINGER;        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.orientation = 0;        coords.pressure = 1;        coords.size = 1;    }
    private void setPointerCoords(Point point) {        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.x = point.getX();        coords.y = point.getY();    }
    private boolean injectKeycode(int keyCode) {        return injectKeyEvent(KeyEvent.ACTION_DOWN, keyCode, 0, 0)                && injectKeyEvent(KeyEvent.ACTION_UP, keyCode, 0, 0);    }
    private boolean injectScroll(Position position, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        setPointerCoords(point);        setScroll(hScroll, vScroll);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, MotionEvent.ACTION_SCROLL, 1, pointerProperties, pointerCoords, 0, 0, 1f, 1f, 0,                0, InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
    private boolean injectKeyEvent(int action, int keyCode, int repeat, int metaState) {        long now = SystemClock.uptimeMillis();        KeyEvent event = new KeyEvent(now, now, action, keyCode, repeat, metaState, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, 0,                InputDevice.SOURCE_KEYBOARD);        return injectEvent(event);    }
    private boolean injectKeyEvent(int action, int keyCode, int repeat, int metaState) {        long now = SystemClock.uptimeMillis();        KeyEvent event = new KeyEvent(now, now, action, keyCode, repeat, metaState, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, 0,                InputDevice.SOURCE_KEYBOARD);        return injectEvent(event);    }
    public Controller(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;        initPointer();        sender = new DeviceMessageSender(connection);    }
    private void setScroll(int hScroll, int vScroll) {        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.setAxisValue(MotionEvent.AXIS_HSCROLL, hScroll);        coords.setAxisValue(MotionEvent.AXIS_VSCROLL, vScroll);    }
    private boolean injectMouse(int action, int buttons, Position position) {        long now = SystemClock.uptimeMillis();        if (action == MotionEvent.ACTION_DOWN) {            lastMouseDown = now;        }        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        setPointerCoords(point);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, action, 1, pointerProperties, pointerCoords, 0, buttons, 1f, 1f, 0, 0,                InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
    private void initMousePointer() {        MotionEvent.PointerProperties props = mousePointerProperties[0];        props.id = 0;        props.toolType = MotionEvent.TOOL_TYPE_FINGER;        MotionEvent.PointerCoords coords = mousePointerCoords[0];        coords.orientation = 0;        coords.pressure = 1;        coords.size = 1;    }
    private void initMousePointer() {        MotionEvent.PointerProperties props = mousePointerProperties[0];        props.id = 0;        props.toolType = MotionEvent.TOOL_TYPE_FINGER;        MotionEvent.PointerCoords coords = mousePointerCoords[0];        coords.orientation = 0;        coords.pressure = 1;        coords.size = 1;    }
    private void setMousePointerCoords(Point point) {        MotionEvent.PointerCoords coords = mousePointerCoords[0];        coords.x = point.getX();        coords.y = point.getY();    }
    private boolean injectKeycode(int keyCode) {        return injectKeyEvent(KeyEvent.ACTION_DOWN, keyCode, 0, 0) && injectKeyEvent(KeyEvent.ACTION_UP, keyCode, 0, 0);    }
    private boolean injectScroll(Position position, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        setMousePointerCoords(point);        setScroll(hScroll, vScroll);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, MotionEvent.ACTION_SCROLL, 1,                mousePointerProperties, mousePointerCoords, 0, 0, 1f, 1f, 0, 0, InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
    private boolean injectKeyEvent(int action, int keyCode, int repeat, int metaState) {        long now = SystemClock.uptimeMillis();        KeyEvent event = new KeyEvent(now, now, action, keyCode, repeat, metaState, KeyCharacterMap.VIRTUAL_KEYBOARD,                0, 0, InputDevice.SOURCE_KEYBOARD);        return injectEvent(event);    }
    private void setMousePointerCoords(Point point) {        MotionEvent.PointerCoords coords = mousePointerCoords[0];        coords.x = point.getX();        coords.y = point.getY();    }
    public Controller(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;        initMousePointer();        sender = new DeviceMessageSender(connection);    }
    private void setScroll(int hScroll, int vScroll) {        MotionEvent.PointerCoords coords = mousePointerCoords[0];        coords.setAxisValue(MotionEvent.AXIS_HSCROLL, hScroll);        coords.setAxisValue(MotionEvent.AXIS_VSCROLL, vScroll);    }
    private boolean injectMouse(int action, int buttons, Position position) {        long now = SystemClock.uptimeMillis();        if (action == MotionEvent.ACTION_DOWN) {            lastMouseDown = now;        }        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        setMousePointerCoords(point);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, action, 1, mousePointerProperties,                mousePointerCoords, 0, buttons, 1f, 1f, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
static void test_serialize_mouse_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_MOUSE,        .mouse_event = {            .action = AMOTION_EVENT_ACTION_DOWN,            .buttons = AMOTION_EVENT_BUTTON_PRIMARY,            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 14);    const unsigned char expected[] = {        0x02, // CONTROL_EVENT_TYPE_MOUSE        0x00, // AKEY_EVENT_ACTION_DOWN        0x00, 0x00, 0x00, 0x01, // AMOTION_EVENT_BUTTON_PRIMARY        0x01, 0x04, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_scroll_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_SCROLL,        .scroll_event = {            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },            .hscroll = 1,            .vscroll = -1,        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 17);    const unsigned char expected[] = {        0x03, // CONTROL_EVENT_TYPE_SCROLL        0x01, 0x04, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920        0x00, 0x00, 0x00, 0x01, // 1        0xFF, 0xFF, 0xFF, 0xFF, // -1    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_mouse_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_MOUSE,        .mouse_event = {            .action = AMOTION_EVENT_ACTION_DOWN,            .buttons = AMOTION_EVENT_BUTTON_PRIMARY,            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 18);    const unsigned char expected[] = {        0x02, // CONTROL_EVENT_TYPE_MOUSE        0x00, // AKEY_EVENT_ACTION_DOWN        0x00, 0x00, 0x00, 0x01, // AMOTION_EVENT_BUTTON_PRIMARY        0x00, 0x00, 0x01, 0x04, 0x00, 0x00, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_scroll_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_SCROLL,        .scroll_event = {            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },            .hscroll = 1,            .vscroll = -1,        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 21);    const unsigned char expected[] = {        0x03, // CONTROL_EVENT_TYPE_SCROLL        0x00, 0x00, 0x01, 0x04, 0x00, 0x00, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920        0x00, 0x00, 0x00, 0x01, // 1        0xFF, 0xFF, 0xFF, 0xFF, // -1    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void print_version(void) {    fprintf(stderr, "scrcpy v%s\n\n", SCRCPY_VERSION);    fprintf(stderr, "dependencies:\n");    fprintf(stderr, " - SDL %d.%d.%d\n", SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL);    fprintf(stderr, " - libavcodec %d.%d.%d\n", LIBAVCODEC_VERSION_MAJOR, LIBAVCODEC_VERSION_MINOR, LIBAVCODEC_VERSION_MICRO);    fprintf(stderr, " - libavformat %d.%d.%d\n", LIBAVFORMAT_VERSION_MAJOR, LIBAVFORMAT_VERSION_MINOR, LIBAVFORMAT_VERSION_MICRO);    fprintf(stderr, " - libavutil %d.%d.%d\n", LIBAVUTIL_VERSION_MAJOR, LIBAVUTIL_VERSION_MINOR, LIBAVUTIL_VERSION_MICRO);}
static void print_version(void) {    fprintf(stderr, "scrcpy %s\n\n", SCRCPY_VERSION);    fprintf(stderr, "dependencies:\n");    fprintf(stderr, " - SDL %d.%d.%d\n", SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL);    fprintf(stderr, " - libavcodec %d.%d.%d\n", LIBAVCODEC_VERSION_MAJOR, LIBAVCODEC_VERSION_MINOR, LIBAVCODEC_VERSION_MICRO);    fprintf(stderr, " - libavformat %d.%d.%d\n", LIBAVFORMAT_VERSION_MAJOR, LIBAVFORMAT_VERSION_MINOR, LIBAVFORMAT_VERSION_MICRO);    fprintf(stderr, " - libavutil %d.%d.%d\n", LIBAVUTIL_VERSION_MAJOR, LIBAVUTIL_VERSION_MINOR, LIBAVUTIL_VERSION_MICRO);}
recorder_close(struct recorder *recorder) {    int ret = av_write_trailer(recorder->ctx);    if (ret < 0) {        LOGE("Failed to write trailer to %s", recorder->filename);    }    avio_close(recorder->ctx->pb);    avformat_free_context(recorder->ctx);    const char *format_name = recorder_get_format_name(recorder->format);    LOGI("Recording complete to %s file: %s", format_name, recorder->filename);}
recorder_close(struct recorder *recorder) {    int ret = av_write_trailer(recorder->ctx);    if (ret < 0) {        LOGE("Failed to write trailer to %s", recorder->filename);        recorder->failed = true;    }    avio_close(recorder->ctx->pb);    avformat_free_context(recorder->ctx);    if (recorder->failed) {        LOGE("Recording failed to %s", recorder->filename);    } else {        const char *format_name = recorder_get_format_name(recorder->format);        LOGI("Recording complete to %s file: %s", format_name, recorder->filename);    }}
Uint64 buffer_read64be(Uint8 *buf) {    Uint32 msb = buffer_read32be(buf);    Uint32 lsb = buffer_read32be(&buf[4]);    return ((Uint64) msb << 32) | lsb;}
buffer_write32be(Uint8 *buf, Uint32 value) {    buf[0] = value >> 24;    buf[1] = value >> 16;    buf[2] = value >> 8;    buf[3] = value;}
Uint64 buffer_read64be(Uint8 *buf) {    Uint32 msb = buffer_read32be(buf);    Uint32 lsb = buffer_read32be(&buf[4]);    return ((Uint64) msb << 32) | lsb;}
buffer_read32be(Uint8 *buf) {    return (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];}
buffer_write32be(Uint8 *buf, Uint32 value) {    buf[0] = value >> 24;    buf[1] = value >> 16;    buf[2] = value >> 8;    buf[3] = value;}
buffer_write16be(Uint8 *buf, Uint16 value) {    buf[0] = value >> 8;    buf[1] = value;}
buffer_write16be(Uint8 *buf, Uint16 value) {    buf[0] = value >> 8;    buf[1] = value;}
buffer_read32be(Uint8 *buf) {    return (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];}
uint64_t buffer_read64be(uint8_t *buf) {    uint32_t msb = buffer_read32be(buf);    uint32_t lsb = buffer_read32be(&buf[4]);    return ((uint64_t) msb << 32) | lsb;}
static inline voidbuffer_write32be(uint8_t *buf, uint32_t value) {    buf[0] = value >> 24;    buf[1] = value >> 16;    buf[2] = value >> 8;    buf[3] = value;}
static inlineuint64_t buffer_read64be(uint8_t *buf) {    uint32_t msb = buffer_read32be(buf);    uint32_t lsb = buffer_read32be(&buf[4]);    return ((uint64_t) msb << 32) | lsb;}
buffer_read32be(uint8_t *buf) {    return (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];}
buffer_write32be(uint8_t *buf, uint32_t value) {    buf[0] = value >> 24;    buf[1] = value >> 16;    buf[2] = value >> 8;    buf[3] = value;}
static inline voidbuffer_write16be(uint8_t *buf, uint16_t value) {    buf[0] = value >> 8;    buf[1] = value;}
buffer_write16be(uint8_t *buf, uint16_t value) {    buf[0] = value >> 8;    buf[1] = value;}
static inline uint32_tbuffer_read32be(uint8_t *buf) {    return (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];}
process_check_success(process_t proc, const char *name) {    if (proc == PROCESS_NONE) {        LOGE("Could not execute \"%s\"", name);        return SDL_FALSE;    }    exit_code_t exit_code;    if (!cmd_simple_wait(proc, &exit_code)) {        if (exit_code != NO_EXIT_CODE) {            LOGE("\"%s\" returned with value %" PRIexitcode, name, exit_code);        } else {            LOGE("\"%s\" exited unexpectedly", name);        }        return SDL_FALSE;    }    return SDL_TRUE;}
process_check_success(process_t proc, const char *name) {    if (proc == PROCESS_NONE) {        LOGE("Could not execute \"%s\"", name);        return false;    }    exit_code_t exit_code;    if (!cmd_simple_wait(proc, &exit_code)) {        if (exit_code != NO_EXIT_CODE) {            LOGE("\"%s\" returned with value %" PRIexitcode, name, exit_code);        } else {            LOGE("\"%s\" exited unexpectedly", name);        }        return false;    }    return true;}
control_event_queue_take(struct control_event_queue *queue,                         struct control_event *event) {    if (control_event_queue_is_empty(queue)) {        return SDL_FALSE;    }    *event = queue->data[queue->tail];    queue->tail = (queue->tail + 1) % CONTROL_EVENT_QUEUE_SIZE;    return SDL_TRUE;}
control_event_queue_init(struct control_event_queue *queue) {    queue->head = 0;    queue->tail = 0;    // the current implementation may not fail    return SDL_TRUE;}
control_event_queue_push(struct control_event_queue *queue,                         const struct control_event *event) {    if (control_event_queue_is_full(queue)) {        return SDL_FALSE;    }    queue->data[queue->head] = *event;    queue->head = (queue->head + 1) % CONTROL_EVENT_QUEUE_SIZE;    return SDL_TRUE;}
write_position(Uint8 *buf, const struct position *position) {    buffer_write32be(&buf[0], position->point.x);    buffer_write32be(&buf[4], position->point.y);    buffer_write16be(&buf[8], position->screen_size.width);    buffer_write16be(&buf[10], position->screen_size.height);}
control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            buffer_write32be(&buf[2], event->keycode_event.keycode);            buffer_write32be(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (2 bytes) + string (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > TEXT_MAX_LENGTH) {                // injecting a text takes time, so limit the text length                len = TEXT_MAX_LENGTH;            }            buffer_write16be(&buf[1], (Uint16) len);            memcpy(&buf[3], event->text_event.text, len);            return 3 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            buffer_write32be(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 18;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            buffer_write32be(&buf[13], (Uint32) event->scroll_event.hscroll);            buffer_write32be(&buf[17], (Uint32) event->scroll_event.vscroll);            return 21;        case CONTROL_EVENT_TYPE_COMMAND:            buf[1] = event->command_event.action;            return 2;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
write_position(Uint8 *buf, const struct position *position) {    buffer_write32be(&buf[0], position->point.x);    buffer_write32be(&buf[4], position->point.y);    buffer_write16be(&buf[8], position->screen_size.width);    buffer_write16be(&buf[10], position->screen_size.height);}
control_event_queue_take(struct control_event_queue *queue,                         struct control_event *event) {    if (control_event_queue_is_empty(queue)) {        return false;    }    *event = queue->data[queue->tail];    queue->tail = (queue->tail + 1) % CONTROL_EVENT_QUEUE_SIZE;    return true;}
control_event_queue_init(struct control_event_queue *queue) {    queue->head = 0;    queue->tail = 0;    // the current implementation may not fail    return true;}
control_event_queue_push(struct control_event_queue *queue,                         const struct control_event *event) {    if (control_event_queue_is_full(queue)) {        return false;    }    queue->data[queue->head] = *event;    queue->head = (queue->head + 1) % CONTROL_EVENT_QUEUE_SIZE;    return true;}
    buffer_write32be(&buf[0], position->point.x);    buffer_write32be(&buf[4], position->point.y);    buffer_write16be(&buf[8], position->screen_size.width);    buffer_write16be(&buf[10], position->screen_size.height);}int
control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            buffer_write32be(&buf[2], event->keycode_event.keycode);            buffer_write32be(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (2 bytes) + string (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > TEXT_MAX_LENGTH) {                // injecting a text takes time, so limit the text length                len = TEXT_MAX_LENGTH;            }            buffer_write16be(&buf[1], (uint16_t) len);            memcpy(&buf[3], event->text_event.text, len);            return 3 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            buffer_write32be(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 18;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            buffer_write32be(&buf[13], (uint32_t) event->scroll_event.hscroll);            buffer_write32be(&buf[17], (uint32_t) event->scroll_event.vscroll);            return 21;        case CONTROL_EVENT_TYPE_COMMAND:            buf[1] = event->command_event.action;            return 2;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
write_position(uint8_t *buf, const struct position *position) {    buffer_write32be(&buf[0], position->point.x);    buffer_write32be(&buf[4], position->point.y);    buffer_write16be(&buf[8], position->screen_size.width);    buffer_write16be(&buf[10], position->screen_size.height);}
controller_stop(struct controller *controller) {    mutex_lock(controller->mutex);    controller->stopped = SDL_TRUE;    cond_signal(controller->event_cond);    mutex_unlock(controller->mutex);}
controller_push_event(struct controller *controller,                      const struct control_event *event) {    SDL_bool res;    mutex_lock(controller->mutex);    SDL_bool was_empty = control_event_queue_is_empty(&controller->queue);    res = control_event_queue_push(&controller->queue, event);    if (was_empty) {        cond_signal(controller->event_cond);    }    mutex_unlock(controller->mutex);    return res;}
run_controller(void *data) {    struct controller *controller = data;    for (;;) {        mutex_lock(controller->mutex);        while (!controller->stopped                && control_event_queue_is_empty(&controller->queue)) {            cond_wait(controller->event_cond, controller->mutex);        }        if (controller->stopped) {            // stop immediately, do not process further events            mutex_unlock(controller->mutex);            break;        }        struct control_event event;        SDL_bool non_empty = control_event_queue_take(&controller->queue,                                                      &event);        SDL_assert(non_empty);        mutex_unlock(controller->mutex);        SDL_bool ok = process_event(controller, &event);        control_event_destroy(&event);        if (!ok) {            LOGD("Cannot write event to socket");            break;        }    }    return 0;}
controller_start(struct controller *controller) {    LOGD("Starting controller thread");    controller->thread = SDL_CreateThread(run_controller, "controller",                                          controller);    if (!controller->thread) {        LOGC("Could not start controller thread");        return SDL_FALSE;    }    return SDL_TRUE;}
process_event(struct controller *controller,              const struct control_event *event) {    unsigned char serialized_event[SERIALIZED_EVENT_MAX_SIZE];    int length = control_event_serialize(event, serialized_event);    if (!length) {        return SDL_FALSE;    }    int w = net_send_all(controller->video_socket, serialized_event, length);    return w == length;}
controller_init(struct controller *controller, socket_t video_socket) {    if (!control_event_queue_init(&controller->queue)) {        return SDL_FALSE;    }    if (!(controller->mutex = SDL_CreateMutex())) {        return SDL_FALSE;    }    if (!(controller->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(controller->mutex);        return SDL_FALSE;    }    controller->video_socket = video_socket;    controller->stopped = SDL_FALSE;    return SDL_TRUE;}
controller_stop(struct controller *controller) {    mutex_lock(controller->mutex);    controller->stopped = true;    cond_signal(controller->event_cond);    mutex_unlock(controller->mutex);}
controller_push_event(struct controller *controller,                      const struct control_event *event) {    bool res;    mutex_lock(controller->mutex);    bool was_empty = control_event_queue_is_empty(&controller->queue);    res = control_event_queue_push(&controller->queue, event);    if (was_empty) {        cond_signal(controller->event_cond);    }    mutex_unlock(controller->mutex);    return res;}
run_controller(void *data) {    struct controller *controller = data;    for (;;) {        mutex_lock(controller->mutex);        while (!controller->stopped                && control_event_queue_is_empty(&controller->queue)) {            cond_wait(controller->event_cond, controller->mutex);        }        if (controller->stopped) {            // stop immediately, do not process further events            mutex_unlock(controller->mutex);            break;        }        struct control_event event;        bool non_empty = control_event_queue_take(&controller->queue,                                                      &event);        SDL_assert(non_empty);        mutex_unlock(controller->mutex);        bool ok = process_event(controller, &event);        control_event_destroy(&event);        if (!ok) {            LOGD("Cannot write event to socket");            break;        }    }    return 0;}
controller_start(struct controller *controller) {    LOGD("Starting controller thread");    controller->thread = SDL_CreateThread(run_controller, "controller",                                          controller);    if (!controller->thread) {        LOGC("Could not start controller thread");        return false;    }    return true;}
process_event(struct controller *controller,              const struct control_event *event) {    unsigned char serialized_event[SERIALIZED_EVENT_MAX_SIZE];    int length = control_event_serialize(event, serialized_event);    if (!length) {        return false;    }    int w = net_send_all(controller->video_socket, serialized_event, length);    return w == length;}
controller_init(struct controller *controller, socket_t video_socket) {    if (!control_event_queue_init(&controller->queue)) {        return false;    }    if (!(controller->mutex = SDL_CreateMutex())) {        return false;    }    if (!(controller->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(controller->mutex);        return false;    }    controller->video_socket = video_socket;    controller->stopped = false;    return true;}
convert_keycode(SDL_Keycode from, enum android_keycode *to, Uint16 mod) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_HOME,         AKEYCODE_HOME);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);    }    if (mod & (KMOD_LALT | KMOD_RALT | KMOD_LGUI | KMOD_RGUI)) {        return SDL_FALSE;    }    // if ALT and META are not pressed, also handle letters and space    switch (from) {        MAP(SDLK_a,            AKEYCODE_A);        MAP(SDLK_b,            AKEYCODE_B);        MAP(SDLK_c,            AKEYCODE_C);        MAP(SDLK_d,            AKEYCODE_D);        MAP(SDLK_e,            AKEYCODE_E);        MAP(SDLK_f,            AKEYCODE_F);        MAP(SDLK_g,            AKEYCODE_G);        MAP(SDLK_h,            AKEYCODE_H);        MAP(SDLK_i,            AKEYCODE_I);        MAP(SDLK_j,            AKEYCODE_J);        MAP(SDLK_k,            AKEYCODE_K);        MAP(SDLK_l,            AKEYCODE_L);        MAP(SDLK_m,            AKEYCODE_M);        MAP(SDLK_n,            AKEYCODE_N);        MAP(SDLK_o,            AKEYCODE_O);        MAP(SDLK_p,            AKEYCODE_P);        MAP(SDLK_q,            AKEYCODE_Q);        MAP(SDLK_r,            AKEYCODE_R);        MAP(SDLK_s,            AKEYCODE_S);        MAP(SDLK_t,            AKEYCODE_T);        MAP(SDLK_u,            AKEYCODE_U);        MAP(SDLK_v,            AKEYCODE_V);        MAP(SDLK_w,            AKEYCODE_W);        MAP(SDLK_x,            AKEYCODE_X);        MAP(SDLK_y,            AKEYCODE_Y);        MAP(SDLK_z,            AKEYCODE_Z);        MAP(SDLK_SPACE,        AKEYCODE_SPACE);        FAIL;    }}
mouse_motion_from_sdl_to_android(const SDL_MouseMotionEvent *from,                                 struct size screen_size,                                 struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    to->mouse_event.action = AMOTION_EVENT_ACTION_MOVE;    to->mouse_event.buttons = convert_mouse_buttons(from->state);    to->mouse_event.position.screen_size = screen_size;    to->mouse_event.position.point.x = from->x;    to->mouse_event.position.point.y = from->y;    return SDL_TRUE;}
mouse_wheel_from_sdl_to_android(const SDL_MouseWheelEvent *from,                                struct position position,                                struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_SCROLL;    to->scroll_event.position = position;    int mul = from->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    // SDL behavior seems inconsistent between horizontal and vertical scrolling    // so reverse the horizontal    // <https://wiki.libsdl.org/SDL_MouseWheelEvent#Remarks>    to->scroll_event.hscroll = -mul * from->x;    to->scroll_event.vscroll = mul * from->y;    return SDL_TRUE;}
convert_keycode(SDL_Keycode from, enum android_keycode *to, Uint16 mod) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_HOME,         AKEYCODE_HOME);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);    }    if (mod & (KMOD_LALT | KMOD_RALT | KMOD_LGUI | KMOD_RGUI)) {        return SDL_FALSE;    }    // if ALT and META are not pressed, also handle letters and space    switch (from) {        MAP(SDLK_a,            AKEYCODE_A);        MAP(SDLK_b,            AKEYCODE_B);        MAP(SDLK_c,            AKEYCODE_C);        MAP(SDLK_d,            AKEYCODE_D);        MAP(SDLK_e,            AKEYCODE_E);        MAP(SDLK_f,            AKEYCODE_F);        MAP(SDLK_g,            AKEYCODE_G);        MAP(SDLK_h,            AKEYCODE_H);        MAP(SDLK_i,            AKEYCODE_I);        MAP(SDLK_j,            AKEYCODE_J);        MAP(SDLK_k,            AKEYCODE_K);        MAP(SDLK_l,            AKEYCODE_L);        MAP(SDLK_m,            AKEYCODE_M);        MAP(SDLK_n,            AKEYCODE_N);        MAP(SDLK_o,            AKEYCODE_O);        MAP(SDLK_p,            AKEYCODE_P);        MAP(SDLK_q,            AKEYCODE_Q);        MAP(SDLK_r,            AKEYCODE_R);        MAP(SDLK_s,            AKEYCODE_S);        MAP(SDLK_t,            AKEYCODE_T);        MAP(SDLK_u,            AKEYCODE_U);        MAP(SDLK_v,            AKEYCODE_V);        MAP(SDLK_w,            AKEYCODE_W);        MAP(SDLK_x,            AKEYCODE_X);        MAP(SDLK_y,            AKEYCODE_Y);        MAP(SDLK_z,            AKEYCODE_Z);        MAP(SDLK_SPACE,        AKEYCODE_SPACE);        FAIL;    }}
convert_mouse_buttons(Uint32 state) {    enum android_motionevent_buttons buttons = 0;    if (state & SDL_BUTTON_LMASK) {        buttons |= AMOTION_EVENT_BUTTON_PRIMARY;    }    if (state & SDL_BUTTON_RMASK) {        buttons |= AMOTION_EVENT_BUTTON_SECONDARY;    }    if (state & SDL_BUTTON_MMASK) {        buttons |= AMOTION_EVENT_BUTTON_TERTIARY;    }    if (state & SDL_BUTTON_X1) {        buttons |= AMOTION_EVENT_BUTTON_BACK;    }    if (state & SDL_BUTTON_X2) {        buttons |= AMOTION_EVENT_BUTTON_FORWARD;    }    return buttons;}
convert_mouse_buttons(Uint32 state) {    enum android_motionevent_buttons buttons = 0;    if (state & SDL_BUTTON_LMASK) {        buttons |= AMOTION_EVENT_BUTTON_PRIMARY;    }    if (state & SDL_BUTTON_RMASK) {        buttons |= AMOTION_EVENT_BUTTON_SECONDARY;    }    if (state & SDL_BUTTON_MMASK) {        buttons |= AMOTION_EVENT_BUTTON_TERTIARY;    }    if (state & SDL_BUTTON_X1) {        buttons |= AMOTION_EVENT_BUTTON_BACK;    }    if (state & SDL_BUTTON_X2) {        buttons |= AMOTION_EVENT_BUTTON_FORWARD;    }    return buttons;}
input_key_from_sdl_to_android(const SDL_KeyboardEvent *from,                              struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_KEYCODE;    if (!convert_keycode_action(from->type, &to->keycode_event.action)) {        return SDL_FALSE;    }    Uint16 mod = from->keysym.mod;    if (!convert_keycode(from->keysym.sym, &to->keycode_event.keycode, mod)) {        return SDL_FALSE;    }    to->keycode_event.metastate = convert_meta_state(mod);    return SDL_TRUE;}
mouse_button_from_sdl_to_android(const SDL_MouseButtonEvent *from,                                 struct size screen_size,                                 struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    if (!convert_mouse_action(from->type, &to->mouse_event.action)) {        return SDL_FALSE;    }    to->mouse_event.buttons = convert_mouse_buttons(SDL_BUTTON(from->button));    to->mouse_event.position.screen_size = screen_size;    to->mouse_event.position.point.x = from->x;    to->mouse_event.position.point.y = from->y;    return SDL_TRUE;}
convert_keycode(SDL_Keycode from, enum android_keycode *to, uint16_t mod) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_HOME,         AKEYCODE_HOME);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);    }    if (mod & (KMOD_LALT | KMOD_RALT | KMOD_LGUI | KMOD_RGUI)) {        return false;    }    // if ALT and META are not pressed, also handle letters and space    switch (from) {        MAP(SDLK_a,            AKEYCODE_A);        MAP(SDLK_b,            AKEYCODE_B);        MAP(SDLK_c,            AKEYCODE_C);        MAP(SDLK_d,            AKEYCODE_D);        MAP(SDLK_e,            AKEYCODE_E);        MAP(SDLK_f,            AKEYCODE_F);        MAP(SDLK_g,            AKEYCODE_G);        MAP(SDLK_h,            AKEYCODE_H);        MAP(SDLK_i,            AKEYCODE_I);        MAP(SDLK_j,            AKEYCODE_J);        MAP(SDLK_k,            AKEYCODE_K);        MAP(SDLK_l,            AKEYCODE_L);        MAP(SDLK_m,            AKEYCODE_M);        MAP(SDLK_n,            AKEYCODE_N);        MAP(SDLK_o,            AKEYCODE_O);        MAP(SDLK_p,            AKEYCODE_P);        MAP(SDLK_q,            AKEYCODE_Q);        MAP(SDLK_r,            AKEYCODE_R);        MAP(SDLK_s,            AKEYCODE_S);        MAP(SDLK_t,            AKEYCODE_T);        MAP(SDLK_u,            AKEYCODE_U);        MAP(SDLK_v,            AKEYCODE_V);        MAP(SDLK_w,            AKEYCODE_W);        MAP(SDLK_x,            AKEYCODE_X);        MAP(SDLK_y,            AKEYCODE_Y);        MAP(SDLK_z,            AKEYCODE_Z);        MAP(SDLK_SPACE,        AKEYCODE_SPACE);        FAIL;    }}
mouse_motion_from_sdl_to_android(const SDL_MouseMotionEvent *from,                                 struct size screen_size,                                 struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    to->mouse_event.action = AMOTION_EVENT_ACTION_MOVE;    to->mouse_event.buttons = convert_mouse_buttons(from->state);    to->mouse_event.position.screen_size = screen_size;    to->mouse_event.position.point.x = from->x;    to->mouse_event.position.point.y = from->y;    return true;}
mouse_wheel_from_sdl_to_android(const SDL_MouseWheelEvent *from,                                struct position position,                                struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_SCROLL;    to->scroll_event.position = position;    int mul = from->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    // SDL behavior seems inconsistent between horizontal and vertical scrolling    // so reverse the horizontal    // <https://wiki.libsdl.org/SDL_MouseWheelEvent#Remarks>    to->scroll_event.hscroll = -mul * from->x;    to->scroll_event.vscroll = mul * from->y;    return true;}
convert_keycode(SDL_Keycode from, enum android_keycode *to, uint16_t mod) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_HOME,         AKEYCODE_HOME);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);    }    if (mod & (KMOD_LALT | KMOD_RALT | KMOD_LGUI | KMOD_RGUI)) {        return false;    }    // if ALT and META are not pressed, also handle letters and space    switch (from) {        MAP(SDLK_a,            AKEYCODE_A);        MAP(SDLK_b,            AKEYCODE_B);        MAP(SDLK_c,            AKEYCODE_C);        MAP(SDLK_d,            AKEYCODE_D);        MAP(SDLK_e,            AKEYCODE_E);        MAP(SDLK_f,            AKEYCODE_F);        MAP(SDLK_g,            AKEYCODE_G);        MAP(SDLK_h,            AKEYCODE_H);        MAP(SDLK_i,            AKEYCODE_I);        MAP(SDLK_j,            AKEYCODE_J);        MAP(SDLK_k,            AKEYCODE_K);        MAP(SDLK_l,            AKEYCODE_L);        MAP(SDLK_m,            AKEYCODE_M);        MAP(SDLK_n,            AKEYCODE_N);        MAP(SDLK_o,            AKEYCODE_O);        MAP(SDLK_p,            AKEYCODE_P);        MAP(SDLK_q,            AKEYCODE_Q);        MAP(SDLK_r,            AKEYCODE_R);        MAP(SDLK_s,            AKEYCODE_S);        MAP(SDLK_t,            AKEYCODE_T);        MAP(SDLK_u,            AKEYCODE_U);        MAP(SDLK_v,            AKEYCODE_V);        MAP(SDLK_w,            AKEYCODE_W);        MAP(SDLK_x,            AKEYCODE_X);        MAP(SDLK_y,            AKEYCODE_Y);        MAP(SDLK_z,            AKEYCODE_Z);        MAP(SDLK_SPACE,        AKEYCODE_SPACE);        FAIL;    }}
convert_mouse_buttons(uint32_t state) {    enum android_motionevent_buttons buttons = 0;    if (state & SDL_BUTTON_LMASK) {        buttons |= AMOTION_EVENT_BUTTON_PRIMARY;    }    if (state & SDL_BUTTON_RMASK) {        buttons |= AMOTION_EVENT_BUTTON_SECONDARY;    }    if (state & SDL_BUTTON_MMASK) {        buttons |= AMOTION_EVENT_BUTTON_TERTIARY;    }    if (state & SDL_BUTTON_X1) {        buttons |= AMOTION_EVENT_BUTTON_BACK;    }    if (state & SDL_BUTTON_X2) {        buttons |= AMOTION_EVENT_BUTTON_FORWARD;    }    return buttons;}
convert_mouse_buttons(uint32_t state) {    enum android_motionevent_buttons buttons = 0;    if (state & SDL_BUTTON_LMASK) {        buttons |= AMOTION_EVENT_BUTTON_PRIMARY;    }    if (state & SDL_BUTTON_RMASK) {        buttons |= AMOTION_EVENT_BUTTON_SECONDARY;    }    if (state & SDL_BUTTON_MMASK) {        buttons |= AMOTION_EVENT_BUTTON_TERTIARY;    }    if (state & SDL_BUTTON_X1) {        buttons |= AMOTION_EVENT_BUTTON_BACK;    }    if (state & SDL_BUTTON_X2) {        buttons |= AMOTION_EVENT_BUTTON_FORWARD;    }    return buttons;}
input_key_from_sdl_to_android(const SDL_KeyboardEvent *from,                              struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_KEYCODE;    if (!convert_keycode_action(from->type, &to->keycode_event.action)) {        return false;    }    uint16_t mod = from->keysym.mod;    if (!convert_keycode(from->keysym.sym, &to->keycode_event.keycode, mod)) {        return false;    }    to->keycode_event.metastate = convert_meta_state(mod);    return true;}
mouse_button_from_sdl_to_android(const SDL_MouseButtonEvent *from,                                 struct size screen_size,                                 struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    if (!convert_mouse_action(from->type, &to->mouse_event.action)) {        return false;    }    to->mouse_event.buttons = convert_mouse_buttons(SDL_BUTTON(from->button));    to->mouse_event.position.screen_size = screen_size;    to->mouse_event.position.point.x = from->x;    to->mouse_event.position.point.y = from->y;    return true;}
decoder_open(struct decoder *decoder, AVCodec *codec) {    decoder->codec_ctx = avcodec_alloc_context3(codec);    if (!decoder->codec_ctx) {        LOGC("Could not allocate decoder context");        return SDL_FALSE;    }    if (avcodec_open2(decoder->codec_ctx, codec, NULL) < 0) {        LOGE("Could not open codec");        avcodec_free_context(&decoder->codec_ctx);        return SDL_FALSE;    }    return SDL_TRUE;}
decoder_push(struct decoder *decoder, AVPacket *packet) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#ifdef SCRCPY_LAVF_HAS_NEW_ENCODING_DECODING_API    int ret;    if ((ret = avcodec_send_packet(decoder->codec_ctx, packet)) < 0) {        LOGE("Could not send video packet: %d", ret);        return SDL_FALSE;    }    ret = avcodec_receive_frame(decoder->codec_ctx,                                decoder->video_buffer->decoding_frame);    if (!ret) {        // a frame was received        push_frame(decoder);    } else if (ret != AVERROR(EAGAIN)) {        LOGE("Could not receive video frame: %d", ret);        return SDL_FALSE;    }#else    int got_picture;    int len = avcodec_decode_video2(decoder->codec_ctx,                                    decoder->video_buffer->decoding_frame,                                    &got_picture,                                    packet);    if (len < 0) {        LOGE("Could not decode video packet: %d", len);        return SDL_FALSE;    }    if (got_picture) {        push_frame(decoder);    }#endif    return SDL_TRUE;}
push_frame(struct decoder *decoder) {    SDL_bool previous_frame_consumed =            video_buffer_offer_decoded_frame(decoder->video_buffer);    if (!previous_frame_consumed) {        // the previous EVENT_NEW_FRAME will consume this frame        return;    }    static SDL_Event new_frame_event = {        .type = EVENT_NEW_FRAME,    };    SDL_PushEvent(&new_frame_event);}
decoder_open(struct decoder *decoder, AVCodec *codec) {    decoder->codec_ctx = avcodec_alloc_context3(codec);    if (!decoder->codec_ctx) {        LOGC("Could not allocate decoder context");        return false;    }    if (avcodec_open2(decoder->codec_ctx, codec, NULL) < 0) {        LOGE("Could not open codec");        avcodec_free_context(&decoder->codec_ctx);        return false;    }    return true;}
decoder_push(struct decoder *decoder, AVPacket *packet) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#ifdef SCRCPY_LAVF_HAS_NEW_ENCODING_DECODING_API    int ret;    if ((ret = avcodec_send_packet(decoder->codec_ctx, packet)) < 0) {        LOGE("Could not send video packet: %d", ret);        return false;    }    ret = avcodec_receive_frame(decoder->codec_ctx,                                decoder->video_buffer->decoding_frame);    if (!ret) {        // a frame was received        push_frame(decoder);    } else if (ret != AVERROR(EAGAIN)) {        LOGE("Could not receive video frame: %d", ret);        return false;    }#else    int got_picture;    int len = avcodec_decode_video2(decoder->codec_ctx,                                    decoder->video_buffer->decoding_frame,                                    &got_picture,                                    packet);    if (len < 0) {        LOGE("Could not decode video packet: %d", len);        return false;    }    if (got_picture) {        push_frame(decoder);    }#endif    return true;}
push_frame(struct decoder *decoder) {    bool previous_frame_consumed =            video_buffer_offer_decoded_frame(decoder->video_buffer);    if (!previous_frame_consumed) {        // the previous EVENT_NEW_FRAME will consume this frame        return;    }    static SDL_Event new_frame_event = {        .type = EVENT_NEW_FRAME,    };    SDL_PushEvent(&new_frame_event);}
device_read_info(socket_t device_socket, char *device_name, struct size *size) {    unsigned char buf[DEVICE_NAME_FIELD_LENGTH + 4];    int r = net_recv_all(device_socket, buf, sizeof(buf));    if (r < DEVICE_NAME_FIELD_LENGTH + 4) {        LOGE("Could not retrieve device information");        return SDL_FALSE;    }    // in case the client sends garbage    buf[DEVICE_NAME_FIELD_LENGTH - 1] = '\0';    // strcpy is safe here, since name contains at least    // DEVICE_NAME_FIELD_LENGTH bytes and strlen(buf) < DEVICE_NAME_FIELD_LENGTH    strcpy(device_name, (char *) buf);    size->width = (buf[DEVICE_NAME_FIELD_LENGTH] << 8)            | buf[DEVICE_NAME_FIELD_LENGTH + 1];    size->height = (buf[DEVICE_NAME_FIELD_LENGTH + 2] << 8)            | buf[DEVICE_NAME_FIELD_LENGTH + 3];    return SDL_TRUE;}
device_read_info(socket_t device_socket, char *device_name, struct size *size) {    unsigned char buf[DEVICE_NAME_FIELD_LENGTH + 4];    int r = net_recv_all(device_socket, buf, sizeof(buf));    if (r < DEVICE_NAME_FIELD_LENGTH + 4) {        LOGE("Could not retrieve device information");        return false;    }    // in case the client sends garbage    buf[DEVICE_NAME_FIELD_LENGTH - 1] = '\0';    // strcpy is safe here, since name contains at least    // DEVICE_NAME_FIELD_LENGTH bytes and strlen(buf) < DEVICE_NAME_FIELD_LENGTH    strcpy(device_name, (char *) buf);    size->width = (buf[DEVICE_NAME_FIELD_LENGTH] << 8)            | buf[DEVICE_NAME_FIELD_LENGTH + 1];    size->height = (buf[DEVICE_NAME_FIELD_LENGTH + 2] << 8)            | buf[DEVICE_NAME_FIELD_LENGTH + 3];    return true;}
file_handler_start(struct file_handler *file_handler) {    LOGD("Starting file_handler thread");    file_handler->thread = SDL_CreateThread(run_file_handler, "file_handler",                                            file_handler);    if (!file_handler->thread) {        LOGC("Could not start file_handler thread");        return SDL_FALSE;    }    return SDL_TRUE;}
file_handler_stop(struct file_handler *file_handler) {    mutex_lock(file_handler->mutex);    file_handler->stopped = SDL_TRUE;    cond_signal(file_handler->event_cond);    if (file_handler->current_process != PROCESS_NONE) {        if (!cmd_terminate(file_handler->current_process)) {            LOGW("Cannot terminate install process");        }        cmd_simple_wait(file_handler->current_process, NULL);        file_handler->current_process = PROCESS_NONE;    }    mutex_unlock(file_handler->mutex);}
request_queue_init(struct request_queue *queue) {    queue->head = 0;    queue->tail = 0;    return SDL_TRUE;}
request_queue_take(struct request_queue *queue, struct request **req) {    if (request_queue_is_empty(queue)) {        return SDL_FALSE;    }    // transfer ownership    *req = queue->reqs[queue->tail];    queue->tail = (queue->tail + 1) % REQUEST_QUEUE_SIZE;    return SDL_TRUE;}
run_file_handler(void *data) {    struct file_handler *file_handler = data;    for (;;) {        mutex_lock(file_handler->mutex);        file_handler->current_process = PROCESS_NONE;        while (!file_handler->stopped                && request_queue_is_empty(&file_handler->queue)) {            cond_wait(file_handler->event_cond, file_handler->mutex);        }        if (file_handler->stopped) {            // stop immediately, do not process further events            mutex_unlock(file_handler->mutex);            break;        }        struct request *req;        SDL_bool non_empty = request_queue_take(&file_handler->queue, &req);        SDL_assert(non_empty);        process_t process;        if (req->action == ACTION_INSTALL_APK) {            LOGI("Installing %s...", req->file);            process = install_apk(file_handler->serial, req->file);        } else {            LOGI("Pushing %s...", req->file);            process = push_file(file_handler->serial, req->file);        }        file_handler->current_process = process;        mutex_unlock(file_handler->mutex);        if (req->action == ACTION_INSTALL_APK) {            if (process_check_success(process, "adb install")) {                LOGI("%s successfully installed", req->file);            } else {                LOGE("Failed to install %s", req->file);            }        } else {            if (process_check_success(process, "adb push")) {                LOGI("%s successfully pushed to /sdcard/", req->file);            } else {                LOGE("Failed to push %s to /sdcard/", req->file);            }        }        request_free(req);    }    return 0;}
file_handler_request(struct file_handler *file_handler,                     file_handler_action_t action,                     const char *file) {    SDL_bool res;    // start file_handler if it's used for the first time    if (!file_handler->initialized) {        if (!file_handler_start(file_handler)) {            return SDL_FALSE;        }        file_handler->initialized = SDL_TRUE;    }    LOGI("Request to %s %s", action == ACTION_INSTALL_APK ? "install" : "push",                             file);    struct request *req = request_new(action, file);    if (!req) {        LOGE("Could not create request");        return SDL_FALSE;    }    mutex_lock(file_handler->mutex);    SDL_bool was_empty = request_queue_is_empty(&file_handler->queue);    res = request_queue_push(&file_handler->queue, req);    if (was_empty) {        cond_signal(file_handler->event_cond);    }    mutex_unlock(file_handler->mutex);    return res;}
file_handler_init(struct file_handler *file_handler, const char *serial) {    if (!request_queue_init(&file_handler->queue)) {        return SDL_FALSE;    }    if (!(file_handler->mutex = SDL_CreateMutex())) {        return SDL_FALSE;    }    if (!(file_handler->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(file_handler->mutex);        return SDL_FALSE;    }    if (serial) {        file_handler->serial = SDL_strdup(serial);        if (!file_handler->serial) {            LOGW("Cannot strdup serial");            SDL_DestroyMutex(file_handler->mutex);            return SDL_FALSE;        }    } else {        file_handler->serial = NULL;    }    // lazy initialization    file_handler->initialized = SDL_FALSE;    file_handler->stopped = SDL_FALSE;    file_handler->current_process = PROCESS_NONE;    return SDL_TRUE;}
request_queue_push(struct request_queue *queue, struct request *req) {    if (request_queue_is_full(queue)) {        return SDL_FALSE;    }    queue->reqs[queue->head] = req;    queue->head = (queue->head + 1) % REQUEST_QUEUE_SIZE;    return SDL_TRUE;}
file_handler_start(struct file_handler *file_handler) {    LOGD("Starting file_handler thread");    file_handler->thread = SDL_CreateThread(run_file_handler, "file_handler",                                            file_handler);    if (!file_handler->thread) {        LOGC("Could not start file_handler thread");        return false;    }    return true;}
file_handler_stop(struct file_handler *file_handler) {    mutex_lock(file_handler->mutex);    file_handler->stopped = true;    cond_signal(file_handler->event_cond);    if (file_handler->current_process != PROCESS_NONE) {        if (!cmd_terminate(file_handler->current_process)) {            LOGW("Cannot terminate install process");        }        cmd_simple_wait(file_handler->current_process, NULL);        file_handler->current_process = PROCESS_NONE;    }    mutex_unlock(file_handler->mutex);}
request_queue_init(struct request_queue *queue) {    queue->head = 0;    queue->tail = 0;    return true;}
request_queue_take(struct request_queue *queue, struct request **req) {    if (request_queue_is_empty(queue)) {        return false;    }    // transfer ownership    *req = queue->reqs[queue->tail];    queue->tail = (queue->tail + 1) % REQUEST_QUEUE_SIZE;    return true;}
run_file_handler(void *data) {    struct file_handler *file_handler = data;    for (;;) {        mutex_lock(file_handler->mutex);        file_handler->current_process = PROCESS_NONE;        while (!file_handler->stopped                && request_queue_is_empty(&file_handler->queue)) {            cond_wait(file_handler->event_cond, file_handler->mutex);        }        if (file_handler->stopped) {            // stop immediately, do not process further events            mutex_unlock(file_handler->mutex);            break;        }        struct request *req;        bool non_empty = request_queue_take(&file_handler->queue, &req);        SDL_assert(non_empty);        process_t process;        if (req->action == ACTION_INSTALL_APK) {            LOGI("Installing %s...", req->file);            process = install_apk(file_handler->serial, req->file);        } else {            LOGI("Pushing %s...", req->file);            process = push_file(file_handler->serial, req->file);        }        file_handler->current_process = process;        mutex_unlock(file_handler->mutex);        if (req->action == ACTION_INSTALL_APK) {            if (process_check_success(process, "adb install")) {                LOGI("%s successfully installed", req->file);            } else {                LOGE("Failed to install %s", req->file);            }        } else {            if (process_check_success(process, "adb push")) {                LOGI("%s successfully pushed to /sdcard/", req->file);            } else {                LOGE("Failed to push %s to /sdcard/", req->file);            }        }        request_free(req);    }    return 0;}
file_handler_request(struct file_handler *file_handler,                     file_handler_action_t action,                     const char *file) {    bool res;    // start file_handler if it's used for the first time    if (!file_handler->initialized) {        if (!file_handler_start(file_handler)) {            return false;        }        file_handler->initialized = true;    }    LOGI("Request to %s %s", action == ACTION_INSTALL_APK ? "install" : "push",                             file);    struct request *req = request_new(action, file);    if (!req) {        LOGE("Could not create request");        return false;    }    mutex_lock(file_handler->mutex);    bool was_empty = request_queue_is_empty(&file_handler->queue);    res = request_queue_push(&file_handler->queue, req);    if (was_empty) {        cond_signal(file_handler->event_cond);    }    mutex_unlock(file_handler->mutex);    return res;}
file_handler_init(struct file_handler *file_handler, const char *serial) {    if (!request_queue_init(&file_handler->queue)) {        return false;    }    if (!(file_handler->mutex = SDL_CreateMutex())) {        return false;    }    if (!(file_handler->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(file_handler->mutex);        return false;    }    if (serial) {        file_handler->serial = SDL_strdup(serial);        if (!file_handler->serial) {            LOGW("Cannot strdup serial");            SDL_DestroyMutex(file_handler->mutex);            return false;        }    } else {        file_handler->serial = NULL;    }    // lazy initialization    file_handler->initialized = false;    file_handler->stopped = false;    file_handler->current_process = PROCESS_NONE;    return true;}
request_queue_push(struct request_queue *queue, struct request *req) {    if (request_queue_is_full(queue)) {        return false;    }    queue->reqs[queue->head] = req;    queue->head = (queue->head + 1) % REQUEST_QUEUE_SIZE;    return true;}
fps_counter_start(struct fps_counter *counter) {    counter->started = SDL_TRUE;    counter->slice_start = SDL_GetTicks();    counter->nr_rendered = 0;#ifdef SKIP_FRAMES    counter->nr_skipped = 0;#endif}
fps_counter_init(struct fps_counter *counter) {    counter->started = SDL_FALSE;    // no need to initialize the other fields, they are meaningful only when    // started is true}
check_expired(struct fps_counter *counter) {    Uint32 now = SDL_GetTicks();    if (now - counter->slice_start >= 1000) {        display_fps(counter);        // add a multiple of one second        Uint32 elapsed_slices = (now - counter->slice_start) / 1000;        counter->slice_start += 1000 * elapsed_slices;        counter->nr_rendered = 0;#ifdef SKIP_FRAMES        counter->nr_skipped = 0;#endif    }}
fps_counter_stop(struct fps_counter *counter) {    counter->started = SDL_FALSE;}
fps_counter_start(struct fps_counter *counter) {    counter->started = true;    counter->slice_start = SDL_GetTicks();    counter->nr_rendered = 0;#ifdef SKIP_FRAMES    counter->nr_skipped = 0;#endif}
fps_counter_init(struct fps_counter *counter) {    counter->started = false;    // no need to initialize the other fields, they are meaningful only when    // started is true}
check_expired(struct fps_counter *counter) {    uint32_t now = SDL_GetTicks();    if (now - counter->slice_start >= 1000) {        display_fps(counter);        // add a multiple of one second        uint32_t elapsed_slices = (now - counter->slice_start) / 1000;        counter->slice_start += 1000 * elapsed_slices;        counter->nr_rendered = 0;#ifdef SKIP_FRAMES        counter->nr_skipped = 0;#endif    }}
fps_counter_stop(struct fps_counter *counter) {    counter->started = false;}
parse_bit_rate(char *optarg, Uint32 *bit_rate) {    char *endptr;    if (*optarg == '\0') {        LOGE("Bit-rate parameter is empty");        return SDL_FALSE;    }    long value = strtol(optarg, &endptr, 0);    int mul = 1;    if (*endptr != '\0') {        if (optarg == endptr) {            LOGE("Invalid bit-rate: %s", optarg);            return SDL_FALSE;        }        if ((*endptr == 'M' || *endptr == 'm') && endptr[1] == '\0') {            mul = 1000000;        } else if ((*endptr == 'K' || *endptr == 'k') && endptr[1] == '\0') {            mul = 1000;        } else {            LOGE("Invalid bit-rate unit: %s", optarg);            return SDL_FALSE;        }    }    if (value < 0 || ((Uint32) -1) / mul < value) {        LOGE("Bitrate must be positive and less than 2^32: %s", optarg);        return SDL_FALSE;    }    *bit_rate = (Uint32) value * mul;    return SDL_TRUE;}
parse_port(char *optarg, Uint16 *port) {    char *endptr;    if (*optarg == '\0') {        LOGE("Invalid port parameter is empty");        return SDL_FALSE;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid port: %s", optarg);        return SDL_FALSE;    }    if (value & ~0xffff) {        LOGE("Port out of range: %ld", value);        return SDL_FALSE;    }    *port = (Uint16) value;    return SDL_TRUE;}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top", no_argument,       NULL, 'T'},        {"bit-rate",      required_argument, NULL, 'b'},        {"crop",          required_argument, NULL, 'c'},        {"fullscreen",    no_argument,       NULL, 'f'},        {"help",          no_argument,       NULL, 'h'},        {"max-size",      required_argument, NULL, 'm'},        {"no-control",    no_argument,       NULL, 'n'},        {"no-display",    no_argument,       NULL, 'N'},        {"port",          required_argument, NULL, 'p'},        {"record",        required_argument, NULL, 'r'},        {"record-format", required_argument, NULL, 'f'},        {"serial",        required_argument, NULL, 's'},        {"show-touches",  no_argument,       NULL, 't'},        {"version",       no_argument,       NULL, 'v'},        {NULL,            0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:tTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = SDL_TRUE;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return SDL_FALSE;                }                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'n':                args->no_control = SDL_TRUE;                break;            case 'N':                args->no_display = SDL_TRUE;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = SDL_TRUE;                break;            case 'T':                args->always_on_top = SDL_TRUE;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    if (args->no_display && !args->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return SDL_FALSE;    }    if (args->no_display && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return SDL_FALSE;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return SDL_FALSE;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return SDL_FALSE;        }    }    return SDL_TRUE;}
parse_max_size(char *optarg, Uint16 *max_size) {    char *endptr;    if (*optarg == '\0') {        LOGE("Max size parameter is empty");        return SDL_FALSE;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid max size: %s", optarg);        return SDL_FALSE;    }    if (value & ~0xffff) {        LOGE("Max size must be between 0 and 65535: %ld", value);        return SDL_FALSE;    }    *max_size = (Uint16) value;    return SDL_TRUE;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .record_format = 0,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = SDL_FALSE,        .no_control = SDL_FALSE,        .no_display = SDL_FALSE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,        .no_control = args.no_control,        .no_display = args.no_display,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
parse_port(char *optarg, Uint16 *port) {    char *endptr;    if (*optarg == '\0') {        LOGE("Invalid port parameter is empty");        return SDL_FALSE;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid port: %s", optarg);        return SDL_FALSE;    }    if (value & ~0xffff) {        LOGE("Port out of range: %ld", value);        return SDL_FALSE;    }    *port = (Uint16) value;    return SDL_TRUE;}
parse_max_size(char *optarg, Uint16 *max_size) {    char *endptr;    if (*optarg == '\0') {        LOGE("Max size parameter is empty");        return SDL_FALSE;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid max size: %s", optarg);        return SDL_FALSE;    }    if (value & ~0xffff) {        LOGE("Max size must be between 0 and 65535: %ld", value);        return SDL_FALSE;    }    *max_size = (Uint16) value;    return SDL_TRUE;}
parse_bit_rate(char *optarg, Uint32 *bit_rate) {    char *endptr;    if (*optarg == '\0') {        LOGE("Bit-rate parameter is empty");        return SDL_FALSE;    }    long value = strtol(optarg, &endptr, 0);    int mul = 1;    if (*endptr != '\0') {        if (optarg == endptr) {            LOGE("Invalid bit-rate: %s", optarg);            return SDL_FALSE;        }        if ((*endptr == 'M' || *endptr == 'm') && endptr[1] == '\0') {            mul = 1000000;        } else if ((*endptr == 'K' || *endptr == 'k') && endptr[1] == '\0') {            mul = 1000;        } else {            LOGE("Invalid bit-rate unit: %s", optarg);            return SDL_FALSE;        }    }    if (value < 0 || ((Uint32) -1) / mul < value) {        LOGE("Bitrate must be positive and less than 2^32: %s", optarg);        return SDL_FALSE;    }    *bit_rate = (Uint32) value * mul;    return SDL_TRUE;}
parse_record_format(const char *optarg, enum recorder_format *format) {    if (!strcmp(optarg, "mp4")) {        *format = RECORDER_FORMAT_MP4;        return SDL_TRUE;    }    if (!strcmp(optarg, "mkv")) {        *format = RECORDER_FORMAT_MKV;        return SDL_TRUE;    }    LOGE("Unsupported format: %s (expected mp4 or mkv)", optarg);    return SDL_FALSE;}
parse_bit_rate(char *optarg, uint32_t *bit_rate) {    char *endptr;    if (*optarg == '\0') {        LOGE("Bit-rate parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    int mul = 1;    if (*endptr != '\0') {        if (optarg == endptr) {            LOGE("Invalid bit-rate: %s", optarg);            return false;        }        if ((*endptr == 'M' || *endptr == 'm') && endptr[1] == '\0') {            mul = 1000000;        } else if ((*endptr == 'K' || *endptr == 'k') && endptr[1] == '\0') {            mul = 1000;        } else {            LOGE("Invalid bit-rate unit: %s", optarg);            return false;        }    }    if (value < 0 || ((uint32_t) -1) / mul < value) {        LOGE("Bitrate must be positive and less than 2^32: %s", optarg);        return false;    }    *bit_rate = (uint32_t) value * mul;    return true;}
static boolparse_port(char *optarg, uint16_t *port) {    char *endptr;    if (*optarg == '\0') {        LOGE("Invalid port parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid port: %s", optarg);        return false;    }    if (value & ~0xffff) {        LOGE("Port out of range: %ld", value);        return false;    }    *port = (uint16_t) value;    return true;
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top", no_argument,       NULL, 'T'},        {"bit-rate",      required_argument, NULL, 'b'},        {"crop",          required_argument, NULL, 'c'},        {"fullscreen",    no_argument,       NULL, 'f'},        {"help",          no_argument,       NULL, 'h'},        {"max-size",      required_argument, NULL, 'm'},        {"no-control",    no_argument,       NULL, 'n'},        {"no-display",    no_argument,       NULL, 'N'},        {"port",          required_argument, NULL, 'p'},        {"record",        required_argument, NULL, 'r'},        {"record-format", required_argument, NULL, 'f'},        {"serial",        required_argument, NULL, 's'},        {"show-touches",  no_argument,       NULL, 't'},        {"version",       no_argument,       NULL, 'v'},        {NULL,            0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:tTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return false;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = true;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return false;                }                break;            case 'n':                args->no_control = true;                break;            case 'N':                args->no_display = true;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return false;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = true;                break;            case 'T':                args->always_on_top = true;                break;            case 'v':                args->version = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (args->no_display && !args->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (args->no_display && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return false;        }    }    return true;}
static boolparse_max_size(char *optarg, uint16_t *max_size) {    char *endptr;    if (*optarg == '\0') {        LOGE("Max size parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid max size: %s", optarg);        return false;    }    if (value & ~0xffff) {        LOGE("Max size must be between 0 and 65535: %ld", value);        return false;    }    *max_size = (uint16_t) value;    return true;
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .record_format = 0,        .help = false,        .version = false,        .show_touches = false,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = false,        .no_control = false,        .no_display = false,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,        .no_control = args.no_control,        .no_display = args.no_display,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
parse_port(char *optarg, uint16_t *port) {    char *endptr;    if (*optarg == '\0') {        LOGE("Invalid port parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid port: %s", optarg);        return false;    }    if (value & ~0xffff) {        LOGE("Port out of range: %ld", value);        return false;    }    *port = (uint16_t) value;    return true;}
parse_max_size(char *optarg, uint16_t *max_size) {    char *endptr;    if (*optarg == '\0') {        LOGE("Max size parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid max size: %s", optarg);        return false;    }    if (value & ~0xffff) {        LOGE("Max size must be between 0 and 65535: %ld", value);        return false;    }    *max_size = (uint16_t) value;    return true;}
static boolparse_bit_rate(char *optarg, uint32_t *bit_rate) {    char *endptr;    if (*optarg == '\0') {        LOGE("Bit-rate parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    int mul = 1;    if (*endptr != '\0') {        if (optarg == endptr) {            LOGE("Invalid bit-rate: %s", optarg);            return false;        }        if ((*endptr == 'M' || *endptr == 'm') && endptr[1] == '\0') {            mul = 1000000;        } else if ((*endptr == 'K' || *endptr == 'k') && endptr[1] == '\0') {            mul = 1000;        } else {            LOGE("Invalid bit-rate unit: %s", optarg);            return false;        }    }    if (value < 0 || ((uint32_t) -1) / mul < value) {        LOGE("Bitrate must be positive and less than 2^32: %s", optarg);        return false;    }    *bit_rate = (uint32_t) value * mul;    return true;
parse_record_format(const char *optarg, enum recorder_format *format) {    if (!strcmp(optarg, "mp4")) {        *format = RECORDER_FORMAT_MP4;        return true;    }    if (!strcmp(optarg, "mkv")) {        *format = RECORDER_FORMAT_MKV;        return true;    }    LOGE("Unsupported format: %s (expected mp4 or mkv)", optarg);    return false;}
net_connect(Uint32 addr, Uint16 port) {    socket_t sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        perror("socket");        return INVALID_SOCKET;    }    SOCKADDR_IN sin;    sin.sin_family = AF_INET;    sin.sin_addr.s_addr = htonl(addr);    sin.sin_port = htons(port);    if (connect(sock, (SOCKADDR *) &sin, sizeof(sin)) == SOCKET_ERROR) {        perror("connect");        return INVALID_SOCKET;    }    return sock;}
net_listen(Uint32 addr, Uint16 port, int backlog) {    socket_t sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        perror("socket");        return INVALID_SOCKET;    }    int reuse = 1;    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (const void *) &reuse,                   sizeof(reuse)) == -1) {        perror("setsockopt(SO_REUSEADDR)");    }    SOCKADDR_IN sin;    sin.sin_family = AF_INET;    sin.sin_addr.s_addr = htonl(addr); // htonl() harmless on INADDR_ANY    sin.sin_port = htons(port);    if (bind(sock, (SOCKADDR *) &sin, sizeof(sin)) == SOCKET_ERROR) {        perror("bind");        return INVALID_SOCKET;    }    if (listen(sock, backlog) == SOCKET_ERROR) {        perror("listen");        return INVALID_SOCKET;    }    return sock;}
net_listen(Uint32 addr, Uint16 port, int backlog) {    socket_t sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        perror("socket");        return INVALID_SOCKET;    }    int reuse = 1;    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (const void *) &reuse,                   sizeof(reuse)) == -1) {        perror("setsockopt(SO_REUSEADDR)");    }    SOCKADDR_IN sin;    sin.sin_family = AF_INET;    sin.sin_addr.s_addr = htonl(addr); // htonl() harmless on INADDR_ANY    sin.sin_port = htons(port);    if (bind(sock, (SOCKADDR *) &sin, sizeof(sin)) == SOCKET_ERROR) {        perror("bind");        return INVALID_SOCKET;    }    if (listen(sock, backlog) == SOCKET_ERROR) {        perror("listen");        return INVALID_SOCKET;    }    return sock;}
net_connect(Uint32 addr, Uint16 port) {    socket_t sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        perror("socket");        return INVALID_SOCKET;    }    SOCKADDR_IN sin;    sin.sin_family = AF_INET;    sin.sin_addr.s_addr = htonl(addr);    sin.sin_port = htons(port);    if (connect(sock, (SOCKADDR *) &sin, sizeof(sin)) == SOCKET_ERROR) {        perror("connect");        return INVALID_SOCKET;    }    return sock;}
net_connect(uint32_t addr, uint16_t port) {    socket_t sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        perror("socket");        return INVALID_SOCKET;    }    SOCKADDR_IN sin;    sin.sin_family = AF_INET;    sin.sin_addr.s_addr = htonl(addr);    sin.sin_port = htons(port);    if (connect(sock, (SOCKADDR *) &sin, sizeof(sin)) == SOCKET_ERROR) {        perror("connect");        return INVALID_SOCKET;    }    return sock;}
net_listen(uint32_t addr, uint16_t port, int backlog) {    socket_t sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        perror("socket");        return INVALID_SOCKET;    }    int reuse = 1;    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (const void *) &reuse,                   sizeof(reuse)) == -1) {        perror("setsockopt(SO_REUSEADDR)");    }    SOCKADDR_IN sin;    sin.sin_family = AF_INET;    sin.sin_addr.s_addr = htonl(addr); // htonl() harmless on INADDR_ANY    sin.sin_port = htons(port);    if (bind(sock, (SOCKADDR *) &sin, sizeof(sin)) == SOCKET_ERROR) {        perror("bind");        return INVALID_SOCKET;    }    if (listen(sock, backlog) == SOCKET_ERROR) {        perror("listen");        return INVALID_SOCKET;    }    return sock;}
net_listen(uint32_t addr, uint16_t port, int backlog) {    socket_t sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        perror("socket");        return INVALID_SOCKET;    }    int reuse = 1;    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (const void *) &reuse,                   sizeof(reuse)) == -1) {        perror("setsockopt(SO_REUSEADDR)");    }    SOCKADDR_IN sin;    sin.sin_family = AF_INET;    sin.sin_addr.s_addr = htonl(addr); // htonl() harmless on INADDR_ANY    sin.sin_port = htons(port);    if (bind(sock, (SOCKADDR *) &sin, sizeof(sin)) == SOCKET_ERROR) {        perror("bind");        return INVALID_SOCKET;    }    if (listen(sock, backlog) == SOCKET_ERROR) {        perror("listen");        return INVALID_SOCKET;    }    return sock;}
net_connect(uint32_t addr, uint16_t port) {    socket_t sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        perror("socket");        return INVALID_SOCKET;    }    SOCKADDR_IN sin;    sin.sin_family = AF_INET;    sin.sin_addr.s_addr = htonl(addr);    sin.sin_port = htons(port);    if (connect(sock, (SOCKADDR *) &sin, sizeof(sin)) == SOCKET_ERROR) {        perror("connect");        return INVALID_SOCKET;    }    return sock;}
recorder_init(struct recorder *recorder,              const char *filename,              enum recorder_format format,              struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Cannot strdup filename");        return SDL_FALSE;    }    recorder->format = format;    recorder->declared_frame_size = declared_frame_size;    recorder->header_written = SDL_FALSE;    return SDL_TRUE;}
recorder_write(struct recorder *recorder, AVPacket *packet) {    if (!recorder->header_written) {        SDL_bool ok = recorder_write_header(recorder, packet);        if (!ok) {            return SDL_FALSE;        }        recorder->header_written = SDL_TRUE;    }    recorder_rescale_packet(recorder, packet);    return av_write_frame(recorder->ctx, packet) >= 0;}
recorder_write_header(struct recorder *recorder, AVPacket *packet) {    AVStream *ostream = recorder->ctx->streams[0];    uint8_t *extradata = av_malloc(packet->size * sizeof(uint8_t));    if (!extradata) {        LOGC("Cannot allocate extradata");        return SDL_FALSE;    }    // copy the first packet to the extra data    memcpy(extradata, packet->data, packet->size);#ifdef SCRCPY_LAVF_HAS_NEW_CODEC_PARAMS_API    ostream->codecpar->extradata = extradata;    ostream->codecpar->extradata_size = packet->size;#else    ostream->codec->extradata = extradata;    ostream->codec->extradata_size = packet->size;#endif    int ret = avformat_write_header(recorder->ctx, NULL);    if (ret < 0) {        LOGE("Failed to write header to %s", recorder->filename);        SDL_free(extradata);        avio_closep(&recorder->ctx->pb);        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    return SDL_TRUE;}
recorder_open(struct recorder *recorder, AVCodec *input_codec) {    const char *format_name = recorder_get_format_name(recorder->format);    SDL_assert(format_name);    const AVOutputFormat *format = find_muxer(format_name);    if (!format) {        LOGE("Could not find muxer");        return SDL_FALSE;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return SDL_FALSE;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) format;    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }#ifdef SCRCPY_LAVF_HAS_NEW_CODEC_PARAMS_API    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    LOGI("Recording started to %s file: %s", format_name, recorder->filename);    return SDL_TRUE;}
recorder_init(struct recorder *recorder,              const char *filename,              enum recorder_format format,              struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Cannot strdup filename");        return false;    }    recorder->format = format;    recorder->declared_frame_size = declared_frame_size;    recorder->header_written = false;    return true;}
recorder_write(struct recorder *recorder, AVPacket *packet) {    if (!recorder->header_written) {        bool ok = recorder_write_header(recorder, packet);        if (!ok) {            return false;        }        recorder->header_written = true;    }    recorder_rescale_packet(recorder, packet);    return av_write_frame(recorder->ctx, packet) >= 0;}
recorder_write_header(struct recorder *recorder, AVPacket *packet) {    AVStream *ostream = recorder->ctx->streams[0];    uint8_t *extradata = av_malloc(packet->size * sizeof(uint8_t));    if (!extradata) {        LOGC("Cannot allocate extradata");        return false;    }    // copy the first packet to the extra data    memcpy(extradata, packet->data, packet->size);#ifdef SCRCPY_LAVF_HAS_NEW_CODEC_PARAMS_API    ostream->codecpar->extradata = extradata;    ostream->codecpar->extradata_size = packet->size;#else    ostream->codec->extradata = extradata;    ostream->codec->extradata_size = packet->size;#endif    int ret = avformat_write_header(recorder->ctx, NULL);    if (ret < 0) {        LOGE("Failed to write header to %s", recorder->filename);        SDL_free(extradata);        avio_closep(&recorder->ctx->pb);        avformat_free_context(recorder->ctx);        return false;    }    return true;}
recorder_open(struct recorder *recorder, AVCodec *input_codec) {    const char *format_name = recorder_get_format_name(recorder->format);    SDL_assert(format_name);    const AVOutputFormat *format = find_muxer(format_name);    if (!format) {        LOGE("Could not find muxer");        return false;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return false;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) format;    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return false;    }#ifdef SCRCPY_LAVF_HAS_NEW_CODEC_PARAMS_API    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return false;    }    LOGI("Recording started to %s file: %s", format_name, recorder->filename);    return true;}
handle_event(SDL_Event *event, SDL_bool control) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = SDL_TRUE;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return SDL_FALSE;            }            break;        case SDL_WINDOWEVENT:            switch (event->window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;            }            break;        case SDL_TEXTINPUT:            if (!control) {                break;            }            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            // some key events do not interact with the device, so process the            // event even if control is disabled            input_manager_process_key(&input_manager, &event->key);            break;        case SDL_MOUSEMOTION:            if (!control) {                break;            }            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            if (!control) {                break;            }            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            // some mouse events do not interact with the device, so process            // the event even if control is disabled            input_manager_process_mouse_button(&input_manager, &event->button);            break;        case SDL_DROPFILE: {            if (!control) {                break;            }            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
handle_event(SDL_Event *event, SDL_bool control) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = SDL_TRUE;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return SDL_FALSE;            }            break;        case SDL_WINDOWEVENT:            switch (event->window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;            }            break;        case SDL_TEXTINPUT:            if (!control) {                break;            }            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            // some key events do not interact with the device, so process the            // event even if control is disabled            input_manager_process_key(&input_manager, &event->key);            break;        case SDL_MOUSEMOTION:            if (!control) {                break;            }            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            if (!control) {                break;            }            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            // some mouse events do not interact with the device, so process            // the event even if control is disabled            input_manager_process_mouse_button(&input_manager, &event->button);            break;        case SDL_DROPFILE: {            if (!control) {                break;            }            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
event_loop(SDL_bool display, SDL_bool control) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    if (display) {        SDL_AddEventWatch(event_watcher, NULL);    }#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        enum event_result result = handle_event(&event, control);        switch (result) {            case EVENT_RESULT_STOPPED_BY_USER:                return SDL_TRUE;            case EVENT_RESULT_STOPPED_BY_EOS:                return SDL_FALSE;            case EVENT_RESULT_CONTINUE:                break;        }    }    return SDL_FALSE;}
set_show_touches_enabled(const char *serial, SDL_bool enabled) {    const char *value = enabled ? "1" : "0";    const char *const adb_cmd[] = {        "shell", "settings", "put", "system", "show_touches", value    };    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
event_loop(SDL_bool display, SDL_bool control) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    if (display) {        SDL_AddEventWatch(event_watcher, NULL);    }#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        enum event_result result = handle_event(&event, control);        switch (result) {            case EVENT_RESULT_STOPPED_BY_USER:                return SDL_TRUE;            case EVENT_RESULT_STOPPED_BY_EOS:                return SDL_FALSE;            case EVENT_RESULT_CONTINUE:                break;        }    }    return SDL_FALSE;}
scrcpy(const struct scrcpy_options *options) {    SDL_bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    SDL_bool display = !options->no_display;    SDL_bool control = !options->no_control;    input_manager.control = control;    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            server_stop(&server);            ret = SDL_FALSE;            goto finally_destroy_server;        }        if (control && !file_handler_init(&file_handler, server.serial)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_video_buffer;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (display) {        if (control) {            if (!controller_init(&controller, device_socket)) {                ret = SDL_FALSE;                goto finally_stop_stream;            }            if (!controller_start(&controller)) {                ret = SDL_FALSE;                goto finally_destroy_controller;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            ret = SDL_FALSE;            goto finally_stop_and_join_controller;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    ret = event_loop(display, control);    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    if (display && control) {        controller_stop(&controller);        controller_join(&controller);    }finally_destroy_controller:    if (display && control) {        controller_destroy(&controller);    }finally_stop_stream:    stream_stop(&stream);    // stop the server before stream_join() to wake up the stream    server_stop(&server);    stream_join(&stream);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    if (display && control) {        file_handler_stop(&file_handler);        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }finally_destroy_video_buffer:    if (display) {        video_buffer_destroy(&video_buffer);    }finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial,                                                     SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
set_show_touches_enabled(const char *serial, SDL_bool enabled) {    const char *value = enabled ? "1" : "0";    const char *const adb_cmd[] = {        "shell", "settings", "put", "system", "show_touches", value    };    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
handle_event(SDL_Event *event, bool control) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = true;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return false;            }            break;        case SDL_WINDOWEVENT:            switch (event->window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;            }            break;        case SDL_TEXTINPUT:            if (!control) {                break;            }            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            // some key events do not interact with the device, so process the            // event even if control is disabled            input_manager_process_key(&input_manager, &event->key);            break;        case SDL_MOUSEMOTION:            if (!control) {                break;            }            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            if (!control) {                break;            }            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            // some mouse events do not interact with the device, so process            // the event even if control is disabled            input_manager_process_mouse_button(&input_manager, &event->button);            break;        case SDL_DROPFILE: {            if (!control) {                break;            }            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
handle_event(SDL_Event *event, bool control) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = true;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return false;            }            break;        case SDL_WINDOWEVENT:            switch (event->window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;            }            break;        case SDL_TEXTINPUT:            if (!control) {                break;            }            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            // some key events do not interact with the device, so process the            // event even if control is disabled            input_manager_process_key(&input_manager, &event->key);            break;        case SDL_MOUSEMOTION:            if (!control) {                break;            }            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            if (!control) {                break;            }            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            // some mouse events do not interact with the device, so process            // the event even if control is disabled            input_manager_process_mouse_button(&input_manager, &event->button);            break;        case SDL_DROPFILE: {            if (!control) {                break;            }            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
event_loop(bool display, bool control) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    if (display) {        SDL_AddEventWatch(event_watcher, NULL);    }#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        enum event_result result = handle_event(&event, control);        switch (result) {            case EVENT_RESULT_STOPPED_BY_USER:                return true;            case EVENT_RESULT_STOPPED_BY_EOS:                return false;            case EVENT_RESULT_CONTINUE:                break;        }    }    return false;}
set_show_touches_enabled(const char *serial, bool enabled) {    const char *value = enabled ? "1" : "0";    const char *const adb_cmd[] = {        "shell", "settings", "put", "system", "show_touches", value    };    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
event_loop(bool display, bool control) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    if (display) {        SDL_AddEventWatch(event_watcher, NULL);    }#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        enum event_result result = handle_event(&event, control);        switch (result) {            case EVENT_RESULT_STOPPED_BY_USER:                return true;            case EVENT_RESULT_STOPPED_BY_EOS:                return false;            case EVENT_RESULT_CONTINUE:                break;        }    }    return false;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = true;    if (!sdl_init_and_configure()) {        ret = false;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = false;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = false;        goto finally_destroy_server;    }    bool display = !options->no_display;    bool control = !options->no_control;    input_manager.control = control;    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            server_stop(&server);            ret = false;            goto finally_destroy_server;        }        if (control && !file_handler_init(&file_handler, server.serial)) {            ret = false;            server_stop(&server);            goto finally_destroy_video_buffer;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = false;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        ret = false;        server_stop(&server);        goto finally_destroy_recorder;    }    if (display) {        if (control) {            if (!controller_init(&controller, device_socket)) {                ret = false;                goto finally_stop_stream;            }            if (!controller_start(&controller)) {                ret = false;                goto finally_destroy_controller;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            ret = false;            goto finally_stop_and_join_controller;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(display, control);    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    if (display && control) {        controller_stop(&controller);        controller_join(&controller);    }finally_destroy_controller:    if (display && control) {        controller_destroy(&controller);    }finally_stop_stream:    stream_stop(&stream);    // stop the server before stream_join() to wake up the stream    server_stop(&server);    stream_join(&stream);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    if (display && control) {        file_handler_stop(&file_handler);        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }finally_destroy_video_buffer:    if (display) {        video_buffer_destroy(&video_buffer);    }finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial,                                                     false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
set_show_touches_enabled(const char *serial, bool enabled) {    const char *value = enabled ? "1" : "0";    const char *const adb_cmd[] = {        "shell", "settings", "put", "system", "show_touches", value    };    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
sdl_init_and_configure(void) {    if (SDL_Init(SDL_INIT_VIDEO)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return SDL_FALSE;    }    atexit(SDL_Quit);    // Use the best available scale quality    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "2")) {        LOGW("Could not enable bilinear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return SDL_TRUE;}
get_optimal_size(struct size current_size, struct size frame_size) {    if (frame_size.width == 0 || frame_size.height == 0) {        // avoid division by 0        return current_size;    }    struct size display_size;    // 32 bits because we need to multiply two 16 bits values    Uint32 w;    Uint32 h;    if (!get_preferred_display_bounds(&display_size)) {        // cannot get display bounds, do not constraint the size        w = current_size.width;        h = current_size.height;    } else {        w = MIN(current_size.width, display_size.width);        h = MIN(current_size.height, display_size.height);    }    SDL_bool keep_width = frame_size.width * h > frame_size.height * w;    if (keep_width) {        // remove black borders on top and bottom        h = frame_size.height * w / frame_size.width;    } else {        // remove black borders on left and right (or none at all if it already        // fits)        w = frame_size.width * h / frame_size.height;    }    // w and h must fit into 16 bits    SDL_assert_release(w < 0x10000 && h < 0x10000);    return (struct size) {w, h};}
screen_init_rendering(struct screen *screen, const char *device_name,                      struct size frame_size, SDL_bool always_on_top) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    Uint32 window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED,                                      SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    return SDL_TRUE;}
screen_update_frame(struct screen *screen, struct video_buffer *vb) {    mutex_lock(vb->mutex);    const AVFrame *frame = video_buffer_consume_rendered_frame(vb);    struct size new_frame_size = {frame->width, frame->height};    if (!prepare_for_frame(screen, new_frame_size)) {        mutex_unlock(vb->mutex);        return SDL_FALSE;    }    update_texture(screen, frame);    mutex_unlock(vb->mutex);    screen_render(screen);    return SDL_TRUE;}
prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width            || screen->frame_size.height != new_frame_size.height) {        if (SDL_RenderSetLogicalSize(screen->renderer, new_frame_size.width,                                     new_frame_size.height)) {            LOGE("Could not set renderer logical size: %s", SDL_GetError());            return SDL_FALSE;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        struct size current_size = get_window_size(screen);        struct size target_size = {            (Uint32) current_size.width * new_frame_size.width                    / screen->frame_size.width,            (Uint32) current_size.height * new_frame_size.height                    / screen->frame_size.height,        };        target_size = get_optimal_size(target_size, new_frame_size);        set_window_size(screen, target_size);        screen->frame_size = new_frame_size;        LOGD("New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = create_texture(screen->renderer, new_frame_size);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return SDL_FALSE;        }    }    return SDL_TRUE;}
screen_init_rendering(struct screen *screen, const char *device_name,                      struct size frame_size, SDL_bool always_on_top) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    Uint32 window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED,                                      SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    return SDL_TRUE;}
screen_switch_fullscreen(struct screen *screen) {    if (!screen->fullscreen) {        // going to fullscreen, store the current windowed window size        screen->windowed_window_size = get_native_window_size(screen->window);    }    Uint32 new_mode = screen->fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;    if (SDL_SetWindowFullscreen(screen->window, new_mode)) {        LOGW("Could not switch fullscreen mode: %s", SDL_GetError());        return;    }    screen->fullscreen = !screen->fullscreen;    if (!screen->fullscreen) {        // fullscreen disabled, restore expected windowed window size        SDL_SetWindowSize(screen->window, screen->windowed_window_size.width,                          screen->windowed_window_size.height);    }    LOGD("Switched to %s mode", screen->fullscreen ? "fullscreen" : "windowed");    screen_render(screen);}
get_preferred_display_bounds(struct size *bounds) {    SDL_Rect rect;#ifdef SCRCPY_SDL_HAS_GET_DISPLAY_USABLE_BOUNDS# define GET_DISPLAY_BOUNDS(i, r) SDL_GetDisplayUsableBounds((i), (r))#else# define GET_DISPLAY_BOUNDS(i, r) SDL_GetDisplayBounds((i), (r))#endif    if (GET_DISPLAY_BOUNDS(0, &rect)) {        LOGW("Could not get display usable bounds: %s", SDL_GetError());        return SDL_FALSE;    }    bounds->width = MAX(0, rect.w - DISPLAY_MARGINS);    bounds->height = MAX(0, rect.h - DISPLAY_MARGINS);    return SDL_TRUE;}
sdl_init_and_configure(void) {    if (SDL_Init(SDL_INIT_VIDEO)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return false;    }    atexit(SDL_Quit);    // Use the best available scale quality    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "2")) {        LOGW("Could not enable bilinear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return true;}
get_optimal_size(struct size current_size, struct size frame_size) {    if (frame_size.width == 0 || frame_size.height == 0) {        // avoid division by 0        return current_size;    }    struct size display_size;    // 32 bits because we need to multiply two 16 bits values    uint32_t w;    uint32_t h;    if (!get_preferred_display_bounds(&display_size)) {        // cannot get display bounds, do not constraint the size        w = current_size.width;        h = current_size.height;    } else {        w = MIN(current_size.width, display_size.width);        h = MIN(current_size.height, display_size.height);    }    bool keep_width = frame_size.width * h > frame_size.height * w;    if (keep_width) {        // remove black borders on top and bottom        h = frame_size.height * w / frame_size.width;    } else {        // remove black borders on left and right (or none at all if it already        // fits)        w = frame_size.width * h / frame_size.height;    }    // w and h must fit into 16 bits    SDL_assert_release(w < 0x10000 && h < 0x10000);    return (struct size) {w, h};}
boolscreen_init_rendering(struct screen *screen, const char *device_name,                      struct size frame_size, bool always_on_top) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED,                                      SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    return true;}
screen_update_frame(struct screen *screen, struct video_buffer *vb) {    mutex_lock(vb->mutex);    const AVFrame *frame = video_buffer_consume_rendered_frame(vb);    struct size new_frame_size = {frame->width, frame->height};    if (!prepare_for_frame(screen, new_frame_size)) {        mutex_unlock(vb->mutex);        return false;    }    update_texture(screen, frame);    mutex_unlock(vb->mutex);    screen_render(screen);    return true;}
prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width            || screen->frame_size.height != new_frame_size.height) {        if (SDL_RenderSetLogicalSize(screen->renderer, new_frame_size.width,                                     new_frame_size.height)) {            LOGE("Could not set renderer logical size: %s", SDL_GetError());            return false;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        struct size current_size = get_window_size(screen);        struct size target_size = {            (uint32_t) current_size.width * new_frame_size.width                    / screen->frame_size.width,            (uint32_t) current_size.height * new_frame_size.height                    / screen->frame_size.height,        };        target_size = get_optimal_size(target_size, new_frame_size);        set_window_size(screen, target_size);        screen->frame_size = new_frame_size;        LOGD("New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = create_texture(screen->renderer, new_frame_size);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return false;        }    }    return true;}
screen_init_rendering(struct screen *screen, const char *device_name,                      struct size frame_size, bool always_on_top) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED,                                      SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    return true;}
screen_switch_fullscreen(struct screen *screen) {    if (!screen->fullscreen) {        // going to fullscreen, store the current windowed window size        screen->windowed_window_size = get_native_window_size(screen->window);    }    uint32_t new_mode = screen->fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;    if (SDL_SetWindowFullscreen(screen->window, new_mode)) {        LOGW("Could not switch fullscreen mode: %s", SDL_GetError());        return;    }    screen->fullscreen = !screen->fullscreen;    if (!screen->fullscreen) {        // fullscreen disabled, restore expected windowed window size        SDL_SetWindowSize(screen->window, screen->windowed_window_size.width,                          screen->windowed_window_size.height);    }    LOGD("Switched to %s mode", screen->fullscreen ? "fullscreen" : "windowed");    screen_render(screen);}
get_preferred_display_bounds(struct size *bounds) {    SDL_Rect rect;#ifdef SCRCPY_SDL_HAS_GET_DISPLAY_USABLE_BOUNDS# define GET_DISPLAY_BOUNDS(i, r) SDL_GetDisplayUsableBounds((i), (r))#else# define GET_DISPLAY_BOUNDS(i, r) SDL_GetDisplayBounds((i), (r))#endif    if (GET_DISPLAY_BOUNDS(0, &rect)) {        LOGW("Could not get display usable bounds: %s", SDL_GetError());        return false;    }    bounds->width = MAX(0, rect.w - DISPLAY_MARGINS);    bounds->height = MAX(0, rect.h - DISPLAY_MARGINS);    return true;}
connect_to_server(Uint16 port, Uint32 attempts, Uint32 delay) {    do {        LOGD("Remaining connection attempts: %d", (int) attempts);        socket_t socket = connect_and_read_byte(port);        if (socket != INVALID_SOCKET) {            // it worked!            return socket;        }        if (attempts) {            SDL_Delay(delay);        }    } while (--attempts > 0);    return INVALID_SOCKET;}
enable_tunnel_reverse(const char *serial, Uint16 local_port) {    process_t process = adb_reverse(serial, SOCKET_NAME, local_port);    return process_check_success(process, "adb reverse");}
enable_tunnel_reverse(const char *serial, Uint16 local_port) {    process_t process = adb_reverse(serial, SOCKET_NAME, local_port);    return process_check_success(process, "adb reverse");}
server_connect_to(struct server *server) {    if (!server->tunnel_forward) {        server->device_socket = net_accept(server->server_socket);    } else {        Uint32 attempts = 100;        Uint32 delay = 100; // ms        server->device_socket = connect_to_server(server->local_port, attempts,                                                  delay);    }    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    if (!server->tunnel_forward) {        // we don't need the server socket anymore        close_socket(&server->server_socket);    }    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = SDL_FALSE;    return server->device_socket;}
connect_and_read_byte(Uint16 port) {    socket_t socket = net_connect(IPV4_LOCALHOST, port);    if (socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    char byte;    // the connection may succeed even if the server behind the "adb tunnel"    // is not listening, so read one byte to detect a working connection    if (net_recv_all(socket, &byte, 1) != 1) {        // the server is not listening yet behind the adb tunnel        return INVALID_SOCKET;    }    return socket;}
server_start(struct server *server, const char *serial,             Uint16 local_port, Uint16 max_size, Uint32 bit_rate,             const char *crop, SDL_bool send_frame_meta) {    server->local_port = local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return SDL_FALSE;        }    }    if (!push_server(serial)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    if (!enable_tunnel(server)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, local_port);            disable_tunnel(server);            SDL_free((void *) server->serial);            return SDL_FALSE;        }    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate,                                     server->tunnel_forward, crop,                                     send_frame_meta);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free((void *) server->serial);        return SDL_FALSE;    }    server->tunnel_enabled = SDL_TRUE;    return SDL_TRUE;}
enable_tunnel_forward(const char *serial, Uint16 local_port) {    process_t process = adb_forward(serial, local_port, SOCKET_NAME);    return process_check_success(process, "adb forward");}
listen_on_port(Uint16 port) {    return net_listen(IPV4_LOCALHOST, port, 1);}
disable_tunnel_forward(const char *serial, Uint16 local_port) {    process_t process = adb_forward_remove(serial, local_port);    return process_check_success(process, "adb forward --remove");}
listen_on_port(Uint16 port) {    return net_listen(IPV4_LOCALHOST, port, 1);}
connect_and_read_byte(Uint16 port) {    socket_t socket = net_connect(IPV4_LOCALHOST, port);    if (socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    char byte;    // the connection may succeed even if the server behind the "adb tunnel"    // is not listening, so read one byte to detect a working connection    if (net_recv_all(socket, &byte, 1) != 1) {        // the server is not listening yet behind the adb tunnel        return INVALID_SOCKET;    }    return socket;}
enable_tunnel(struct server *server) {    if (enable_tunnel_reverse(server->serial, server->local_port)) {        return SDL_TRUE;    }    LOGW("'adb reverse' failed, fallback to 'adb forward'");    server->tunnel_forward = SDL_TRUE;    return enable_tunnel_forward(server->serial, server->local_port);}
execute_server(const char *serial,               Uint16 max_size, Uint32 bit_rate,               SDL_bool tunnel_forward, const char *crop,               SDL_bool send_frame_meta) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        tunnel_forward ? "true" : "false",        crop ? crop : "-",        send_frame_meta ? "true" : "false",    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
connect_to_server(Uint16 port, Uint32 attempts, Uint32 delay) {    do {        LOGD("Remaining connection attempts: %d", (int) attempts);        socket_t socket = connect_and_read_byte(port);        if (socket != INVALID_SOCKET) {            // it worked!            return socket;        }        if (attempts) {            SDL_Delay(delay);        }    } while (--attempts > 0);    return INVALID_SOCKET;}
disable_tunnel_forward(const char *serial, Uint16 local_port) {    process_t process = adb_forward_remove(serial, local_port);    return process_check_success(process, "adb forward --remove");}
server_start(struct server *server, const char *serial,             Uint16 local_port, Uint16 max_size, Uint32 bit_rate,             const char *crop, SDL_bool send_frame_meta) {    server->local_port = local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return SDL_FALSE;        }    }    if (!push_server(serial)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    if (!enable_tunnel(server)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, local_port);            disable_tunnel(server);            SDL_free((void *) server->serial);            return SDL_FALSE;        }    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate,                                     server->tunnel_forward, crop,                                     send_frame_meta);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free((void *) server->serial);        return SDL_FALSE;    }    server->tunnel_enabled = SDL_TRUE;    return SDL_TRUE;}
execute_server(const char *serial,               Uint16 max_size, Uint32 bit_rate,               SDL_bool tunnel_forward, const char *crop,               SDL_bool send_frame_meta) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        tunnel_forward ? "true" : "false",        crop ? crop : "-",        send_frame_meta ? "true" : "false",    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
enable_tunnel_forward(const char *serial, Uint16 local_port) {    process_t process = adb_forward(serial, local_port, SOCKET_NAME);    return process_check_success(process, "adb forward");}
    do {        LOGD("Remaining connection attempts: %d", (int) attempts);        socket_t socket = connect_and_read_byte(port);        if (socket != INVALID_SOCKET) {            // it worked!            return socket;        }        if (attempts) {            SDL_Delay(delay);        }    } while (--attempts > 0);    return INVALID_SOCKET;}static void
enable_tunnel_reverse(const char *serial, uint16_t local_port) {    process_t process = adb_reverse(serial, SOCKET_NAME, local_port);    return process_check_success(process, "adb reverse");}
    process_t process = adb_reverse(serial, SOCKET_NAME, local_port);    return process_check_success(process, "adb reverse");}static bool
server_connect_to(struct server *server) {    if (!server->tunnel_forward) {        server->device_socket = net_accept(server->server_socket);    } else {        uint32_t attempts = 100;        uint32_t delay = 100; // ms        server->device_socket = connect_to_server(server->local_port, attempts,                                                  delay);    }    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    if (!server->tunnel_forward) {        // we don't need the server socket anymore        close_socket(&server->server_socket);    }    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = false;    return server->device_socket;}
connect_and_read_byte(uint16_t port) {    socket_t socket = net_connect(IPV4_LOCALHOST, port);    if (socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    char byte;    // the connection may succeed even if the server behind the "adb tunnel"    // is not listening, so read one byte to detect a working connection    if (net_recv_all(socket, &byte, 1) != 1) {        // the server is not listening yet behind the adb tunnel        return INVALID_SOCKET;    }    return socket;}
             uint16_t local_port, uint16_t max_size, uint32_t bit_rate,             const char *crop, bool send_frame_meta) {    server->local_port = local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        SDL_free((void *) server->serial);        return false;    }    if (!enable_tunnel(server)) {        SDL_free((void *) server->serial);        return false;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, local_port);            disable_tunnel(server);            SDL_free((void *) server->serial);            return false;        }    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate,                                     server->tunnel_forward, crop,                                     send_frame_meta);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free((void *) server->serial);        return false;    }    server->tunnel_enabled = true;    return true;}socket_t
enable_tunnel_forward(const char *serial, uint16_t local_port) {    process_t process = adb_forward(serial, local_port, SOCKET_NAME);    return process_check_success(process, "adb forward");}
    return net_listen(IPV4_LOCALHOST, port, 1);}static socket_t
disable_tunnel_forward(const char *serial, uint16_t local_port) {    process_t process = adb_forward_remove(serial, local_port);    return process_check_success(process, "adb forward --remove");}
listen_on_port(uint16_t port) {    return net_listen(IPV4_LOCALHOST, port, 1);}
    socket_t socket = net_connect(IPV4_LOCALHOST, port);    if (socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    char byte;    // the connection may succeed even if the server behind the "adb tunnel"    // is not listening, so read one byte to detect a working connection    if (net_recv_all(socket, &byte, 1) != 1) {        // the server is not listening yet behind the adb tunnel        return INVALID_SOCKET;    }    return socket;}static socket_t
enable_tunnel(struct server *server) {    if (enable_tunnel_reverse(server->serial, server->local_port)) {        return true;    }    LOGW("'adb reverse' failed, fallback to 'adb forward'");    server->tunnel_forward = true;    return enable_tunnel_forward(server->serial, server->local_port);}
               uint16_t max_size, uint32_t bit_rate,               bool tunnel_forward, const char *crop,               bool send_frame_meta) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        tunnel_forward ? "true" : "false",        crop ? crop : "-",        send_frame_meta ? "true" : "false",    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}#define IPV4_LOCALHOST 0x7F000001
connect_to_server(uint16_t port, uint32_t attempts, uint32_t delay) {    do {        LOGD("Remaining connection attempts: %d", (int) attempts);        socket_t socket = connect_and_read_byte(port);        if (socket != INVALID_SOCKET) {            // it worked!            return socket;        }        if (attempts) {            SDL_Delay(delay);        }    } while (--attempts > 0);    return INVALID_SOCKET;}
    process_t process = adb_forward_remove(serial, local_port);    return process_check_success(process, "adb forward --remove");}static bool
server_start(struct server *server, const char *serial,             uint16_t local_port, uint16_t max_size, uint32_t bit_rate,             const char *crop, bool send_frame_meta) {    server->local_port = local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        SDL_free((void *) server->serial);        return false;    }    if (!enable_tunnel(server)) {        SDL_free((void *) server->serial);        return false;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, local_port);            disable_tunnel(server);            SDL_free((void *) server->serial);            return false;        }    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate,                                     server->tunnel_forward, crop,                                     send_frame_meta);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free((void *) server->serial);        return false;    }    server->tunnel_enabled = true;    return true;}
execute_server(const char *serial,               uint16_t max_size, uint32_t bit_rate,               bool tunnel_forward, const char *crop,               bool send_frame_meta) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        tunnel_forward ? "true" : "false",        crop ? crop : "-",        send_frame_meta ? "true" : "false",    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
    process_t process = adb_forward(serial, local_port, SOCKET_NAME);    return process_check_success(process, "adb forward");}static bool
frame_meta_new(Uint64 pts) {    struct frame_meta *meta = malloc(sizeof(*meta));    if (!meta) {        return meta;    }    meta->pts = pts;    meta->next = NULL;    return meta;}
read_packet_with_meta(void *opaque, uint8_t *buf, int buf_size) {    struct stream *stream = opaque;    struct receiver_state *state = &stream->receiver_state;    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    if (!state->remaining) {#define HEADER_SIZE 12        uint8_t header[HEADER_SIZE];        ssize_t r = net_recv_all(stream->socket, header, HEADER_SIZE);        if (r == -1) {            return AVERROR(errno);        }        if (r == 0) {            return AVERROR_EOF;        }        // no partial read (net_recv_all())        SDL_assert_release(r == HEADER_SIZE);        Uint64 pts = buffer_read64be(header);        state->remaining = buffer_read32be(&header[8]);        if (pts != NO_PTS && !receiver_state_push_meta(state, pts)) {            LOGE("Could not store PTS for recording");            // we cannot save the PTS, the recording would be broken            return AVERROR(ENOMEM);        }    }    SDL_assert(state->remaining);    if (buf_size > state->remaining) {        buf_size = state->remaining;    }    ssize_t r = net_recv(stream->socket, buf, buf_size);    if (r == -1) {        return AVERROR(errno);    }    if (r == 0) {        return AVERROR_EOF;    }    SDL_assert(state->remaining >= r);    state->remaining -= r;    return r;}
run_stream(void *data) {    struct stream *stream = data;    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto end;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto finally_free_format_ctx;    }    // initialize the receiver state    stream->receiver_state.frame_meta_queue = NULL;    stream->receiver_state.remaining = 0;    // if recording is enabled, a "header" is sent between raw packets    int (*read_packet)(void *, uint8_t *, int) =            stream->recorder ? read_packet_with_meta : read_raw_packet;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, stream,                                               read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto finally_free_avio_ctx;    }    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto end;    }    if (stream->decoder && !decoder_open(stream->decoder, codec)) {        LOGE("Could not open decoder");        goto finally_close_input;    }    if (stream->recorder && !recorder_open(stream->recorder, codec)) {        LOGE("Could not open recorder");        goto finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {        if (stream->decoder && !decoder_push(stream->decoder, &packet)) {            av_packet_unref(&packet);            goto quit;        }        if (stream->recorder) {            // we retrieve the PTS in order they were received, so they will            // be assigned to the correct frame            Uint64 pts = receiver_state_take_meta(&stream->receiver_state);            packet.pts = pts;            packet.dts = pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(stream->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");quit:    if (stream->recorder) {        recorder_close(stream->recorder);    }finally_close_input:    avformat_close_input(&format_ctx);finally_free_avio_ctx:    av_free(avio_ctx->buffer);    av_free(avio_ctx);finally_free_format_ctx:    avformat_free_context(format_ctx);end:    notify_stopped();    return 0;}
receiver_state_take_meta(struct receiver_state *state) {    struct frame_meta *frame_meta = state->frame_meta_queue; // first item    SDL_assert(frame_meta); // must not be empty    Uint64 pts = frame_meta->pts;    state->frame_meta_queue = frame_meta->next; // remove the item    frame_meta_delete(frame_meta);    return pts;}
stream_start(struct stream *stream) {    LOGD("Starting stream thread");    stream->thread = SDL_CreateThread(run_stream, "stream", stream);    if (!stream->thread) {        LOGC("Could not start stream thread");        return SDL_FALSE;    }    return SDL_TRUE;}
frame_meta_new(Uint64 pts) {    struct frame_meta *meta = malloc(sizeof(*meta));    if (!meta) {        return meta;    }    meta->pts = pts;    meta->next = NULL;    return meta;}
receiver_state_push_meta(struct receiver_state *state, Uint64 pts) {    struct frame_meta *frame_meta = frame_meta_new(pts);    if (!frame_meta) {        return SDL_FALSE;    }    // append to the list    // (iterate to find the last item, in practice the list should be tiny)    struct frame_meta **p = &state->frame_meta_queue;    while (*p) {        p = &(*p)->next;    }    *p = frame_meta;    return SDL_TRUE;}
receiver_state_push_meta(struct receiver_state *state, Uint64 pts) {    struct frame_meta *frame_meta = frame_meta_new(pts);    if (!frame_meta) {        return SDL_FALSE;    }    // append to the list    // (iterate to find the last item, in practice the list should be tiny)    struct frame_meta **p = &state->frame_meta_queue;    while (*p) {        p = &(*p)->next;    }    *p = frame_meta;    return SDL_TRUE;}
frame_meta_new(uint64_t pts) {    struct frame_meta *meta = malloc(sizeof(*meta));    if (!meta) {        return meta;    }    meta->pts = pts;    meta->next = NULL;    return meta;}
read_packet_with_meta(void *opaque, uint8_t *buf, int buf_size) {    struct stream *stream = opaque;    struct receiver_state *state = &stream->receiver_state;    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    if (!state->remaining) {#define HEADER_SIZE 12        uint8_t header[HEADER_SIZE];        ssize_t r = net_recv_all(stream->socket, header, HEADER_SIZE);        if (r == -1) {            return AVERROR(errno);        }        if (r == 0) {            return AVERROR_EOF;        }        // no partial read (net_recv_all())        SDL_assert_release(r == HEADER_SIZE);        uint64_t pts = buffer_read64be(header);        state->remaining = buffer_read32be(&header[8]);        if (pts != NO_PTS && !receiver_state_push_meta(state, pts)) {            LOGE("Could not store PTS for recording");            // we cannot save the PTS, the recording would be broken            return AVERROR(ENOMEM);        }    }    SDL_assert(state->remaining);    if (buf_size > state->remaining) {        buf_size = state->remaining;    }    ssize_t r = net_recv(stream->socket, buf, buf_size);    if (r == -1) {        return AVERROR(errno);    }    if (r == 0) {        return AVERROR_EOF;    }    SDL_assert(state->remaining >= r);    state->remaining -= r;    return r;}
run_stream(void *data) {    struct stream *stream = data;    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto end;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto finally_free_format_ctx;    }    // initialize the receiver state    stream->receiver_state.frame_meta_queue = NULL;    stream->receiver_state.remaining = 0;    // if recording is enabled, a "header" is sent between raw packets    int (*read_packet)(void *, uint8_t *, int) =            stream->recorder ? read_packet_with_meta : read_raw_packet;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, stream,                                               read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto finally_free_avio_ctx;    }    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto end;    }    if (stream->decoder && !decoder_open(stream->decoder, codec)) {        LOGE("Could not open decoder");        goto finally_close_input;    }    if (stream->recorder && !recorder_open(stream->recorder, codec)) {        LOGE("Could not open recorder");        goto finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {        if (stream->decoder && !decoder_push(stream->decoder, &packet)) {            av_packet_unref(&packet);            goto quit;        }        if (stream->recorder) {            // we retrieve the PTS in order they were received, so they will            // be assigned to the correct frame            uint64_t pts = receiver_state_take_meta(&stream->receiver_state);            packet.pts = pts;            packet.dts = pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(stream->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");quit:    if (stream->recorder) {        recorder_close(stream->recorder);    }finally_close_input:    avformat_close_input(&format_ctx);finally_free_avio_ctx:    av_free(avio_ctx->buffer);    av_free(avio_ctx);finally_free_format_ctx:    avformat_free_context(format_ctx);end:    notify_stopped();    return 0;}
receiver_state_take_meta(struct receiver_state *state) {    struct frame_meta *frame_meta = state->frame_meta_queue; // first item    SDL_assert(frame_meta); // must not be empty    uint64_t pts = frame_meta->pts;    state->frame_meta_queue = frame_meta->next; // remove the item    frame_meta_delete(frame_meta);    return pts;}
stream_start(struct stream *stream) {    LOGD("Starting stream thread");    stream->thread = SDL_CreateThread(run_stream, "stream", stream);    if (!stream->thread) {        LOGC("Could not start stream thread");        return false;    }    return true;}
frame_meta_new(uint64_t pts) {    struct frame_meta *meta = malloc(sizeof(*meta));    if (!meta) {        return meta;    }    meta->pts = pts;    meta->next = NULL;    return meta;}
receiver_state_push_meta(struct receiver_state *state, uint64_t pts) {    struct frame_meta *frame_meta = frame_meta_new(pts);    if (!frame_meta) {        return false;    }    // append to the list    // (iterate to find the last item, in practice the list should be tiny)    struct frame_meta **p = &state->frame_meta_queue;    while (*p) {        p = &(*p)->next;    }    *p = frame_meta;    return true;}
receiver_state_push_meta(struct receiver_state *state, uint64_t pts) {    struct frame_meta *frame_meta = frame_meta_new(pts);    if (!frame_meta) {        return false;    }    // append to the list    // (iterate to find the last item, in practice the list should be tiny)    struct frame_meta **p = &state->frame_meta_queue;    while (*p) {        p = &(*p)->next;    }    *p = frame_meta;    return true;}
net_init(void) {    // do nothing    return SDL_TRUE;}
net_init(void) {    // do nothing    return true;}
net_init(void) {    WSADATA wsa;    int res = WSAStartup(MAKEWORD(2, 2), &wsa) < 0;    if (res < 0) {        LOGC("WSAStartup failed with error %d", res);        return SDL_FALSE;    }    return SDL_TRUE;}
net_init(void) {    WSADATA wsa;    int res = WSAStartup(MAKEWORD(2, 2), &wsa) < 0;    if (res < 0) {        LOGC("WSAStartup failed with error %d", res);        return false;    }    return true;}
read_xpm(char *xpm[]) {#if SDL_ASSERT_LEVEL >= 2    // patch the XPM to change the icon color in debug mode    xpm[2] = ".	c #CC00CC";#endif    char *endptr;    // *** No error handling, assume the XPM source is valid ***    // (it's in our source repo)    // Assertions are only checked in debug    int width = strtol(xpm[0], &endptr, 10);    int height = strtol(endptr + 1, &endptr, 10);    int colors = strtol(endptr + 1, &endptr, 10);    int chars = strtol(endptr + 1, &endptr, 10);    // sanity checks    SDL_assert(0 <= width && width < 256);    SDL_assert(0 <= height && height < 256);    SDL_assert(0 <= colors && colors < 256);    SDL_assert(chars == 1); // this implementation does not support more    // init index    struct index index[colors];    for (int i = 0; i < colors; ++i) {        const char *line = xpm[1+i];        index[i].c = line[0];        SDL_assert(line[1] == '\t');        SDL_assert(line[2] == 'c');        SDL_assert(line[3] == ' ');        if (line[4] == '#') {            index[i].color = 0xff000000 | strtol(&line[5], &endptr, 0x10);            SDL_assert(*endptr == '\0');        } else {            SDL_assert(!strcmp("None", &line[4]));            index[i].color = 0;        }    }    // parse image    Uint32 *pixels = SDL_malloc(4 * width * height);    if (!pixels) {        LOGE("Could not allocate icon memory");        return NULL;    }    for (int y = 0; y < height; ++y) {        const char *line = xpm[1 + colors + y];        for (int x = 0; x < width; ++x) {            char c = line[x];            Uint32 color;            SDL_bool color_found = find_color(index, colors, c, &color);            SDL_assert(color_found);            pixels[y * width + x] = color;        }    }#if SDL_BYTEORDER == SDL_BIG_ENDIAN    Uint32 amask = 0x000000ff;    Uint32 rmask = 0x0000ff00;    Uint32 gmask = 0x00ff0000;    Uint32 bmask = 0xff000000;#else // little endian, like x86    Uint32 amask = 0xff000000;    Uint32 rmask = 0x00ff0000;    Uint32 gmask = 0x0000ff00;    Uint32 bmask = 0x000000ff;#endif    SDL_Surface *surface = SDL_CreateRGBSurfaceFrom(pixels,                                                    width, height,                                                    32, 4 * width,                                                    rmask, gmask, bmask, amask);    // make the surface own the raw pixels    surface->flags &= ~SDL_PREALLOC;    return surface;}
find_color(struct index *index, int len, char c, Uint32 *color) {    // there are typically very few color, so it's ok to iterate over the array    for (int i = 0; i < len; ++i) {        if (index[i].c == c) {            *color = index[i].color;            return SDL_TRUE;        }    }    *color = 0;    return SDL_FALSE;}
find_color(struct index *index, int len, char c, Uint32 *color) {    // there are typically very few color, so it's ok to iterate over the array    for (int i = 0; i < len; ++i) {        if (index[i].c == c) {            *color = index[i].color;            return SDL_TRUE;        }    }    *color = 0;    return SDL_FALSE;}
read_xpm(char *xpm[]) {#if SDL_ASSERT_LEVEL >= 2    // patch the XPM to change the icon color in debug mode    xpm[2] = ".	c #CC00CC";#endif    char *endptr;    // *** No error handling, assume the XPM source is valid ***    // (it's in our source repo)    // Assertions are only checked in debug    int width = strtol(xpm[0], &endptr, 10);    int height = strtol(endptr + 1, &endptr, 10);    int colors = strtol(endptr + 1, &endptr, 10);    int chars = strtol(endptr + 1, &endptr, 10);    // sanity checks    SDL_assert(0 <= width && width < 256);    SDL_assert(0 <= height && height < 256);    SDL_assert(0 <= colors && colors < 256);    SDL_assert(chars == 1); // this implementation does not support more    // init index    struct index index[colors];    for (int i = 0; i < colors; ++i) {        const char *line = xpm[1+i];        index[i].c = line[0];        SDL_assert(line[1] == '\t');        SDL_assert(line[2] == 'c');        SDL_assert(line[3] == ' ');        if (line[4] == '#') {            index[i].color = 0xff000000 | strtol(&line[5], &endptr, 0x10);            SDL_assert(*endptr == '\0');        } else {            SDL_assert(!strcmp("None", &line[4]));            index[i].color = 0;        }    }    // parse image    uint32_t *pixels = SDL_malloc(4 * width * height);    if (!pixels) {        LOGE("Could not allocate icon memory");        return NULL;    }    for (int y = 0; y < height; ++y) {        const char *line = xpm[1 + colors + y];        for (int x = 0; x < width; ++x) {            char c = line[x];            uint32_t color;            bool color_found = find_color(index, colors, c, &color);            SDL_assert(color_found);            pixels[y * width + x] = color;        }    }#if SDL_BYTEORDER == SDL_BIG_ENDIAN    uint32_t amask = 0x000000ff;    uint32_t rmask = 0x0000ff00;    uint32_t gmask = 0x00ff0000;    uint32_t bmask = 0xff000000;#else // little endian, like x86    uint32_t amask = 0xff000000;    uint32_t rmask = 0x00ff0000;    uint32_t gmask = 0x0000ff00;    uint32_t bmask = 0x000000ff;#endif    SDL_Surface *surface = SDL_CreateRGBSurfaceFrom(pixels,                                                    width, height,                                                    32, 4 * width,                                                    rmask, gmask, bmask, amask);    // make the surface own the raw pixels    surface->flags &= ~SDL_PREALLOC;    return surface;}
find_color(struct index *index, int len, char c, uint32_t *color) {    // there are typically very few color, so it's ok to iterate over the array    for (int i = 0; i < len; ++i) {        if (index[i].c == c) {            *color = index[i].color;            return true;        }    }    *color = 0;    return false;}
static boolfind_color(struct index *index, int len, char c, uint32_t *color) {    // there are typically very few color, so it's ok to iterate over the array    for (int i = 0; i < len; ++i) {        if (index[i].c == c) {            *color = index[i].color;            return true;        }    }    *color = 0;    return false;
video_buffer_offer_decoded_frame(struct video_buffer *vb) {    mutex_lock(vb->mutex);#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then the decoder must wait for the current    // frame to be consumed    while (!vb->rendering_frame_consumed && !vb->interrupted) {        cond_wait(vb->rendering_frame_consumed_cond, vb->mutex);    }#else    if (vb->fps_counter.started && !vb->rendering_frame_consumed) {        fps_counter_add_skipped_frame(&vb->fps_counter);    }#endif    video_buffer_swap_frames(vb);    SDL_bool previous_frame_consumed = vb->rendering_frame_consumed;    vb->rendering_frame_consumed = SDL_FALSE;    mutex_unlock(vb->mutex);    return previous_frame_consumed;}
video_buffer_init(struct video_buffer *vb) {    if (!(vb->decoding_frame = av_frame_alloc())) {        goto error_0;    }    if (!(vb->rendering_frame = av_frame_alloc())) {        goto error_1;    }    if (!(vb->mutex = SDL_CreateMutex())) {        goto error_2;    }#ifndef SKIP_FRAMES    if (!(vb->rendering_frame_consumed_cond = SDL_CreateCond())) {        SDL_DestroyMutex(vb->mutex);        goto error_2;    }    vb->interrupted = SDL_FALSE;#endif    // there is initially no rendering frame, so consider it has already been    // consumed    vb->rendering_frame_consumed = SDL_TRUE;    fps_counter_init(&vb->fps_counter);    return SDL_TRUE;error_2:    av_frame_free(&vb->rendering_frame);error_1:    av_frame_free(&vb->decoding_frame);error_0:    return SDL_FALSE;}
video_buffer_interrupt(struct video_buffer *vb) {#ifdef SKIP_FRAMES    (void) vb; // unused#else    mutex_lock(vb->mutex);    vb->interrupted = SDL_TRUE;    mutex_unlock(vb->mutex);    // wake up blocking wait    cond_signal(vb->rendering_frame_consumed_cond);#endif}
video_buffer_consume_rendered_frame(struct video_buffer *vb) {    SDL_assert(!vb->rendering_frame_consumed);    vb->rendering_frame_consumed = SDL_TRUE;    if (vb->fps_counter.started) {        fps_counter_add_rendered_frame(&vb->fps_counter);    }#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then notify the decoder the current frame is    // consumed, so that it may push a new one    cond_signal(vb->rendering_frame_consumed_cond);#endif    return vb->rendering_frame;}
video_buffer_offer_decoded_frame(struct video_buffer *vb) {    mutex_lock(vb->mutex);#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then the decoder must wait for the current    // frame to be consumed    while (!vb->rendering_frame_consumed && !vb->interrupted) {        cond_wait(vb->rendering_frame_consumed_cond, vb->mutex);    }#else    if (vb->fps_counter.started && !vb->rendering_frame_consumed) {        fps_counter_add_skipped_frame(&vb->fps_counter);    }#endif    video_buffer_swap_frames(vb);    bool previous_frame_consumed = vb->rendering_frame_consumed;    vb->rendering_frame_consumed = false;    mutex_unlock(vb->mutex);    return previous_frame_consumed;}
video_buffer_init(struct video_buffer *vb) {    if (!(vb->decoding_frame = av_frame_alloc())) {        goto error_0;    }    if (!(vb->rendering_frame = av_frame_alloc())) {        goto error_1;    }    if (!(vb->mutex = SDL_CreateMutex())) {        goto error_2;    }#ifndef SKIP_FRAMES    if (!(vb->rendering_frame_consumed_cond = SDL_CreateCond())) {        SDL_DestroyMutex(vb->mutex);        goto error_2;    }    vb->interrupted = false;#endif    // there is initially no rendering frame, so consider it has already been    // consumed    vb->rendering_frame_consumed = true;    fps_counter_init(&vb->fps_counter);    return true;error_2:    av_frame_free(&vb->rendering_frame);error_1:    av_frame_free(&vb->decoding_frame);error_0:    return false;}
video_buffer_interrupt(struct video_buffer *vb) {#ifdef SKIP_FRAMES    (void) vb; // unused#else    mutex_lock(vb->mutex);    vb->interrupted = true;    mutex_unlock(vb->mutex);    // wake up blocking wait    cond_signal(vb->rendering_frame_consumed_cond);#endif}
video_buffer_consume_rendered_frame(struct video_buffer *vb) {    SDL_assert(!vb->rendering_frame_consumed);    vb->rendering_frame_consumed = true;    if (vb->fps_counter.started) {        fps_counter_add_rendered_frame(&vb->fps_counter);    }#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then notify the decoder the current frame is    // consumed, so that it may push a new one    cond_signal(vb->rendering_frame_consumed_cond);#endif    return vb->rendering_frame;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .window_title = NULL,        .push_target = NULL,        .record_format = 0,        .help = false,        .version = false,        .show_touches = false,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = false,        .no_control = false,        .no_display = false,        .turn_screen_off = false,        .render_expired_frames = false,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .window_title = args.window_title,        .push_target = args.push_target,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,        .control = !args.no_control,        .display = !args.no_display,        .turn_screen_off = args.turn_screen_off,        .render_expired_frames = args.render_expired_frames,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .window_title = NULL,        .push_target = NULL,        .record_format = 0,        .help = false,        .version = false,        .show_touches = false,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = false,        .no_control = false,        .no_display = false,        .turn_screen_off = false,        .render_expired_frames = false,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    LOGI("scrcpy " SCRCPY_VERSION " <https://github.com/Genymobile/scrcpy>");#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .window_title = args.window_title,        .push_target = args.push_target,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,        .control = !args.no_control,        .display = !args.no_display,        .turn_screen_off = args.turn_screen_off,        .render_expired_frames = args.render_expired_frames,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
static int parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"bit-rate", required_argument, NULL, 'b'},        {"help",     no_argument,       NULL, 'h'},        {"max-size", required_argument, NULL, 'm'},        {"port",     required_argument, NULL, 'p'},        {"version",  no_argument,       NULL, 'v'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:hm:p:v", long_options, NULL)) != -1) {        switch (c) {            case 'b': {                char *endptr;                if (*optarg == '\0') {                    LOGE("Bit-rate parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                int mul = 1;                if (*endptr != '\0') {                    if (optarg == endptr) {                        LOGE("Invalid bit-rate: %s", optarg);                        return -1;                    }                    if ((*endptr == 'M' || *endptr == 'm') && endptr[1] == '\0') {                        mul = 1000000;                    } else if ((*endptr == 'K' || *endptr == 'k') && endptr[1] == '\0') {                        mul = 1000;                    } else {                        LOGE("Invalid bit-rate unit: %s", optarg);                        return -1;                    }                }                if (value < 0 || ((Uint32) -1) / mul < value) {                    LOGE("Bitrate must be positive and less than 2^32: %s", optarg);                    return -1;                }                args->bit_rate = (Uint32) value * mul;                break;            }            case 'h': {                args->help = SDL_TRUE;                break;            }            case 'm': {                char *endptr;                if (*optarg == '\0') {                    LOGE("Max size parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                if (*endptr != '\0') {                    LOGE("Invalid max size: %s", optarg);                    return -1;                }                if (value & ~0xffff) {                    LOGE("Max size must be between 0 and 65535: %ld", value);                    return -1;                }                args->max_size = (Uint16) value;                break;            }            case 'p': {                char *endptr;                if (*optarg == '\0') {                    LOGE("Invalid port parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                if (*endptr != '\0') {                    LOGE("Invalid port: %s", optarg);                    return -1;                }                if (value & ~0xffff) {                    LOGE("Port out of range: %ld", value);                    return -1;                }                args->port = (Uint16) value;                break;            }            case 'v': {                args->version = SDL_TRUE;                break;            }            default:                // getopt prints the error message on stderr                return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return -1;    }    return 0;}
int main(int argc, char *argv[]) {    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (parse_args(&args, argc, argv)) {        usage(argv[0]);        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    int res = scrcpy(args.serial, args.port, args.max_size, args.bit_rate) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"bit-rate", required_argument, NULL, 'b'},        {"help",     no_argument,       NULL, 'h'},        {"max-size", required_argument, NULL, 'm'},        {"port",     required_argument, NULL, 'p'},        {"version",  no_argument,       NULL, 'v'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:hm:p:v", long_options, NULL)) != -1) {        switch (c) {            case 'b': {                char *endptr;                if (*optarg == '\0') {                    LOGE("Bit-rate parameter is empty");                    return SDL_FALSE;                }                long value = strtol(optarg, &endptr, 0);                int mul = 1;                if (*endptr != '\0') {                    if (optarg == endptr) {                        LOGE("Invalid bit-rate: %s", optarg);                        return SDL_FALSE;                    }                    if ((*endptr == 'M' || *endptr == 'm') && endptr[1] == '\0') {                        mul = 1000000;                    } else if ((*endptr == 'K' || *endptr == 'k') && endptr[1] == '\0') {                        mul = 1000;                    } else {                        LOGE("Invalid bit-rate unit: %s", optarg);                        return SDL_FALSE;                    }                }                if (value < 0 || ((Uint32) -1) / mul < value) {                    LOGE("Bitrate must be positive and less than 2^32: %s", optarg);                    return SDL_FALSE;                }                args->bit_rate = (Uint32) value * mul;                break;            }            case 'h': {                args->help = SDL_TRUE;                break;            }            case 'm': {                char *endptr;                if (*optarg == '\0') {                    LOGE("Max size parameter is empty");                    return SDL_FALSE;                }                long value = strtol(optarg, &endptr, 0);                if (*endptr != '\0') {                    LOGE("Invalid max size: %s", optarg);                    return SDL_FALSE;                }                if (value & ~0xffff) {                    LOGE("Max size must be between 0 and 65535: %ld", value);                    return SDL_FALSE;                }                args->max_size = (Uint16) value;                break;            }            case 'p': {                char *endptr;                if (*optarg == '\0') {                    LOGE("Invalid port parameter is empty");                    return SDL_FALSE;                }                long value = strtol(optarg, &endptr, 0);                if (*endptr != '\0') {                    LOGE("Invalid port: %s", optarg);                    return SDL_FALSE;                }                if (value & ~0xffff) {                    LOGE("Port out of range: %ld", value);                    return SDL_FALSE;                }                args->port = (Uint16) value;                break;            }            case 'v': {                args->version = SDL_TRUE;                break;            }            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    return SDL_TRUE;}
int main(int argc, char *argv[]) {    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        usage(argv[0]);        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    int res = scrcpy(args.serial, args.port, args.max_size, args.bit_rate) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
    public void setScreenPowerMode(int mode) {        IBinder d = SurfaceControl.getBuiltInDisplay(0);        SurfaceControl.setDisplayPowerMode(d, mode);        Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));    }
    public void setScreenPowerMode(int mode) {        IBinder d = SurfaceControl.getBuiltInDisplay(0);        if (d == null) {            Ln.e("Could not get built-in display");            return;        }        SurfaceControl.setDisplayPowerMode(d, mode);        Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));    }
    public ClipboardManager(IInterface manager) {        this.manager = manager;        try {            getPrimaryClipMethod = manager.getClass().getMethod("getPrimaryClip", String.class);            setPrimaryClipMethod = manager.getClass().getMethod("setPrimaryClip", ClipData.class, String.class);        } catch (NoSuchMethodException e) {            throw new AssertionError(e);        }    }
    public CharSequence getText() {        try {            ClipData clipData = (ClipData) getPrimaryClipMethod.invoke(manager, "com.android.shell");            if (clipData == null || clipData.getItemCount() == 0) {                return null;            }            return clipData.getItemAt(0).getText();        } catch (InvocationTargetException | IllegalAccessException e) {            throw new AssertionError(e);        }    }
    public void setText(CharSequence text) {        ClipData clipData = ClipData.newPlainText(null, text);        try {            setPrimaryClipMethod.invoke(manager, clipData, "com.android.shell");        } catch (InvocationTargetException | IllegalAccessException e) {            throw new AssertionError(e);        }    }}
    public ClipboardManager(IInterface manager) {        this.manager = manager;    }
    public CharSequence getText() {        Method method = getGetPrimaryClipMethod();        if (method == null) {            return null;        }        try {            ClipData clipData = (ClipData) method.invoke(manager, "com.android.shell");            if (clipData == null || clipData.getItemCount() == 0) {                return null;            }            return clipData.getItemAt(0).getText();        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);            return null;        }    }
    public void setText(CharSequence text) {        Method method = getSetPrimaryClipMethod();        if (method == null) {            return;        }        ClipData clipData = ClipData.newPlainText(null, text);        try {            method.invoke(manager, clipData, "com.android.shell");        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);        }    }}
    public boolean injectInputEvent(InputEvent inputEvent, int mode) {        try {            return (Boolean) injectInputEventMethod.invoke(manager, inputEvent, mode);        } catch (InvocationTargetException | IllegalAccessException e) {            throw new AssertionError(e);        }    }}
    public InputManager(IInterface manager) {        this.manager = manager;        try {            injectInputEventMethod = manager.getClass().getMethod("injectInputEvent", InputEvent.class, int.class);        } catch (NoSuchMethodException e) {            throw new AssertionError(e);        }    }
    public boolean injectInputEvent(InputEvent inputEvent, int mode) {        Method method = getInjectInputEventMethod();        if (method == null) {            return false;        }        try {            return (Boolean) method.invoke(manager, inputEvent, mode);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);            return false;        }    }}
    public InputManager(IInterface manager) {        this.manager = manager;    }
    public PowerManager(IInterface manager) {        this.manager = manager;        try {            @SuppressLint("ObsoleteSdkInt") // we may lower minSdkVersion in the future            String methodName = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT_WATCH ? "isInteractive" : "isScreenOn";            isScreenOnMethod = manager.getClass().getMethod(methodName);        } catch (NoSuchMethodException e) {            throw new AssertionError(e);        }    }
    public PowerManager(IInterface manager) {        this.manager = manager;        try {            @SuppressLint("ObsoleteSdkInt") // we may lower minSdkVersion in the future            String methodName = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT_WATCH ? "isInteractive" : "isScreenOn";            isScreenOnMethod = manager.getClass().getMethod(methodName);        } catch (NoSuchMethodException e) {            throw new AssertionError(e);        }    }
    public boolean isScreenOn() {        try {            return (Boolean) isScreenOnMethod.invoke(manager);        } catch (InvocationTargetException | IllegalAccessException e) {            throw new AssertionError(e);        }    }}
    public PowerManager(IInterface manager) {        this.manager = manager;    }
    private Method getIsScreenOnMethod() {        if (isScreenOnMethod == null) {            try {                @SuppressLint("ObsoleteSdkInt") // we may lower minSdkVersion in the future                        String methodName = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT_WATCH ? "isInteractive" : "isScreenOn";                isScreenOnMethod = manager.getClass().getMethod(methodName);            } catch (NoSuchMethodException e) {                Ln.e("Could not find method", e);            }        }        return isScreenOnMethod;    }
    public boolean isScreenOn() {        Method method = getIsScreenOnMethod();        if (method == null) {            return false;        }        try {            return (Boolean) method.invoke(manager);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);            return false;        }    }}
    public void expandNotificationsPanel() {        if (expandNotificationsPanelMethod == null) {            try {                expandNotificationsPanelMethod = manager.getClass().getMethod("expandNotificationsPanel");            } catch (NoSuchMethodException e) {                Ln.e("ServiceBarManager.expandNotificationsPanel() is not available on this device");                return;            }        }        try {            expandNotificationsPanelMethod.invoke(manager);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke ServiceBarManager.expandNotificationsPanel()", e);        }    }
    public void expandNotificationsPanel() {        if (expandNotificationsPanelMethod == null) {            try {                expandNotificationsPanelMethod = manager.getClass().getMethod("expandNotificationsPanel");            } catch (NoSuchMethodException e) {                Ln.e("ServiceBarManager.expandNotificationsPanel() is not available on this device");                return;            }        }        try {            expandNotificationsPanelMethod.invoke(manager);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke ServiceBarManager.expandNotificationsPanel()", e);        }    }
    public void expandNotificationsPanel() {        if (expandNotificationsPanelMethod == null) {            try {                expandNotificationsPanelMethod = manager.getClass().getMethod("expandNotificationsPanel");            } catch (NoSuchMethodException e) {                Ln.e("ServiceBarManager.expandNotificationsPanel() is not available on this device");                return;            }        }        try {            expandNotificationsPanelMethod.invoke(manager);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke ServiceBarManager.expandNotificationsPanel()", e);        }    }
    public void collapsePanels() {        if (collapsePanelsMethod == null) {            try {                collapsePanelsMethod = manager.getClass().getMethod("collapsePanels");            } catch (NoSuchMethodException e) {                Ln.e("ServiceBarManager.collapsePanels() is not available on this device");                return;            }        }        try {            collapsePanelsMethod.invoke(manager);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke ServiceBarManager.collapsePanels()", e);        }    }}
    public void expandNotificationsPanel() {        Method method = getExpandNotificationsPanelMethod();        if (method == null) {            return;        }        try {            method.invoke(manager);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);        }    }
    private Method getCollapsePanelsMethod() {        if (collapsePanelsMethod == null) {            try {                collapsePanelsMethod = manager.getClass().getMethod("collapsePanels");            } catch (NoSuchMethodException e) {                Ln.e("Could not find method", e);            }        }        return collapsePanelsMethod;    }
    private Method getExpandNotificationsPanelMethod() {        if (expandNotificationsPanelMethod == null) {            try {                expandNotificationsPanelMethod = manager.getClass().getMethod("expandNotificationsPanel");            } catch (NoSuchMethodException e) {                Ln.e("Could not find method", e);            }        }        return expandNotificationsPanelMethod;    }
    public void collapsePanels() {        Method method = getCollapsePanelsMethod();        if (method == null) {            return;        }        try {            method.invoke(manager);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);        }    }}
    public static IBinder getBuiltInDisplay(int builtInDisplayId) {        try {            // the method signature has changed in Android Q            // <https://github.com/Genymobile/scrcpy/issues/586>            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                return (IBinder) CLASS.getMethod("getBuiltInDisplay", int.class).invoke(null, builtInDisplayId);            }            return (IBinder) CLASS.getMethod("getPhysicalDisplayToken", long.class).invoke(null, builtInDisplayId);        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public static IBinder getBuiltInDisplay(int builtInDisplayId) {        try {            // the method signature has changed in Android Q            // <https://github.com/Genymobile/scrcpy/issues/586>            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                return (IBinder) CLASS.getMethod("getBuiltInDisplay", int.class).invoke(null, builtInDisplayId);            }            return (IBinder) CLASS.getMethod("getPhysicalDisplayToken", long.class).invoke(null, builtInDisplayId);        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public static void setDisplayPowerMode(IBinder displayToken, int mode) {        try {            CLASS.getMethod("setDisplayPowerMode", IBinder.class, int.class).invoke(null, displayToken, mode);        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public static void setDisplayPowerMode(IBinder displayToken, int mode) {        try {            CLASS.getMethod("setDisplayPowerMode", IBinder.class, int.class).invoke(null, displayToken, mode);        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public static IBinder getBuiltInDisplay(int builtInDisplayId) {        Method method = getGetBuiltInDisplayMethod();        if (method == null) {            return null;        }        try {            return (IBinder) method.invoke(null, builtInDisplayId);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);            return null;        }    }
    private static Method getGetBuiltInDisplayMethod() {        if (getBuiltInDisplayMethod == null) {            try {                // the method signature has changed in Android Q                // <https://github.com/Genymobile/scrcpy/issues/586>                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                    getBuiltInDisplayMethod = CLASS.getMethod("getBuiltInDisplay", int.class);                } else {                    getBuiltInDisplayMethod = CLASS.getMethod("getPhysicalDisplayToken", long.class);                }            } catch (NoSuchMethodException e) {                Ln.e("Could not find method", e);            }        }        return getBuiltInDisplayMethod;    }
    public static void setDisplayPowerMode(IBinder displayToken, int mode) {        Method method = getSetDisplayPowerModeMethod();        if (method == null) {            return;        }        try {            method.invoke(null, displayToken, mode);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);        }    }
    private static Method getSetDisplayPowerModeMethod() {        if (setDisplayPowerModeMethod == null) {            try {                setDisplayPowerModeMethod = CLASS.getMethod("setDisplayPowerMode", IBinder.class, int.class);            } catch (NoSuchMethodException e) {                Ln.e("Could not find method", e);            }        }        return setDisplayPowerModeMethod;    }
process_t adb_push(const char *serial, const char *local, const char *remote) {    const char *const adb_cmd[] = {"push", local, remote};    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
process_t adb_remove_path(const char *serial, const char *path) {    const char *const adb_cmd[] = {"shell", "rm", path};    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
static SDL_bool push_server(const char *serial) {    process_t process = adb_push(serial, get_server_path(), "/data/local/tmp/scrcpy-server.jar");    return process_check_success(process, "adb push");}
static SDL_bool push_server(const char *serial) {    process_t process = adb_push(serial, get_server_path(), "/data/local/tmp/scrcpy-server.jar");    return process_check_success(process, "adb push");}
SDL_bool server_start(struct server *server, const char *serial, Uint16 local_port,                      Uint16 max_size, Uint32 bit_rate) {    if (!push_server(serial)) {        return SDL_FALSE;    }    if (!enable_tunnel(serial, local_port)) {        return SDL_FALSE;    }    // At the application level, the device part is "the server" because it    // serves video stream and control. However, at network level, the client    // listens and the server connects to the client. That way, the client can    // listen before starting the server app, so there is no need to try to    // connect until the server socket is listening on the device.    server->server_socket = listen_on_port(local_port);    if (server->server_socket == INVALID_SOCKET) {        LOGE("Could not listen on port %" PRIu16, local_port);        disable_tunnel(serial);        return SDL_FALSE;    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate);    if (server->process == PROCESS_NONE) {        close_socket(&server->server_socket);        disable_tunnel(serial);        return SDL_FALSE;    }    server->adb_reverse_enabled = SDL_TRUE;    return SDL_TRUE;}
void server_stop(struct server *server, const char *serial) {    SDL_assert(server->process != PROCESS_NONE);    if (server->device_socket != INVALID_SOCKET) {        // shutdown the socket to finish the device process gracefully        if (!net_shutdown(server->device_socket, SHUT_RDWR)) {            LOGW("Cannot shutdown socket");        }    }    LOGD("Waiting the server to complete execution on the device...");    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->adb_reverse_enabled) {        // ignore failure        disable_tunnel(serial);    }}
socket_t server_connect_to(struct server *server, const char *serial, Uint32 timeout_ms) {    server->device_socket = net_accept(server->server_socket);    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    // we don't need the server socket anymore    close_socket(&server->server_socket);    // we don't need the adb tunnel anymore    disable_tunnel(serial); // ignore failure    server->adb_reverse_enabled = SDL_FALSE;    return server->device_socket;}
static SDL_bool push_server(const char *serial) {    process_t process = adb_push(serial, get_server_path(), DEVICE_SERVER_PATH);    return process_check_success(process, "adb push");}
static SDL_bool remove_server(const char *serial) {    process_t process = adb_remove_path(serial, DEVICE_SERVER_PATH);    return process_check_success(process, "adb shell rm");}
SDL_bool server_start(struct server *server, const char *serial, Uint16 local_port,                      Uint16 max_size, Uint32 bit_rate) {    if (!push_server(serial)) {        return SDL_FALSE;    }    server->server_copied_to_device = SDL_TRUE;    if (!enable_tunnel(serial, local_port)) {        return SDL_FALSE;    }    // At the application level, the device part is "the server" because it    // serves video stream and control. However, at network level, the client    // listens and the server connects to the client. That way, the client can    // listen before starting the server app, so there is no need to try to    // connect until the server socket is listening on the device.    server->server_socket = listen_on_port(local_port);    if (server->server_socket == INVALID_SOCKET) {        LOGE("Could not listen on port %" PRIu16, local_port);        disable_tunnel(serial);        return SDL_FALSE;    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate);    if (server->process == PROCESS_NONE) {        close_socket(&server->server_socket);        disable_tunnel(serial);        return SDL_FALSE;    }    server->adb_reverse_enabled = SDL_TRUE;    return SDL_TRUE;}
void server_stop(struct server *server, const char *serial) {    SDL_assert(server->process != PROCESS_NONE);    if (server->device_socket != INVALID_SOCKET) {        // shutdown the socket to finish the device process gracefully        if (!net_shutdown(server->device_socket, SHUT_RDWR)) {            LOGW("Cannot shutdown socket");        }    }    LOGD("Waiting the server to complete execution on the device...");    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->adb_reverse_enabled) {        // ignore failure        disable_tunnel(serial);    }    if (server->server_copied_to_device) {        remove_server(serial); // ignore failure    }}
socket_t server_connect_to(struct server *server, const char *serial, Uint32 timeout_ms) {    server->device_socket = net_accept(server->server_socket);    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    // we don't need the server socket anymore    close_socket(&server->server_socket);    // the server is started, we can clean up the jar from the temporary folder    remove_server(serial); // ignore failure    server->server_copied_to_device = SDL_FALSE;    // we don't need the adb tunnel anymore    disable_tunnel(serial); // ignore failure    server->adb_reverse_enabled = SDL_FALSE;    return server->device_socket;}
static void handle_mouse_motion(const SDL_MouseMotionEvent *event, struct size screen_size) {    struct control_event control_event;    if (mouse_motion_from_sdl_to_android(event, screen_size, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse motion event");        }    }}
static void handle_mouse_motion(const SDL_MouseMotionEvent *event, struct size screen_size) {    if (!event->state) {        // do not send motion events when no button is pressed        return;    }    struct control_event control_event;    if (mouse_motion_from_sdl_to_android(event, screen_size, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse motion event");        }    }}
    // send UP event    control_event.keycode_event.action = AKEY_EVENT_ACTION_UP;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot send %s (UP)", name);    }}static inline void action_home(struct controller *controller) {    send_keycode(controller, AKEYCODE_HOME, "HOME");}static inline void action_back(struct controller *controller) {
    // send UP event    control_event.keycode_event.action = AKEY_EVENT_ACTION_UP;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot send %s (UP)", name);    }}static inline void action_home(struct controller *controller) {    send_keycode(controller, AKEYCODE_HOME, "HOME");}static inline void action_back(struct controller *controller) {
void screencontrol_handle_mouse_button(struct controller *controller,                                       struct screen *screen,                                       const SDL_MouseButtonEvent *event) {    if (event->button == SDL_BUTTON_RIGHT && event->type == SDL_MOUSEBUTTONDOWN) {        turn_screen_on(controller);        return;    };    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, screen->frame_size, &control_event)) {        if (!controller_push_event(controller, &control_event)) {            LOGW("Cannot send mouse button event");        }    }}
void screencontrol_handle_mouse_wheel(struct controller *controller,                                      struct screen *screen,                                      const SDL_MouseWheelEvent *event) {    struct position position = {        .screen_size = screen->frame_size,        .point = get_mouse_point(),    };    struct control_event control_event;    if (mouse_wheel_from_sdl_to_android(event, position, &control_event)) {        if (!controller_push_event(controller, &control_event)) {            LOGW("Cannot send wheel button event");        }    }}
void screencontrol_handle_text_input(struct controller *controller,                                     struct screen *screen,                                     const SDL_TextInputEvent *event) {    if (is_ctrl_down()) {        switch (event->text[0]) {            case '+':                action_volume_up(controller);                break;            case '-':                action_volume_down(controller);                break;        }        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    strncpy(control_event.text_event.text, event->text, TEXT_MAX_LENGTH);    control_event.text_event.text[TEXT_MAX_LENGTH] = '\0';    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot send text event");    }}
void screencontrol_handle_mouse_motion(struct controller *controller,                                       struct screen *screen,                                       const SDL_MouseMotionEvent *event) {    if (!event->state) {        // do not send motion events when no button is pressed        return;    }    struct control_event control_event;    if (mouse_motion_from_sdl_to_android(event, screen->frame_size, &control_event)) {        if (!controller_push_event(controller, &control_event)) {            LOGW("Cannot send mouse motion event");        }    }}
void screencontrol_handle_mouse_motion(struct controller *controller,                                       struct screen *screen,                                       const SDL_MouseMotionEvent *event) {    if (!event->state) {        // do not send motion events when no button is pressed        return;    }    struct control_event control_event;    if (mouse_motion_from_sdl_to_android(event, screen->frame_size, &control_event)) {        if (!controller_push_event(controller, &control_event)) {            LOGW("Cannot send mouse motion event");        }    }}
void screencontrol_handle_mouse_motion(struct controller *controller,                                       struct screen *screen,                                       const SDL_MouseMotionEvent *event) {    if (!event->state) {        // do not send motion events when no button is pressed        return;    }    struct control_event control_event;    if (mouse_motion_from_sdl_to_android(event, screen->frame_size, &control_event)) {        if (!controller_push_event(controller, &control_event)) {            LOGW("Cannot send mouse motion event");        }    }}
void screencontrol_handle_key(struct controller *controller,                              struct screen *screen,                              const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        switch (keycode) {            case SDLK_h:                action_home(controller);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(controller);                return;            case SDLK_m:                action_app_switch(controller);                return;            case SDLK_p:                action_power(controller);                return;            case SDLK_f:                screen_switch_fullscreen(screen);                return;            case SDLK_x:                screen_resize_to_fit(screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(screen);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
void screencontrol_handle_key(struct controller *controller,                              struct screen *screen,                              const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        switch (keycode) {            case SDLK_h:                action_home(controller);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(controller);                return;            case SDLK_m:                action_app_switch(controller);                return;            case SDLK_p:                action_power(controller);                return;            case SDLK_f:                screen_switch_fullscreen(screen);                return;            case SDLK_x:                screen_resize_to_fit(screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(screen);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
void input_manager_process_mouse_button(struct input_manager *input_manager,                                        const SDL_MouseButtonEvent *event) {    if (event->button == SDL_BUTTON_RIGHT && event->type == SDL_MOUSEBUTTONDOWN) {        turn_screen_on(input_manager->controller);        return;    };    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, input_manager->screen->frame_size, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send mouse button event");        }    }}
void input_manager_process_mouse_wheel(struct input_manager *input_manager,                                       const SDL_MouseWheelEvent *event) {    struct position position = {        .screen_size = input_manager->screen->frame_size,        .point = get_mouse_point(),    };    struct control_event control_event;    if (mouse_wheel_from_sdl_to_android(event, position, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send wheel button event");        }    }}
        turn_screen_on(input_manager->controller);        return;    };    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, input_manager->screen->frame_size, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send mouse button event");        }    }}void input_manager_process_mouse_wheel(struct input_manager *input_manager,                                       const SDL_MouseWheelEvent *event) {    struct position position = {        .screen_size = input_manager->screen->frame_size,
        .point = get_mouse_point(),    };    struct control_event control_event;    if (mouse_wheel_from_sdl_to_android(event, position, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send wheel button event");        }    }}
void input_manager_process_text_input(struct input_manager *input_manager,                                      const SDL_TextInputEvent *event) {    if (is_ctrl_down()) {        switch (event->text[0]) {            case '+':                action_volume_up(input_manager->controller);                break;            case '-':                action_volume_down(input_manager->controller);                break;        }        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    strncpy(control_event.text_event.text, event->text, TEXT_MAX_LENGTH);    control_event.text_event.text[TEXT_MAX_LENGTH] = '\0';    if (!controller_push_event(input_manager->controller, &control_event)) {        LOGW("Cannot send text event");    }}void input_manager_process_key(struct input_manager *input_manager,
    if (!event->state) {        // do not send motion events when no button is pressed        return;    }    struct control_event control_event;    if (mouse_motion_from_sdl_to_android(event, input_manager->screen->frame_size, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send mouse motion event");        }    }}void input_manager_process_mouse_button(struct input_manager *input_manager,                                        const SDL_MouseButtonEvent *event) {    if (event->button == SDL_BUTTON_RIGHT && event->type == SDL_MOUSEBUTTONDOWN) {
void input_manager_process_text_input(struct input_manager *input_manager,                                      const SDL_TextInputEvent *event) {    if (is_ctrl_down()) {        switch (event->text[0]) {            case '+':                action_volume_up(input_manager->controller);                break;            case '-':                action_volume_down(input_manager->controller);                break;        }        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    strncpy(control_event.text_event.text, event->text, TEXT_MAX_LENGTH);    control_event.text_event.text[TEXT_MAX_LENGTH] = '\0';    if (!controller_push_event(input_manager->controller, &control_event)) {        LOGW("Cannot send text event");    }}
void input_manager_process_mouse_motion(struct input_manager *input_manager,                                        const SDL_MouseMotionEvent *event) {    if (!event->state) {        // do not send motion events when no button is pressed        return;    }    struct control_event control_event;    if (mouse_motion_from_sdl_to_android(event, input_manager->screen->frame_size, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send mouse motion event");        }    }}
                               const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        switch (keycode) {            case SDLK_h:                action_home(input_manager->controller);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(input_manager->controller);                return;            case SDLK_m:                action_app_switch(input_manager->controller);                return;            case SDLK_p:                action_power(input_manager->controller);                return;            case SDLK_f:                screen_switch_fullscreen(input_manager->screen);                return;            case SDLK_x:                screen_resize_to_fit(input_manager->screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(input_manager->screen);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}void input_manager_process_mouse_motion(struct input_manager *input_manager,                                        const SDL_MouseMotionEvent *event) {
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        switch (keycode) {            case SDLK_h:                action_home(input_manager->controller);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(input_manager->controller);                return;            case SDLK_m:                action_app_switch(input_manager->controller);                return;            case SDLK_p:                action_power(input_manager->controller);                return;            case SDLK_f:                screen_switch_fullscreen(input_manager->screen);                return;            case SDLK_x:                screen_resize_to_fit(input_manager->screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(input_manager->screen);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
static void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return;            case SDL_QUIT:                LOGD("User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                    fps_counter_start(&frames.fps_counter);                }                if (!screen_update_frame(&screen, &frames)) {                    return;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;                }                break;            case SDL_TEXTINPUT: {                screencontrol_handle_text_input(&controller, &screen, &event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                screencontrol_handle_key(&controller, &screen, &event.key);                break;            case SDL_MOUSEMOTION:                screencontrol_handle_mouse_motion(&controller, &screen, &event.motion);                break;            case SDL_MOUSEWHEEL: {                screencontrol_handle_mouse_wheel(&controller, &screen, &event.wheel);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                screencontrol_handle_mouse_button(&controller, &screen, &event.button);                break;            }        }    }}
static void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return;            case SDL_QUIT:                LOGD("User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                    fps_counter_start(&frames.fps_counter);                }                if (!screen_update_frame(&screen, &frames)) {                    return;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;                }                break;            case SDL_TEXTINPUT: {                input_manager_process_text_input(&input_manager, &event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL: {                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                input_manager_process_mouse_button(&input_manager, &event.button);                break;            }        }    }}
    public static void e(String message, Throwable throwable) {        if (isEnabled(Level.ERROR)) {            Log.e(TAG, message, throwable);            System.out.println("ERROR: " + message);            throwable.printStackTrace();        }    }}
    public static void e(String message, Throwable throwable) {        if (isEnabled(Level.ERROR)) {            Log.e(TAG, message, throwable);            System.out.println("ERROR: " + message);            throwable.printStackTrace();        }    }}
    public static void e(String message, Throwable throwable) {        if (isEnabled(Level.ERROR)) {            Log.e(TAG, message, throwable);            System.out.println("ERROR: " + message);            if (throwable != null) {                throwable.printStackTrace();            }        }    }
    public static void e(String message) {        e(message, null);    }}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
static void event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, screen.window);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return;            case SDL_QUIT:                LOGD("User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;                }                break;            case SDL_TEXTINPUT: {                input_manager_process_text_input(&input_manager, &event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL: {                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                input_manager_process_mouse_button(&input_manager, &event.button);                break;            }        }    }}
static int event_watcher(void* data, SDL_Event* event) {    if (event->type == SDL_WINDOWEVENT && event->window.event == SDL_WINDOWEVENT_RESIZED) {        // called from another thread, not very safe, but it's a workaround!        screen_render(&screen);    }    return 0;}#endif
static void event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return;            case SDL_QUIT:                LOGD("User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;                }                break;            case SDL_TEXTINPUT: {                input_manager_process_text_input(&input_manager, &event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL: {                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                input_manager_process_mouse_button(&input_manager, &event.button);                break;            }        }    }}
static int event_watcher(void *data, SDL_Event *event) {    if (event->type == SDL_WINDOWEVENT && event->window.event == SDL_WINDOWEVENT_RESIZED) {        // called from another thread, not very safe, but it's a workaround!        screen_render(&screen);    }    return 0;}#endif
ssize_t net_send_all(socket_t socket, const void *buf, size_t len) {    ssize_t w;    while (len > 0) {        w = send(socket, buf, len, 0);        if (w == -1) {            return -1;        }        len -= w;        buf = (char *) buf + w;    }    return w;}
ssize_t net_send_all(socket_t socket, const void *buf, size_t len) {    ssize_t w = 0;    while (len > 0) {        w = send(socket, buf, len, 0);        if (w == -1) {            return -1;        }        len -= w;        buf = (char *) buf + w;    }    return w;}
int main(int argc, char *argv[]) {    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (parse_args(&args, argc, argv)) {        usage(argv[0]);        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    int res = scrcpy(args.serial, args.port, args.max_size, args.bit_rate) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (parse_args(&args, argc, argv)) {        usage(argv[0]);        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    int res = scrcpy(args.serial, args.port, args.max_size, args.bit_rate) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
is_apk(const char *file) {    const char *ext = strrchr(file, '.');    return ext && !strcmp(ext, ".apk");}enum event_result {    EVENT_RESULT_CONTINUE,    EVENT_RESULT_STOPPED_BY_USER,    EVENT_RESULT_STOPPED_BY_EOS,};static enum event_resulthandle_event(SDL_Event *event, bool control) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = true;
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = true;    if (!sdl_init_and_configure()) {        ret = false;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = false;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = false;        goto finally_destroy_server;    }    bool display = !options->no_display;    bool control = !options->no_control;    input_manager.control = control;    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            server_stop(&server);            ret = false;            goto finally_destroy_server;        }        if (control && !file_handler_init(&file_handler, server.serial)) {            ret = false;            server_stop(&server);            goto finally_destroy_video_buffer;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = false;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        ret = false;        server_stop(&server);        goto finally_destroy_recorder;    }    if (display) {        if (control) {            if (!controller_init(&controller, device_socket)) {                ret = false;                goto finally_stop_stream;            }            if (!controller_start(&controller)) {                ret = false;                goto finally_destroy_controller;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            ret = false;            goto finally_stop_and_join_controller;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(display, control);    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    if (display && control) {        controller_stop(&controller);        controller_join(&controller);    }finally_destroy_controller:    if (display && control) {        controller_destroy(&controller);    }finally_stop_stream:    stream_stop(&stream);    // stop the server before stream_join() to wake up the stream    server_stop(&server);    stream_join(&stream);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    if (display && control) {        file_handler_stop(&file_handler);        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }finally_destroy_video_buffer:    if (display) {        video_buffer_destroy(&video_buffer);    }finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial,                                                     false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
sdl_init_and_configure(bool display) {    uint32_t flags = display ? SDL_INIT_VIDEO : SDL_INIT_EVENTS;    if (SDL_Init(flags)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return false;    }    atexit(SDL_Quit);    if (!display) {        return true;    }    // Use the best available scale quality    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "2")) {        LOGW("Could not enable bilinear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return true;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = true;    bool display = !options->no_display;    bool control = !options->no_control;    if (!sdl_init_and_configure(display)) {        ret = false;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = false;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = false;        goto finally_destroy_server;    }    input_manager.control = control;    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            server_stop(&server);            ret = false;            goto finally_destroy_server;        }        if (control && !file_handler_init(&file_handler, server.serial)) {            ret = false;            server_stop(&server);            goto finally_destroy_video_buffer;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = false;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        ret = false;        server_stop(&server);        goto finally_destroy_recorder;    }    if (display) {        if (control) {            if (!controller_init(&controller, device_socket)) {                ret = false;                goto finally_stop_stream;            }            if (!controller_start(&controller)) {                ret = false;                goto finally_destroy_controller;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            ret = false;            goto finally_stop_and_join_controller;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(display, control);    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    if (display && control) {        controller_stop(&controller);        controller_join(&controller);    }finally_destroy_controller:    if (display && control) {        controller_destroy(&controller);    }finally_stop_stream:    stream_stop(&stream);    // stop the server before stream_join() to wake up the stream    server_stop(&server);    stream_join(&stream);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    if (display && control) {        file_handler_stop(&file_handler);        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }finally_destroy_video_buffer:    if (display) {        video_buffer_destroy(&video_buffer);    }finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial,                                                     false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
sdl_init_and_configure(void) {    if (SDL_Init(SDL_INIT_VIDEO)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return false;    }    atexit(SDL_Quit);    // Use the best available scale quality    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "2")) {        LOGW("Could not enable bilinear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return true;}
static struct sizeget_native_window_size(SDL_Window *window) {    int width;    int height;    SDL_GetWindowSize(window, &width, &height);    struct size size;    size.width = width;    size.height = height;    return size;}// get the windowed window sizestatic struct sizeget_window_size(const struct screen *screen) {    if (screen->fullscreen) {        return screen->windowed_window_size;    }    return get_native_window_size(screen->window);}// set the window size to be applied when fullscreen is disabledstatic voidset_window_size(struct screen *screen, struct size new_size) {    // setting the window size during fullscreen is implementation defined,    // so apply the resize only after fullscreen is disabled
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = true;    bool display = !options->no_display;    bool control = !options->no_control;    if (!sdl_init_and_configure(display)) {        ret = false;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = false;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = false;        goto finally_destroy_server;    }    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            server_stop(&server);            ret = false;            goto finally_destroy_server;        }        if (control && !file_handler_init(&file_handler, server.serial)) {            ret = false;            server_stop(&server);            goto finally_destroy_video_buffer;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = false;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        ret = false;        server_stop(&server);        goto finally_destroy_recorder;    }    if (display) {        if (control) {            if (!controller_init(&controller, device_socket)) {                ret = false;                goto finally_stop_stream;            }            if (!controller_start(&controller)) {                ret = false;                goto finally_destroy_controller;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            ret = false;            goto finally_stop_and_join_controller;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(display, control);    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    if (display && control) {        controller_stop(&controller);        controller_join(&controller);    }finally_destroy_controller:    if (display && control) {        controller_destroy(&controller);    }finally_stop_stream:    stream_stop(&stream);    // stop the server before stream_join() to wake up the stream    server_stop(&server);    stream_join(&stream);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    if (display && control) {        file_handler_stop(&file_handler);        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }finally_destroy_video_buffer:    if (display) {        video_buffer_destroy(&video_buffer);    }finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = true;    bool display = !options->no_display;    bool control = !options->no_control;    if (!sdl_init_and_configure(display)) {        ret = false;        goto finally_destroy_server;    }    if (!server_connect_to(&server)) {        server_stop(&server);        ret = false;        goto finally_destroy_server;    }    socket_t device_socket = server.device_socket;    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = false;        goto finally_destroy_server;    }    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            server_stop(&server);            ret = false;            goto finally_destroy_server;        }        if (control && !file_handler_init(&file_handler, server.serial)) {            ret = false;            server_stop(&server);            goto finally_destroy_video_buffer;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = false;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        ret = false;        server_stop(&server);        goto finally_destroy_recorder;    }    if (display) {        if (control) {            if (!controller_init(&controller, device_socket)) {                ret = false;                goto finally_stop_stream;            }            if (!controller_start(&controller)) {                ret = false;                goto finally_destroy_controller;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            ret = false;            goto finally_stop_and_join_controller;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(display, control);    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    if (display && control) {        controller_stop(&controller);        controller_join(&controller);    }finally_destroy_controller:    if (display && control) {        controller_destroy(&controller);    }finally_stop_stream:    stream_stop(&stream);    // stop the server before stream_join() to wake up the stream    server_stop(&server);    stream_join(&stream);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    if (display && control) {        file_handler_stop(&file_handler);        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }finally_destroy_video_buffer:    if (display) {        video_buffer_destroy(&video_buffer);    }finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
server_connect_to(struct server *server) {    if (!server->tunnel_forward) {        server->device_socket = net_accept(server->server_socket);    } else {        uint32_t attempts = 100;        uint32_t delay = 100; // ms        server->device_socket = connect_to_server(server->local_port, attempts,                                                  delay);    }    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    if (!server->tunnel_forward) {        // we don't need the server socket anymore        close_socket(&server->server_socket);    }    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = false;    return server->device_socket;}
server_connect_to(struct server *server) {    if (!server->tunnel_forward) {        server->device_socket = net_accept(server->server_socket);    } else {        uint32_t attempts = 100;        uint32_t delay = 100; // ms        server->device_socket = connect_to_server(server->local_port, attempts,                                                  delay);    }    if (server->device_socket == INVALID_SOCKET) {        return false;    }    if (!server->tunnel_forward) {        // we don't need the server socket anymore        close_socket(&server->server_socket);    }    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = false;    return true;}
    public void testUtf8Trucate() {        String s = "aÉbÔc";        byte[] utf8 = s.getBytes(StandardCharsets.UTF_8);        Assert.assertEquals(7, utf8.length);        int count;        count = StringUtils.getUtf8TruncationIndex(utf8, 1);        Assert.assertEquals(1, count);        count = StringUtils.getUtf8TruncationIndex(utf8, 2);        Assert.assertEquals(1, count); // É is 2 bytes-wide        count = StringUtils.getUtf8TruncationIndex(utf8, 3);        Assert.assertEquals(3, count);        count = StringUtils.getUtf8TruncationIndex(utf8, 4);        Assert.assertEquals(4, count);        count = StringUtils.getUtf8TruncationIndex(utf8, 5);        Assert.assertEquals(4, count); // Ô is 2 bytes-wide        count = StringUtils.getUtf8TruncationIndex(utf8, 6);        Assert.assertEquals(6, count);        count = StringUtils.getUtf8TruncationIndex(utf8, 7);        Assert.assertEquals(7, count);        count = StringUtils.getUtf8TruncationIndex(utf8, 8);        Assert.assertEquals(7, count); // no more chars    }}
    public void testUtf8Trucate() {        String s = "aÉbÔc";        byte[] utf8 = s.getBytes(StandardCharsets.UTF_8);        Assert.assertEquals(7, utf8.length);        int count;        count = StringUtils.getUtf8TruncationIndex(utf8, 1);        Assert.assertEquals(1, count);        count = StringUtils.getUtf8TruncationIndex(utf8, 2);        Assert.assertEquals(1, count); // É is 2 bytes-wide        count = StringUtils.getUtf8TruncationIndex(utf8, 3);        Assert.assertEquals(3, count);        count = StringUtils.getUtf8TruncationIndex(utf8, 4);        Assert.assertEquals(4, count);        count = StringUtils.getUtf8TruncationIndex(utf8, 5);        Assert.assertEquals(4, count); // Ô is 2 bytes-wide        count = StringUtils.getUtf8TruncationIndex(utf8, 6);        Assert.assertEquals(6, count);        count = StringUtils.getUtf8TruncationIndex(utf8, 7);        Assert.assertEquals(7, count);        count = StringUtils.getUtf8TruncationIndex(utf8, 8);        Assert.assertEquals(7, count); // no more chars    }}
    public void testUtf8Truncate() {        String s = "aÉbÔc";        byte[] utf8 = s.getBytes(StandardCharsets.UTF_8);        Assert.assertEquals(7, utf8.length);        int count;        count = StringUtils.getUtf8TruncationIndex(utf8, 1);        Assert.assertEquals(1, count);        count = StringUtils.getUtf8TruncationIndex(utf8, 2);        Assert.assertEquals(1, count); // É is 2 bytes-wide        count = StringUtils.getUtf8TruncationIndex(utf8, 3);        Assert.assertEquals(3, count);        count = StringUtils.getUtf8TruncationIndex(utf8, 4);        Assert.assertEquals(4, count);        count = StringUtils.getUtf8TruncationIndex(utf8, 5);        Assert.assertEquals(4, count); // Ô is 2 bytes-wide        count = StringUtils.getUtf8TruncationIndex(utf8, 6);        Assert.assertEquals(6, count);        count = StringUtils.getUtf8TruncationIndex(utf8, 7);        Assert.assertEquals(7, count);        count = StringUtils.getUtf8TruncationIndex(utf8, 8);        Assert.assertEquals(7, count); // no more chars    }}
    public void testUtf8Truncate() {        String s = "aÉbÔc";        byte[] utf8 = s.getBytes(StandardCharsets.UTF_8);        Assert.assertEquals(7, utf8.length);        int count;        count = StringUtils.getUtf8TruncationIndex(utf8, 1);        Assert.assertEquals(1, count);        count = StringUtils.getUtf8TruncationIndex(utf8, 2);        Assert.assertEquals(1, count); // É is 2 bytes-wide        count = StringUtils.getUtf8TruncationIndex(utf8, 3);        Assert.assertEquals(3, count);        count = StringUtils.getUtf8TruncationIndex(utf8, 4);        Assert.assertEquals(4, count);        count = StringUtils.getUtf8TruncationIndex(utf8, 5);        Assert.assertEquals(4, count); // Ô is 2 bytes-wide        count = StringUtils.getUtf8TruncationIndex(utf8, 6);        Assert.assertEquals(6, count);        count = StringUtils.getUtf8TruncationIndex(utf8, 7);        Assert.assertEquals(7, count);        count = StringUtils.getUtf8TruncationIndex(utf8, 8);        Assert.assertEquals(7, count); // no more chars    }}
static inline void mutex_lock(SDL_mutex *mutex) {    if (SDL_LockMutex(mutex)) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not lock mutex");        exit(1);    }}
void mutex_lock(SDL_mutex *mutex);void mutex_unlock(SDL_mutex *mutex);void cond_wait(SDL_cond *cond, SDL_mutex *mutex);void cond_signal(SDL_cond *cond);#endif
                switch_fps_counter_state(input_manager->frames);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}void input_manager_process_mouse_motion(struct input_manager *input_manager,                                        const SDL_MouseMotionEvent *event) {    if (!event->state) {        // do not send motion events when no button is pressed        return;    }    struct control_event control_event;    if (mouse_motion_from_sdl_to_android(event, input_manager->screen->frame_size, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send mouse motion event");        }    }}
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    // capture all Ctrl events    if (ctrl) {        SDL_bool repeat = event->repeat;        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        SDL_Keycode keycode = event->keysym.sym;        switch (keycode) {            case SDLK_h:                action_home(input_manager->controller);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(input_manager->controller);                return;            case SDLK_m:                action_app_switch(input_manager->controller);                return;            case SDLK_p:                action_power(input_manager->controller);                return;            case SDLK_v:                clipboard_paste(input_manager->controller);                return;            case SDLK_f:                screen_switch_fullscreen(input_manager->screen);                return;            case SDLK_x:                screen_resize_to_fit(input_manager->screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(input_manager->screen);                return;            case SDLK_i:                switch_fps_counter_state(input_manager->frames);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
static inline void action_shake(struct controller *controller) {    send_keycode(controller, AKEYCODE_MENU, "SHAKE");}
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    // capture all Ctrl events    if (ctrl) {        SDL_bool repeat = event->repeat;        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        SDL_Keycode keycode = event->keysym.sym;        switch (keycode) {            case SDLK_h:                action_home(input_manager->controller);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(input_manager->controller);                return;            case SDLK_m:                action_app_switch(input_manager->controller);                return;            case SDLK_s:                action_shake(input_manager->controller);                return;            case SDLK_p:                action_power(input_manager->controller);                return;            case SDLK_v:                clipboard_paste(input_manager->controller);                return;            case SDLK_f:                screen_switch_fullscreen(input_manager->screen);                return;            case SDLK_x:                screen_resize_to_fit(input_manager->screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(input_manager->screen);                return;            case SDLK_i:                switch_fps_counter_state(input_manager->frames);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+m\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+'+'\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+'-'\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+m\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+s\n"        "        click on MENU\n"        "\n"        "    Ctrl+'+'\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+'-'\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
    }}void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    SDL_bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    if (alt) {        // no shortcut involves Alt or Meta, and they should not be forwarded        // to the device        return;    }    // capture all Ctrl events    if (ctrl | meta) {        SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        if (shift) {            // currently, there is no shortcut involving SHIFT            return;        }        SDL_Keycode keycode = event->keysym.sym;        int action = event->type == SDL_KEYDOWN ? ACTION_DOWN : ACTION_UP;        SDL_bool repeat = event->repeat;        switch (keycode) {            case SDLK_h:                if (ctrl && !meta && !repeat) {                    action_home(input_manager->controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (ctrl && !meta && !repeat) {                    action_back(input_manager->controller, action);                }                return;            case SDLK_s:                if (ctrl && !meta && !repeat) {                    action_app_switch(input_manager->controller, action);                }                return;            case SDLK_m:                if (ctrl && !meta && !repeat) {                    action_menu(input_manager->controller, action);                }                return;            case SDLK_p:                if (ctrl && !meta && !repeat) {                    action_power(input_manager->controller, action);                }                return;            case SDLK_DOWN:#ifdef __APPLE__
    }}void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    SDL_bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    if (alt) {        // no shortcut involves Alt or Meta, and they should not be forwarded        // to the device        return;    }    // capture all Ctrl events    if (ctrl | meta) {        SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        if (shift) {            // currently, there is no shortcut involving SHIFT            return;        }        SDL_Keycode keycode = event->keysym.sym;        int action = event->type == SDL_KEYDOWN ? ACTION_DOWN : ACTION_UP;        SDL_bool repeat = event->repeat;        switch (keycode) {            case SDLK_h:                if (ctrl && !meta && !repeat) {                    action_home(input_manager->controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (ctrl && !meta && !repeat) {                    action_back(input_manager->controller, action);                }                return;            case SDLK_s:                if (ctrl && !meta && !repeat) {                    action_app_switch(input_manager->controller, action);                }                return;            case SDLK_m:                if (ctrl && !meta && !repeat) {                    action_menu(input_manager->controller, action);                }                return;            case SDLK_p:                if (ctrl && !meta && !repeat) {                    action_power(input_manager->controller, action);                }                return;            case SDLK_DOWN:#ifdef __APPLE__
static void collapse_notification_panel(struct controller *controller) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_COMMAND;    control_event.command_event.action = CONTROL_EVENT_COMMAND_COLLAPSE_NOTIFICATION_PANEL;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot collapse notification panel");    }}
static void expand_notification_panel(struct controller *controller) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_COMMAND;    control_event.command_event.action = CONTROL_EVENT_COMMAND_EXPAND_NOTIFICATION_PANEL;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot expand notification panel");    }}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
                synchronized (Device.this) {                    screenInfo = screenInfo.withRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        });    }    public synchronized ScreenInfo getScreenInfo() {        return screenInfo;    }    private ScreenInfo computeScreenInfo(Rect crop, int maxSize) {        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        Rect contentRect = new Rect(0, 0, deviceSize.getWidth(), deviceSize.getHeight());        if (crop != null) {            if (rotated) {                // the crop (provided by the user) is expressed in the natural orientation                crop = flipRect(crop);            }            if (!contentRect.intersect(crop)) {                // intersect() changes contentRect so that it is intersected with crop                Ln.w("Crop rectangle (" + formatCrop(crop) + ") does not intersect device screen (" + formatCrop(deviceSize.toRect()) + ")");                contentRect = new Rect(); // empty            }        }        Size videoSize = computeVideoSize(contentRect.width(), contentRect.height(), maxSize);        return new ScreenInfo(contentRect, videoSize, rotated);    }    private static String formatCrop(Rect rect) {        return rect.width() + ":" + rect.height() + ":" + rect.left + ":" + rect.top;    }    @SuppressWarnings("checkstyle:MagicNumber")    private static Size computeVideoSize(int w, int h, int maxSize) {        // Compute the video size and the padding of the content inside this video.        // Principle:        // - scale down the great side of the screen to maxSize (if necessary);        // - scale down the other side so that the aspect ratio is preserved;        // - round this value to the nearest multiple of 8 (H.264 only accepts multiples of 8)        w &= ~7; // in case it's not a multiple of 8        h &= ~7;        if (maxSize > 0) {            if (BuildConfig.DEBUG && maxSize % 8 != 0) {                throw new AssertionError("Max size must be a multiple of 8");            }            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;            if (major > maxSize) {                int minorExact = minor * maxSize / major;                // +4 to round the value to the nearest multiple of 8                minor = (minorExact + 4) & ~7;                major = maxSize;            }            w = portrait ? minor : major;            h = portrait ? major : minor;        }        return new Size(w, h);    }    public Point getPhysicalPoint(Position position) {        // it hides the field on purpose, to read it with a lock        @SuppressWarnings("checkstyle:HiddenField")        ScreenInfo screenInfo = getScreenInfo(); // read with synchronization        Size videoSize = screenInfo.getVideoSize();        Size clientVideoSize = position.getScreenSize();        if (!videoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event            return null;        }        Rect contentRect = screenInfo.getContentRect();        Point point = position.getPoint();        int scaledX = contentRect.left + point.x * contentRect.width() / videoSize.getWidth();        int scaledY = contentRect.top + point.y * contentRect.height() / videoSize.getHeight();        return new Point(scaledX, scaledY);    }    public static String getDeviceName() {        return Build.MODEL;    }    public boolean injectInputEvent(InputEvent inputEvent, int mode) {        return serviceManager.getInputManager().injectInputEvent(inputEvent, mode);    }    public boolean isScreenOn() {        return serviceManager.getPowerManager().isScreenOn();    }    public void registerRotationWatcher(IRotationWatcher rotationWatcher) {        serviceManager.getWindowManager().registerRotationWatcher(rotationWatcher);    }    public synchronized void setRotationListener(RotationListener rotationListener) {        this.rotationListener = rotationListener;    }    static Rect flipRect(Rect crop) {        return new Rect(crop.top, crop.left, crop.bottom, crop.right);    }
                synchronized (Device.this) {                    screenInfo = screenInfo.withRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        });    }    public synchronized ScreenInfo getScreenInfo() {        return screenInfo;    }    private ScreenInfo computeScreenInfo(Rect crop, int maxSize) {        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        Rect contentRect = new Rect(0, 0, deviceSize.getWidth(), deviceSize.getHeight());        if (crop != null) {            if (rotated) {                // the crop (provided by the user) is expressed in the natural orientation                crop = flipRect(crop);            }            if (!contentRect.intersect(crop)) {                // intersect() changes contentRect so that it is intersected with crop                Ln.w("Crop rectangle (" + formatCrop(crop) + ") does not intersect device screen (" + formatCrop(deviceSize.toRect()) + ")");                contentRect = new Rect(); // empty            }        }        Size videoSize = computeVideoSize(contentRect.width(), contentRect.height(), maxSize);        return new ScreenInfo(contentRect, videoSize, rotated);    }    private static String formatCrop(Rect rect) {        return rect.width() + ":" + rect.height() + ":" + rect.left + ":" + rect.top;    }    @SuppressWarnings("checkstyle:MagicNumber")    private static Size computeVideoSize(int w, int h, int maxSize) {        // Compute the video size and the padding of the content inside this video.        // Principle:        // - scale down the great side of the screen to maxSize (if necessary);        // - scale down the other side so that the aspect ratio is preserved;        // - round this value to the nearest multiple of 8 (H.264 only accepts multiples of 8)        w &= ~7; // in case it's not a multiple of 8        h &= ~7;        if (maxSize > 0) {            if (BuildConfig.DEBUG && maxSize % 8 != 0) {                throw new AssertionError("Max size must be a multiple of 8");            }            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;            if (major > maxSize) {                int minorExact = minor * maxSize / major;                // +4 to round the value to the nearest multiple of 8                minor = (minorExact + 4) & ~7;                major = maxSize;            }            w = portrait ? minor : major;            h = portrait ? major : minor;        }        return new Size(w, h);    }    public Point getPhysicalPoint(Position position) {        // it hides the field on purpose, to read it with a lock        @SuppressWarnings("checkstyle:HiddenField")        ScreenInfo screenInfo = getScreenInfo(); // read with synchronization        Size videoSize = screenInfo.getVideoSize();        Size clientVideoSize = position.getScreenSize();        if (!videoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event            return null;        }        Rect contentRect = screenInfo.getContentRect();        Point point = position.getPoint();        int scaledX = contentRect.left + point.x * contentRect.width() / videoSize.getWidth();        int scaledY = contentRect.top + point.y * contentRect.height() / videoSize.getHeight();        return new Point(scaledX, scaledY);    }    public static String getDeviceName() {        return Build.MODEL;    }    public boolean injectInputEvent(InputEvent inputEvent, int mode) {        return serviceManager.getInputManager().injectInputEvent(inputEvent, mode);    }    public boolean isScreenOn() {        return serviceManager.getPowerManager().isScreenOn();    }    public void registerRotationWatcher(IRotationWatcher rotationWatcher) {        serviceManager.getWindowManager().registerRotationWatcher(rotationWatcher);    }    public synchronized void setRotationListener(RotationListener rotationListener) {        this.rotationListener = rotationListener;    }    static Rect flipRect(Rect crop) {        return new Rect(crop.top, crop.left, crop.bottom, crop.right);    }
    public void collapsePanels() {        serviceManager.getStatusBarManager().collapsePanels();    }
    public void expandNotificationPanel() {        serviceManager.getStatusBarManager().expandNotificationsPanel();    }
    private boolean executeCommand(int action) {        switch (action) {            case ControlEvent.COMMAND_BACK_OR_SCREEN_ON:                return pressBackOrTurnScreenOn();            default:                Ln.w("Unsupported command: " + action);        }        return false;    }}
    private boolean executeCommand(int action) {        switch (action) {            case ControlEvent.COMMAND_BACK_OR_SCREEN_ON:                return pressBackOrTurnScreenOn();            case ControlEvent.COMMAND_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                return true;            case ControlEvent.COMMAND_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                return true;            default:                Ln.w("Unsupported command: " + action);        }        return false;    }}
void input_manager_process_mouse_button(struct input_manager *input_manager,                                        const SDL_MouseButtonEvent *event) {    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(input_manager->controller);            return;        }        if (event->button == SDL_BUTTON_MIDDLE) {            action_home(input_manager->controller);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            SDL_bool outside_device_screen =                    event->x < 0 || event->x >= input_manager->screen->frame_size.width ||                    event->y < 0 || event->y >= input_manager->screen->frame_size.height;                if (outside_device_screen) {                    screen_resize_to_fit(input_manager->screen);                }            return;        }    };    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, input_manager->screen->frame_size, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send mouse button event");        }    }}
void input_manager_process_mouse_button(struct input_manager *input_manager,                                        const SDL_MouseButtonEvent *event) {    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(input_manager->controller);            return;        }        if (event->button == SDL_BUTTON_MIDDLE) {            action_home(input_manager->controller);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            SDL_bool outside_device_screen =                    event->x < 0 || event->x >= input_manager->screen->frame_size.width ||                    event->y < 0 || event->y >= input_manager->screen->frame_size.height;            if (outside_device_screen) {                screen_resize_to_fit(input_manager->screen);                return;            }            // otherwise, send the click event to the device        }    };    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, input_manager->screen->frame_size, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send mouse button event");        }    }}
            goto run_quit;        }        if ((ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame)) < 0) {            SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Could not receive video frame: %d", ret);            goto run_quit;        }        push_frame(decoder);#endif    }    SDL_LogDebug(SDL_LOG_CATEGORY_VIDEO, "End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);
void decoder_init(struct decoder *decoder, struct frames *frames, TCPsocket video_socket) {    decoder->frames = frames;    decoder->video_socket = video_socket;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = server_connect_to(&server, serial);    if (!device_socket) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server, serial);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // kill the server before decoder_join() to wake up the decoder    server_stop(&server, serial);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = server_connect_to(&server, serial);    if (!device_socket) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server, serial);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // kill the server before decoder_join() to wake up the decoder    server_stop(&server, serial);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
static void write_point(Uint8 *buf, const struct point *point) {    write16(&buf[0], point->position.x);    write16(&buf[2], point->position.y);    write16(&buf[4], point->screen_size.width);    write16(&buf[6], point->screen_size.height);}
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {    case CONTROL_EVENT_TYPE_KEYCODE:        buf[1] = event->keycode_event.action;        write32(&buf[2], event->keycode_event.keycode);        write32(&buf[6], event->keycode_event.metastate);        return 10;    case CONTROL_EVENT_TYPE_TEXT: {        // write length (1 byte) + date (non nul-terminated)        size_t len = strlen(event->text_event.text);        if (len > TEXT_MAX_LENGTH) {            len = TEXT_MAX_LENGTH;        }        buf[1] = (Uint8) len;        memcpy(&buf[2], &event->text_event.text, len);        return 2 + len;    }    case CONTROL_EVENT_TYPE_MOUSE:        buf[1] = event->mouse_event.action;        write32(&buf[2], event->mouse_event.buttons);        write_point(&buf[6], &event->mouse_event.point);        return 14;    case CONTROL_EVENT_TYPE_SCROLL:        write_point(&buf[1], &event->scroll_event.point);        write32(&buf[9], (Uint32) event->scroll_event.hscroll);        write32(&buf[13], (Uint32) event->scroll_event.vscroll);        return 17;    default:        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Unknown event type: %u\n", (unsigned) event->type);        return 0;    }}
static void write_position(Uint8 *buf, const struct position *position) {    write16(&buf[0], position->point.x);    write16(&buf[2], position->point.y);    write16(&buf[4], position->screen_size.width);    write16(&buf[6], position->screen_size.height);}
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {    case CONTROL_EVENT_TYPE_KEYCODE:        buf[1] = event->keycode_event.action;        write32(&buf[2], event->keycode_event.keycode);        write32(&buf[6], event->keycode_event.metastate);        return 10;    case CONTROL_EVENT_TYPE_TEXT: {        // write length (1 byte) + date (non nul-terminated)        size_t len = strlen(event->text_event.text);        if (len > TEXT_MAX_LENGTH) {            len = TEXT_MAX_LENGTH;        }        buf[1] = (Uint8) len;        memcpy(&buf[2], &event->text_event.text, len);        return 2 + len;    }    case CONTROL_EVENT_TYPE_MOUSE:        buf[1] = event->mouse_event.action;        write32(&buf[2], event->mouse_event.buttons);        write_position(&buf[6], &event->mouse_event.position);        return 14;    case CONTROL_EVENT_TYPE_SCROLL:        write_position(&buf[1], &event->scroll_event.position);        write32(&buf[9], (Uint32) event->scroll_event.hscroll);        write32(&buf[13], (Uint32) event->scroll_event.vscroll);        return 17;    default:        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Unknown event type: %u\n", (unsigned) event->type);        return 0;    }}
SDL_bool mouse_wheel_from_sdl_to_android(const SDL_MouseWheelEvent *from,                                         const struct point point,                                         struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_SCROLL;    to->scroll_event.point = point;    int mul = from->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    to->scroll_event.hscroll = mul * from->x;    to->scroll_event.vscroll = mul * from->y;    return SDL_TRUE;}
SDL_bool mouse_motion_from_sdl_to_android(const SDL_MouseMotionEvent *from,                                          const struct size screen_size,                                          struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    to->mouse_event.action = AMOTION_EVENT_ACTION_MOVE;    to->mouse_event.buttons = convert_mouse_buttons(from->state);    to->mouse_event.point.screen_size = screen_size;    to->mouse_event.point.position.x = from->x;    to->mouse_event.point.position.y = from->y;    return SDL_TRUE;}
SDL_bool mouse_motion_from_sdl_to_android(const SDL_MouseMotionEvent *from,                                          const struct size screen_size,                                          struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    to->mouse_event.action = AMOTION_EVENT_ACTION_MOVE;    to->mouse_event.buttons = convert_mouse_buttons(from->state);    to->mouse_event.point.screen_size = screen_size;    to->mouse_event.point.position.x = from->x;    to->mouse_event.point.position.y = from->y;    return SDL_TRUE;}
SDL_bool mouse_wheel_from_sdl_to_android(const SDL_MouseWheelEvent *from,                                         const struct point point,                                         struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_SCROLL;    to->scroll_event.point = point;    int mul = from->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    to->scroll_event.hscroll = mul * from->x;    to->scroll_event.vscroll = mul * from->y;    return SDL_TRUE;}
SDL_bool mouse_button_from_sdl_to_android(const SDL_MouseButtonEvent *from,                                          struct size screen_size,                                          struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    if (!convert_mouse_action(from->type, &to->mouse_event.action)) {        return SDL_FALSE;    }    to->mouse_event.buttons = convert_mouse_buttons(SDL_BUTTON(from->button));    to->mouse_event.point.screen_size = screen_size;    to->mouse_event.point.position.x = (Uint16) from->x;    to->mouse_event.point.position.y = (Uint16) from->y;    return SDL_TRUE;}
SDL_bool mouse_wheel_from_sdl_to_android(const SDL_MouseWheelEvent *from,                                         struct position position,                                         struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_SCROLL;    to->scroll_event.position = position;    int mul = from->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    to->scroll_event.hscroll = mul * from->x;    to->scroll_event.vscroll = mul * from->y;    return SDL_TRUE;}
SDL_bool mouse_motion_from_sdl_to_android(const SDL_MouseMotionEvent *from,                                          struct size screen_size,                                          struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    to->mouse_event.action = AMOTION_EVENT_ACTION_MOVE;    to->mouse_event.buttons = convert_mouse_buttons(from->state);    to->mouse_event.position.screen_size = screen_size;    to->mouse_event.position.point.x = from->x;    to->mouse_event.position.point.y = from->y;    return SDL_TRUE;}
SDL_bool mouse_motion_from_sdl_to_android(const SDL_MouseMotionEvent *from,                                          struct size screen_size,                                          struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    to->mouse_event.action = AMOTION_EVENT_ACTION_MOVE;    to->mouse_event.buttons = convert_mouse_buttons(from->state);    to->mouse_event.position.screen_size = screen_size;    to->mouse_event.position.point.x = from->x;    to->mouse_event.position.point.y = from->y;    return SDL_TRUE;}
SDL_bool mouse_wheel_from_sdl_to_android(const SDL_MouseWheelEvent *from,                                         struct position position,                                         struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_SCROLL;    to->scroll_event.position = position;    int mul = from->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    to->scroll_event.hscroll = mul * from->x;    to->scroll_event.vscroll = mul * from->y;    return SDL_TRUE;}
SDL_bool mouse_button_from_sdl_to_android(const SDL_MouseButtonEvent *from,                                          struct size screen_size,                                          struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    if (!convert_mouse_action(from->type, &to->mouse_event.action)) {        return SDL_FALSE;    }    to->mouse_event.buttons = convert_mouse_buttons(SDL_BUTTON(from->button));    to->mouse_event.position.screen_size = screen_size;    to->mouse_event.position.point.x = (Uint16) from->x;    to->mouse_event.position.point.y = (Uint16) from->y;    return SDL_TRUE;}
    SDL_bool keep_width = frame_size.width * h > frame_size.height * w;    if (keep_width) {        // remove black borders on top and bottom        h = frame_size.height * w / frame_size.width;    } else {        // remove black borders on left and right (or none at all if it already fits)        w = frame_size.width * h / frame_size.height;    }    // w and h must fit into 16 bits    SDL_assert_release(w < 0x10000 && h < 0x10000);    return (struct size) {w, h};}// initially, there is no current size, so use the frame size as current sizestatic inline struct size get_initial_optimal_size(struct size frame_size) {
static void handle_mouse_wheel(const SDL_MouseWheelEvent *event, struct point point) {    struct control_event control_event;    if (mouse_wheel_from_sdl_to_android(event, point, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send wheel button event");        }    }}
static void handle_mouse_wheel(const SDL_MouseWheelEvent *event, struct point point) {    struct control_event control_event;    if (mouse_wheel_from_sdl_to_android(event, point, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send wheel button event");        }    }}
void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            return;        case EVENT_NEW_FRAME:            if (!handle_new_frame()) {                return;            }            texture_empty = SDL_FALSE;            count_frame(); // display fps for debug            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_TEXTINPUT: {            handle_text_input(&event.text);            break;        }        case SDL_KEYDOWN:        case SDL_KEYUP:            handle_key(&event.key);            break;        case SDL_MOUSEMOTION:            handle_mouse_motion(&event.motion, frame_size);            break;        case SDL_MOUSEWHEEL: {            struct point point = {                .screen_size = frame_size,                .position = get_mouse_position(),            };            handle_mouse_wheel(&event.wheel, point);            break;        }        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP: {            handle_mouse_button(&event.button, frame_size);            break;        }        }    }}
static inline struct position get_mouse_position() {    int x;    int y;    SDL_GetMouseState(&x, &y);    SDL_assert_release(x >= 0 && x < 0x10000 && y >= 0 && y < 0x10000);    return (struct position) {        .x = (Uint16) x,        .y = (Uint16) y,    };}
static inline struct point get_mouse_point() {    int x;    int y;    SDL_GetMouseState(&x, &y);    SDL_assert_release(x >= 0 && x < 0x10000 && y >= 0 && y < 0x10000);    return (struct point) {        .x = (Uint16) x,        .y = (Uint16) y,    };}
static void handle_mouse_wheel(const SDL_MouseWheelEvent *event, struct position position) {    struct control_event control_event;    if (mouse_wheel_from_sdl_to_android(event, position, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send wheel button event");        }    }}
static void handle_mouse_wheel(const SDL_MouseWheelEvent *event, struct position position) {    struct control_event control_event;    if (mouse_wheel_from_sdl_to_android(event, position, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send wheel button event");        }    }}
void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            return;        case EVENT_NEW_FRAME:            if (!handle_new_frame()) {                return;            }            texture_empty = SDL_FALSE;            count_frame(); // display fps for debug            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_TEXTINPUT: {            handle_text_input(&event.text);            break;        }        case SDL_KEYDOWN:        case SDL_KEYUP:            handle_key(&event.key);            break;        case SDL_MOUSEMOTION:            handle_mouse_motion(&event.motion, frame_size);            break;        case SDL_MOUSEWHEEL: {            struct position position = {                .screen_size = frame_size,                .point = get_mouse_point(),            };            handle_mouse_wheel(&event.wheel, position);            break;        }        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP: {            handle_mouse_button(&event.button, frame_size);            break;        }        }    }}
static inline struct point get_mouse_point() {    int x;    int y;    SDL_GetMouseState(&x, &y);    SDL_assert_release(x >= 0 && x < 0x10000 && y >= 0 && y < 0x10000);    return (struct point) {        .x = (Uint16) x,        .y = (Uint16) y,    };}
static void test_serialize_scroll_event() {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_SCROLL,        .scroll_event = {            .point = {                .position = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },            .hscroll = 1,            .vscroll = -1,        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 17);    const unsigned char expected[] = {        0x03, // CONTROL_EVENT_TYPE_SCROLL        0x01, 0x04, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920        0x00, 0x00, 0x00, 0x01, // 1        0xFF, 0xFF, 0xFF, 0xFF, // -1    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_mouse_event() {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_MOUSE,        .mouse_event = {            .action = AMOTION_EVENT_ACTION_DOWN,            .buttons = AMOTION_EVENT_BUTTON_PRIMARY,            .point = {                .position = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 14);    const unsigned char expected[] = {        0x02, // CONTROL_EVENT_TYPE_MOUSE        0x00, // AKEY_EVENT_ACTION_DOWN        0x00, 0x00, 0x00, 0x01, // AMOTION_EVENT_BUTTON_PRIMARY        0x01, 0x04, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_scroll_event() {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_SCROLL,        .scroll_event = {            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },            .hscroll = 1,            .vscroll = -1,        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 17);    const unsigned char expected[] = {        0x03, // CONTROL_EVENT_TYPE_SCROLL        0x01, 0x04, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920        0x00, 0x00, 0x00, 0x01, // 1        0xFF, 0xFF, 0xFF, 0xFF, // -1    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_mouse_event() {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_MOUSE,        .mouse_event = {            .action = AMOTION_EVENT_ACTION_DOWN,            .buttons = AMOTION_EVENT_BUTTON_PRIMARY,            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 14);    const unsigned char expected[] = {        0x02, // CONTROL_EVENT_TYPE_MOUSE        0x00, // AKEY_EVENT_ACTION_DOWN        0x00, 0x00, 0x00, 0x01, // AMOTION_EVENT_BUTTON_PRIMARY        0x01, 0x04, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920    };    assert(!memcmp(buf, expected, sizeof(expected)));}
        return event;    }    public static ControlEvent createScrollControlEvent(Point point, int hScroll, int vScroll) {        ControlEvent event = new ControlEvent();        event.type = TYPE_SCROLL;        event.point = point;        event.hScroll = hScroll;        event.vScroll = vScroll;        return event;    }    public int getType() {        return type;    }    public String getText() {        return text;    }    public int getMetaState() {        return metaState;    }    public int getAction() {        return action;    }    public int getKeycode() {        return keycode;    }    public int getButtons() {
    public static ControlEvent createScrollControlEvent(Point point, int hScroll, int vScroll) {        ControlEvent event = new ControlEvent();        event.type = TYPE_SCROLL;        event.point = point;        event.hScroll = hScroll;        event.vScroll = vScroll;        return event;    }
    public Point getPoint() {        return point;    }
    public static ControlEvent createMotionControlEvent(int action, int buttons, Point point) {        ControlEvent event = new ControlEvent();        event.type = TYPE_MOUSE;        event.action = action;        event.buttons = buttons;        event.point = point;        return event;    }
    public static ControlEvent createMotionControlEvent(int action, int buttons, Point point) {        ControlEvent event = new ControlEvent();        event.type = TYPE_MOUSE;        event.action = action;        event.buttons = buttons;        event.point = point;        return event;    }
    public static ControlEvent createScrollControlEvent(Point point, int hScroll, int vScroll) {        ControlEvent event = new ControlEvent();        event.type = TYPE_SCROLL;        event.point = point;        event.hScroll = hScroll;        event.vScroll = vScroll;        return event;    }
    public Position getPosition() {        return position;    }
    public static ControlEvent createScrollControlEvent(Position position, int hScroll, int vScroll) {        ControlEvent event = new ControlEvent();        event.type = TYPE_SCROLL;        event.position = position;        event.hScroll = hScroll;        event.vScroll = vScroll;        return event;    }
    public Position getPosition() {        return position;    }
    public static ControlEvent createMotionControlEvent(int action, int buttons, Position position) {        ControlEvent event = new ControlEvent();        event.type = TYPE_MOUSE;        event.action = action;        event.buttons = buttons;        event.position = position;        return event;    }
    public static ControlEvent createMotionControlEvent(int action, int buttons, Position position) {        ControlEvent event = new ControlEvent();        event.type = TYPE_MOUSE;        event.action = action;        event.buttons = buttons;        event.position = position;        return event;    }
    public static ControlEvent createScrollControlEvent(Position position, int hScroll, int vScroll) {        ControlEvent event = new ControlEvent();        event.type = TYPE_SCROLL;        event.position = position;        event.hScroll = hScroll;        event.vScroll = vScroll;        return event;    }
    private static Point readPoint(ByteBuffer buffer) {        int x = toUnsigned(buffer.getShort());        int y = toUnsigned(buffer.getShort());        int screenWidth = toUnsigned(buffer.getShort());        int screenHeight = toUnsigned(buffer.getShort());        return new Point(x, y, screenWidth, screenHeight);    }
    public ControlEvent next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        switch (type) {            case ControlEvent.TYPE_KEYCODE: {                if (buffer.remaining() < KEYCODE_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                int keycode = buffer.getInt();                int metaState = buffer.getInt();                return ControlEvent.createKeycodeControlEvent(action, keycode, metaState);            }            case ControlEvent.TYPE_TEXT: {                if (buffer.remaining() < 1) {                    break;                }                int len = toUnsigned(buffer.get());                if (buffer.remaining() < len) {                    break;                }                buffer.get(textBuffer, 0, len);                String text = new String(textBuffer, 0, len, StandardCharsets.UTF_8);                return ControlEvent.createTextControlEvent(text);            }            case ControlEvent.TYPE_MOUSE: {                if (buffer.remaining() < MOUSE_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                int buttons = buffer.getInt();                Point point = readPoint(buffer);                return ControlEvent.createMotionControlEvent(action, buttons, point);            }            case ControlEvent.TYPE_SCROLL: {                if (buffer.remaining() < SCROLL_PAYLOAD_LENGTH) {                    break;                }                Point point = readPoint(buffer);                int hscroll = buffer.getInt();                int vscroll = buffer.getInt();                return ControlEvent.createScrollControlEvent(point, hscroll, vscroll);            }            default:                Ln.w("Unknown event type: " + type);        }        // failure, reset savedPosition        buffer.position(savedPosition);        return null;    }
    public ControlEvent next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        switch (type) {            case ControlEvent.TYPE_KEYCODE: {                if (buffer.remaining() < KEYCODE_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                int keycode = buffer.getInt();                int metaState = buffer.getInt();                return ControlEvent.createKeycodeControlEvent(action, keycode, metaState);            }            case ControlEvent.TYPE_TEXT: {                if (buffer.remaining() < 1) {                    break;                }                int len = toUnsigned(buffer.get());                if (buffer.remaining() < len) {                    break;                }                buffer.get(textBuffer, 0, len);                String text = new String(textBuffer, 0, len, StandardCharsets.UTF_8);                return ControlEvent.createTextControlEvent(text);            }            case ControlEvent.TYPE_MOUSE: {                if (buffer.remaining() < MOUSE_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                int buttons = buffer.getInt();                Point point = readPoint(buffer);                return ControlEvent.createMotionControlEvent(action, buttons, point);            }            case ControlEvent.TYPE_SCROLL: {                if (buffer.remaining() < SCROLL_PAYLOAD_LENGTH) {                    break;                }                Point point = readPoint(buffer);                int hscroll = buffer.getInt();                int vscroll = buffer.getInt();                return ControlEvent.createScrollControlEvent(point, hscroll, vscroll);            }            default:                Ln.w("Unknown event type: " + type);        }        // failure, reset savedPosition        buffer.position(savedPosition);        return null;    }
    private static Position readPosition(ByteBuffer buffer) {        int x = toUnsigned(buffer.getShort());        int y = toUnsigned(buffer.getShort());        int screenWidth = toUnsigned(buffer.getShort());        int screenHeight = toUnsigned(buffer.getShort());        return new Position(x, y, screenWidth, screenHeight);    }
    public ControlEvent next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        switch (type) {            case ControlEvent.TYPE_KEYCODE: {                if (buffer.remaining() < KEYCODE_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                int keycode = buffer.getInt();                int metaState = buffer.getInt();                return ControlEvent.createKeycodeControlEvent(action, keycode, metaState);            }            case ControlEvent.TYPE_TEXT: {                if (buffer.remaining() < 1) {                    break;                }                int len = toUnsigned(buffer.get());                if (buffer.remaining() < len) {                    break;                }                buffer.get(textBuffer, 0, len);                String text = new String(textBuffer, 0, len, StandardCharsets.UTF_8);                return ControlEvent.createTextControlEvent(text);            }            case ControlEvent.TYPE_MOUSE: {                if (buffer.remaining() < MOUSE_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                int buttons = buffer.getInt();                Position position = readPosition(buffer);                return ControlEvent.createMotionControlEvent(action, buttons, position);            }            case ControlEvent.TYPE_SCROLL: {                if (buffer.remaining() < SCROLL_PAYLOAD_LENGTH) {                    break;                }                Position position = readPosition(buffer);                int hScroll = buffer.getInt();                int vScroll = buffer.getInt();                return ControlEvent.createScrollControlEvent(position, hScroll, vScroll);            }            default:                Ln.w("Unknown event type: " + type);        }        // failure, reset savedPosition        buffer.position(savedPosition);        return null;    }
    private static Position readPosition(ByteBuffer buffer) {        int x = toUnsigned(buffer.getShort());        int y = toUnsigned(buffer.getShort());        int screenWidth = toUnsigned(buffer.getShort());        int screenHeight = toUnsigned(buffer.getShort());        return new Position(x, y, screenWidth, screenHeight);    }
    public RawPoint getPhysicalPoint(Point point) {        ScreenInfo screenInfo = getScreenInfo();        int deviceWidth = screenInfo.getLogicalWidth();        int deviceHeight = screenInfo.getLogicalHeight();        int scaledX = point.getX() * deviceWidth / point.getScreenWidth();        int scaledY = point.getY() * deviceHeight / point.getScreenHeight();        return new RawPoint(scaledX, scaledY);    }
    public RawPoint getPhysicalPoint(Point point) {        ScreenInfo screenInfo = getScreenInfo();        int deviceWidth = screenInfo.getLogicalWidth();        int deviceHeight = screenInfo.getLogicalHeight();        int scaledX = point.getX() * deviceWidth / point.getScreenWidth();        int scaledY = point.getY() * deviceHeight / point.getScreenHeight();        return new RawPoint(scaledX, scaledY);    }
    public Point getPhysicalPoint(Position position) {        ScreenInfo screenInfo = getScreenInfo();        int deviceWidth = screenInfo.getLogicalWidth();        int deviceHeight = screenInfo.getLogicalHeight();        int scaledX = position.getX() * deviceWidth / position.getScreenWidth();        int scaledY = position.getY() * deviceHeight / position.getScreenHeight();        return new Point(scaledX, scaledY);    }
    public Point getPhysicalPoint(Position position) {        ScreenInfo screenInfo = getScreenInfo();        int deviceWidth = screenInfo.getLogicalWidth();        int deviceHeight = screenInfo.getLogicalHeight();        int scaledX = position.getX() * deviceWidth / position.getScreenWidth();        int scaledY = position.getY() * deviceHeight / position.getScreenHeight();        return new Point(scaledX, scaledY);    }
    private boolean injectMouse(int action, int buttons, Point point) {        long now = SystemClock.uptimeMillis();        if (action == MotionEvent.ACTION_DOWN) {            lastMouseDown = now;        }        RawPoint rawPoint = Device.getInstance().getPhysicalPoint(point);        if (rawPoint == null) {            // ignore event            return false;        }        setPointerCoords(rawPoint);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, action, 1, pointerProperties, pointerCoords, 0, buttons, 1f, 1f, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
    private boolean injectScroll(Point point, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        RawPoint rawPoint = Device.getInstance().getPhysicalPoint(point);        if (rawPoint == null) {            // ignore event            return false;        }        setPointerCoords(rawPoint);        setScroll(hScroll, vScroll);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, MotionEvent.ACTION_SCROLL, 1, pointerProperties, pointerCoords, 0, 0, 1f, 1f, 0, 0, InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
    private boolean injectMouse(int action, int buttons, Point point) {        long now = SystemClock.uptimeMillis();        if (action == MotionEvent.ACTION_DOWN) {            lastMouseDown = now;        }        RawPoint rawPoint = Device.getInstance().getPhysicalPoint(point);        if (rawPoint == null) {            // ignore event            return false;        }        setPointerCoords(rawPoint);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, action, 1, pointerProperties, pointerCoords, 0, buttons, 1f, 1f, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
    private void setPointerCoords(RawPoint rawPoint) {        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.x = rawPoint.getX();        coords.y = rawPoint.getY();    }
    private boolean injectScroll(Point point, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        RawPoint rawPoint = Device.getInstance().getPhysicalPoint(point);        if (rawPoint == null) {            // ignore event            return false;        }        setPointerCoords(rawPoint);        setScroll(hScroll, vScroll);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, MotionEvent.ACTION_SCROLL, 1, pointerProperties, pointerCoords, 0, 0, 1f, 1f, 0, 0, InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
    private void setPointerCoords(RawPoint rawPoint) {        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.x = rawPoint.getX();        coords.y = rawPoint.getY();    }
    private boolean handleEvent() throws IOException {        ControlEvent controlEvent = connection.receiveControlEvent();        if (controlEvent == null) {            return false;        }        switch (controlEvent.getType()) {            case ControlEvent.TYPE_KEYCODE:                injectKeycode(controlEvent.getAction(), controlEvent.getKeycode(), controlEvent.getMetaState());                break;            case ControlEvent.TYPE_TEXT:                injectText(controlEvent.getText());                break;            case ControlEvent.TYPE_MOUSE:                injectMouse(controlEvent.getAction(), controlEvent.getButtons(), controlEvent.getPoint());                break;            case ControlEvent.TYPE_SCROLL:                injectScroll(controlEvent.getPoint(), controlEvent.getHScroll(), controlEvent.getVScroll());        }        return true;    }
    private boolean injectMouse(int action, int buttons, Position position) {        long now = SystemClock.uptimeMillis();        if (action == MotionEvent.ACTION_DOWN) {            lastMouseDown = now;        }        Point point = Device.getInstance().getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        setPointerCoords(point);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, action, 1, pointerProperties, pointerCoords, 0, buttons, 1f, 1f, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
    private boolean injectScroll(Position position, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        Point point = Device.getInstance().getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        setPointerCoords(point);        setScroll(hScroll, vScroll);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, MotionEvent.ACTION_SCROLL, 1, pointerProperties, pointerCoords, 0, 0, 1f, 1f, 0, 0, InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
    private boolean injectMouse(int action, int buttons, Position position) {        long now = SystemClock.uptimeMillis();        if (action == MotionEvent.ACTION_DOWN) {            lastMouseDown = now;        }        Point point = Device.getInstance().getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        setPointerCoords(point);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, action, 1, pointerProperties, pointerCoords, 0, buttons, 1f, 1f, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
    private void setPointerCoords(Point point) {        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.x = point.getX();        coords.y = point.getY();    }
    private boolean injectScroll(Position position, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        Point point = Device.getInstance().getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        setPointerCoords(point);        setScroll(hScroll, vScroll);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, MotionEvent.ACTION_SCROLL, 1, pointerProperties, pointerCoords, 0, 0, 1f, 1f, 0, 0, InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
    private void setPointerCoords(Point point) {        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.x = point.getX();        coords.y = point.getY();    }
    private boolean handleEvent() throws IOException {        ControlEvent controlEvent = connection.receiveControlEvent();        if (controlEvent == null) {            return false;        }        switch (controlEvent.getType()) {            case ControlEvent.TYPE_KEYCODE:                injectKeycode(controlEvent.getAction(), controlEvent.getKeycode(), controlEvent.getMetaState());                break;            case ControlEvent.TYPE_TEXT:                injectText(controlEvent.getText());                break;            case ControlEvent.TYPE_MOUSE:                injectMouse(controlEvent.getAction(), controlEvent.getButtons(), controlEvent.getPosition());                break;            case ControlEvent.TYPE_SCROLL:                injectScroll(controlEvent.getPosition(), controlEvent.getHScroll(), controlEvent.getVScroll());        }        return true;    }
    public int getScreenWidth() {        return screenWidth;    }
    public Point(int x, int y, int screenWidth, int screenHeight) {        this.x = x;        this.y = y;        this.screenWidth = screenWidth;        this.screenHeight = screenHeight;    }
    public Point(int x, int y, int screenWidth, int screenHeight) {        this.x = x;        this.y = y;        this.screenWidth = screenWidth;        this.screenHeight = screenHeight;    }
                '}';    }}
    public Point(int x, int y) {        this.x = x;        this.y = y;    }
    }    public int getX() {        return x;    }    public int getY() {
    private ScreenInfo computeScreenInfo(int maxSize) {        // Compute the video size and the padding of the content inside this video.        // Principle:        // - scale down the great side of the screen to maxSize (if necessary);        // - scale down the other side so that the aspect ratio is preserved;        // - round this value to the nearest multiple of 8 (H.264 only accepts multiples of 8)        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        int w = deviceSize.getWidth() & ~7; // in case it's not a multiple of 8        int h = deviceSize.getHeight() & ~7;        if (maxSize > 0) {            if (BuildConfig.DEBUG && maxSize % 8 != 0) {                throw new AssertionError("Max size must be a multiple of 8");            }            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;            if (major > maxSize) {                int minorExact = minor * maxSize / major;                // +4 to round the value to the nearest multiple of 8                minor = (minorExact + 4) & ~7;                major = maxSize;            }            w = portrait ? minor : major;            h = portrait ? major : minor;        }        Size videoSize = new Size(w, h);        return new ScreenInfo(deviceSize, videoSize, rotated);    }
    private ScreenInfo computeScreenInfo(int maxSize) {        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        Size videoSize = computeVideoSize(deviceSize, maxSize);        return new ScreenInfo(deviceSize, videoSize, rotated);    }
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"bit-rate", required_argument, NULL, 'b'},        {"help",     no_argument,       NULL, 'h'},        {"max-size", required_argument, NULL, 'm'},        {"port",     required_argument, NULL, 'p'},        {"serial",   required_argument, NULL, 's'},        {"version",  no_argument,       NULL, 'v'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:hm:p:s:v", long_options, NULL)) != -1) {        switch (c) {            case 'b': {                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            }            case 'h': {                args->help = SDL_TRUE;                break;            }            case 'm': {                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            }            case 'p': {                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            }            case 's': {                args->serial = optarg;                break;            }            case 'v': {                args->version = SDL_TRUE;                break;            }            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    return SDL_TRUE;}
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"bit-rate", required_argument, NULL, 'b'},        {"help",     no_argument,       NULL, 'h'},        {"max-size", required_argument, NULL, 'm'},        {"port",     required_argument, NULL, 'p'},        {"serial",   required_argument, NULL, 's'},        {"version",  no_argument,       NULL, 'v'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:hm:p:s:v", long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 's':                args->serial = optarg;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    return SDL_TRUE;}
handle_event(SDL_Event *event, bool control) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = true;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return false;            }            break;        case SDL_WINDOWEVENT:            switch (event->window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;            }            break;        case SDL_TEXTINPUT:            if (!control) {                break;            }            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            // some key events do not interact with the device, so process the            // event even if control is disabled            input_manager_process_key(&input_manager, &event->key, control);            break;        case SDL_MOUSEMOTION:            if (!control) {                break;            }            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            if (!control) {                break;            }            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            // some mouse events do not interact with the device, so process            // the event even if control is disabled            input_manager_process_mouse_button(&input_manager, &event->button,                                               control);            break;        case SDL_DROPFILE: {            if (!control) {                break;            }            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
handle_event(SDL_Event *event, bool control) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = true;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return EVENT_RESULT_CONTINUE;            }            break;        case SDL_WINDOWEVENT:            switch (event->window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;            }            break;        case SDL_TEXTINPUT:            if (!control) {                break;            }            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            // some key events do not interact with the device, so process the            // event even if control is disabled            input_manager_process_key(&input_manager, &event->key, control);            break;        case SDL_MOUSEMOTION:            if (!control) {                break;            }            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            if (!control) {                break;            }            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            // some mouse events do not interact with the device, so process            // the event even if control is disabled            input_manager_process_mouse_button(&input_manager, &event->button,                                               control);            break;        case SDL_DROPFILE: {            if (!control) {                break;            }            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
run_stream(void *data) {    struct stream *stream = data;    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto end;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto finally_free_format_ctx;    }    // initialize the receiver state    stream->receiver_state.frame_meta_queue = NULL;    stream->receiver_state.remaining = 0;    // if recording is enabled, a "header" is sent between raw packets    int (*read_packet)(void *, uint8_t *, int) =            stream->recorder ? read_packet_with_meta : read_raw_packet;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, stream,                                               read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto finally_free_avio_ctx;    }    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto end;    }    if (stream->decoder && !decoder_open(stream->decoder, codec)) {        LOGE("Could not open decoder");        goto finally_close_input;    }    if (stream->recorder && !recorder_open(stream->recorder, codec)) {        LOGE("Could not open recorder");        goto finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {        if (SDL_AtomicGet(&stream->stopped)) {            // if the stream is stopped, the socket had been shutdown, so the            // last packet is probably corrupted (but not detected as such by            // FFmpeg) and will not be decoded correctly            av_packet_unref(&packet);            goto quit;        }        if (stream->decoder && !decoder_push(stream->decoder, &packet)) {            av_packet_unref(&packet);            goto quit;        }        if (stream->recorder) {            // we retrieve the PTS in order they were received, so they will            // be assigned to the correct frame            uint64_t pts = receiver_state_take_meta(&stream->receiver_state);            packet.pts = pts;            packet.dts = pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(stream->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");quit:    if (stream->recorder) {        recorder_close(stream->recorder);    }finally_close_input:    avformat_close_input(&format_ctx);finally_free_avio_ctx:    av_free(avio_ctx->buffer);    av_free(avio_ctx);finally_free_format_ctx:    avformat_free_context(format_ctx);end:    notify_stopped();    return 0;}
run_stream(void *data) {    struct stream *stream = data;    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto end;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto finally_free_format_ctx;    }    // initialize the receiver state    stream->receiver_state.frame_meta_queue = NULL;    stream->receiver_state.remaining = 0;    // if recording is enabled, a "header" is sent between raw packets    int (*read_packet)(void *, uint8_t *, int) =            stream->recorder ? read_packet_with_meta : read_raw_packet;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, stream,                                               read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto finally_free_avio_ctx;    }    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto end;    }    if (stream->decoder && !decoder_open(stream->decoder, codec)) {        LOGE("Could not open decoder");        goto finally_close_input;    }    if (stream->recorder && !recorder_open(stream->recorder, codec)) {        LOGE("Could not open recorder");        goto finally_close_decoder;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {        if (SDL_AtomicGet(&stream->stopped)) {            // if the stream is stopped, the socket had been shutdown, so the            // last packet is probably corrupted (but not detected as such by            // FFmpeg) and will not be decoded correctly            av_packet_unref(&packet);            goto quit;        }        if (stream->decoder && !decoder_push(stream->decoder, &packet)) {            av_packet_unref(&packet);            goto quit;        }        if (stream->recorder) {            // we retrieve the PTS in order they were received, so they will            // be assigned to the correct frame            uint64_t pts = receiver_state_take_meta(&stream->receiver_state);            packet.pts = pts;            packet.dts = pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(stream->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");quit:    if (stream->recorder) {        recorder_close(stream->recorder);    }finally_close_decoder:    if (stream->decoder) {        decoder_close(stream->decoder);    }finally_close_input:    avformat_close_input(&format_ctx);finally_free_avio_ctx:    av_free(avio_ctx->buffer);    av_free(avio_ctx);finally_free_format_ctx:    avformat_free_context(format_ctx);end:    notify_stopped();    return 0;}
static inline const char *get_adb_command() {    if (!adb_command) {        adb_command = getenv("ADB");        if (!adb_command)            adb_command = "adb";    }    return adb_command;}
static inline const char *get_adb_command() {    if (!adb_command) {        adb_command = getenv("ADB");        if (!adb_command)            adb_command = "adb";    }    return adb_command;}
static inline const char *get_adb_command(void) {    if (!adb_command) {        adb_command = getenv("ADB");        if (!adb_command)            adb_command = "adb";    }    return adb_command;}
static inline const char *get_adb_command(void) {    if (!adb_command) {        adb_command = getenv("ADB");        if (!adb_command)            adb_command = "adb";    }    return adb_command;}
static void test_control_event_queue_empty() {    struct control_event_queue queue;    SDL_bool init_ok = control_event_queue_init(&queue);    assert(init_ok);    assert(control_event_queue_is_empty(&queue));    struct control_event dummy_event;    SDL_bool push_ok = control_event_queue_push(&queue, &dummy_event);    assert(push_ok);    assert(!control_event_queue_is_empty(&queue));    SDL_bool take_ok = control_event_queue_take(&queue, &dummy_event);    assert(take_ok);    assert(control_event_queue_is_empty(&queue));    SDL_bool take_empty_ok = control_event_queue_take(&queue, &dummy_event);    assert(!take_empty_ok); // the queue is empty    control_event_queue_destroy(&queue);}
static void test_control_event_queue_full() {    struct control_event_queue queue;    SDL_bool init_ok = control_event_queue_init(&queue);    assert(init_ok);    assert(!control_event_queue_is_full(&queue));    struct control_event dummy_event;    // fill the queue    while (control_event_queue_push(&queue, &dummy_event));    SDL_bool take_ok = control_event_queue_take(&queue, &dummy_event);    assert(take_ok);    assert(!control_event_queue_is_full(&queue));    control_event_queue_destroy(&queue);}
static void test_control_event_queue_push_take() {    struct control_event_queue queue;    SDL_bool init_ok = control_event_queue_init(&queue);    assert(init_ok);    struct control_event event = {        .type = CONTROL_EVENT_TYPE_KEYCODE,        .keycode_event = {            .action = AKEY_EVENT_ACTION_DOWN,            .keycode = AKEYCODE_ENTER,            .metastate = AMETA_CTRL_LEFT_ON | AMETA_CTRL_ON,        },    };    SDL_bool push1_ok = control_event_queue_push(&queue, &event);    assert(push1_ok);    event = (struct control_event) {        .type = CONTROL_EVENT_TYPE_TEXT,        .text_event = {            .text = "abc",        },    };    SDL_bool push2_ok = control_event_queue_push(&queue, &event);    assert(push2_ok);    // overwrite event    SDL_bool take1_ok = control_event_queue_take(&queue, &event);    assert(take1_ok);    assert(event.type == CONTROL_EVENT_TYPE_KEYCODE);    assert(event.keycode_event.action == AKEY_EVENT_ACTION_DOWN);    assert(event.keycode_event.keycode == AKEYCODE_ENTER);    assert(event.keycode_event.metastate == (AMETA_CTRL_LEFT_ON | AMETA_CTRL_ON));    // overwrite event    SDL_bool take2_ok = control_event_queue_take(&queue, &event);    assert(take2_ok);    assert(event.type == CONTROL_EVENT_TYPE_TEXT);    assert(!strcmp(event.text_event.text, "abc"));    control_event_queue_destroy(&queue);}
static void test_control_event_queue_empty() {    struct control_event_queue queue;    SDL_bool init_ok = control_event_queue_init(&queue);    assert(init_ok);    assert(control_event_queue_is_empty(&queue));    struct control_event dummy_event;    SDL_bool push_ok = control_event_queue_push(&queue, &dummy_event);    assert(push_ok);    assert(!control_event_queue_is_empty(&queue));    SDL_bool take_ok = control_event_queue_take(&queue, &dummy_event);    assert(take_ok);    assert(control_event_queue_is_empty(&queue));    SDL_bool take_empty_ok = control_event_queue_take(&queue, &dummy_event);    assert(!take_empty_ok); // the queue is empty    control_event_queue_destroy(&queue);}
static void test_control_event_queue_push_take() {    struct control_event_queue queue;    SDL_bool init_ok = control_event_queue_init(&queue);    assert(init_ok);    struct control_event event = {        .type = CONTROL_EVENT_TYPE_KEYCODE,        .keycode_event = {            .action = AKEY_EVENT_ACTION_DOWN,            .keycode = AKEYCODE_ENTER,            .metastate = AMETA_CTRL_LEFT_ON | AMETA_CTRL_ON,        },    };    SDL_bool push1_ok = control_event_queue_push(&queue, &event);    assert(push1_ok);    event = (struct control_event) {        .type = CONTROL_EVENT_TYPE_TEXT,        .text_event = {            .text = "abc",        },    };    SDL_bool push2_ok = control_event_queue_push(&queue, &event);    assert(push2_ok);    // overwrite event    SDL_bool take1_ok = control_event_queue_take(&queue, &event);    assert(take1_ok);    assert(event.type == CONTROL_EVENT_TYPE_KEYCODE);    assert(event.keycode_event.action == AKEY_EVENT_ACTION_DOWN);    assert(event.keycode_event.keycode == AKEYCODE_ENTER);    assert(event.keycode_event.metastate == (AMETA_CTRL_LEFT_ON | AMETA_CTRL_ON));    // overwrite event    SDL_bool take2_ok = control_event_queue_take(&queue, &event);    assert(take2_ok);    assert(event.type == CONTROL_EVENT_TYPE_TEXT);    assert(!strcmp(event.text_event.text, "abc"));    control_event_queue_destroy(&queue);}
static void test_control_event_queue_full() {    struct control_event_queue queue;    SDL_bool init_ok = control_event_queue_init(&queue);    assert(init_ok);    assert(!control_event_queue_is_full(&queue));    struct control_event dummy_event;    // fill the queue    while (control_event_queue_push(&queue, &dummy_event));    SDL_bool take_ok = control_event_queue_take(&queue, &dummy_event);    assert(take_ok);    assert(!control_event_queue_is_full(&queue));    control_event_queue_destroy(&queue);}
int main() {    test_control_event_queue_empty();    test_control_event_queue_full();    test_control_event_queue_push_take();    return 0;}
int main() {    test_control_event_queue_empty();    test_control_event_queue_full();    test_control_event_queue_push_take();    return 0;}
static void test_control_event_queue_empty(void) {    struct control_event_queue queue;    SDL_bool init_ok = control_event_queue_init(&queue);    assert(init_ok);    assert(control_event_queue_is_empty(&queue));    struct control_event dummy_event;    SDL_bool push_ok = control_event_queue_push(&queue, &dummy_event);    assert(push_ok);    assert(!control_event_queue_is_empty(&queue));    SDL_bool take_ok = control_event_queue_take(&queue, &dummy_event);    assert(take_ok);    assert(control_event_queue_is_empty(&queue));    SDL_bool take_empty_ok = control_event_queue_take(&queue, &dummy_event);    assert(!take_empty_ok); // the queue is empty    control_event_queue_destroy(&queue);}
static void test_control_event_queue_full(void) {    struct control_event_queue queue;    SDL_bool init_ok = control_event_queue_init(&queue);    assert(init_ok);    assert(!control_event_queue_is_full(&queue));    struct control_event dummy_event;    // fill the queue    while (control_event_queue_push(&queue, &dummy_event));    SDL_bool take_ok = control_event_queue_take(&queue, &dummy_event);    assert(take_ok);    assert(!control_event_queue_is_full(&queue));    control_event_queue_destroy(&queue);}
static void test_control_event_queue_push_take(void) {    struct control_event_queue queue;    SDL_bool init_ok = control_event_queue_init(&queue);    assert(init_ok);    struct control_event event = {        .type = CONTROL_EVENT_TYPE_KEYCODE,        .keycode_event = {            .action = AKEY_EVENT_ACTION_DOWN,            .keycode = AKEYCODE_ENTER,            .metastate = AMETA_CTRL_LEFT_ON | AMETA_CTRL_ON,        },    };    SDL_bool push1_ok = control_event_queue_push(&queue, &event);    assert(push1_ok);    event = (struct control_event) {        .type = CONTROL_EVENT_TYPE_TEXT,        .text_event = {            .text = "abc",        },    };    SDL_bool push2_ok = control_event_queue_push(&queue, &event);    assert(push2_ok);    // overwrite event    SDL_bool take1_ok = control_event_queue_take(&queue, &event);    assert(take1_ok);    assert(event.type == CONTROL_EVENT_TYPE_KEYCODE);    assert(event.keycode_event.action == AKEY_EVENT_ACTION_DOWN);    assert(event.keycode_event.keycode == AKEYCODE_ENTER);    assert(event.keycode_event.metastate == (AMETA_CTRL_LEFT_ON | AMETA_CTRL_ON));    // overwrite event    SDL_bool take2_ok = control_event_queue_take(&queue, &event);    assert(take2_ok);    assert(event.type == CONTROL_EVENT_TYPE_TEXT);    assert(!strcmp(event.text_event.text, "abc"));    control_event_queue_destroy(&queue);}
static void test_control_event_queue_empty(void) {    struct control_event_queue queue;    SDL_bool init_ok = control_event_queue_init(&queue);    assert(init_ok);    assert(control_event_queue_is_empty(&queue));    struct control_event dummy_event;    SDL_bool push_ok = control_event_queue_push(&queue, &dummy_event);    assert(push_ok);    assert(!control_event_queue_is_empty(&queue));    SDL_bool take_ok = control_event_queue_take(&queue, &dummy_event);    assert(take_ok);    assert(control_event_queue_is_empty(&queue));    SDL_bool take_empty_ok = control_event_queue_take(&queue, &dummy_event);    assert(!take_empty_ok); // the queue is empty    control_event_queue_destroy(&queue);}
static void test_control_event_queue_push_take(void) {    struct control_event_queue queue;    SDL_bool init_ok = control_event_queue_init(&queue);    assert(init_ok);    struct control_event event = {        .type = CONTROL_EVENT_TYPE_KEYCODE,        .keycode_event = {            .action = AKEY_EVENT_ACTION_DOWN,            .keycode = AKEYCODE_ENTER,            .metastate = AMETA_CTRL_LEFT_ON | AMETA_CTRL_ON,        },    };    SDL_bool push1_ok = control_event_queue_push(&queue, &event);    assert(push1_ok);    event = (struct control_event) {        .type = CONTROL_EVENT_TYPE_TEXT,        .text_event = {            .text = "abc",        },    };    SDL_bool push2_ok = control_event_queue_push(&queue, &event);    assert(push2_ok);    // overwrite event    SDL_bool take1_ok = control_event_queue_take(&queue, &event);    assert(take1_ok);    assert(event.type == CONTROL_EVENT_TYPE_KEYCODE);    assert(event.keycode_event.action == AKEY_EVENT_ACTION_DOWN);    assert(event.keycode_event.keycode == AKEYCODE_ENTER);    assert(event.keycode_event.metastate == (AMETA_CTRL_LEFT_ON | AMETA_CTRL_ON));    // overwrite event    SDL_bool take2_ok = control_event_queue_take(&queue, &event);    assert(take2_ok);    assert(event.type == CONTROL_EVENT_TYPE_TEXT);    assert(!strcmp(event.text_event.text, "abc"));    control_event_queue_destroy(&queue);}
static void test_control_event_queue_full(void) {    struct control_event_queue queue;    SDL_bool init_ok = control_event_queue_init(&queue);    assert(init_ok);    assert(!control_event_queue_is_full(&queue));    struct control_event dummy_event;    // fill the queue    while (control_event_queue_push(&queue, &dummy_event));    SDL_bool take_ok = control_event_queue_take(&queue, &dummy_event);    assert(take_ok);    assert(!control_event_queue_is_full(&queue));    control_event_queue_destroy(&queue);}
int main(void) {    test_control_event_queue_empty();    test_control_event_queue_full();    test_control_event_queue_push_take();    return 0;}
int main(void) {    test_control_event_queue_empty();    test_control_event_queue_full();    test_control_event_queue_push_take();    return 0;}
static void test_serialize_long_text_event() {    struct control_event event;    event.type = CONTROL_EVENT_TYPE_TEXT;    char text[TEXT_MAX_LENGTH];    memset(text, 'a', sizeof(text));    event.text_event.text = text;    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 3 + sizeof(text));    unsigned char expected[3 + TEXT_MAX_LENGTH];    expected[0] = 0x01; // CONTROL_EVENT_TYPE_KEYCODE    expected[1] = 0x01;    expected[2] = 0x2c; // text length (16 bits)    memset(&expected[3], 'a', TEXT_MAX_LENGTH);    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_keycode_event() {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_KEYCODE,        .keycode_event = {            .action = AKEY_EVENT_ACTION_UP,            .keycode = AKEYCODE_ENTER,            .metastate = AMETA_SHIFT_ON | AMETA_SHIFT_LEFT_ON,        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 10);    const unsigned char expected[] = {        0x00, // CONTROL_EVENT_TYPE_KEYCODE        0x01, // AKEY_EVENT_ACTION_UP        0x00, 0x00, 0x00, 0x42, // AKEYCODE_ENTER        0x00, 0x00, 0x00, 0x41, // AMETA_SHIFT_ON | AMETA_SHIFT_LEFT_ON    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_keycode_event() {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_KEYCODE,        .keycode_event = {            .action = AKEY_EVENT_ACTION_UP,            .keycode = AKEYCODE_ENTER,            .metastate = AMETA_SHIFT_ON | AMETA_SHIFT_LEFT_ON,        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 10);    const unsigned char expected[] = {        0x00, // CONTROL_EVENT_TYPE_KEYCODE        0x01, // AKEY_EVENT_ACTION_UP        0x00, 0x00, 0x00, 0x42, // AKEYCODE_ENTER        0x00, 0x00, 0x00, 0x41, // AMETA_SHIFT_ON | AMETA_SHIFT_LEFT_ON    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_mouse_event() {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_MOUSE,        .mouse_event = {            .action = AMOTION_EVENT_ACTION_DOWN,            .buttons = AMOTION_EVENT_BUTTON_PRIMARY,            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 14);    const unsigned char expected[] = {        0x02, // CONTROL_EVENT_TYPE_MOUSE        0x00, // AKEY_EVENT_ACTION_DOWN        0x00, 0x00, 0x00, 0x01, // AMOTION_EVENT_BUTTON_PRIMARY        0x01, 0x04, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_scroll_event() {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_SCROLL,        .scroll_event = {            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },            .hscroll = 1,            .vscroll = -1,        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 17);    const unsigned char expected[] = {        0x03, // CONTROL_EVENT_TYPE_SCROLL        0x01, 0x04, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920        0x00, 0x00, 0x00, 0x01, // 1        0xFF, 0xFF, 0xFF, 0xFF, // -1    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_scroll_event() {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_SCROLL,        .scroll_event = {            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },            .hscroll = 1,            .vscroll = -1,        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 17);    const unsigned char expected[] = {        0x03, // CONTROL_EVENT_TYPE_SCROLL        0x01, 0x04, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920        0x00, 0x00, 0x00, 0x01, // 1        0xFF, 0xFF, 0xFF, 0xFF, // -1    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_long_text_event() {    struct control_event event;    event.type = CONTROL_EVENT_TYPE_TEXT;    char text[TEXT_MAX_LENGTH];    memset(text, 'a', sizeof(text));    event.text_event.text = text;    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 3 + sizeof(text));    unsigned char expected[3 + TEXT_MAX_LENGTH];    expected[0] = 0x01; // CONTROL_EVENT_TYPE_KEYCODE    expected[1] = 0x01;    expected[2] = 0x2c; // text length (16 bits)    memset(&expected[3], 'a', TEXT_MAX_LENGTH);    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_mouse_event() {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_MOUSE,        .mouse_event = {            .action = AMOTION_EVENT_ACTION_DOWN,            .buttons = AMOTION_EVENT_BUTTON_PRIMARY,            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 14);    const unsigned char expected[] = {        0x02, // CONTROL_EVENT_TYPE_MOUSE        0x00, // AKEY_EVENT_ACTION_DOWN        0x00, 0x00, 0x00, 0x01, // AMOTION_EVENT_BUTTON_PRIMARY        0x01, 0x04, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_text_event() {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_TEXT,        .text_event = {            .text = "hello, world!",        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 16);    const unsigned char expected[] = {        0x01, // CONTROL_EVENT_TYPE_KEYCODE        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
int main() {    test_serialize_keycode_event();    test_serialize_text_event();    test_serialize_long_text_event();    test_serialize_mouse_event();    test_serialize_scroll_event();    return 0;}
int main() {    test_serialize_keycode_event();    test_serialize_text_event();    test_serialize_long_text_event();    test_serialize_mouse_event();    test_serialize_scroll_event();    return 0;}
static void test_serialize_text_event() {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_TEXT,        .text_event = {            .text = "hello, world!",        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 16);    const unsigned char expected[] = {        0x01, // CONTROL_EVENT_TYPE_KEYCODE        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_long_text_event(void) {    struct control_event event;    event.type = CONTROL_EVENT_TYPE_TEXT;    char text[TEXT_MAX_LENGTH];    memset(text, 'a', sizeof(text));    event.text_event.text = text;    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 3 + sizeof(text));    unsigned char expected[3 + TEXT_MAX_LENGTH];    expected[0] = 0x01; // CONTROL_EVENT_TYPE_KEYCODE    expected[1] = 0x01;    expected[2] = 0x2c; // text length (16 bits)    memset(&expected[3], 'a', TEXT_MAX_LENGTH);    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_keycode_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_KEYCODE,        .keycode_event = {            .action = AKEY_EVENT_ACTION_UP,            .keycode = AKEYCODE_ENTER,            .metastate = AMETA_SHIFT_ON | AMETA_SHIFT_LEFT_ON,        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 10);    const unsigned char expected[] = {        0x00, // CONTROL_EVENT_TYPE_KEYCODE        0x01, // AKEY_EVENT_ACTION_UP        0x00, 0x00, 0x00, 0x42, // AKEYCODE_ENTER        0x00, 0x00, 0x00, 0x41, // AMETA_SHIFT_ON | AMETA_SHIFT_LEFT_ON    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_keycode_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_KEYCODE,        .keycode_event = {            .action = AKEY_EVENT_ACTION_UP,            .keycode = AKEYCODE_ENTER,            .metastate = AMETA_SHIFT_ON | AMETA_SHIFT_LEFT_ON,        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 10);    const unsigned char expected[] = {        0x00, // CONTROL_EVENT_TYPE_KEYCODE        0x01, // AKEY_EVENT_ACTION_UP        0x00, 0x00, 0x00, 0x42, // AKEYCODE_ENTER        0x00, 0x00, 0x00, 0x41, // AMETA_SHIFT_ON | AMETA_SHIFT_LEFT_ON    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_mouse_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_MOUSE,        .mouse_event = {            .action = AMOTION_EVENT_ACTION_DOWN,            .buttons = AMOTION_EVENT_BUTTON_PRIMARY,            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 14);    const unsigned char expected[] = {        0x02, // CONTROL_EVENT_TYPE_MOUSE        0x00, // AKEY_EVENT_ACTION_DOWN        0x00, 0x00, 0x00, 0x01, // AMOTION_EVENT_BUTTON_PRIMARY        0x01, 0x04, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_scroll_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_SCROLL,        .scroll_event = {            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },            .hscroll = 1,            .vscroll = -1,        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 17);    const unsigned char expected[] = {        0x03, // CONTROL_EVENT_TYPE_SCROLL        0x01, 0x04, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920        0x00, 0x00, 0x00, 0x01, // 1        0xFF, 0xFF, 0xFF, 0xFF, // -1    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_scroll_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_SCROLL,        .scroll_event = {            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },            .hscroll = 1,            .vscroll = -1,        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 17);    const unsigned char expected[] = {        0x03, // CONTROL_EVENT_TYPE_SCROLL        0x01, 0x04, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920        0x00, 0x00, 0x00, 0x01, // 1        0xFF, 0xFF, 0xFF, 0xFF, // -1    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_long_text_event(void) {    struct control_event event;    event.type = CONTROL_EVENT_TYPE_TEXT;    char text[TEXT_MAX_LENGTH];    memset(text, 'a', sizeof(text));    event.text_event.text = text;    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 3 + sizeof(text));    unsigned char expected[3 + TEXT_MAX_LENGTH];    expected[0] = 0x01; // CONTROL_EVENT_TYPE_KEYCODE    expected[1] = 0x01;    expected[2] = 0x2c; // text length (16 bits)    memset(&expected[3], 'a', TEXT_MAX_LENGTH);    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_mouse_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_MOUSE,        .mouse_event = {            .action = AMOTION_EVENT_ACTION_DOWN,            .buttons = AMOTION_EVENT_BUTTON_PRIMARY,            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 14);    const unsigned char expected[] = {        0x02, // CONTROL_EVENT_TYPE_MOUSE        0x00, // AKEY_EVENT_ACTION_DOWN        0x00, 0x00, 0x00, 0x01, // AMOTION_EVENT_BUTTON_PRIMARY        0x01, 0x04, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_text_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_TEXT,        .text_event = {            .text = "hello, world!",        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 16);    const unsigned char expected[] = {        0x01, // CONTROL_EVENT_TYPE_KEYCODE        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
int main(void) {    test_serialize_keycode_event();    test_serialize_text_event();    test_serialize_long_text_event();    test_serialize_mouse_event();    test_serialize_scroll_event();}
int main(void) {    test_serialize_keycode_event();    test_serialize_text_event();    test_serialize_long_text_event();    test_serialize_mouse_event();    test_serialize_scroll_event();}
static void test_serialize_text_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_TEXT,        .text_event = {            .text = "hello, world!",        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 16);    const unsigned char expected[] = {        0x01, // CONTROL_EVENT_TYPE_KEYCODE        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_xstrncpy_just_fit() {    char s[] = "xxxxxx";    size_t w = xstrncpy(s, "abcdef", sizeof(s));    // returns strlen of copied string    assert(w == 6);    // is nul-terminated    assert(s[6] == '\0');    // copies the content as expected    assert(!strcmp("abcdef", s));}
static void test_xstrjoin_simple() {    const char *const tokens[] = { "abc", "de", "fghi", NULL };    char s[] = "xxxxxxxxxxxxxx";    size_t w = xstrjoin(s, tokens, ' ', sizeof(s));    // returns strlen of concatenation    assert(w == 11);    // is nul-terminated    assert(s[11] == '\0');    // does not write useless bytes    assert(s[12] == 'x');    // copies the content as expected    assert(!strcmp("abc de fghi", s));}
static void test_xstrncpy_just_fit() {    char s[] = "xxxxxx";    size_t w = xstrncpy(s, "abcdef", sizeof(s));    // returns strlen of copied string    assert(w == 6);    // is nul-terminated    assert(s[6] == '\0');    // copies the content as expected    assert(!strcmp("abcdef", s));}
static void test_xstrjoin_simple() {    const char *const tokens[] = { "abc", "de", "fghi", NULL };    char s[] = "xxxxxxxxxxxxxx";    size_t w = xstrjoin(s, tokens, ' ', sizeof(s));    // returns strlen of concatenation    assert(w == 11);    // is nul-terminated    assert(s[11] == '\0');    // does not write useless bytes    assert(s[12] == 'x');    // copies the content as expected    assert(!strcmp("abc de fghi", s));}
static void test_xstrjoin_truncated_before_sep() {    const char *const tokens[] = { "abc", "de", "fghi", NULL };    char s[] = "xxxxxx";    size_t w = xstrjoin(s, tokens, ' ', sizeof(s));    // returns 'n' (sizeof(s))    assert(w == 7);    // is nul-terminated    assert(s[6] == '\0');    // copies the content as expected    assert(!strcmp("abc de", s));}
static void test_xstrncpy_truncated() {    char s[] = "xxx";    size_t w = xstrncpy(s, "abcdef", sizeof(s));    // returns 'n' (sizeof(s))    assert(w == 4);    // is nul-terminated    assert(s[3] == '\0');    // copies the content as expected    assert(!strncmp("abcdef", s, 3));}
static void test_xstrncpy_simple() {    char s[] = "xxxxxxxxxx";    size_t w = xstrncpy(s, "abcdef", sizeof(s));    // returns strlen of copied string    assert(w == 6);    // is nul-terminated    assert(s[6] == '\0');    // does not write useless bytes    assert(s[7] == 'x');    // copies the content as expected    assert(!strcmp("abcdef", s));}
static void test_xstrjoin_just_fit() {    const char *const tokens[] = { "abc", "de", "fghi", NULL };    char s[] = "xxxxxxxxxxx";    size_t w = xstrjoin(s, tokens, ' ', sizeof(s));    // returns strlen of concatenation    assert(w == 11);    // is nul-terminated    assert(s[11] == '\0');    // copies the content as expected    assert(!strcmp("abc de fghi", s));}
static void test_xstrjoin_just_fit() {    const char *const tokens[] = { "abc", "de", "fghi", NULL };    char s[] = "xxxxxxxxxxx";    size_t w = xstrjoin(s, tokens, ' ', sizeof(s));    // returns strlen of concatenation    assert(w == 11);    // is nul-terminated    assert(s[11] == '\0');    // copies the content as expected    assert(!strcmp("abc de fghi", s));}
static void test_xstrncpy_truncated() {    char s[] = "xxx";    size_t w = xstrncpy(s, "abcdef", sizeof(s));    // returns 'n' (sizeof(s))    assert(w == 4);    // is nul-terminated    assert(s[3] == '\0');    // copies the content as expected    assert(!strncmp("abcdef", s, 3));}
static void test_xstrjoin_truncated_after_sep() {    const char *const tokens[] = { "abc", "de", "fghi", NULL };    char s[] = "xxxxxxx";    size_t w = xstrjoin(s, tokens, ' ', sizeof(s));    // returns 'n' (sizeof(s))    assert(w == 8);    // is nul-terminated    assert(s[7] == '\0');    // copies the content as expected    assert(!strcmp("abc de ", s));}
int main() {    test_xstrncpy_simple();    test_xstrncpy_just_fit();    test_xstrncpy_truncated();    test_xstrjoin_simple();    test_xstrjoin_just_fit();    test_xstrjoin_truncated_in_token();    test_xstrjoin_truncated_before_sep();    test_xstrjoin_truncated_after_sep();    return 0;}
static void test_xstrncpy_simple() {    char s[] = "xxxxxxxxxx";    size_t w = xstrncpy(s, "abcdef", sizeof(s));    // returns strlen of copied string    assert(w == 6);    // is nul-terminated    assert(s[6] == '\0');    // does not write useless bytes    assert(s[7] == 'x');    // copies the content as expected    assert(!strcmp("abcdef", s));}
static void test_xstrjoin_truncated_after_sep() {    const char *const tokens[] = { "abc", "de", "fghi", NULL };    char s[] = "xxxxxxx";    size_t w = xstrjoin(s, tokens, ' ', sizeof(s));    // returns 'n' (sizeof(s))    assert(w == 8);    // is nul-terminated    assert(s[7] == '\0');    // copies the content as expected    assert(!strcmp("abc de ", s));}
static void test_xstrjoin_truncated_in_token() {    const char *const tokens[] = { "abc", "de", "fghi", NULL };    char s[] = "xxxxx";    size_t w = xstrjoin(s, tokens, ' ', sizeof(s));    // returns 'n' (sizeof(s))    assert(w == 6);    // is nul-terminated    assert(s[5] == '\0');    // copies the content as expected    assert(!strcmp("abc d", s));}
int main() {    test_xstrncpy_simple();    test_xstrncpy_just_fit();    test_xstrncpy_truncated();    test_xstrjoin_simple();    test_xstrjoin_just_fit();    test_xstrjoin_truncated_in_token();    test_xstrjoin_truncated_before_sep();    test_xstrjoin_truncated_after_sep();    return 0;}
static void test_xstrjoin_truncated_in_token() {    const char *const tokens[] = { "abc", "de", "fghi", NULL };    char s[] = "xxxxx";    size_t w = xstrjoin(s, tokens, ' ', sizeof(s));    // returns 'n' (sizeof(s))    assert(w == 6);    // is nul-terminated    assert(s[5] == '\0');    // copies the content as expected    assert(!strcmp("abc d", s));}
static void test_xstrjoin_truncated_before_sep() {    const char *const tokens[] = { "abc", "de", "fghi", NULL };    char s[] = "xxxxxx";    size_t w = xstrjoin(s, tokens, ' ', sizeof(s));    // returns 'n' (sizeof(s))    assert(w == 7);    // is nul-terminated    assert(s[6] == '\0');    // copies the content as expected    assert(!strcmp("abc de", s));}
static void test_xstrncpy_just_fit(void) {    char s[] = "xxxxxx";    size_t w = xstrncpy(s, "abcdef", sizeof(s));    // returns strlen of copied string    assert(w == 6);    // is nul-terminated    assert(s[6] == '\0');    // copies the content as expected    assert(!strcmp("abcdef", s));}
static void test_xstrjoin_simple(void) {    const char *const tokens[] = { "abc", "de", "fghi", NULL };    char s[] = "xxxxxxxxxxxxxx";    size_t w = xstrjoin(s, tokens, ' ', sizeof(s));    // returns strlen of concatenation    assert(w == 11);    // is nul-terminated    assert(s[11] == '\0');    // does not write useless bytes    assert(s[12] == 'x');    // copies the content as expected    assert(!strcmp("abc de fghi", s));}
static void test_xstrncpy_just_fit(void) {    char s[] = "xxxxxx";    size_t w = xstrncpy(s, "abcdef", sizeof(s));    // returns strlen of copied string    assert(w == 6);    // is nul-terminated    assert(s[6] == '\0');    // copies the content as expected    assert(!strcmp("abcdef", s));}
static void test_xstrjoin_simple(void) {    const char *const tokens[] = { "abc", "de", "fghi", NULL };    char s[] = "xxxxxxxxxxxxxx";    size_t w = xstrjoin(s, tokens, ' ', sizeof(s));    // returns strlen of concatenation    assert(w == 11);    // is nul-terminated    assert(s[11] == '\0');    // does not write useless bytes    assert(s[12] == 'x');    // copies the content as expected    assert(!strcmp("abc de fghi", s));}
static void test_xstrjoin_truncated_before_sep(void) {    const char *const tokens[] = { "abc", "de", "fghi", NULL };    char s[] = "xxxxxx";    size_t w = xstrjoin(s, tokens, ' ', sizeof(s));    // returns 'n' (sizeof(s))    assert(w == 7);    // is nul-terminated    assert(s[6] == '\0');    // copies the content as expected    assert(!strcmp("abc de", s));}
static void test_xstrncpy_truncated(void) {    char s[] = "xxx";    size_t w = xstrncpy(s, "abcdef", sizeof(s));    // returns 'n' (sizeof(s))    assert(w == 4);    // is nul-terminated    assert(s[3] == '\0');    // copies the content as expected    assert(!strncmp("abcdef", s, 3));}
static void test_xstrncpy_simple(void) {    char s[] = "xxxxxxxxxx";    size_t w = xstrncpy(s, "abcdef", sizeof(s));    // returns strlen of copied string    assert(w == 6);    // is nul-terminated    assert(s[6] == '\0');    // does not write useless bytes    assert(s[7] == 'x');    // copies the content as expected    assert(!strcmp("abcdef", s));}
static void test_xstrjoin_just_fit(void) {    const char *const tokens[] = { "abc", "de", "fghi", NULL };    char s[] = "xxxxxxxxxxx";    size_t w = xstrjoin(s, tokens, ' ', sizeof(s));    // returns strlen of concatenation    assert(w == 11);    // is nul-terminated    assert(s[11] == '\0');    // copies the content as expected    assert(!strcmp("abc de fghi", s));}
static void test_xstrjoin_just_fit(void) {    const char *const tokens[] = { "abc", "de", "fghi", NULL };    char s[] = "xxxxxxxxxxx";    size_t w = xstrjoin(s, tokens, ' ', sizeof(s));    // returns strlen of concatenation    assert(w == 11);    // is nul-terminated    assert(s[11] == '\0');    // copies the content as expected    assert(!strcmp("abc de fghi", s));}
static void test_xstrncpy_truncated(void) {    char s[] = "xxx";    size_t w = xstrncpy(s, "abcdef", sizeof(s));    // returns 'n' (sizeof(s))    assert(w == 4);    // is nul-terminated    assert(s[3] == '\0');    // copies the content as expected    assert(!strncmp("abcdef", s, 3));}
static void test_xstrjoin_truncated_after_sep(void) {    const char *const tokens[] = { "abc", "de", "fghi", NULL };    char s[] = "xxxxxxx";    size_t w = xstrjoin(s, tokens, ' ', sizeof(s));    // returns 'n' (sizeof(s))    assert(w == 8);    // is nul-terminated    assert(s[7] == '\0');    // copies the content as expected    assert(!strcmp("abc de ", s));}
int main(void) {    test_xstrncpy_simple();    test_xstrncpy_just_fit();    test_xstrncpy_truncated();    test_xstrjoin_simple();    test_xstrjoin_just_fit();    test_xstrjoin_truncated_in_token();    test_xstrjoin_truncated_before_sep();    test_xstrjoin_truncated_after_sep();    return 0;}
static void test_xstrncpy_simple(void) {    char s[] = "xxxxxxxxxx";    size_t w = xstrncpy(s, "abcdef", sizeof(s));    // returns strlen of copied string    assert(w == 6);    // is nul-terminated    assert(s[6] == '\0');    // does not write useless bytes    assert(s[7] == 'x');    // copies the content as expected    assert(!strcmp("abcdef", s));}
static void test_xstrjoin_truncated_after_sep(void) {    const char *const tokens[] = { "abc", "de", "fghi", NULL };    char s[] = "xxxxxxx";    size_t w = xstrjoin(s, tokens, ' ', sizeof(s));    // returns 'n' (sizeof(s))    assert(w == 8);    // is nul-terminated    assert(s[7] == '\0');    // copies the content as expected    assert(!strcmp("abc de ", s));}
static void test_xstrjoin_truncated_in_token(void) {    const char *const tokens[] = { "abc", "de", "fghi", NULL };    char s[] = "xxxxx";    size_t w = xstrjoin(s, tokens, ' ', sizeof(s));    // returns 'n' (sizeof(s))    assert(w == 6);    // is nul-terminated    assert(s[5] == '\0');    // copies the content as expected    assert(!strcmp("abc d", s));}
int main(void) {    test_xstrncpy_simple();    test_xstrncpy_just_fit();    test_xstrncpy_truncated();    test_xstrjoin_simple();    test_xstrjoin_just_fit();    test_xstrjoin_truncated_in_token();    test_xstrjoin_truncated_before_sep();    test_xstrjoin_truncated_after_sep();    return 0;}
static void test_xstrjoin_truncated_in_token(void) {    const char *const tokens[] = { "abc", "de", "fghi", NULL };    char s[] = "xxxxx";    size_t w = xstrjoin(s, tokens, ' ', sizeof(s));    // returns 'n' (sizeof(s))    assert(w == 6);    // is nul-terminated    assert(s[5] == '\0');    // copies the content as expected    assert(!strcmp("abc d", s));}
static void test_xstrjoin_truncated_before_sep(void) {    const char *const tokens[] = { "abc", "de", "fghi", NULL };    char s[] = "xxxxxx";    size_t w = xstrjoin(s, tokens, ' ', sizeof(s));    // returns 'n' (sizeof(s))    assert(w == 7);    // is nul-terminated    assert(s[6] == '\0');    // copies the content as expected    assert(!strcmp("abc de", s));}
static void usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
process_event(struct controller *controller,              const struct control_event *event) {    unsigned char serialized_event[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int length = control_event_serialize(event, serialized_event);    if (!length) {        return false;    }    int w = net_send_all(controller->video_socket, serialized_event, length);    return w == length;}
controller_init(struct controller *controller, socket_t video_socket) {    cbuf_init(&controller->queue);    if (!(controller->mutex = SDL_CreateMutex())) {        return false;    }    if (!(controller->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(controller->mutex);        return false;    }    controller->video_socket = video_socket;    controller->stopped = false;    return true;}
controller_init(struct controller *controller, socket_t video_socket) {    cbuf_init(&controller->queue);    if (!(controller->mutex = SDL_CreateMutex())) {        return false;    }    if (!(controller->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(controller->mutex);        return false;    }    controller->video_socket = video_socket;    controller->stopped = false;    return true;}
process_event(struct controller *controller,              const struct control_event *event) {    unsigned char serialized_event[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int length = control_event_serialize(event, serialized_event);    if (!length) {        return false;    }    int w = net_send_all(controller->control_socket, serialized_event, length);    return w == length;}
controller_init(struct controller *controller, socket_t control_socket) {    cbuf_init(&controller->queue);    if (!(controller->mutex = SDL_CreateMutex())) {        return false;    }    if (!(controller->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(controller->mutex);        return false;    }    controller->control_socket = control_socket;    controller->stopped = false;    return true;}
controller_init(struct controller *controller, socket_t control_socket) {    cbuf_init(&controller->queue);    if (!(controller->mutex = SDL_CreateMutex())) {        return false;    }    if (!(controller->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(controller->mutex);        return false;    }    controller->control_socket = control_socket;    controller->stopped = false;    return true;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    bool display = !options->no_display;    bool control = !options->no_control;    if (!sdl_init_and_configure(display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    socket_t device_socket = server.device_socket;    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            goto end;        }        video_buffer_initialized = true;        if (control) {            if (!file_handler_init(&file_handler, server.serial)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (display) {        if (control) {            if (!controller_init(&controller, device_socket)) {                goto end;            }            if (!controller_start(&controller)) {                goto end;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(display, control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    bool display = !options->no_display;    bool control = !options->no_control;    if (!sdl_init_and_configure(display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            goto end;        }        video_buffer_initialized = true;        if (control) {            if (!file_handler_init(&file_handler, server.serial)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (display) {        if (control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            if (!controller_start(&controller)) {                goto end;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(display, control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
server_connect_to(struct server *server) {    if (!server->tunnel_forward) {        server->device_socket = net_accept(server->server_socket);        if (server->device_socket == INVALID_SOCKET) {            return false;        }        // we don't need the server socket anymore        close_socket(&server->server_socket);    } else {        uint32_t attempts = 100;        uint32_t delay = 100; // ms        server->device_socket = connect_to_server(server->local_port, attempts,                                                  delay);        if (server->device_socket == INVALID_SOCKET) {            return false;        }    }    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = false;    return true;}
server_stop(struct server *server) {    if (server->server_socket != INVALID_SOCKET) {        close_socket(&server->server_socket);    }    if (server->device_socket != INVALID_SOCKET) {        close_socket(&server->device_socket);    }    SDL_assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Cannot terminate server");    }    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->tunnel_enabled) {        // ignore failure        disable_tunnel(server);    }}
server_connect_to(struct server *server) {    if (!server->tunnel_forward) {        server->video_socket = net_accept(server->server_socket);        if (server->video_socket == INVALID_SOCKET) {            return false;        }        server->control_socket = net_accept(server->server_socket);        if (server->control_socket == INVALID_SOCKET) {            // the video_socket will be clean up on destroy            return false;        }        // we don't need the server socket anymore        close_socket(&server->server_socket);    } else {        uint32_t attempts = 100;        uint32_t delay = 100; // ms        server->video_socket =            connect_to_server(server->local_port, attempts, delay);        if (server->video_socket == INVALID_SOCKET) {            return false;        }        // we know that the device is listening, we don't need several attempts        server->control_socket =            net_connect(IPV4_LOCALHOST, server->local_port);        if (server->control_socket == INVALID_SOCKET) {            return false;        }    }    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = false;    return true;}
server_stop(struct server *server) {    if (server->server_socket != INVALID_SOCKET) {        close_socket(&server->server_socket);    }    if (server->video_socket != INVALID_SOCKET) {        close_socket(&server->video_socket);    }    if (server->control_socket != INVALID_SOCKET) {        close_socket(&server->control_socket);    }    SDL_assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Cannot terminate server");    }    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->tunnel_enabled) {        // ignore failure        disable_tunnel(server);    }}
    private static LocalSocket listenAndAccept(String abstractName) throws IOException {        LocalServerSocket localServerSocket = new LocalServerSocket(abstractName);        try {            return localServerSocket.accept();        } finally {            localServerSocket.close();        }    }
    private DesktopConnection(LocalSocket socket) throws IOException {        this.socket = socket;        inputStream = socket.getInputStream();        fd = socket.getFileDescriptor();    }
    public FileDescriptor getFd() {        return fd;    }
    public ControlEvent receiveControlEvent() throws IOException {        ControlEvent event = reader.next();        while (event == null) {            reader.readFrom(inputStream);            event = reader.next();        }        return event;    }}
    private DesktopConnection(LocalSocket socket) throws IOException {        this.socket = socket;        inputStream = socket.getInputStream();        fd = socket.getFileDescriptor();    }
    public static DesktopConnection open(Device device, boolean tunnelForward) throws IOException {        LocalSocket socket;        if (tunnelForward) {            socket = listenAndAccept(SOCKET_NAME);            // send one byte so the client may read() to detect a connection error            socket.getOutputStream().write(0);        } else {            socket = connect(SOCKET_NAME);        }        DesktopConnection connection = new DesktopConnection(socket);        Size videoSize = device.getScreenInfo().getVideoSize();        connection.send(Device.getDeviceName(), videoSize.getWidth(), videoSize.getHeight());        return connection;    }
    private void send(String deviceName, int width, int height) throws IOException {        byte[] buffer = new byte[DEVICE_NAME_FIELD_LENGTH + 4];        byte[] deviceNameBytes = deviceName.getBytes(StandardCharsets.UTF_8);        int len = Math.min(DEVICE_NAME_FIELD_LENGTH - 1, deviceNameBytes.length);        System.arraycopy(deviceNameBytes, 0, buffer, 0, len);        // byte[] are always 0-initialized in java, no need to set '\0' explicitly        buffer[DEVICE_NAME_FIELD_LENGTH] = (byte) (width >> 8);        buffer[DEVICE_NAME_FIELD_LENGTH + 1] = (byte) width;        buffer[DEVICE_NAME_FIELD_LENGTH + 2] = (byte) (height >> 8);        buffer[DEVICE_NAME_FIELD_LENGTH + 3] = (byte) height;        IO.writeFully(fd, buffer, 0, buffer.length);    }
    public void close() throws IOException {        socket.shutdownInput();        socket.shutdownOutput();        socket.close();    }
        localSocket.connect(new LocalSocketAddress(abstractName));        return localSocket;    }    public static DesktopConnection open(Device device, boolean tunnelForward) throws IOException {        LocalSocket videoSocket;        LocalSocket controlSocket;        if (tunnelForward) {            LocalServerSocket localServerSocket = new LocalServerSocket(SOCKET_NAME);
    private final ControlEventReader reader = new ControlEventReader();    private DesktopConnection(LocalSocket videoSocket, LocalSocket controlSocket) throws IOException {        this.videoSocket = videoSocket;        this.controlSocket = controlSocket;
    @SuppressWarnings("checkstyle:MagicNumber")    private void send(String deviceName, int width, int height) throws IOException {        byte[] buffer = new byte[DEVICE_NAME_FIELD_LENGTH + 4];
    public ControlEvent receiveControlEvent() throws IOException {        ControlEvent event = reader.next();        while (event == null) {            reader.readFrom(controlInputStream);            event = reader.next();        }        return event;    }}
    private DesktopConnection(LocalSocket videoSocket, LocalSocket controlSocket) throws IOException {        this.videoSocket = videoSocket;        this.controlSocket = controlSocket;        controlInputStream = controlSocket.getInputStream();        videoFd = videoSocket.getFileDescriptor();    }
    public static DesktopConnection open(Device device, boolean tunnelForward) throws IOException {        LocalSocket videoSocket;        LocalSocket controlSocket;        if (tunnelForward) {            LocalServerSocket localServerSocket = new LocalServerSocket(SOCKET_NAME);            try {                videoSocket = localServerSocket.accept();                // send one byte so the client may read() to detect a connection error                videoSocket.getOutputStream().write(0);                try {                    controlSocket = localServerSocket.accept();                } catch (IOException | RuntimeException e) {                    videoSocket.close();                    throw e;                }            } finally {                localServerSocket.close();            }        } else {            videoSocket = connect(SOCKET_NAME);            try {                controlSocket = connect(SOCKET_NAME);            } catch (IOException | RuntimeException e) {                videoSocket.close();                throw e;            }        }        DesktopConnection connection = new DesktopConnection(videoSocket, controlSocket);        Size videoSize = device.getScreenInfo().getVideoSize();        connection.send(Device.getDeviceName(), videoSize.getWidth(), videoSize.getHeight());        return connection;    }
    private void send(String deviceName, int width, int height) throws IOException {        byte[] buffer = new byte[DEVICE_NAME_FIELD_LENGTH + 4];        byte[] deviceNameBytes = deviceName.getBytes(StandardCharsets.UTF_8);        int len = Math.min(DEVICE_NAME_FIELD_LENGTH - 1, deviceNameBytes.length);        System.arraycopy(deviceNameBytes, 0, buffer, 0, len);        // byte[] are always 0-initialized in java, no need to set '\0' explicitly        buffer[DEVICE_NAME_FIELD_LENGTH] = (byte) (width >> 8);        buffer[DEVICE_NAME_FIELD_LENGTH + 1] = (byte) width;        buffer[DEVICE_NAME_FIELD_LENGTH + 2] = (byte) (height >> 8);        buffer[DEVICE_NAME_FIELD_LENGTH + 3] = (byte) height;        IO.writeFully(videoFd, buffer, 0, buffer.length);    }
    public void close() throws IOException {        videoSocket.shutdownInput();        videoSocket.shutdownOutput();        videoSocket.close();        controlSocket.shutdownInput();        controlSocket.shutdownOutput();        controlSocket.close();    }
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate());            // asynchronous            startEventController(device, connection);            try {                // synchronous                screenEncoder.streamScreen(device, connection.getFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate());            // asynchronous            startEventController(device, connection);            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, 'T'},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, 'c'},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"push-target",           required_argument, NULL,                                                 OPT_PUSH_TARGET},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, 'F'},        {"render-expired-frames", no_argument,       NULL,                                                 OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL,                                                 OPT_WINDOW_TITLE},        {NULL,                    0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                opts->crop = optarg;                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port(optarg, &opts->port)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, 'T'},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, 'c'},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"push-target",           required_argument, NULL, OPT_PUSH_TARGET},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, 'F'},        {"render-expired-frames", no_argument,       NULL,                                                     OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL,                                                     OPT_WINDOW_TITLE},        {NULL,                    0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                opts->crop = optarg;                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port(optarg, &opts->port)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
int decoder_start(struct decoder *decoder) {    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Starting decoder thread");    decoder->thread = SDL_CreateThread(run_decoder, "video_decoder", decoder);    if (!decoder->thread) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not start decoder thread");        return -1;    }    return 0;}
SDL_bool decoder_start(struct decoder *decoder) {    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Starting decoder thread");    decoder->thread = SDL_CreateThread(run_decoder, "video_decoder", decoder);    if (!decoder->thread) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not start decoder thread");        return SDL_FALSE;    }    return SDL_TRUE;}
int frames_init(struct frames *frames) {    if (!(frames->decoding_frame = av_frame_alloc())) {        goto error_0;    }    if (!(frames->rendering_frame = av_frame_alloc())) {        goto error_1;    }    if (!(frames->mutex = SDL_CreateMutex())) {        goto error_2;    }    if (!(frames->rendering_frame_consumed_cond = SDL_CreateCond())) {        goto error_3;    }    frames->rendering_frame_consumed = SDL_TRUE;    return 0;error_3:    SDL_DestroyMutex(frames->mutex);error_2:    av_frame_free(&frames->rendering_frame);error_1:    av_frame_free(&frames->decoding_frame);error_0:    return -1;}
SDL_bool frames_init(struct frames *frames) {    if (!(frames->decoding_frame = av_frame_alloc())) {        goto error_0;    }    if (!(frames->rendering_frame = av_frame_alloc())) {        goto error_1;    }    if (!(frames->mutex = SDL_CreateMutex())) {        goto error_2;    }    if (!(frames->rendering_frame_consumed_cond = SDL_CreateCond())) {        goto error_3;    }    frames->rendering_frame_consumed = SDL_TRUE;    return SDL_TRUE;error_3:    SDL_DestroyMutex(frames->mutex);error_2:    av_frame_free(&frames->rendering_frame);error_1:    av_frame_free(&frames->decoding_frame);error_0:    return SDL_FALSE;}
int main(int argc, char *argv[]) {    av_register_all();    avformat_network_init();    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    struct args args = {        .serial = NULL,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return -1;    }    return show_screen(args.serial, args.port);}
int main(int argc, char *argv[]) {    av_register_all();    avformat_network_init();    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    struct args args = {        .serial = NULL,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    return show_screen(args.serial, args.port) ? 0 : 1;}
int show_screen(const char *serial, Uint16 local_port) {    int ret = 0;    const char *server_jar_path = getenv("SCRCPY_SERVER_JAR");    if (!server_jar_path) {        server_jar_path = "scrcpy-server.jar";    }    process_t push_proc = adb_push(serial, server_jar_path, "/data/local/tmp/");    if (wait_for_success(push_proc, "adb push")) {        return -1;    }    process_t reverse_tunnel_proc = adb_reverse(serial, SOCKET_NAME, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return -1;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = -1;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = -1;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    struct size frame_size;    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = -1;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (frames_init(&frames)) {        ret = -1;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the width and height values, the socket receives the video stream    // start the decoder    if (decoder_start(&decoder)) {        ret = -1;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = -1;        goto screen_finally_stop_decoder;    }    atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    SDL_Window *window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = -1;        goto screen_finally_stop_decoder;    }    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = -1;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = -1;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    SDL_Texture *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = -1;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    long ts = timestamp_ms();    int nbframes = 0;    SDL_bool texture_empty = SDL_TRUE;    SDL_bool fullscreen = SDL_FALSE;    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            goto screen_quit;        case EVENT_NEW_FRAME:            lock_mutex(frames.mutex);            AVFrame *frame = frames.rendering_frame;            frames.rendering_frame_consumed = SDL_TRUE;            if (!decoder.skip_frames) {                SDL_CondSignal(frames.rendering_frame_consumed_cond);            }            struct size current_frame_size = {frame->width, frame->height};            if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {                goto screen_quit;            }            frame_size = current_frame_size;            update_texture(frame, texture);            unlock_mutex(frames.mutex);            texture_empty = SDL_FALSE;            long now = timestamp_ms();            ++nbframes;            if (now - ts > 1000) {                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "%d fps", nbframes);                ts = now;                nbframes = 0;            }            render(renderer, texture);            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_KEYDOWN: {            SDL_bool ctrl = SDL_GetModState() & (KMOD_LCTRL | KMOD_RCTRL);            SDL_bool shift = SDL_GetModState() & (KMOD_LSHIFT | KMOD_RSHIFT);            SDL_bool repeat = event.key.repeat;            switch (event.key.keysym.sym) {            case SDLK_x:                if (!repeat && ctrl && !shift) {                    // Ctrl+x                    struct size optimal_size = get_optimal_window_size(window, frame_size);                    SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                }                break;            case SDLK_f:                if (!repeat && ctrl && !shift) {                    // Ctrl+f                    Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;                    if (!SDL_SetWindowFullscreen(window, new_mode)) {                        fullscreen = !fullscreen;                        render(renderer, texture_empty ? NULL : texture);                    } else {                        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());                    }                }                break;            }            break;        }        }    }screen_quit:    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = adb_reverse_remove(serial, SOCKET_NAME);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool show_screen(const char *serial, Uint16 local_port) {    SDL_bool ret = 0;    const char *server_jar_path = getenv("SCRCPY_SERVER_JAR");    if (!server_jar_path) {        server_jar_path = "scrcpy-server.jar";    }    process_t push_proc = adb_push(serial, server_jar_path, "/data/local/tmp/");    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = adb_reverse(serial, SOCKET_NAME, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    struct size frame_size;    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the width and height values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    SDL_Window *window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    SDL_Texture *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    long ts = timestamp_ms();    int nbframes = 0;    SDL_bool texture_empty = SDL_TRUE;    SDL_bool fullscreen = SDL_FALSE;    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            goto screen_quit;        case EVENT_NEW_FRAME:            lock_mutex(frames.mutex);            AVFrame *frame = frames.rendering_frame;            frames.rendering_frame_consumed = SDL_TRUE;            if (!decoder.skip_frames) {                SDL_CondSignal(frames.rendering_frame_consumed_cond);            }            struct size current_frame_size = {frame->width, frame->height};            if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {                goto screen_quit;            }            frame_size = current_frame_size;            update_texture(frame, texture);            unlock_mutex(frames.mutex);            texture_empty = SDL_FALSE;            long now = timestamp_ms();            ++nbframes;            if (now - ts > 1000) {                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "%d fps", nbframes);                ts = now;                nbframes = 0;            }            render(renderer, texture);            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_KEYDOWN: {            SDL_bool ctrl = SDL_GetModState() & (KMOD_LCTRL | KMOD_RCTRL);            SDL_bool shift = SDL_GetModState() & (KMOD_LSHIFT | KMOD_RSHIFT);            SDL_bool repeat = event.key.repeat;            switch (event.key.keysym.sym) {            case SDLK_x:                if (!repeat && ctrl && !shift) {                    // Ctrl+x                    struct size optimal_size = get_optimal_window_size(window, frame_size);                    SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                }                break;            case SDLK_f:                if (!repeat && ctrl && !shift) {                    // Ctrl+f                    Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;                    if (!SDL_SetWindowFullscreen(window, new_mode)) {                        fullscreen = !fullscreen;                        render(renderer, texture_empty ? NULL : texture);                    } else {                        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());                    }                }                break;            }            break;        }        }    }screen_quit:    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = adb_reverse_remove(serial, SOCKET_NAME);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
controller_destroy(struct controller *controller) {    SDL_DestroyCond(controller->event_cond);    SDL_DestroyMutex(controller->mutex);    struct control_event event;    while (cbuf_take(&controller->queue, &event)) {        control_event_destroy(&event);    }}
controller_start(struct controller *controller) {    LOGD("Starting controller thread");    controller->thread = SDL_CreateThread(run_controller, "controller",                                          controller);    if (!controller->thread) {        LOGC("Could not start controller thread");        return false;    }    return true;}
controller_init(struct controller *controller, socket_t control_socket) {    cbuf_init(&controller->queue);    if (!(controller->mutex = SDL_CreateMutex())) {        return false;    }    if (!(controller->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(controller->mutex);        return false;    }    controller->control_socket = control_socket;    controller->stopped = false;    return true;}
controller_join(struct controller *controller) {    SDL_WaitThread(controller->thread, NULL);}
controller_destroy(struct controller *controller) {    SDL_DestroyCond(controller->event_cond);    SDL_DestroyMutex(controller->mutex);    struct control_event event;    while (cbuf_take(&controller->queue, &event)) {        control_event_destroy(&event);    }    receiver_destroy(&controller->receiver);}
controller_start(struct controller *controller) {    LOGD("Starting controller thread");    controller->thread = SDL_CreateThread(run_controller, "controller",                                          controller);    if (!controller->thread) {        LOGC("Could not start controller thread");        return false;    }    if (!receiver_start(&controller->receiver)) {        controller_stop(controller);        SDL_WaitThread(controller->thread, NULL);        return false;    }    return true;}
controller_init(struct controller *controller, socket_t control_socket) {    cbuf_init(&controller->queue);    if (!receiver_init(&controller->receiver, control_socket)) {        return false;    }    if (!(controller->mutex = SDL_CreateMutex())) {        receiver_destroy(&controller->receiver);        return false;    }    if (!(controller->event_cond = SDL_CreateCond())) {        receiver_destroy(&controller->receiver);        SDL_DestroyMutex(controller->mutex);        return false;    }    controller->control_socket = control_socket;    controller->stopped = false;    return true;}
controller_join(struct controller *controller) {    SDL_WaitThread(controller->thread, NULL);    receiver_join(&controller->receiver);}
control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            buffer_write32be(&buf[2], event->keycode_event.keycode);            buffer_write32be(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (2 bytes) + string (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > CONTROL_EVENT_TEXT_MAX_LENGTH) {                // injecting a text takes time, so limit the text length                len = CONTROL_EVENT_TEXT_MAX_LENGTH;            }            buffer_write16be(&buf[1], (uint16_t) len);            memcpy(&buf[3], event->text_event.text, len);            return 3 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            buffer_write32be(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 18;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            buffer_write32be(&buf[13], (uint32_t) event->scroll_event.hscroll);            buffer_write32be(&buf[17], (uint32_t) event->scroll_event.vscroll);            return 21;        case CONTROL_EVENT_TYPE_COMMAND:            buf[1] = event->command_event.action;            return 2;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            buffer_write32be(&buf[2], event->keycode_event.keycode);            buffer_write32be(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (2 bytes) + string (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > CONTROL_EVENT_TEXT_MAX_LENGTH) {                // injecting a text takes time, so limit the text length                len = CONTROL_EVENT_TEXT_MAX_LENGTH;            }            buffer_write16be(&buf[1], (uint16_t) len);            memcpy(&buf[3], event->text_event.text, len);            return 3 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            buffer_write32be(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 18;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            buffer_write32be(&buf[13], (uint32_t) event->scroll_event.hscroll);            buffer_write32be(&buf[17], (uint32_t) event->scroll_event.vscroll);            return 21;        case CONTROL_EVENT_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_EVENT_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_EVENT_TYPE_COLLAPSE_NOTIFICATION_PANEL:            // no additional data            return 1;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
expand_notification_panel(struct controller *controller) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_COMMAND;    control_event.command_event.action =            CONTROL_EVENT_COMMAND_EXPAND_NOTIFICATION_PANEL;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot expand notification panel");    }}
press_back_or_turn_screen_on(struct controller *controller) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_COMMAND;    control_event.command_event.action =            CONTROL_EVENT_COMMAND_BACK_OR_SCREEN_ON;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot turn screen on");    }}
collapse_notification_panel(struct controller *controller) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_COMMAND;    control_event.command_event.action =            CONTROL_EVENT_COMMAND_COLLAPSE_NOTIFICATION_PANEL;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot collapse notification panel");    }}
expand_notification_panel(struct controller *controller) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_EXPAND_NOTIFICATION_PANEL;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot expand notification panel");    }}
press_back_or_turn_screen_on(struct controller *controller) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_BACK_OR_SCREEN_ON;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot turn screen on");    }}
collapse_notification_panel(struct controller *controller) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_COLLAPSE_NOTIFICATION_PANEL;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot collapse notification panel");    }}
    public static ControlEvent createCommandControlEvent(int action) {        ControlEvent event = new ControlEvent();        event.type = TYPE_COMMAND;        event.action = action;        return event;    }
    public static ControlEvent createCommandControlEvent(int action) {        ControlEvent event = new ControlEvent();        event.type = TYPE_COMMAND;        event.action = action;        return event;    }
        event.type = type;        return event;    }    public int getType() {        return type;    }
    public static ControlEvent createSimpleControlEvent(int type) {        ControlEvent event = new ControlEvent();        event.type = type;        return event;    }
    public ControlEvent next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        ControlEvent controlEvent;        switch (type) {            case ControlEvent.TYPE_KEYCODE:                controlEvent = parseKeycodeControlEvent();                break;            case ControlEvent.TYPE_TEXT:                controlEvent = parseTextControlEvent();                break;            case ControlEvent.TYPE_MOUSE:                controlEvent = parseMouseControlEvent();                break;            case ControlEvent.TYPE_SCROLL:                controlEvent = parseScrollControlEvent();                break;            case ControlEvent.TYPE_COMMAND:                controlEvent = parseCommandControlEvent();                break;            default:                Ln.w("Unknown event type: " + type);                controlEvent = null;                break;        }        if (controlEvent == null) {            // failure, reset savedPosition            buffer.position(savedPosition);        }        return controlEvent;    }
    private ControlEvent parseCommandControlEvent() {        if (buffer.remaining() < COMMAND_PAYLOAD_LENGTH) {            return null;        }        int action = toUnsigned(buffer.get());        return ControlEvent.createCommandControlEvent(action);    }
    public ControlEvent next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        ControlEvent controlEvent;        switch (type) {            case ControlEvent.TYPE_KEYCODE:                controlEvent = parseKeycodeControlEvent();                break;            case ControlEvent.TYPE_TEXT:                controlEvent = parseTextControlEvent();                break;            case ControlEvent.TYPE_MOUSE:                controlEvent = parseMouseControlEvent();                break;            case ControlEvent.TYPE_SCROLL:                controlEvent = parseScrollControlEvent();                break;            case ControlEvent.TYPE_BACK_OR_SCREEN_ON:            case ControlEvent.TYPE_EXPAND_NOTIFICATION_PANEL:            case ControlEvent.TYPE_COLLAPSE_NOTIFICATION_PANEL:                controlEvent = ControlEvent.createSimpleControlEvent(type);                break;            default:                Ln.w("Unknown event type: " + type);                controlEvent = null;                break;        }        if (controlEvent == null) {            // failure, reset savedPosition            buffer.position(savedPosition);        }        return controlEvent;    }
    private static Position readPosition(ByteBuffer buffer) {        int x = buffer.getInt();        int y = buffer.getInt();        int screenWidth = toUnsigned(buffer.getShort());        int screenHeight = toUnsigned(buffer.getShort());        return new Position(x, y, screenWidth, screenHeight);    }
    private boolean executeCommand(int action) {        switch (action) {            case ControlEvent.COMMAND_BACK_OR_SCREEN_ON:                return pressBackOrTurnScreenOn();            case ControlEvent.COMMAND_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                return true;            case ControlEvent.COMMAND_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                return true;            default:                Ln.w("Unsupported command: " + action);        }        return false;    }}
    private void handleEvent() throws IOException {        ControlEvent controlEvent = connection.receiveControlEvent();        switch (controlEvent.getType()) {            case ControlEvent.TYPE_KEYCODE:                injectKeycode(controlEvent.getAction(), controlEvent.getKeycode(), controlEvent.getMetaState());                break;            case ControlEvent.TYPE_TEXT:                injectText(controlEvent.getText());                break;            case ControlEvent.TYPE_MOUSE:                injectMouse(controlEvent.getAction(), controlEvent.getButtons(), controlEvent.getPosition());                break;            case ControlEvent.TYPE_SCROLL:                injectScroll(controlEvent.getPosition(), controlEvent.getHScroll(), controlEvent.getVScroll());                break;            case ControlEvent.TYPE_COMMAND:                executeCommand(controlEvent.getAction());                break;            default:                // do nothing        }    }
    private boolean pressBackOrTurnScreenOn() {        int keycode = device.isScreenOn() ? KeyEvent.KEYCODE_BACK : KeyEvent.KEYCODE_POWER;        return injectKeycode(keycode);    }}
    private void handleEvent() throws IOException {        ControlEvent controlEvent = connection.receiveControlEvent();        switch (controlEvent.getType()) {            case ControlEvent.TYPE_KEYCODE:                injectKeycode(controlEvent.getAction(), controlEvent.getKeycode(), controlEvent.getMetaState());                break;            case ControlEvent.TYPE_TEXT:                injectText(controlEvent.getText());                break;            case ControlEvent.TYPE_MOUSE:                injectMouse(controlEvent.getAction(), controlEvent.getButtons(), controlEvent.getPosition());                break;            case ControlEvent.TYPE_SCROLL:                injectScroll(controlEvent.getPosition(), controlEvent.getHScroll(), controlEvent.getVScroll());                break;            case ControlEvent.TYPE_BACK_OR_SCREEN_ON:                pressBackOrTurnScreenOn();                break;            case ControlEvent.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlEvent.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            default:                // do nothing        }    }
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // Capture Ctrl+x: optimal size    if (keycode == SDLK_x && !repeat && ctrl && !shift) {        if (event->type == SDL_KEYDOWN) {            struct size optimal_size = get_optimal_window_size(window, frame_size);            SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);        }        return;    }    // Capture Ctrl+f: switch fullscreen    if (keycode == SDLK_f && !repeat && ctrl && !shift) {        if (event->type == SDL_KEYDOWN) {            Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;            if (!SDL_SetWindowFullscreen(window, new_mode)) {                fullscreen = !fullscreen;                render(renderer, texture_empty ? NULL : texture);            } else {                SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());            }        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        // Ctrl+x: optimal size        if (keycode == SDLK_x && !shift) {            struct size optimal_size = get_optimal_window_size(window, frame_size);            SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);            return;        }        // Ctrl+f: switch fullscreen        if (keycode == SDLK_f && !shift) {            Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;            if (!SDL_SetWindowFullscreen(window, new_mode)) {                fullscreen = !fullscreen;                render(renderer, texture_empty ? NULL : texture);            } else {                SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());            }            return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
    private static Options createOptions(String... args) {        if (args.length != 6) {            throw new IllegalArgumentException("Expecting 5 parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[0]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[1]);        options.setBitRate(bitRate);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[2]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[3]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[4]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[5]);        options.setControl(control);        return options;    }
    private static Options createOptions(String... args) {        if (args.length != 6) {            throw new IllegalArgumentException("Expecting 6 parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[0]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[1]);        options.setBitRate(bitRate);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[2]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[3]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[4]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[5]);        options.setControl(control);        return options;    }
press_back_or_turn_screen_on(struct controller *controller) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON;    if (!controller_push_msg(controller, &msg)) {        LOGW("Could not request 'turn screen on'");    }}
press_back_or_turn_screen_on(struct controller *controller) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON;    if (!controller_push_msg(controller, &msg)) {        LOGW("Could not request 'press back or turn screen on'");    }}
    private void send(String deviceName, int width, int height) throws IOException {        assert width < 0x10000 : "width may not be stored on 16 bits";        assert height < 0x10000 : "height may not be stored on 16 bits";        byte[] buffer = new byte[DEVICE_NAME_FIELD_LENGTH + 4];        byte[] deviceNameBytes = deviceName.getBytes(StandardCharsets.UTF_8);        int len = Math.min(DEVICE_NAME_FIELD_LENGTH - 1, deviceNameBytes.length);        System.arraycopy(deviceNameBytes, 0, buffer, 0, len);        // byte[] are always 0-initialized in java, no need to set '\0' explicitly        buffer[DEVICE_NAME_FIELD_LENGTH] = (byte) (width >> 8);        buffer[DEVICE_NAME_FIELD_LENGTH + 1] = (byte) width;        buffer[DEVICE_NAME_FIELD_LENGTH + 2] = (byte) (height >> 8);        buffer[DEVICE_NAME_FIELD_LENGTH + 3] = (byte) height;        outputStream.write(buffer, 0, buffer.length);    }
    @SuppressWarnings("checkstyle:MagicNumber")    private void send(String deviceName, int width, int height) throws IOException {        byte[] buffer = new byte[DEVICE_NAME_FIELD_LENGTH + 4];        byte[] deviceNameBytes = deviceName.getBytes(StandardCharsets.UTF_8);        int len = Math.min(DEVICE_NAME_FIELD_LENGTH - 1, deviceNameBytes.length);        System.arraycopy(deviceNameBytes, 0, buffer, 0, len);        // byte[] are always 0-initialized in java, no need to set '\0' explicitly        buffer[DEVICE_NAME_FIELD_LENGTH] = (byte) (width >> 8);        buffer[DEVICE_NAME_FIELD_LENGTH + 1] = (byte) width;        buffer[DEVICE_NAME_FIELD_LENGTH + 2] = (byte) (height >> 8);        buffer[DEVICE_NAME_FIELD_LENGTH + 3] = (byte) height;        outputStream.write(buffer, 0, buffer.length);    }    public OutputStream getOutputStream() {
    private ScreenInfo computeScreenInfo(int maxSize) {        // Compute the video size and the padding of the content inside this video.        // Principle:        // - scale down the great side of the screen to maxSize (if necessary);        // - scale down the other side so that the aspect ratio is preserved;        // - round this value to the nearest multiple of 8 (H.264 only accepts multiples of 8)        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        int w = deviceSize.getWidth();        int h = deviceSize.getHeight();        if (maxSize > 0) {            assert maxSize % 8 == 0;            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;            if (major > maxSize) {                int minorExact = minor * maxSize / major;                // +4 to round the value to the nearest multiple of 8                minor = (minorExact + 4) & ~7;                major = maxSize;            }            w = portrait ? minor : major;            h = portrait ? major : minor;        }        Size videoSize = new Size(w, h);        return new ScreenInfo(deviceSize, videoSize, rotated);    }
    public Point getPhysicalPoint(Position position) {        ScreenInfo screenInfo = getScreenInfo(); // read with synchronization        Size videoSize = screenInfo.getVideoSize();        Size clientVideoSize = position.getScreenSize();        if (!videoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event            return null;        }        Size deviceSize = screenInfo.getDeviceSize();        Point point = position.getPoint();        int scaledX = point.x * deviceSize.getWidth() / videoSize.getWidth();        int scaledY = point.y * deviceSize.getHeight() / videoSize.getHeight();        return new Point(scaledX, scaledY);    }
    private ScreenInfo computeScreenInfo(int maxSize) {        // Compute the video size and the padding of the content inside this video.        // Principle:        // - scale down the great side of the screen to maxSize (if necessary);        // - scale down the other side so that the aspect ratio is preserved;        // - round this value to the nearest multiple of 8 (H.264 only accepts multiples of 8)        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        int w = deviceSize.getWidth();        int h = deviceSize.getHeight();        if (maxSize > 0) {            if (BuildConfig.DEBUG && maxSize % 8 != 0) {                throw new AssertionError("Max size must be a multiple of 8");            }            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;            if (major > maxSize) {                int minorExact = minor * maxSize / major;                // +4 to round the value to the nearest multiple of 8                minor = (minorExact + 4) & ~7;                major = maxSize;            }            w = portrait ? minor : major;            h = portrait ? major : minor;        }        Size videoSize = new Size(w, h);        return new ScreenInfo(deviceSize, videoSize, rotated);    }
    public Point getPhysicalPoint(Position position) {        @SuppressWarnings("checkstyle:HiddenField") // it hides the field on purpose, to read it with a lock        ScreenInfo screenInfo = getScreenInfo(); // read with synchronization        Size videoSize = screenInfo.getVideoSize();        Size clientVideoSize = position.getScreenSize();        if (!videoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event            return null;        }        Size deviceSize = screenInfo.getDeviceSize();        Point point = position.getPoint();        int scaledX = point.x * deviceSize.getWidth() / videoSize.getWidth();        int scaledY = point.y * deviceSize.getHeight() / videoSize.getHeight();        return new Point(scaledX, scaledY);    }
    private void handleEvent() throws IOException {        ControlEvent controlEvent = connection.receiveControlEvent();        switch (controlEvent.getType()) {            case ControlEvent.TYPE_KEYCODE:                injectKeycode(controlEvent.getAction(), controlEvent.getKeycode(), controlEvent.getMetaState());                break;            case ControlEvent.TYPE_TEXT:                injectText(controlEvent.getText());                break;            case ControlEvent.TYPE_MOUSE:                injectMouse(controlEvent.getAction(), controlEvent.getButtons(), controlEvent.getPosition());                break;            case ControlEvent.TYPE_SCROLL:                injectScroll(controlEvent.getPosition(), controlEvent.getHScroll(), controlEvent.getVScroll());                break;            case ControlEvent.TYPE_COMMAND:                executeCommand(controlEvent.getAction());                break;        }    }
    private boolean executeCommand(int action) {        switch (action) {            case ControlEvent.COMMAND_SCREEN_ON:                return turnScreenOn();        }        return false;    }}
    private void handleEvent() throws IOException {        ControlEvent controlEvent = connection.receiveControlEvent();        switch (controlEvent.getType()) {            case ControlEvent.TYPE_KEYCODE:                injectKeycode(controlEvent.getAction(), controlEvent.getKeycode(), controlEvent.getMetaState());                break;            case ControlEvent.TYPE_TEXT:                injectText(controlEvent.getText());                break;            case ControlEvent.TYPE_MOUSE:                injectMouse(controlEvent.getAction(), controlEvent.getButtons(), controlEvent.getPosition());                break;            case ControlEvent.TYPE_SCROLL:                injectScroll(controlEvent.getPosition(), controlEvent.getHScroll(), controlEvent.getVScroll());                break;            case ControlEvent.TYPE_COMMAND:                executeCommand(controlEvent.getAction());                break;            default:                // do nothing        }    }
    private boolean executeCommand(int action) {        switch (action) {            case ControlEvent.COMMAND_SCREEN_ON:                return turnScreenOn();            default:                Ln.w("Unsupported command: " + action);        }        return false;    }}
    public String toString() {        return "Position{" +                "point=" + point +                ", screenSize=" + screenSize +                '}';    }
    public boolean equals(Object o) {        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Position position = (Position) o;        return Objects.equals(point, position.point) &&                Objects.equals(screenSize, position.screenSize);    }
    public String toString() {        return "Position{"                + "point=" + point                + ", screenSize=" + screenSize                + '}';    }
    public boolean equals(Object o) {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        Position position = (Position) o;        return Objects.equals(point, position.point)                && Objects.equals(screenSize, position.screenSize);    }
                    new EventController(device, connection).control();                } catch (IOException e) {                    Ln.e("Exception from event controller", e);                }            }        }).start();    }
    private ScrCpyServer() {        // not instantiable    }
    private boolean encode(MediaCodec codec, OutputStream outputStream) throws IOException {        byte[] buf = new byte[bitRate / 8]; // may contain up to 1 second of video        boolean eof = false;        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();        while (!checkRotationChanged() && !eof) {            int outputBufferId = codec.dequeueOutputBuffer(bufferInfo, -1);            try {                if (checkRotationChanged()) {                    // must restart encoding with new size                    break;                }                if (outputBufferId >= 0) {                    ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);                    while (outputBuffer.hasRemaining()) {                        int remaining = outputBuffer.remaining();                        int len = Math.min(buf.length, remaining);                        // the outputBuffer is probably direct (it has no underlying array), and LocalSocket does not expose channels,                        // so we must copy the data locally to write them manually to the output stream                        outputBuffer.get(buf, 0, len);                        outputStream.write(buf, 0, len);                    }                }            } finally {                if (outputBufferId >= 0) {                    codec.releaseOutputBuffer(outputBufferId, false);                }            }        }        return !eof;    }
    private static MediaFormat createFormat(int bitRate, int frameRate, int iFrameInterval) throws IOException {        MediaFormat format = new MediaFormat();        format.setString(MediaFormat.KEY_MIME, "video/avc");        format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);        format.setInteger(MediaFormat.KEY_FRAME_RATE, frameRate);        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iFrameInterval);        // display the very first frame, and recover from bad quality when no new frames        format.setLong(MediaFormat.KEY_REPEAT_PREVIOUS_FRAME_AFTER, 1_000_000 * REPEAT_FRAME_DELAY / frameRate); // µs        return format;    }
    private boolean encode(MediaCodec codec, OutputStream outputStream) throws IOException {        @SuppressWarnings("checkstyle:MagicNumber")        byte[] buf = new byte[bitRate / 8]; // may contain up to 1 second of video        boolean eof = false;        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();        while (!checkRotationChanged() && !eof) {            int outputBufferId = codec.dequeueOutputBuffer(bufferInfo, -1);            try {                if (checkRotationChanged()) {                    // must restart encoding with new size                    break;                }                if (outputBufferId >= 0) {                    ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);                    while (outputBuffer.hasRemaining()) {                        int remaining = outputBuffer.remaining();                        int len = Math.min(buf.length, remaining);                        // the outputBuffer is probably direct (it has no underlying array), and LocalSocket does not expose channels,                        // so we must copy the data locally to write them manually to the output stream                        outputBuffer.get(buf, 0, len);                        outputStream.write(buf, 0, len);                    }                }            } finally {                if (outputBufferId >= 0) {                    codec.releaseOutputBuffer(outputBufferId, false);                }            }        }        return !eof;    }
    private static MediaFormat createFormat(int bitRate, int frameRate, int iFrameInterval) throws IOException {        MediaFormat format = new MediaFormat();        format.setString(MediaFormat.KEY_MIME, "video/avc");        format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);        format.setInteger(MediaFormat.KEY_FRAME_RATE, frameRate);        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iFrameInterval);        // display the very first frame, and recover from bad quality when no new frames        format.setLong(MediaFormat.KEY_REPEAT_PREVIOUS_FRAME_AFTER, MICROSECONDS_IN_ONE_SECOND * REPEAT_FRAME_DELAY / frameRate); // µs        return format;    }
    public String toString() {        return "Size{" +                "width=" + width +                ", height=" + height +                '}';    }}
    public boolean equals(Object o) {        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Size size = (Size) o;        return width == size.width &&                height == size.height;    }
    public String toString() {        return "Size{"                + "width=" + width                + ", height=" + height                + '}';    }}
    public boolean equals(Object o) {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        Size size = (Size) o;        return width == size.width                && height == size.height;    }
    public PowerManager(IInterface manager) {        this.manager = manager;        try {            String methodName = Build.VERSION.SDK_INT >= 20 ? "isInteractive" : "isScreenOn";            isScreenOnMethod = manager.getClass().getMethod(methodName);        } catch (NoSuchMethodException e) {            throw new AssertionError(e);        }    }
    public PowerManager(IInterface manager) {        this.manager = manager;        try {            @SuppressLint("ObsoleteSdkInt") // we may lower minSdkVersion in the future            String methodName = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT_WATCH ? "isInteractive" : "isScreenOn";            isScreenOnMethod = manager.getClass().getMethod(methodName);        } catch (NoSuchMethodException e) {            throw new AssertionError(e);        }    }
    public static void setDisplayLayerStack(IBinder displayToken, int layerStack) {        try {            cls.getMethod("setDisplayLayerStack", IBinder.class, int.class).invoke(null, displayToken, layerStack);        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public static void setDisplayProjection(IBinder displayToken, int orientation, Rect layerStackRect, Rect displayRect) {        try {            cls.getMethod("setDisplayProjection", IBinder.class, int.class, Rect.class, Rect.class)                    .invoke(null, displayToken, orientation, layerStackRect, displayRect);        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public static IBinder createDisplay(String name, boolean secure) {        try {            return (IBinder) cls.getMethod("createDisplay", String.class, boolean.class).invoke(null, name, secure);        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public static void setDisplaySurface(IBinder displayToken, Surface surface) {        try {            cls.getMethod("setDisplaySurface", IBinder.class, Surface.class).invoke(null, displayToken, surface);        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public static void openTransaction() {        try {            cls.getMethod("openTransaction").invoke(null);        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public static void destroyDisplay(IBinder displayToken) {        try {            cls.getMethod("destroyDisplay", IBinder.class).invoke(null, displayToken);        } catch (Exception e) {            throw new AssertionError(e);        }    }}
    public static void closeTransaction() {        try {            cls.getMethod("closeTransaction").invoke(null);        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public static void setDisplayLayerStack(IBinder displayToken, int layerStack) {        try {            CLASS.getMethod("setDisplayLayerStack", IBinder.class, int.class).invoke(null, displayToken, layerStack);        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public static void setDisplayProjection(IBinder displayToken, int orientation, Rect layerStackRect, Rect displayRect) {        try {            CLASS.getMethod("setDisplayProjection", IBinder.class, int.class, Rect.class, Rect.class)                    .invoke(null, displayToken, orientation, layerStackRect, displayRect);        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public static IBinder createDisplay(String name, boolean secure) {        try {            return (IBinder) CLASS.getMethod("createDisplay", String.class, boolean.class).invoke(null, name, secure);        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public static void setDisplaySurface(IBinder displayToken, Surface surface) {        try {            CLASS.getMethod("setDisplaySurface", IBinder.class, Surface.class).invoke(null, displayToken, surface);        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public static void openTransaction() {        try {            CLASS.getMethod("openTransaction").invoke(null);        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public static void destroyDisplay(IBinder displayToken) {        try {            CLASS.getMethod("destroyDisplay", IBinder.class).invoke(null, displayToken);        } catch (Exception e) {            throw new AssertionError(e);        }    }}
    public static void closeTransaction() {        try {            CLASS.getMethod("closeTransaction").invoke(null);        } catch (Exception e) {            throw new AssertionError(e);        }    }
SDL_bool screen_init_rendering(struct screen *screen,                               const char *device_name,                               struct size frame_size,                               SDL_bool always_on_top) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    Uint32 window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;    }    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height, window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1, SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width, frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    return SDL_TRUE;}
SDL_bool screen_init_rendering(struct screen *screen,                               const char *device_name,                               struct size frame_size,                               SDL_bool always_on_top) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    Uint32 window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height, window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1, SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width, frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    return SDL_TRUE;}
get_server_path(void) {    const char *server_path = getenv("SCRCPY_SERVER_PATH");    if (!server_path) {        server_path = DEFAULT_SERVER_PATH;    }    return server_path;}
get_server_path(void) {    const char *server_path_env = getenv("SCRCPY_SERVER_PATH");    if (server_path_env) {        LOGD("Using SCRCPY_SERVER_PATH: %s", server_path_env);        // if the envvar is set, use it        return server_path_env;    }#ifndef PORTABLE    LOGD("Using server: " DEFAULT_SERVER_PATH);    // the absolute path is hardcoded    return DEFAULT_SERVER_PATH;#else    // use scrcpy-server.jar in the same directory as the executable    char *executable_path = get_executable_path();    if (!executable_path) {        LOGE("Cannot get executable path, "             "using " SERVER_FILENAME " from current directory");        // not found, use current directory        return SERVER_FILENAME;    }    char *dir = dirname(executable_path);    size_t dirlen = strlen(dir);    // sizeof(SERVER_FILENAME) gives statically the size including the null byte    size_t len = dirlen + 1 + sizeof(SERVER_FILENAME);    char *server_path = SDL_malloc(len);    if (!server_path) {        LOGE("Cannot alloc server path string, "             "using " SERVER_FILENAME " from current directory");        SDL_free(executable_path);        return SERVER_FILENAME;    }    memcpy(server_path, dir, dirlen);    server_path[dirlen] = PATH_SEPARATOR;    memcpy(&server_path[dirlen + 1], SERVER_FILENAME, sizeof(SERVER_FILENAME));    // the final null byte has been copied with SERVER_FILENAME    SDL_free(executable_path);    LOGD("Using server (portable): %s", server_path);    return server_path;#endif}
    *pid = fork();    if (*pid == -1) {        perror("fork");        ret = PROCESS_ERROR_GENERIC;        goto end;    }    if (*pid > 0) {
get_executable_path(void) {// <https://stackoverflow.com/a/1024937/1987178>#ifdef __linux__    char buf[PATH_MAX + 1]; // +1 for the null byte    ssize_t len = readlink("/proc/self/exe", buf, PATH_MAX);    if (len == -1) {        perror("readlink");        return NULL;    }    buf[len] = '\0';    return SDL_strdup(buf);#else    // in practice, we only need this feature for portable builds, only used on    // Windows, so we don't care implementing it for every platform    // (it's useful to have a working version on Linux for debugging though)    return NULL;#endif}
    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    char cmd[256];    if (build_cmd(cmd, sizeof(cmd), argv)) {        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }
get_executable_path(void) {    HMODULE hModule = GetModuleHandleW(NULL);    if (!hModule) {        return NULL;    }    WCHAR buf[MAX_PATH + 1]; // +1 for the null byte    int len = GetModuleFileNameW(hModule, buf, MAX_PATH);    if (!len) {        return NULL;    }    buf[len] = '\0';    return utf8_from_wide_char(buf);}
    cmd[len + i] = NULL;    return cmd_execute(cmd[0], cmd);}
process_t adb_execute(const char *serial, const char *const adb_cmd[], int len) {    const char *cmd[len + 4];    int i;    cmd[0] = get_adb_command();    if (serial) {        cmd[1] = "-s";        cmd[2] = serial;        i = 3;    } else {        i = 1;    }    memcpy(&cmd[i], adb_cmd, len * sizeof(const char *));    cmd[len + i] = NULL;    return cmd_execute(cmd[0], cmd);}
static void show_err_msg(int err) {#ifdef __WINDOWS__    (void) err; // unused    LOGE("Failed to execute adb");#else    switch (err) {        case -1:            LOGE("Failed to execute adb");            break;        case ENOENT:            LOGE("'adb' command not found (make it accessible from your PATH "                  "or define its full path in the ADB environment variable)");            break;        default:            LOGE("Failed to execute adb: %s", strerror(err));            break;    }#endif}
process_t adb_execute(const char *serial, const char *const adb_cmd[], int len) {    const char *cmd[len + 4];    int i;    process_t process;    cmd[0] = get_adb_command();    if (serial) {        cmd[1] = "-s";        cmd[2] = serial;        i = 3;    } else {        i = 1;    }    memcpy(&cmd[i], adb_cmd, len * sizeof(const char *));    cmd[len + i] = NULL;    int r = cmd_execute(cmd[0], cmd, &process);    if (r != 0) {        show_err_msg(r);        return PROCESS_NONE;    }    return process;}
pid_t cmd_execute(const char *path, const char *const argv[]) {    pid_t pid = fork();    if (pid == -1) {        perror("fork");        return -1;    }    if (pid == 0) {        execvp(path, (char *const *)argv);        perror("exec");        _exit(1);    }    return pid;}
pid_t cmd_execute(const char *path, const char *const argv[]) {    pid_t pid = fork();    if (pid == -1) {        perror("fork");        return -1;    }    if (pid == 0) {        execvp(path, (char *const *)argv);        perror("exec");        _exit(1);    }    return pid;}
#include "log.h"int cmd_execute(const char *path, const char *const argv[], pid_t *pid) {    int fd[2];    int ret = 0;    if (pipe(fd) == -1) {        perror("pipe");        return -1;    }    *pid = fork();    if (*pid == -1) {        perror("fork");
int cmd_execute(const char *path, const char *const argv[], pid_t *pid) {    int fd[2];    int ret = 0;    if (pipe(fd) == -1) {        perror("pipe");        return -1;    }    *pid = fork();    if (*pid == -1) {        perror("fork");        ret = -1;        goto end;    }    if (*pid > 0) {        // parent close write side        close(fd[1]);        fd[1] = -1;        // wait for EOF or receive errno from child        if (read(fd[0], &ret, sizeof(int)) == -1) {            perror("read");            ret = -1;            goto end;        }    } else if (*pid == 0) {        // child close read side        close(fd[0]);        if (fcntl(fd[1], F_SETFD, FD_CLOEXEC) == 0) {            execvp(path, (char *const *)argv);        } else {            perror("fcntl");        }        // send errno to the parent        ret = errno;        if (write(fd[1], &ret, sizeof(int)) == -1) {            perror("write");        }        // close write side before exiting        close(fd[1]);        _exit(1);    }end:    if (fd[0] != -1) {        close(fd[0]);    }    if (fd[1] != -1) {        close(fd[1]);    }    return ret;}
HANDLE cmd_execute(const char *path, const char *const argv[]) {    STARTUPINFO si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    // Windows command-line parsing is WTF:    // <http://daviddeley.com/autohotkey/parameters/parameters.htm#WINPASS>    // only make it work for this very specific program    // (don't handle escaping nor quotes)    char cmd[256];    size_t ret = xstrjoin(cmd, argv, ' ', sizeof(cmd));    if (ret >= sizeof(cmd)) {        LOGE("Command too long (%" PRIsizet " chars)", sizeof(cmd) - 1);        return NULL;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, flags, NULL, NULL, &si, &pi)) {        return NULL;    }    return pi.hProcess;}
HANDLE cmd_execute(const char *path, const char *const argv[]) {    STARTUPINFO si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    // Windows command-line parsing is WTF:    // <http://daviddeley.com/autohotkey/parameters/parameters.htm#WINPASS>    // only make it work for this very specific program    // (don't handle escaping nor quotes)    char cmd[256];    size_t ret = xstrjoin(cmd, argv, ' ', sizeof(cmd));    if (ret >= sizeof(cmd)) {        LOGE("Command too long (%" PRIsizet " chars)", sizeof(cmd) - 1);        return NULL;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, flags, NULL, NULL, &si, &pi)) {        return NULL;    }    return pi.hProcess;}
int cmd_execute(const char *path, const char *const argv[], HANDLE *handle) {    STARTUPINFO si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    // Windows command-line parsing is WTF:    // <http://daviddeley.com/autohotkey/parameters/parameters.htm#WINPASS>    // only make it work for this very specific program    // (don't handle escaping nor quotes)    char cmd[256];    size_t ret = xstrjoin(cmd, argv, ' ', sizeof(cmd));    if (ret >= sizeof(cmd)) {        LOGE("Command too long (%" PRIsizet " chars)", sizeof(cmd) - 1);        *handle = NULL;        return -1;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, flags, NULL, NULL, &si, &pi)) {        *handle = NULL;        return -1;    }    *handle = pi.hProcess;    return 0;}
int cmd_execute(const char *path, const char *const argv[], HANDLE *handle) {    STARTUPINFO si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    // Windows command-line parsing is WTF:    // <http://daviddeley.com/autohotkey/parameters/parameters.htm#WINPASS>    // only make it work for this very specific program    // (don't handle escaping nor quotes)    char cmd[256];    size_t ret = xstrjoin(cmd, argv, ' ', sizeof(cmd));    if (ret >= sizeof(cmd)) {        LOGE("Command too long (%" PRIsizet " chars)", sizeof(cmd) - 1);        *handle = NULL;        return -1;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, flags, NULL, NULL, &si, &pi)) {        *handle = NULL;        return -1;    }    *handle = pi.hProcess;
ssize_t net_send_all(socket_t socket, const void *buf, size_t len) {    ssize_t w;    while (len > 0) {        w = send(socket, buf, len, 0);        if (w == -1) {            return -1;        }        len -= w;        buf += w;    }    return w;}
ssize_t net_send_all(socket_t socket, const void *buf, size_t len) {    ssize_t w;    while (len > 0) {        w = send(socket, buf, len, 0);        if (w == -1) {            return -1;        }        len -= w;        buf = (char *) buf + w;    }    return w;}
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            write32(&buf[2], event->keycode_event.keycode);            write32(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (1 byte) + date (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > TEXT_MAX_LENGTH) {                len = TEXT_MAX_LENGTH;            }            buf[1] = (Uint8) len;            memcpy(&buf[2], &event->text_event.text, len);            return 2 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            write32(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 14;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            write32(&buf[9], (Uint32) event->scroll_event.hscroll);            write32(&buf[13], (Uint32) event->scroll_event.vscroll);            return 17;        default:            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Unknown event type: %u\n", (unsigned) event->type);            return 0;    }}
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            write32(&buf[2], event->keycode_event.keycode);            write32(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (1 byte) + date (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > TEXT_MAX_LENGTH) {                len = TEXT_MAX_LENGTH;            }            buf[1] = (Uint8) len;            memcpy(&buf[2], &event->text_event.text, len);            return 2 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            write32(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 14;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            write32(&buf[9], (Uint32) event->scroll_event.hscroll);            write32(&buf[13], (Uint32) event->scroll_event.vscroll);            return 17;        default:            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Unknown event type: %u", (unsigned) event->type);            return 0;    }}
static int parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"help",     no_argument,       NULL, 'h'},        {"port",     required_argument, NULL, 'p'},        {"max-size", required_argument, NULL, 'm'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "hp:m:", long_options, NULL)) != -1) {        switch (c) {            case 'h': {                args->help = SDL_TRUE;                break;            }            case 'p': {                char *endptr;                long value = strtol(optarg, &endptr, 0);                if (*optarg == '\0' || *endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s\n", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld\n", value);                    return -1;                }                args->port = (Uint16) value;                break;            }            case 'm': {                char *endptr;                long value = strtol(optarg, &endptr, 0);                if (*optarg == '\0' || *endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid max size: %s\n", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Max size must be between 0 and 65535: %ld\n", value);                    return -1;                }                args->max_size = (Uint16) value;                break;            }            default:                // getopt prints the error message on stderr                return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s\n", argv[index]);        return -1;    }    return 0;}
static int parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"help",     no_argument,       NULL, 'h'},        {"port",     required_argument, NULL, 'p'},        {"max-size", required_argument, NULL, 'm'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "hp:m:", long_options, NULL)) != -1) {        switch (c) {            case 'h': {                args->help = SDL_TRUE;                break;            }            case 'p': {                char *endptr;                long value = strtol(optarg, &endptr, 0);                if (*optarg == '\0' || *endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld", value);                    return -1;                }                args->port = (Uint16) value;                break;            }            case 'm': {                char *endptr;                long value = strtol(optarg, &endptr, 0);                if (*optarg == '\0' || *endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid max size: %s", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Max size must be between 0 and 65535: %ld", value);                    return -1;                }                args->max_size = (Uint16) value;                break;            }            default:                // getopt prints the error message on stderr                return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s", argv[index]);        return -1;    }    return 0;}
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    // capture all Ctrl events    if (ctrl) {        SDL_bool repeat = event->repeat;        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        SDL_Keycode keycode = event->keysym.sym;        switch (keycode) {            case SDLK_h:                action_home(input_manager->controller);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(input_manager->controller);                return;            case SDLK_m:                action_app_switch(input_manager->controller);                return;            case SDLK_s:                action_menu(input_manager->controller);                return;            case SDLK_p:                action_power(input_manager->controller);                return;            case SDLK_v:                clipboard_paste(input_manager->controller);                return;            case SDLK_f:                screen_switch_fullscreen(input_manager->screen);                return;            case SDLK_x:                screen_resize_to_fit(input_manager->screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(input_manager->screen);                return;            case SDLK_i:                switch_fps_counter_state(input_manager->frames);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    // capture all Ctrl events    if (ctrl) {        SDL_bool repeat = event->repeat;        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        SDL_Keycode keycode = event->keysym.sym;        switch (keycode) {            case SDLK_h:                action_home(input_manager->controller);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(input_manager->controller);                return;            case SDLK_s:                action_app_switch(input_manager->controller);                return;            case SDLK_m:                action_menu(input_manager->controller);                return;            case SDLK_p:                action_power(input_manager->controller);                return;            case SDLK_v:                clipboard_paste(input_manager->controller);                return;            case SDLK_f:                screen_switch_fullscreen(input_manager->screen);                return;            case SDLK_x:                screen_resize_to_fit(input_manager->screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(input_manager->screen);                return;            case SDLK_i:                switch_fps_counter_state(input_manager->frames);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+m\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+s\n"        "        click on MENU\n"        "\n"        "    Ctrl+'+'\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+'-'\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+'+'\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+'-'\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    // capture all Ctrl events    if (ctrl) {        SDL_bool repeat = event->repeat;        // ignore repeated events        if (repeat) {            return;        }        SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        if (shift) {            // currently, there is no shortcut involving SHIFT            return;        }        SDL_Keycode keycode = event->keysym.sym;        int action = event->type == SDL_KEYDOWN ? ACTION_DOWN : ACTION_UP;        switch (keycode) {            case SDLK_h:                action_home(input_manager->controller, action);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(input_manager->controller, action);                return;            case SDLK_s:                action_app_switch(input_manager->controller, action);                return;            case SDLK_m:                action_menu(input_manager->controller, action);                return;            case SDLK_p:                action_power(input_manager->controller, action);                return;            case SDLK_DOWN:                action_volume_down(input_manager->controller, action);                return;            case SDLK_UP:                action_volume_up(input_manager->controller, action);                return;            case SDLK_v:                if (event->type == SDL_KEYDOWN) {                    clipboard_paste(input_manager->controller);                }                return;            case SDLK_f:                if (event->type == SDL_KEYDOWN) {                    screen_switch_fullscreen(input_manager->screen);                }                return;            case SDLK_x:                if (event->type == SDL_KEYDOWN) {                    screen_resize_to_fit(input_manager->screen);                }                return;            case SDLK_g:                if (event->type == SDL_KEYDOWN) {                    screen_resize_to_pixel_perfect(input_manager->screen);                }                return;            case SDLK_i:                if (event->type == SDL_KEYDOWN) {                    switch_fps_counter_state(input_manager->frames);                }                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    // capture all Ctrl events    if (ctrl) {        SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        if (shift) {            // currently, there is no shortcut involving SHIFT            return;        }        SDL_Keycode keycode = event->keysym.sym;        int action = event->type == SDL_KEYDOWN ? ACTION_DOWN : ACTION_UP;        SDL_bool repeat = event->repeat;        switch (keycode) {            case SDLK_h:                if (!repeat) {                    action_home(input_manager->controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (!repeat) {                    action_back(input_manager->controller, action);                }                return;            case SDLK_s:                if (!repeat) {                    action_app_switch(input_manager->controller, action);                }                return;            case SDLK_m:                if (!repeat) {                    action_menu(input_manager->controller, action);                }                return;            case SDLK_p:                if (!repeat) {                    action_power(input_manager->controller, action);                }                return;            case SDLK_DOWN:                // forward repeated events                action_volume_down(input_manager->controller, action);                return;            case SDLK_UP:                // forward repeated events                action_volume_up(input_manager->controller, action);                return;            case SDLK_v:                if (!repeat && event->type == SDL_KEYDOWN) {                    clipboard_paste(input_manager->controller);                }                return;            case SDLK_f:                if (!repeat && event->type == SDL_KEYDOWN) {                    screen_switch_fullscreen(input_manager->screen);                }                return;            case SDLK_x:                if (!repeat && event->type == SDL_KEYDOWN) {                    screen_resize_to_fit(input_manager->screen);                }                return;            case SDLK_g:                if (!repeat && event->type == SDL_KEYDOWN) {                    screen_resize_to_pixel_perfect(input_manager->screen);                }                return;            case SDLK_i:                if (!repeat && event->type == SDL_KEYDOWN) {                    switch_fps_counter_state(input_manager->frames);                }                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
    public CharSequence getText() {        Method method = getGetPrimaryClipMethod();        if (method == null) {            return null;        }        try {            ClipData clipData = (ClipData) method.invoke(manager, "com.android.shell");            if (clipData == null || clipData.getItemCount() == 0) {                return null;            }            return clipData.getItemAt(0).getText();        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);            return null;        }    }
    public void setText(CharSequence text) {        Method method = getSetPrimaryClipMethod();        if (method == null) {            return;        }        ClipData clipData = ClipData.newPlainText(null, text);        try {            method.invoke(manager, clipData, "com.android.shell");        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);        }    }}
    public CharSequence getText() {        Method method = getGetPrimaryClipMethod();        if (method == null) {            return null;        }        try {            ClipData clipData = (ClipData) method.invoke(manager, PACKAGE_NAME);            if (clipData == null || clipData.getItemCount() == 0) {                return null;            }            return clipData.getItemAt(0).getText();        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);            return null;        }    }
    public void setText(CharSequence text) {        Method method = getSetPrimaryClipMethod();        if (method == null) {            return;        }        ClipData clipData = ClipData.newPlainText(null, text);        try {            method.invoke(manager, clipData, PACKAGE_NAME);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);        }    }}
                }                int action = toUnsigned(buffer.get());                int keycode = buffer.getInt();                int metaState = buffer.getInt();                return ControlEvent.createKeycodeControlEvent(action, keycode, metaState);            }            case ControlEvent.TYPE_TEXT: {                if (buffer.remaining() < 1) {                    break;                }                int len = toUnsigned(buffer.get());                if (buffer.remaining() < len) {                    break;                }                buffer.get(textBuffer, 0, len);                String text = new String(textBuffer, 0, len, StandardCharsets.UTF_8);                return ControlEvent.createTextControlEvent(text);            }            case ControlEvent.TYPE_MOUSE: {                if (buffer.remaining() < MOUSE_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                int buttons = buffer.getInt();                Position position = readPosition(buffer);                return ControlEvent.createMotionControlEvent(action, buttons, position);            }            case ControlEvent.TYPE_SCROLL: {                if (buffer.remaining() < SCROLL_PAYLOAD_LENGTH) {
                }                int action = toUnsigned(buffer.get());                int keycode = buffer.getInt();                int metaState = buffer.getInt();                return ControlEvent.createKeycodeControlEvent(action, keycode, metaState);            }            case ControlEvent.TYPE_TEXT: {                if (buffer.remaining() < 1) {                    break;                }                int len = toUnsigned(buffer.get());                if (buffer.remaining() < len) {                    break;                }                buffer.get(textBuffer, 0, len);                String text = new String(textBuffer, 0, len, StandardCharsets.UTF_8);                return ControlEvent.createTextControlEvent(text);            }            case ControlEvent.TYPE_MOUSE: {                if (buffer.remaining() < MOUSE_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                int buttons = buffer.getInt();                Position position = readPosition(buffer);                return ControlEvent.createMotionControlEvent(action, buttons, position);            }            case ControlEvent.TYPE_SCROLL: {                if (buffer.remaining() < SCROLL_PAYLOAD_LENGTH) {
    public ControlEvent next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        switch (type) {            case ControlEvent.TYPE_KEYCODE: {                if (buffer.remaining() < KEYCODE_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                int keycode = buffer.getInt();                int metaState = buffer.getInt();                return ControlEvent.createKeycodeControlEvent(action, keycode, metaState);            }            case ControlEvent.TYPE_TEXT: {                if (buffer.remaining() < 1) {                    break;                }                int len = toUnsigned(buffer.get());                if (buffer.remaining() < len) {                    break;                }                buffer.get(textBuffer, 0, len);                String text = new String(textBuffer, 0, len, StandardCharsets.UTF_8);                return ControlEvent.createTextControlEvent(text);            }            case ControlEvent.TYPE_MOUSE: {                if (buffer.remaining() < MOUSE_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                int buttons = buffer.getInt();                Position position = readPosition(buffer);                return ControlEvent.createMotionControlEvent(action, buttons, position);            }            case ControlEvent.TYPE_SCROLL: {                if (buffer.remaining() < SCROLL_PAYLOAD_LENGTH) {                    break;                }                Position position = readPosition(buffer);                int hScroll = buffer.getInt();                int vScroll = buffer.getInt();                return ControlEvent.createScrollControlEvent(position, hScroll, vScroll);            }            case ControlEvent.TYPE_COMMAND: {                if (buffer.remaining() < COMMAND_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                return ControlEvent.createCommandControlEvent(action);            }            default:                Ln.w("Unknown event type: " + type);        }        // failure, reset savedPosition        buffer.position(savedPosition);        return null;    }
    public ControlEvent next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        switch (type) {            case ControlEvent.TYPE_KEYCODE: {                if (buffer.remaining() < KEYCODE_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                int keycode = buffer.getInt();                int metaState = buffer.getInt();                return ControlEvent.createKeycodeControlEvent(action, keycode, metaState);            }            case ControlEvent.TYPE_TEXT: {                if (buffer.remaining() < 1) {                    break;                }                int len = toUnsigned(buffer.get());                if (buffer.remaining() < len) {                    break;                }                buffer.get(textBuffer, 0, len);                String text = new String(textBuffer, 0, len, StandardCharsets.UTF_8);                return ControlEvent.createTextControlEvent(text);            }            case ControlEvent.TYPE_MOUSE: {                if (buffer.remaining() < MOUSE_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                int buttons = buffer.getInt();                Position position = readPosition(buffer);                return ControlEvent.createMotionControlEvent(action, buttons, position);            }            case ControlEvent.TYPE_SCROLL: {                if (buffer.remaining() < SCROLL_PAYLOAD_LENGTH) {                    break;                }                Position position = readPosition(buffer);                int hScroll = buffer.getInt();                int vScroll = buffer.getInt();                return ControlEvent.createScrollControlEvent(position, hScroll, vScroll);            }            case ControlEvent.TYPE_COMMAND: {                if (buffer.remaining() < COMMAND_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                return ControlEvent.createCommandControlEvent(action);            }            default:                Ln.w("Unknown event type: " + type);        }        // failure, reset savedPosition        buffer.position(savedPosition);        return null;    }
    public ControlEvent next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        switch (type) {            case ControlEvent.TYPE_KEYCODE: {                if (buffer.remaining() < KEYCODE_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                int keycode = buffer.getInt();                int metaState = buffer.getInt();                return ControlEvent.createKeycodeControlEvent(action, keycode, metaState);            }            case ControlEvent.TYPE_TEXT: {                if (buffer.remaining() < 1) {                    break;                }                int len = toUnsigned(buffer.get());                if (buffer.remaining() < len) {                    break;                }                buffer.get(textBuffer, 0, len);                String text = new String(textBuffer, 0, len, StandardCharsets.UTF_8);                return ControlEvent.createTextControlEvent(text);            }            case ControlEvent.TYPE_MOUSE: {                if (buffer.remaining() < MOUSE_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                int buttons = buffer.getInt();                Position position = readPosition(buffer);                return ControlEvent.createMotionControlEvent(action, buttons, position);            }            case ControlEvent.TYPE_SCROLL: {                if (buffer.remaining() < SCROLL_PAYLOAD_LENGTH) {                    break;                }                Position position = readPosition(buffer);                int hScroll = buffer.getInt();                int vScroll = buffer.getInt();                return ControlEvent.createScrollControlEvent(position, hScroll, vScroll);            }            case ControlEvent.TYPE_COMMAND: {                if (buffer.remaining() < COMMAND_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                return ControlEvent.createCommandControlEvent(action);            }            default:                Ln.w("Unknown event type: " + type);        }        // failure, reset savedPosition        buffer.position(savedPosition);        return null;    }
    public ControlEvent next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        switch (type) {            case ControlEvent.TYPE_KEYCODE: {                if (buffer.remaining() < KEYCODE_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                int keycode = buffer.getInt();                int metaState = buffer.getInt();                return ControlEvent.createKeycodeControlEvent(action, keycode, metaState);            }            case ControlEvent.TYPE_TEXT: {                if (buffer.remaining() < 1) {                    break;                }                int len = toUnsigned(buffer.get());                if (buffer.remaining() < len) {                    break;                }                buffer.get(textBuffer, 0, len);                String text = new String(textBuffer, 0, len, StandardCharsets.UTF_8);                return ControlEvent.createTextControlEvent(text);            }            case ControlEvent.TYPE_MOUSE: {                if (buffer.remaining() < MOUSE_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                int buttons = buffer.getInt();                Position position = readPosition(buffer);                return ControlEvent.createMotionControlEvent(action, buttons, position);            }            case ControlEvent.TYPE_SCROLL: {                if (buffer.remaining() < SCROLL_PAYLOAD_LENGTH) {                    break;                }                Position position = readPosition(buffer);                int hScroll = buffer.getInt();                int vScroll = buffer.getInt();                return ControlEvent.createScrollControlEvent(position, hScroll, vScroll);            }            case ControlEvent.TYPE_COMMAND: {                if (buffer.remaining() < COMMAND_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                return ControlEvent.createCommandControlEvent(action);            }            default:                Ln.w("Unknown event type: " + type);        }        // failure, reset savedPosition        buffer.position(savedPosition);        return null;    }
    private ControlEvent parseTextControlEvent() {        if (buffer.remaining() < 1) {            return null;        }        int len = toUnsigned(buffer.get());        if (buffer.remaining() < len) {            return null;        }        buffer.get(textBuffer, 0, len);        String text = new String(textBuffer, 0, len, StandardCharsets.UTF_8);        return ControlEvent.createTextControlEvent(text);    }
    private ControlEvent parseScrollControlEvent() {        if (buffer.remaining() < SCROLL_PAYLOAD_LENGTH) {            return null;        }        Position position = readPosition(buffer);        int hScroll = buffer.getInt();        int vScroll = buffer.getInt();        return ControlEvent.createScrollControlEvent(position, hScroll, vScroll);    }
    public ControlEvent next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        ControlEvent controlEvent;        switch (type) {            case ControlEvent.TYPE_KEYCODE:                controlEvent = parseKeycodeControlEvent();                break;            case ControlEvent.TYPE_TEXT:                controlEvent = parseTextControlEvent();                break;            case ControlEvent.TYPE_MOUSE:                controlEvent = parseMouseControlEvent();                break;            case ControlEvent.TYPE_SCROLL:                controlEvent = parseScrollControlEvent();                break;            case ControlEvent.TYPE_COMMAND:                controlEvent = parseCommandControlEvent();                break;            default:                Ln.w("Unknown event type: " + type);                controlEvent = null;                break;        }        if (controlEvent == null) {            // failure, reset savedPosition            buffer.position(savedPosition);        }        return controlEvent;    }
    private ControlEvent parseMouseControlEvent() {        if (buffer.remaining() < MOUSE_PAYLOAD_LENGTH) {            return null;        }        int action = toUnsigned(buffer.get());        int buttons = buffer.getInt();        Position position = readPosition(buffer);        return ControlEvent.createMotionControlEvent(action, buttons, position);    }
    private ControlEvent parseKeycodeControlEvent() {        if (buffer.remaining() < KEYCODE_PAYLOAD_LENGTH) {            return null;        }        int action = toUnsigned(buffer.get());        int keycode = buffer.getInt();        int metaState = buffer.getInt();        return ControlEvent.createKeycodeControlEvent(action, keycode, metaState);    }
    private ControlEvent parseCommandControlEvent() {        if (buffer.remaining() < COMMAND_PAYLOAD_LENGTH) {            return null;        }        int action = toUnsigned(buffer.get());        return ControlEvent.createCommandControlEvent(action);    }
SDL_bool screen_init_rendering(struct screen *screen, const char *device_name, struct size frame_size) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height,                                      SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1, SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width, frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    screen->texture = SDL_CreateTexture(screen->renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                                        frame_size.width, frame_size.height);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    return SDL_TRUE;}
SDL_bool screen_init_rendering(struct screen *screen, const char *device_name, struct size frame_size) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height, SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1, SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width, frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    screen->texture = SDL_CreateTexture(screen->renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                                        frame_size.width, frame_size.height);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    return SDL_TRUE;}
buffer_read32be(uint8_t *buf) {    return (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];}
uint64_t buffer_read64be(uint8_t *buf) {    uint32_t msb = buffer_read32be(buf);    uint32_t lsb = buffer_read32be(&buf[4]);    return ((uint64_t) msb << 32) | lsb;}
buffer_read32be(uint8_t *buf) {    return (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];}
uint64_t buffer_read64be(uint8_t *buf) {    uint32_t msb = buffer_read32be(buf);    uint32_t lsb = buffer_read32be(&buf[4]);    return ((uint64_t) msb << 32) | lsb;}
buffer_read32be(const uint8_t *buf) {    return (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];}
uint64_t buffer_read64be(const uint8_t *buf) {    uint32_t msb = buffer_read32be(buf);    uint32_t lsb = buffer_read32be(&buf[4]);    return ((uint64_t) msb << 32) | lsb;}
buffer_read32be(const uint8_t *buf) {    return (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];}
uint64_t buffer_read64be(const uint8_t *buf) {    uint32_t msb = buffer_read32be(buf);    uint32_t lsb = buffer_read32be(&buf[4]);    return ((uint64_t) msb << 32) | lsb;}
SDL_Surface *read_xpm(char *xpm[]) {    char *endptr;    // *** No error handling, assume the XPM source is valid ***    // (it's in our source repo)    // Assertions are only checked in debug    Uint32 width = strtol(xpm[0], &endptr, 10);    Uint32 height = strtol(endptr + 1, &endptr, 10);    Uint32 colors = strtol(endptr + 1, &endptr, 10);    Uint32 chars = strtol(endptr + 1, &endptr, 10);    // sanity checks    SDL_assert(width < 256);    SDL_assert(height < 256);    SDL_assert(colors < 256);    SDL_assert(chars == 1); // this implementation does not support more    // init index    struct index index[colors];    for (int i = 0; i < colors; ++i) {        const char *line = xpm[1+i];        index[i].c = line[0];        SDL_assert(line[1] == '\t');        SDL_assert(line[2] == 'c');        SDL_assert(line[3] == ' ');        if (line[4] == '#') {            index[i].color = 0xff000000 | strtol(&line[5], &endptr, 0x10);            SDL_assert(*endptr == '\0');        } else {            SDL_assert(!strcmp("None", &line[4]));            index[i].color = 0;        }    }    // parse image    Uint32 *pixels = SDL_malloc(4 * width * height);    if (!pixels) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not allocate icon memory");        return NULL;    }    for (int y = 0; y < height; ++y) {        const char *line = xpm[1 + colors + y];        for (int x = 0; x < width; ++x) {            char c = line[x];            Uint32 color;            SDL_bool color_found = find_color(index, colors, c, &color);            SDL_assert(color_found);            pixels[y * width + x] = color;        }    }#if SDL_BYTEORDER == SDL_BIG_ENDIAN    Uint32 amask = 0x000000ff;    Uint32 rmask = 0x0000ff00;    Uint32 gmask = 0x00ff0000;    Uint32 bmask = 0xff000000;#else // little endian, like x86    Uint32 amask = 0xff000000;    Uint32 rmask = 0x00ff0000;    Uint32 gmask = 0x0000ff00;    Uint32 bmask = 0x000000ff;#endif    SDL_Surface *surface = SDL_CreateRGBSurfaceFrom(pixels,                                                    width, height,                                                    32, 4 * width,                                                    rmask, gmask, bmask, amask);    // make the surface own the raw pixels    surface->flags &= ~SDL_PREALLOC;    return surface;}
SDL_Surface *read_xpm(char *xpm[]) {#if SDL_ASSERT_LEVEL >= 2    // patch the XPM to change the icon color in debug mode    xpm[2] = ".	c #CC00CC";#endif    char *endptr;    // *** No error handling, assume the XPM source is valid ***    // (it's in our source repo)    // Assertions are only checked in debug    Uint32 width = strtol(xpm[0], &endptr, 10);    Uint32 height = strtol(endptr + 1, &endptr, 10);    Uint32 colors = strtol(endptr + 1, &endptr, 10);    Uint32 chars = strtol(endptr + 1, &endptr, 10);    // sanity checks    SDL_assert(width < 256);    SDL_assert(height < 256);    SDL_assert(colors < 256);    SDL_assert(chars == 1); // this implementation does not support more    // init index    struct index index[colors];    for (int i = 0; i < colors; ++i) {        const char *line = xpm[1+i];        index[i].c = line[0];        SDL_assert(line[1] == '\t');        SDL_assert(line[2] == 'c');        SDL_assert(line[3] == ' ');        if (line[4] == '#') {            index[i].color = 0xff000000 | strtol(&line[5], &endptr, 0x10);            SDL_assert(*endptr == '\0');        } else {            SDL_assert(!strcmp("None", &line[4]));            index[i].color = 0;        }    }    // parse image    Uint32 *pixels = SDL_malloc(4 * width * height);    if (!pixels) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not allocate icon memory");        return NULL;    }    for (int y = 0; y < height; ++y) {        const char *line = xpm[1 + colors + y];        for (int x = 0; x < width; ++x) {            char c = line[x];            Uint32 color;            SDL_bool color_found = find_color(index, colors, c, &color);            SDL_assert(color_found);            pixels[y * width + x] = color;        }    }#if SDL_BYTEORDER == SDL_BIG_ENDIAN    Uint32 amask = 0x000000ff;    Uint32 rmask = 0x0000ff00;    Uint32 gmask = 0x00ff0000;    Uint32 bmask = 0xff000000;#else // little endian, like x86    Uint32 amask = 0xff000000;    Uint32 rmask = 0x00ff0000;    Uint32 gmask = 0x0000ff00;    Uint32 bmask = 0x000000ff;#endif    SDL_Surface *surface = SDL_CreateRGBSurfaceFrom(pixels,                                                    width, height,                                                    32, 4 * width,                                                    rmask, gmask, bmask, amask);    // make the surface own the raw pixels    surface->flags &= ~SDL_PREALLOC;    return surface;}
void decoder_init(struct decoder *decoder, struct frames *frames, socket_t video_socket, struct size frame_size) {    decoder->frames = frames;    decoder->video_socket = video_socket;    decoder->frame_size = frame_size;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    int ret;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    AVStream *outstream = NULL;    AVFormatContext *output_ctx = NULL;    if (decoder->out_filename) {        avformat_alloc_output_context2(&output_ctx, NULL, NULL, decoder->out_filename);        if (!output_ctx) {            LOGE("Could not allocate output format context");            goto run_finally_free_avio_ctx;        } else {            outstream = avformat_new_stream(output_ctx, codec);            if (!outstream) {                LOGE("Could not allocate output stream");                goto run_finally_free_output_ctx;            }            outstream->codec = avcodec_alloc_context3(codec);            outstream->codec->pix_fmt = AV_PIX_FMT_YUV420P;            outstream->codec->width = decoder->frame_size.width;            outstream->codec->height = decoder->frame_size.height;            outstream->time_base = (AVRational) {1, 60};            outstream->codec->flags |= AV_CODEC_FLAG_GLOBAL_HEADER;            ret = avio_open(&output_ctx->pb, decoder->out_filename, AVIO_FLAG_WRITE);            if (ret < 0) {                LOGE("Failed to open output file");                goto run_finally_free_output_ctx;            }            ret = avformat_write_header(output_ctx, NULL);            if (ret < 0) {                LOGE("Error writing output header");                avio_closep(&output_ctx->pb);                goto run_finally_free_output_ctx;            }        }    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {        if (output_ctx) {            packet.pts = decoder->pts;            av_packet_rescale_ts(&packet, us, outstream->time_base);            ret = av_write_frame(output_ctx, &packet);        }// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (output_ctx) {        ret = av_write_trailer(output_ctx);        avio_closep(&output_ctx->pb);    }    avformat_close_input(&format_ctx);run_finally_free_output_ctx:    if (output_ctx)        avformat_free_context(output_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static int read_packet(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    uint8_t header[HEADER_SIZE];    int remaining;    int ret;    remaining = decoder->remaining;    if (remaining == 0) {        ret = net_recv(decoder->video_socket, header, HEADER_SIZE);        if (ret <= 0)            return ret;        decoder->pts = from_be(header, 8);        remaining = from_be(header + 12, 4);    }    if (buf_size > remaining)        buf_size = remaining;    ret = net_recv(decoder->video_socket, buf, buf_size);    if (ret <= 0)        return ret;    remaining -= ret;    decoder->remaining = remaining;    return ret;}
SDL_bool decoder_start(struct decoder *decoder, const char *out_filename) {    LOGD("Starting decoder thread");    decoder->out_filename = out_filename;    decoder->thread = SDL_CreateThread(run_decoder, "video_decoder", decoder);    if (!decoder->thread) {        LOGC("Could not start decoder thread");        return SDL_FALSE;    }    return SDL_TRUE;}
void decoder_init(struct decoder *decoder, struct frames *frames,                  socket_t video_socket, struct recorder *recorder) {    decoder->frames = frames;    decoder->video_socket = video_socket;    decoder->recorder = recorder;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {        if (decoder->recorder) {            packet.pts = decoder->pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(decoder->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto run_quit;            }        }// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static int read_packet(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    uint8_t header[HEADER_SIZE];    int remaining;    int ret;    remaining = decoder->remaining;    if (remaining == 0) {        // FIXME what if only part of the header is available?        ret = net_recv(decoder->video_socket, header, HEADER_SIZE);        if (ret <= 0)            return ret;        decoder->pts = from_be(header, 8);        remaining = from_be(header + 12, 4);    }    if (buf_size > remaining)        buf_size = remaining;    ret = net_recv(decoder->video_socket, buf, buf_size);    if (ret <= 0)        return ret;    remaining -= ret;    decoder->remaining = remaining;    return ret;}
SDL_bool decoder_start(struct decoder *decoder) {    LOGD("Starting decoder thread");    decoder->thread = SDL_CreateThread(run_decoder, "video_decoder", decoder);    if (!decoder->thread) {        LOGC("Could not start decoder thread");        return SDL_FALSE;    }    return SDL_TRUE;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    decoder_init(&decoder, &frames, device_socket, frame_size);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder, options->out_filename)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_file_handler;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    struct recorder *rec = NULL;    if (options->out_filename) {        if (!recorder_init(&recorder, options->out_filename, frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    decoder_init(&decoder, &frames, device_socket, rec);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_recorder:    if (options->out_filename) {        recorder_destroy(&recorder);    }finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
request_queue_init(struct request_queue *queue) {    queue->head = 0;    queue->tail = 0;    return true;}
run_file_handler(void *data) {    struct file_handler *file_handler = data;    for (;;) {        mutex_lock(file_handler->mutex);        file_handler->current_process = PROCESS_NONE;        while (!file_handler->stopped                && request_queue_is_empty(&file_handler->queue)) {            cond_wait(file_handler->event_cond, file_handler->mutex);        }        if (file_handler->stopped) {            // stop immediately, do not process further events            mutex_unlock(file_handler->mutex);            break;        }        struct request *req;        bool non_empty = request_queue_take(&file_handler->queue, &req);        SDL_assert(non_empty);        process_t process;        if (req->action == ACTION_INSTALL_APK) {            LOGI("Installing %s...", req->file);            process = install_apk(file_handler->serial, req->file);        } else {            LOGI("Pushing %s...", req->file);            process = push_file(file_handler->serial, req->file);        }        file_handler->current_process = process;        mutex_unlock(file_handler->mutex);        if (req->action == ACTION_INSTALL_APK) {            if (process_check_success(process, "adb install")) {                LOGI("%s successfully installed", req->file);            } else {                LOGE("Failed to install %s", req->file);            }        } else {            if (process_check_success(process, "adb push")) {                LOGI("%s successfully pushed to /sdcard/", req->file);            } else {                LOGE("Failed to push %s to /sdcard/", req->file);            }        }        request_free(req);    }    return 0;}
request_new(file_handler_action_t action, char *file) {    struct request *req = SDL_malloc(sizeof(*req));    if (!req) {        return NULL;    }    req->action = action;    req->file = file;    return req;}
file_handler_destroy(struct file_handler *file_handler) {    SDL_DestroyCond(file_handler->event_cond);    SDL_DestroyMutex(file_handler->mutex);    request_queue_destroy(&file_handler->queue);    SDL_free(file_handler->serial);}
file_handler_request(struct file_handler *file_handler,                     file_handler_action_t action,                     char *file) {    bool res;    // start file_handler if it's used for the first time    if (!file_handler->initialized) {        if (!file_handler_start(file_handler)) {            return false;        }        file_handler->initialized = true;    }    LOGI("Request to %s %s", action == ACTION_INSTALL_APK ? "install" : "push",                             file);    struct request *req = request_new(action, file);    if (!req) {        LOGE("Could not create request");        return false;    }    mutex_lock(file_handler->mutex);    bool was_empty = request_queue_is_empty(&file_handler->queue);    res = request_queue_push(&file_handler->queue, req);    if (was_empty) {        cond_signal(file_handler->event_cond);    }    mutex_unlock(file_handler->mutex);    return res;}
request_queue_is_full(const struct request_queue *queue) {    return (queue->head + 1) % REQUEST_QUEUE_SIZE == queue->tail;}
request_queue_take(struct request_queue *queue, struct request **req) {    if (request_queue_is_empty(queue)) {        return false;    }    // transfer ownership    *req = queue->reqs[queue->tail];    queue->tail = (queue->tail + 1) % REQUEST_QUEUE_SIZE;    return true;}
request_free(struct request *req) {    if (!req) {        return;    }    SDL_free(req->file);    SDL_free(req);}
request_free(struct request *req) {    if (!req) {        return;    }    SDL_free(req->file);    SDL_free(req);}
request_queue_is_empty(const struct request_queue *queue) {    return queue->head == queue->tail;}
request_queue_destroy(struct request_queue *queue) {    int i = queue->tail;    while (i != queue->head) {        request_free(queue->reqs[i]);        i = (i + 1) % REQUEST_QUEUE_SIZE;    }}
file_handler_init(struct file_handler *file_handler, const char *serial) {    if (!request_queue_init(&file_handler->queue)) {        return false;    }    if (!(file_handler->mutex = SDL_CreateMutex())) {        return false;    }    if (!(file_handler->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(file_handler->mutex);        return false;    }    if (serial) {        file_handler->serial = SDL_strdup(serial);        if (!file_handler->serial) {            LOGW("Cannot strdup serial");            SDL_DestroyCond(file_handler->event_cond);            SDL_DestroyMutex(file_handler->mutex);            return false;        }    } else {        file_handler->serial = NULL;    }    // lazy initialization    file_handler->initialized = false;    file_handler->stopped = false;    file_handler->current_process = PROCESS_NONE;    return true;}
request_queue_push(struct request_queue *queue, struct request *req) {    if (request_queue_is_full(queue)) {        return false;    }    queue->reqs[queue->head] = req;    queue->head = (queue->head + 1) % REQUEST_QUEUE_SIZE;    return true;}
    file_handler->current_process = PROCESS_NONE;    return true;}void
run_file_handler(void *data) {    struct file_handler *file_handler = data;    for (;;) {        mutex_lock(file_handler->mutex);        file_handler->current_process = PROCESS_NONE;        while (!file_handler->stopped && cbuf_is_empty(&file_handler->queue)) {            cond_wait(file_handler->event_cond, file_handler->mutex);        }        if (file_handler->stopped) {            // stop immediately, do not process further events            mutex_unlock(file_handler->mutex);            break;        }        struct file_handler_request req;        bool non_empty = cbuf_take(&file_handler->queue, &req);        SDL_assert(non_empty);        process_t process;        if (req.action == ACTION_INSTALL_APK) {            LOGI("Installing %s...", req.file);            process = install_apk(file_handler->serial, req.file);        } else {            LOGI("Pushing %s...", req.file);            process = push_file(file_handler->serial, req.file);        }        file_handler->current_process = process;        mutex_unlock(file_handler->mutex);        if (req.action == ACTION_INSTALL_APK) {            if (process_check_success(process, "adb install")) {                LOGI("%s successfully installed", req.file);            } else {                LOGE("Failed to install %s", req.file);            }        } else {            if (process_check_success(process, "adb push")) {                LOGI("%s successfully pushed to /sdcard/", req.file);            } else {                LOGE("Failed to push %s to /sdcard/", req.file);            }        }        file_handler_request_destroy(&req);    }    return 0;}
boolfile_handler_init(struct file_handler *file_handler, const char *serial) {    cbuf_init(&file_handler->queue);    if (!(file_handler->mutex = SDL_CreateMutex())) {        return false;    }    if (!(file_handler->event_cond = SDL_CreateCond())) {
file_handler_destroy(struct file_handler *file_handler) {    SDL_DestroyCond(file_handler->event_cond);    SDL_DestroyMutex(file_handler->mutex);    SDL_free(file_handler->serial);    struct file_handler_request req;    while (cbuf_take(&file_handler->queue, &req)) {        file_handler_request_destroy(&req);    }}
file_handler_request(struct file_handler *file_handler,                     file_handler_action_t action, char *file) {    // start file_handler if it's used for the first time    if (!file_handler->initialized) {        if (!file_handler_start(file_handler)) {            return false;        }        file_handler->initialized = true;    }    LOGI("Request to %s %s", action == ACTION_INSTALL_APK ? "install" : "push",                             file);    struct file_handler_request req = {        .action = action,        .file = file,    };    mutex_lock(file_handler->mutex);    bool was_empty = cbuf_is_empty(&file_handler->queue);    bool res = cbuf_push(&file_handler->queue, req);    if (was_empty) {        cond_signal(file_handler->event_cond);    }    mutex_unlock(file_handler->mutex);    return res;}
    // lazy initialization    file_handler->initialized = false;
boolfile_handler_request(struct file_handler *file_handler,                     file_handler_action_t action, char *file) {    // start file_handler if it's used for the first time    if (!file_handler->initialized) {        if (!file_handler_start(file_handler)) {            return false;        }        file_handler->initialized = true;
        return false;    }    if (serial) {        file_handler->serial = SDL_strdup(serial);        if (!file_handler->serial) {            LOGW("Cannot strdup serial");            SDL_DestroyCond(file_handler->event_cond);
file_handler_request_destroy(struct file_handler_request *req) {    SDL_free(req->file);}
            return false;        }    } else {        file_handler->serial = NULL;
    SDL_DestroyCond(file_handler->event_cond);    SDL_DestroyMutex(file_handler->mutex);    SDL_free(file_handler->serial);    struct file_handler_request req;    while (cbuf_take(&file_handler->queue, &req)) {        file_handler_request_destroy(&req);    }
file_handler_init(struct file_handler *file_handler, const char *serial) {    cbuf_init(&file_handler->queue);    if (!(file_handler->mutex = SDL_CreateMutex())) {        return false;    }    if (!(file_handler->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(file_handler->mutex);        return false;    }    if (serial) {        file_handler->serial = SDL_strdup(serial);        if (!file_handler->serial) {            LOGW("Cannot strdup serial");            SDL_DestroyCond(file_handler->event_cond);            SDL_DestroyMutex(file_handler->mutex);            return false;        }    } else {        file_handler->serial = NULL;    }    // lazy initialization    file_handler->initialized = false;    file_handler->stopped = false;    file_handler->current_process = PROCESS_NONE;    return true;}
static process_tinstall_apk(const char *serial, const char *file) {    return adb_install(serial, file);}static process_tpush_file(const char *serial, const char *file) {    return adb_push(serial, file, DEVICE_SDCARD_PATH);
void server_stop(struct server *server, const char *serial) {    SDL_assert(server->process != PROCESS_NONE);    if (server->device_socket != INVALID_SOCKET) {        // shutdown the socket to finish the device process gracefully        if (!net_shutdown(server->device_socket, SHUT_RDWR)) {            LOGW("Cannot shutdown socket");        }    }    LOGD("Waiting the server to complete execution on the device...");    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->adb_reverse_enabled) {        // ignore failure        disable_tunnel(serial);    }    if (server->server_copied_to_device) {        remove_server(serial); // ignore failure    }}
void server_stop(struct server *server, const char *serial) {    SDL_assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Cannot terminate server");    }    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->adb_reverse_enabled) {        // ignore failure        disable_tunnel(serial);    }    if (server->server_copied_to_device) {        remove_server(serial); // ignore failure    }}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    SDL_bool ret = 0;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, max_size, bit_rate);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    SDL_bool ret = 0;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, max_size, bit_rate);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable mouse focus clickthrough");    }    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {    case CONTROL_EVENT_TYPE_KEYCODE:        buf[1] = event->keycode_event.action;        write32(&buf[2], event->keycode_event.keycode);        write32(&buf[6], event->keycode_event.metastate);        return 10;    case CONTROL_EVENT_TYPE_TEXT: {        // write length (1 byte) + date (non nul-terminated)        size_t len = strlen(event->text_event.text);        if (len > TEXT_MAX_LENGTH) {            len = TEXT_MAX_LENGTH;        }        buf[1] = (Uint8) len;        memcpy(&buf[2], &event->text_event.text, len);        return 2 + len;    }    case CONTROL_EVENT_TYPE_MOUSE:        buf[1] = event->mouse_event.action;        write32(&buf[2], event->mouse_event.buttons);        write_position(&buf[6], &event->mouse_event.position);        return 14;    case CONTROL_EVENT_TYPE_SCROLL:        write_position(&buf[1], &event->scroll_event.position);        write32(&buf[9], (Uint32) event->scroll_event.hscroll);        write32(&buf[13], (Uint32) event->scroll_event.vscroll);        return 17;    default:        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Unknown event type: %u\n", (unsigned) event->type);        return 0;    }}
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            write32(&buf[2], event->keycode_event.keycode);            write32(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (1 byte) + date (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > TEXT_MAX_LENGTH) {                len = TEXT_MAX_LENGTH;            }            buf[1] = (Uint8) len;            memcpy(&buf[2], &event->text_event.text, len);            return 2 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            write32(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 14;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            write32(&buf[9], (Uint32) event->scroll_event.hscroll);            write32(&buf[13], (Uint32) event->scroll_event.vscroll);            return 17;        default:            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Unknown event type: %u\n", (unsigned) event->type);            return 0;    }}
int parse_args(struct args *args, int argc, char *argv[]) {    int c;    while ((c = getopt(argc, argv, "p:m:")) != -1) {        switch (c) {        case 'p': {            char *endptr;            long value = strtol(optarg, &endptr, 0);            if (*optarg == '\0' || *endptr != '\0') {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s\n", optarg);                return -1;            }            if (value & ~0xffff) {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld\n", value);                return -1;            }            args->port = (Uint16) value;            break;        }        case 'm': {            char *endptr;            long value = strtol(optarg, &endptr, 0);            if (*optarg == '\0' || *endptr != '\0') {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid maximum size: %s\n", optarg);                return -1;            }            if (value & ~0xffff) {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Maximum size must be between 0 and 65535: %ld\n", value);                return -1;            }            args->maximum_size = (Uint16) value;            break;        }        default:            // getopt prints the error message on stderr            return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s\n", argv[index]);        return -1;    }    return 0;}
int parse_args(struct args *args, int argc, char *argv[]) {    int c;    while ((c = getopt(argc, argv, "p:m:")) != -1) {        switch (c) {            case 'p': {                char *endptr;                long value = strtol(optarg, &endptr, 0);                if (*optarg == '\0' || *endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s\n", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld\n", value);                    return -1;                }                args->port = (Uint16) value;                break;            }            case 'm': {                char *endptr;                long value = strtol(optarg, &endptr, 0);                if (*optarg == '\0' || *endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid maximum size: %s\n", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Maximum size must be between 0 and 65535: %ld\n", value);                    return -1;                }                args->maximum_size = (Uint16) value;                break;            }            default:                // getopt prints the error message on stderr                return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s\n", argv[index]);        return -1;    }    return 0;}
void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            return;        case EVENT_NEW_FRAME:            if (!handle_new_frame()) {                return;            }            texture_empty = SDL_FALSE;            count_frame(); // display fps for debug            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_TEXTINPUT: {            handle_text_input(&event.text);            break;        }        case SDL_KEYDOWN:        case SDL_KEYUP:            handle_key(&event.key);            break;        case SDL_MOUSEMOTION:            handle_mouse_motion(&event.motion, frame_size);            break;        case SDL_MOUSEWHEEL: {            struct position position = {                .screen_size = frame_size,                .point = get_mouse_point(),            };            handle_mouse_wheel(&event.wheel, position);            break;        }        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP: {            handle_mouse_button(&event.button, frame_size);            break;        }        }    }}
void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");            case SDL_QUIT:                return;            case EVENT_NEW_FRAME:                if (!handle_new_frame()) {                    return;                }                texture_empty = SDL_FALSE;                count_frame(); // display fps for debug                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    render(renderer, texture_empty ? NULL : texture);                    break;                }                break;            case SDL_TEXTINPUT: {                handle_text_input(&event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                handle_key(&event.key);                break;            case SDL_MOUSEMOTION:                handle_mouse_motion(&event.motion, frame_size);                break;            case SDL_MOUSEWHEEL: {                struct position position = {                    .screen_size = frame_size,                    .point = get_mouse_point(),                };                handle_mouse_wheel(&event.wheel, position);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                handle_mouse_button(&event.button, frame_size);                break;            }        }    }}
static uint64_t receiver_state_take_meta(struct receiver_state *state) {    struct frame_meta *frame_meta = state->frame_meta_queue; // first item    SDL_assert(frame_meta); // must not be empty    uint64_t pts = frame_meta->pts;    state->frame_meta_queue = frame_meta->next; // remove the item    frame_meta_delete(frame_meta);    return pts;}
static SDL_bool receiver_state_push_meta(struct receiver_state *state,                                         uint64_t pts) {    struct frame_meta *frame_meta = frame_meta_new(pts);    if (!frame_meta) {        return SDL_FALSE;    }    // append to the list    // (iterate to find the last item, in practice the list should be tiny)    struct frame_meta **p = &state->frame_meta_queue;    while (*p) {        p = &(*p)->next;    }    *p = frame_meta;    return SDL_TRUE;}
static SDL_bool receiver_state_push_meta(struct receiver_state *state,                                         uint64_t pts) {    struct frame_meta *frame_meta = frame_meta_new(pts);    if (!frame_meta) {        return SDL_FALSE;    }    // append to the list    // (iterate to find the last item, in practice the list should be tiny)    struct frame_meta **p = &state->frame_meta_queue;    while (*p) {        p = &(*p)->next;    }    *p = frame_meta;    return SDL_TRUE;}
static int read_packet_with_meta(void *opaque, uint8_t *buf, int buf_size) {    struct stream *stream = opaque;    struct receiver_state *state = &stream->receiver_state;    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    if (!state->remaining) {#define HEADER_SIZE 12        uint8_t header[HEADER_SIZE];        ssize_t r = net_recv_all(stream->socket, header, HEADER_SIZE);        if (r == -1) {            return AVERROR(errno);        }        if (r == 0) {            return AVERROR_EOF;        }        // no partial read (net_recv_all())        SDL_assert_release(r == HEADER_SIZE);        uint64_t pts = buffer_read64be(header);        state->remaining = buffer_read32be(&header[8]);        if (pts != NO_PTS && !receiver_state_push_meta(state, pts)) {            LOGE("Could not store PTS for recording");            // we cannot save the PTS, the recording would be broken            return AVERROR(ENOMEM);        }    }    SDL_assert(state->remaining);    if (buf_size > state->remaining) {        buf_size = state->remaining;    }    ssize_t r = net_recv(stream->socket, buf, buf_size);    if (r == -1) {        return AVERROR(errno);    }    if (r == 0) {        return AVERROR_EOF;    }    SDL_assert(state->remaining >= r);    state->remaining -= r;    return r;}
static Uint64 receiver_state_take_meta(struct receiver_state *state) {    struct frame_meta *frame_meta = state->frame_meta_queue; // first item    SDL_assert(frame_meta); // must not be empty    Uint64 pts = frame_meta->pts;    state->frame_meta_queue = frame_meta->next; // remove the item    frame_meta_delete(frame_meta);    return pts;}
static SDL_bool receiver_state_push_meta(struct receiver_state *state,                                         Uint64 pts) {    struct frame_meta *frame_meta = frame_meta_new(pts);    if (!frame_meta) {        return SDL_FALSE;    }    // append to the list    // (iterate to find the last item, in practice the list should be tiny)    struct frame_meta **p = &state->frame_meta_queue;    while (*p) {        p = &(*p)->next;    }    *p = frame_meta;    return SDL_TRUE;}
static SDL_bool receiver_state_push_meta(struct receiver_state *state,                                         Uint64 pts) {    struct frame_meta *frame_meta = frame_meta_new(pts);    if (!frame_meta) {        return SDL_FALSE;    }    // append to the list    // (iterate to find the last item, in practice the list should be tiny)    struct frame_meta **p = &state->frame_meta_queue;    while (*p) {        p = &(*p)->next;    }    *p = frame_meta;    return SDL_TRUE;}
static int read_packet_with_meta(void *opaque, uint8_t *buf, int buf_size) {    struct stream *stream = opaque;    struct receiver_state *state = &stream->receiver_state;    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    if (!state->remaining) {#define HEADER_SIZE 12        uint8_t header[HEADER_SIZE];        ssize_t r = net_recv_all(stream->socket, header, HEADER_SIZE);        if (r == -1) {            return AVERROR(errno);        }        if (r == 0) {            return AVERROR_EOF;        }        // no partial read (net_recv_all())        SDL_assert_release(r == HEADER_SIZE);        Uint64 pts = buffer_read64be(header);        state->remaining = buffer_read32be(&header[8]);        if (pts != NO_PTS && !receiver_state_push_meta(state, pts)) {            LOGE("Could not store PTS for recording");            // we cannot save the PTS, the recording would be broken            return AVERROR(ENOMEM);        }    }    SDL_assert(state->remaining);    if (buf_size > state->remaining) {        buf_size = state->remaining;    }    ssize_t r = net_recv(stream->socket, buf, buf_size);    if (r == -1) {        return AVERROR(errno);    }    if (r == 0) {        return AVERROR_EOF;    }    SDL_assert(state->remaining >= r);    state->remaining -= r;    return r;}
    private void initPointer() {        MotionEvent.PointerProperties props = pointerProperties[0];        props.id = 0;        props.toolType = MotionEvent.TOOL_TYPE_FINGER;        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.orientation = 0;        coords.pressure = 1;        coords.size = 1;        coords.toolMajor = 1;        coords.toolMinor = 1;        coords.touchMajor = 1;        coords.touchMinor = 1;    }
    private void initPointer() {        MotionEvent.PointerProperties props = pointerProperties[0];        props.id = 0;        props.toolType = MotionEvent.TOOL_TYPE_FINGER;        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.orientation = 0;        coords.pressure = 1;        coords.size = 1;    }    private void setPointerCoords(Point point) {        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.x = point.x;        coords.y = point.y;
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    // capture all Ctrl events    if (ctrl) {        SDL_bool repeat = event->repeat;        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        SDL_Keycode keycode = event->keysym.sym;        switch (keycode) {            case SDLK_h:                action_home(input_manager->controller);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(input_manager->controller);                return;            case SDLK_s:                action_app_switch(input_manager->controller);                return;            case SDLK_m:                action_menu(input_manager->controller);                return;            case SDLK_p:                action_power(input_manager->controller);                return;            case SDLK_v:                clipboard_paste(input_manager->controller);                return;            case SDLK_f:                screen_switch_fullscreen(input_manager->screen);                return;            case SDLK_x:                screen_resize_to_fit(input_manager->screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(input_manager->screen);                return;            case SDLK_i:                switch_fps_counter_state(input_manager->frames);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
static SDL_bool is_ctrl_down(void) {    const Uint8 *state = SDL_GetKeyboardState(NULL);    return state[SDL_SCANCODE_LCTRL] || state[SDL_SCANCODE_RCTRL];}
void input_manager_process_text_input(struct input_manager *input_manager,                                      const SDL_TextInputEvent *event) {    if (is_ctrl_down()) {        switch (event->text[0]) {            case '+':                action_volume_up(input_manager->controller);                break;            case '-':                action_volume_down(input_manager->controller);                break;        }        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    control_event.text_event.text = SDL_strdup(event->text);    if (!control_event.text_event.text) {        LOGW("Cannot strdup input text");        return;    }    if (!controller_push_event(input_manager->controller, &control_event)) {        LOGW("Cannot send text event");    }}
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    // capture all Ctrl events    if (ctrl) {        SDL_bool repeat = event->repeat;        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        SDL_Keycode keycode = event->keysym.sym;        switch (keycode) {            case SDLK_h:                action_home(input_manager->controller);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(input_manager->controller);                return;            case SDLK_s:                action_app_switch(input_manager->controller);                return;            case SDLK_m:                action_menu(input_manager->controller);                return;            case SDLK_p:                action_power(input_manager->controller);                return;            case SDLK_DOWN:                action_volume_down(input_manager->controller);                return;            case SDLK_UP:                action_volume_up(input_manager->controller);                return;            case SDLK_v:                clipboard_paste(input_manager->controller);                return;            case SDLK_f:                screen_switch_fullscreen(input_manager->screen);                return;            case SDLK_x:                screen_resize_to_fit(input_manager->screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(input_manager->screen);                return;            case SDLK_i:                switch_fps_counter_state(input_manager->frames);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
static void send_keycode(struct controller *controller, enum android_keycode keycode, const char *name) {    // send DOWN event    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_KEYCODE;    control_event.keycode_event.action = AKEY_EVENT_ACTION_DOWN;
    if (!control_event.text_event.text) {        LOGW("Cannot strdup input text");        return;    }    if (!controller_push_event(input_manager->controller, &control_event)) {        LOGW("Cannot send text event");    }}void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    // capture all Ctrl events    if (ctrl) {        SDL_bool repeat = event->repeat;        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        if (shift) {            // currently, there is no shortcut implying SHIFT            return;
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+'+'\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+'-'\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
    private ScreenInfo computeScreenInfo(int maxSize) {        // Compute the video size and the padding of the content inside this video.        // Principle:        // - scale down the great side of the screen to maxSize (if necessary);        // - scale down the other side so that the aspect ratio is preserved;        // - round this value to the nearest multiple of 8 (H.264 only accepts multiples of 8)        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        int w = deviceSize.getWidth();        int h = deviceSize.getHeight();        if (maxSize > 0) {            if (BuildConfig.DEBUG && maxSize % 8 != 0) {                throw new AssertionError("Max size must be a multiple of 8");            }            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;            if (major > maxSize) {                int minorExact = minor * maxSize / major;                // +4 to round the value to the nearest multiple of 8                minor = (minorExact + 4) & ~7;                major = maxSize;            }            w = portrait ? minor : major;            h = portrait ? major : minor;        }        Size videoSize = new Size(w, h);        return new ScreenInfo(deviceSize, videoSize, rotated);    }
    private ScreenInfo computeScreenInfo(int maxSize) {        // Compute the video size and the padding of the content inside this video.        // Principle:        // - scale down the great side of the screen to maxSize (if necessary);        // - scale down the other side so that the aspect ratio is preserved;        // - round this value to the nearest multiple of 8 (H.264 only accepts multiples of 8)        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        int w = deviceSize.getWidth() & ~7; // in case it's not a multiple of 8        int h = deviceSize.getHeight() & ~7;        if (maxSize > 0) {            if (BuildConfig.DEBUG && maxSize % 8 != 0) {                throw new AssertionError("Max size must be a multiple of 8");            }            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;            if (major > maxSize) {                int minorExact = minor * maxSize / major;                // +4 to round the value to the nearest multiple of 8                minor = (minorExact + 4) & ~7;                major = maxSize;            }            w = portrait ? minor : major;            h = portrait ? major : minor;        }        Size videoSize = new Size(w, h);        return new ScreenInfo(deviceSize, videoSize, rotated);    }
    private ControlEvent parseTextControlEvent() {        if (buffer.remaining() < 1) {            return null;        }        int len = toUnsigned(buffer.getShort());        if (buffer.remaining() < len) {            return null;        }        buffer.get(textBuffer, 0, len);        String text = new String(textBuffer, 0, len, StandardCharsets.UTF_8);        return ControlEvent.createTextControlEvent(text);    }
    private ControlEvent parseTextControlEvent() {        if (buffer.remaining() < 2) {            return null;        }        int len = toUnsigned(buffer.getShort());        if (buffer.remaining() < len) {            return null;        }        buffer.get(textBuffer, 0, len);        String text = new String(textBuffer, 0, len, StandardCharsets.UTF_8);        return ControlEvent.createTextControlEvent(text);    }
    public ScreenEncoder() {        this(DEFAULT_BIT_RATE, DEFAULT_FRAME_RATE, DEFAULT_I_FRAME_INTERVAL);    }
    public void onRotationChanged(int rotation) {        rotationChanged.set(true);    }
    public void control() throws IOException {        // on start, turn screen on        turnScreenOn();        while (true) {            handleEvent();        }    }
    public void control() throws IOException {        // on start, turn screen on        turnScreenOn();        while (true) {            handleEvent();        }    }
    private boolean turnScreenOn() {        return device.isScreenOn() || injectKeycode(KeyEvent.KEYCODE_POWER);    }
    public void control() throws IOException {        // on start, power on the device        powerOn();        while (true) {            handleEvent();        }    }
    private boolean powerOn() {        return device.isScreenOn() || injectKeycode(KeyEvent.KEYCODE_POWER);    }
    private boolean powerOn() {        return device.isScreenOn() || injectKeycode(KeyEvent.KEYCODE_POWER);    }
SDL_bool screen_init_rendering(struct screen *screen, const char *device_name, struct size frame_size) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height, SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1, SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width, frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    screen->texture = SDL_CreateTexture(screen->renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                                        frame_size.width, frame_size.height);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    screen_render(screen);    return SDL_TRUE;}
SDL_bool screen_init_rendering(struct screen *screen, const char *device_name, struct size frame_size) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height, SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1, SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width, frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    screen->texture = SDL_CreateTexture(screen->renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                                        frame_size.width, frame_size.height);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    return SDL_TRUE;}void screen_show_window(struct screen *screen) {
    public int getRotation() {        try {            Class<?> cls = manager.getClass();            try {                return (Integer) cls.getMethod("getRotation").invoke(manager);            } catch (NoSuchMethodException e) {                // method changed since this commit:                // https://android.googlesource.com/platform/frameworks/base/+/8ee7285128c3843401d4c4d0412cd66e86ba49e3%5E%21/#F2                return (Integer) cls.getMethod("getDefaultDisplayRotation").invoke(manager);            }        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public void registerRotationWatcher(IRotationWatcher rotationWatcher) {        try {            Class<?> cls = manager.getClass();            try {                cls.getMethod("watchRotation", IRotationWatcher.class).invoke(manager, rotationWatcher);            } catch (NoSuchMethodException e) {                // display parameter added since this commit:                // https://android.googlesource.com/platform/frameworks/base/+/35fa3c26adcb5f6577849fd0df5228b1f67cf2c6%5E%21/#F1                cls.getMethod("watchRotation", IRotationWatcher.class, int.class).invoke(manager, rotationWatcher, 0);            }        } catch (Exception e) {            throw new AssertionError(e);        }    }}
    public int getRotation() {        try {            Class<?> cls = manager.getClass();            try {                // method changed since this commit:                // https://android.googlesource.com/platform/frameworks/base/+/8ee7285128c3843401d4c4d0412cd66e86ba49e3%5E%21/#F2                return (Integer) cls.getMethod("getDefaultDisplayRotation").invoke(manager);            } catch (NoSuchMethodException e) {                // old version                return (Integer) cls.getMethod("getRotation").invoke(manager);            }        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public void registerRotationWatcher(IRotationWatcher rotationWatcher) {        try {            Class<?> cls = manager.getClass();            try {                // display parameter added since this commit:                // https://android.googlesource.com/platform/frameworks/base/+/35fa3c26adcb5f6577849fd0df5228b1f67cf2c6%5E%21/#F1                cls.getMethod("watchRotation", IRotationWatcher.class, int.class).invoke(manager, rotationWatcher, 0);            } catch (NoSuchMethodException e) {                // old version                cls.getMethod("watchRotation", IRotationWatcher.class).invoke(manager, rotationWatcher);            }        } catch (Exception e) {            throw new AssertionError(e);        }    }}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = true;    bool display = !options->no_display;    bool control = !options->no_control;    if (!sdl_init_and_configure(display)) {        ret = false;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = false;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = false;        goto finally_destroy_server;    }    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            server_stop(&server);            ret = false;            goto finally_destroy_server;        }        if (control && !file_handler_init(&file_handler, server.serial)) {            ret = false;            server_stop(&server);            goto finally_destroy_video_buffer;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = false;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        ret = false;        server_stop(&server);        goto finally_destroy_recorder;    }    if (display) {        if (control) {            if (!controller_init(&controller, device_socket)) {                ret = false;                goto finally_stop_stream;            }            if (!controller_start(&controller)) {                ret = false;                goto finally_destroy_controller;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            ret = false;            goto finally_stop_and_join_controller;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(display, control);    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    if (display && control) {        controller_stop(&controller);        controller_join(&controller);    }finally_destroy_controller:    if (display && control) {        controller_destroy(&controller);    }finally_stop_stream:    stream_stop(&stream);    // stop the server before stream_join() to wake up the stream    server_stop(&server);    stream_join(&stream);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    if (display && control) {        file_handler_stop(&file_handler);        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }finally_destroy_video_buffer:    if (display) {        video_buffer_destroy(&video_buffer);    }finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial,                                                     false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = true;    bool display = !options->no_display;    bool control = !options->no_control;    if (!sdl_init_and_configure(display)) {        ret = false;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = false;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = false;        goto finally_destroy_server;    }    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            server_stop(&server);            ret = false;            goto finally_destroy_server;        }        if (control && !file_handler_init(&file_handler, server.serial)) {            ret = false;            server_stop(&server);            goto finally_destroy_video_buffer;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = false;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        ret = false;        server_stop(&server);        goto finally_destroy_recorder;    }    if (display) {        if (control) {            if (!controller_init(&controller, device_socket)) {                ret = false;                goto finally_stop_stream;            }            if (!controller_start(&controller)) {                ret = false;                goto finally_destroy_controller;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            ret = false;            goto finally_stop_and_join_controller;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(display, control);    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    if (display && control) {        controller_stop(&controller);        controller_join(&controller);    }finally_destroy_controller:    if (display && control) {        controller_destroy(&controller);    }finally_stop_stream:    stream_stop(&stream);    // stop the server before stream_join() to wake up the stream    server_stop(&server);    stream_join(&stream);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    if (display && control) {        file_handler_stop(&file_handler);        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }finally_destroy_video_buffer:    if (display) {        video_buffer_destroy(&video_buffer);    }finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
    public static IBinder getBuiltInDisplay(int builtInDisplayId) {        try {            return (IBinder) CLASS.getMethod("getBuiltInDisplay", int.class).invoke(null, builtInDisplayId);        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public static IBinder getBuiltInDisplay(int builtInDisplayId) {        try {            // Android Q does not have this method anymore but has a            // replacement.            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                return (IBinder) CLASS.getMethod("getBuiltInDisplay", int.class).invoke(null, builtInDisplayId);            } else {                return (IBinder) CLASS.getMethod("getPhysicalDisplayToken", long.class).invoke(null, builtInDisplayId);            }        } catch (Exception e) {            throw new AssertionError(e);        }    }
sdl_init_and_configure(bool display) {    uint32_t flags = display ? SDL_INIT_VIDEO : SDL_INIT_EVENTS;    if (SDL_Init(flags)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return false;    }    atexit(SDL_Quit);    if (!display) {        return true;    }    // Use the best available scale quality    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "2")) {        LOGW("Could not enable bilinear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif#ifdef SCRCPY_SDL_HAS_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR    // Disable compositor bypassing on X11    if (!SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, "0")) {        LOGW("Could not disable X11 compositor bypass");    }#endif    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return true;}
sdl_init_and_configure(bool display) {    uint32_t flags = display ? SDL_INIT_VIDEO : SDL_INIT_EVENTS;    if (SDL_Init(flags)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return false;    }    atexit(SDL_Quit);    if (!display) {        return true;    }    // Use the best available scale quality    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "2")) {        LOGW("Could not enable bilinear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif#ifdef SCRCPY_SDL_HAS_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR    // Disable compositor bypassing on X11    if (!SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, "0")) {        LOGW("Could not disable X11 compositor bypass");    }#endif    // Do not minimize on focus loss    if (!SDL_SetHint(SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS, "0")) {        LOGW("Could not disable minimize on focus loss");    }    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return true;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .record_format = 0,        .help = false,        .version = false,        .show_touches = false,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = false,        .no_control = false,        .no_display = false,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,        .no_control = args.no_control,        .no_display = args.no_display,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .record_format = 0,        .help = false,        .version = false,        .show_touches = false,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = false,        .no_control = false,        .no_display = false,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,        .control = !args.no_control,        .display = !args.no_display,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    bool display = !options->no_display;    bool control = !options->no_control;    if (!sdl_init_and_configure(display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            goto end;        }        video_buffer_initialized = true;        if (control) {            if (!file_handler_init(&file_handler, server.serial)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (display) {        if (control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            if (!controller_start(&controller)) {                goto end;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(display, control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!video_buffer_init(&video_buffer)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            if (!controller_start(&controller)) {                goto end;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
get_server_path(void) {    const char *server_path_env = getenv("SCRCPY_SERVER_PATH");    if (server_path_env) {        LOGD("Using SCRCPY_SERVER_PATH: %s", server_path_env);        // if the envvar is set, use it        return server_path_env;    }#ifndef PORTABLE    LOGD("Using server: " DEFAULT_SERVER_PATH);    // the absolute path is hardcoded    return DEFAULT_SERVER_PATH;#else    // use scrcpy-server.jar in the same directory as the executable    char *executable_path = get_executable_path();    if (!executable_path) {        LOGE("Could not get executable path, "             "using " SERVER_FILENAME " from current directory");        // not found, use current directory        return SERVER_FILENAME;    }    char *dir = dirname(executable_path);    size_t dirlen = strlen(dir);    // sizeof(SERVER_FILENAME) gives statically the size including the null byte    size_t len = dirlen + 1 + sizeof(SERVER_FILENAME);    char *server_path = SDL_malloc(len);    if (!server_path) {        LOGE("Could not alloc server path string, "             "using " SERVER_FILENAME " from current directory");        SDL_free(executable_path);        return SERVER_FILENAME;    }    memcpy(server_path, dir, dirlen);    server_path[dirlen] = PATH_SEPARATOR;    memcpy(&server_path[dirlen + 1], SERVER_FILENAME, sizeof(SERVER_FILENAME));    // the final null byte has been copied with SERVER_FILENAME    SDL_free(executable_path);    LOGD("Using server (portable): %s", server_path);    return server_path;#endif}
get_server_path(void) {    const char *server_path_env = getenv("SCRCPY_SERVER_PATH");    if (server_path_env) {        LOGD("Using SCRCPY_SERVER_PATH: %s", server_path_env);        // if the envvar is set, use it        return server_path_env;    }#ifndef PORTABLE    LOGD("Using server: " DEFAULT_SERVER_PATH);    // the absolute path is hardcoded    return DEFAULT_SERVER_PATH;#else    // use scrcpy-server in the same directory as the executable    char *executable_path = get_executable_path();    if (!executable_path) {        LOGE("Could not get executable path, "             "using " SERVER_FILENAME " from current directory");        // not found, use current directory        return SERVER_FILENAME;    }    char *dir = dirname(executable_path);    size_t dirlen = strlen(dir);    // sizeof(SERVER_FILENAME) gives statically the size including the null byte    size_t len = dirlen + 1 + sizeof(SERVER_FILENAME);    char *server_path = SDL_malloc(len);    if (!server_path) {        LOGE("Could not alloc server path string, "             "using " SERVER_FILENAME " from current directory");        SDL_free(executable_path);        return SERVER_FILENAME;    }    memcpy(server_path, dir, dirlen);    server_path[dirlen] = PATH_SEPARATOR;    memcpy(&server_path[dirlen + 1], SERVER_FILENAME, sizeof(SERVER_FILENAME));    // the final null byte has been copied with SERVER_FILENAME    SDL_free(executable_path);    LOGD("Using server (portable): %s", server_path);    return server_path;#endif}
    private boolean streamScreenOnce() throws IOException {        Process process = startScreenRecord();        setCurrentProcess(process);        InputStream inputStream = process.getInputStream();        int r;        while ((r = inputStream.read(buffer)) != -1 && !stopped.get()) {            connection.sendVideoStream(buffer, r);        }        return r != -1;    }
    private boolean streamScreenOnce() throws IOException {        Ln.d("Recording...");        Process process = startScreenRecord();        setCurrentProcess(process);        InputStream inputStream = process.getInputStream();        int r;        while ((r = inputStream.read(buffer)) != -1 && !stopped.get()) {            connection.sendVideoStream(buffer, r);        }        return r != -1;    }
    }    public static void e(String message, Throwable throwable) {        Log.e(TAG, message, throwable);
    public static void e(String message, Throwable throwable) {        Log.e(TAG, message, throwable);        System.out.println("ERROR: " + message);        throwable.printStackTrace();    }}
    public static void i(String message) {        Log.i(TAG, message);        System.out.println("INFO: " + message);    }
    public static void d(String message) {        Log.d(TAG, message);        System.out.println("DEBUG: " + message);    }
    public static void w(String message) {        Log.w(TAG, message);        System.out.println("WARN: " + message);    }
    public static boolean isEnabled(Level level) {        return level.ordinal() >= THRESHOLD.ordinal();    }
    public static void e(String message, Throwable throwable) {        if (isEnabled(Level.ERROR)) {            Log.e(TAG, message, throwable);            System.out.println("ERROR: " + message);            throwable.printStackTrace();        }    }}
    public static void i(String message) {        if (isEnabled(Level.INFO)) {            Log.i(TAG, message);            System.out.println("INFO: " + message);        }    }
    public static void d(String message) {        if (isEnabled(Level.DEBUG)) {            Log.d(TAG, message);            System.out.println("DEBUG: " + message);        }    }
    public static void w(String message) {        if (isEnabled(Level.WARN)) {            Log.w(TAG, message);            System.out.println("WARN: " + message);        }    }
read_packet_with_meta(void *opaque, uint8_t *buf, int buf_size) {    struct stream *stream = opaque;    struct receiver_state *state = &stream->receiver_state;    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    if (!state->remaining) {#define HEADER_SIZE 12        uint8_t header[HEADER_SIZE];        ssize_t r = net_recv_all(stream->socket, header, HEADER_SIZE);        if (r == -1) {            return AVERROR(errno);        }        if (r == 0) {            return AVERROR_EOF;        }        // no partial read (net_recv_all())        SDL_assert_release(r == HEADER_SIZE);        uint64_t pts = buffer_read64be(header);        state->remaining = buffer_read32be(&header[8]);        if (pts != NO_PTS && !receiver_state_push_meta(state, pts)) {            LOGE("Could not store PTS for recording");            // we cannot save the PTS, the recording would be broken            return AVERROR(ENOMEM);        }    }    SDL_assert(state->remaining);    if (buf_size > state->remaining) {        buf_size = state->remaining;    }    ssize_t r = net_recv(stream->socket, buf, buf_size);    if (r == -1) {        return AVERROR(errno);    }    if (r == 0) {        return AVERROR_EOF;    }    SDL_assert(state->remaining >= r);    state->remaining -= r;    return r;}
read_raw_packet(void *opaque, uint8_t *buf, int buf_size) {    struct stream *stream = opaque;    ssize_t r = net_recv(stream->socket, buf, buf_size);    if (r == -1) {        return AVERROR(errno);    }    if (r == 0) {        return AVERROR_EOF;    }    return r;}
read_packet_with_meta(void *opaque, uint8_t *buf, int buf_size) {    struct stream *stream = opaque;    struct receiver_state *state = &stream->receiver_state;    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    if (!state->remaining) {#define HEADER_SIZE 12        uint8_t header[HEADER_SIZE];        ssize_t r = net_recv_all(stream->socket, header, HEADER_SIZE);        if (r == -1) {            return AVERROR(errno);        }        if (r == 0) {            return AVERROR_EOF;        }        // no partial read (net_recv_all())        SDL_assert_release(r == HEADER_SIZE);        uint64_t pts = buffer_read64be(header);        state->remaining = buffer_read32be(&header[8]);        if (pts != NO_PTS && !receiver_state_push_meta(state, pts)) {            LOGE("Could not store PTS for recording");            // we cannot save the PTS, the recording would be broken            return AVERROR(ENOMEM);        }    }    SDL_assert(state->remaining);    if (buf_size > state->remaining) {        buf_size = state->remaining;    }    ssize_t r = net_recv(stream->socket, buf, buf_size);    if (r == -1) {        return errno ? AVERROR(errno) : AVERROR_EOF;    }    if (r == 0) {        return AVERROR_EOF;    }    SDL_assert(state->remaining >= r);    state->remaining -= r;    return r;}
read_raw_packet(void *opaque, uint8_t *buf, int buf_size) {    struct stream *stream = opaque;    ssize_t r = net_recv(stream->socket, buf, buf_size);    if (r == -1) {        return errno ? AVERROR(errno) : AVERROR_EOF;    }    if (r == 0) {        return AVERROR_EOF;    }    return r;}
control_msg_serialize(const struct control_msg *msg, unsigned char *buf) {    buf[0] = msg->type;    switch (msg->type) {        case CONTROL_MSG_TYPE_INJECT_KEYCODE:            buf[1] = msg->inject_keycode.action;            buffer_write32be(&buf[2], msg->inject_keycode.keycode);            buffer_write32be(&buf[6], msg->inject_keycode.metastate);            return 10;        case CONTROL_MSG_TYPE_INJECT_TEXT: {            size_t len = write_string(msg->inject_text.text,                                      CONTROL_MSG_TEXT_MAX_LENGTH, &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_INJECT_MOUSE_EVENT:            buf[1] = msg->inject_mouse_event.action;            buffer_write32be(&buf[2], msg->inject_mouse_event.buttons);            write_position(&buf[6], &msg->inject_mouse_event.position);            return 18;        case CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT:            write_position(&buf[1], &msg->inject_scroll_event.position);            buffer_write32be(&buf[13],                             (uint32_t) msg->inject_scroll_event.hscroll);            buffer_write32be(&buf[17],                             (uint32_t) msg->inject_scroll_event.vscroll);            return 21;        case CONTROL_MSG_TYPE_SET_CLIPBOARD: {            size_t len = write_string(msg->inject_text.text,                                      CONTROL_MSG_CLIPBOARD_TEXT_MAX_LENGTH,                                      &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_GET_CLIPBOARD:            // no additional data            return 1;        default:            LOGW("Unknown message type: %u", (unsigned) msg->type);            return 0;    }}
control_msg_serialize(const struct control_msg *msg, unsigned char *buf) {    buf[0] = msg->type;    switch (msg->type) {        case CONTROL_MSG_TYPE_INJECT_KEYCODE:            buf[1] = msg->inject_keycode.action;            buffer_write32be(&buf[2], msg->inject_keycode.keycode);            buffer_write32be(&buf[6], msg->inject_keycode.metastate);            return 10;        case CONTROL_MSG_TYPE_INJECT_TEXT: {            size_t len = write_string(msg->inject_text.text,                                      CONTROL_MSG_TEXT_MAX_LENGTH, &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_INJECT_MOUSE_EVENT:            buf[1] = msg->inject_mouse_event.action;            buffer_write32be(&buf[2], msg->inject_mouse_event.buttons);            write_position(&buf[6], &msg->inject_mouse_event.position);            return 18;        case CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT:            write_position(&buf[1], &msg->inject_scroll_event.position);            buffer_write32be(&buf[13],                             (uint32_t) msg->inject_scroll_event.hscroll);            buffer_write32be(&buf[17],                             (uint32_t) msg->inject_scroll_event.vscroll);            return 21;        case CONTROL_MSG_TYPE_SET_CLIPBOARD: {            size_t len = write_string(msg->inject_text.text,                                      CONTROL_MSG_CLIPBOARD_TEXT_MAX_LENGTH,                                      &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE:            buf[1] = msg->set_screen_power_mode.mode;            return 2;        case CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_GET_CLIPBOARD:            // no additional data            return 1;        default:            LOGW("Unknown message type: %u", (unsigned) msg->type);            return 0;    }}
    SDL_GetMouseState(&x, &y);    convert_to_renderer_coordinates(screen->renderer, &x, &y);    return (struct point) {        .x = x,        .y = y,    };}static const int ACTION_DOWN = 1;static const int ACTION_UP = 1 << 1;static voidsend_keycode(struct controller *controller, enum android_keycode keycode,             int actions, const char *name) {    // send DOWN event    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_KEYCODE;    msg.inject_keycode.keycode = keycode;    msg.inject_keycode.metastate = 0;    if (actions & ACTION_DOWN) {        msg.inject_keycode.action = AKEY_EVENT_ACTION_DOWN;        if (!controller_push_msg(controller, &msg)) {            LOGW("Cannot request 'inject %s (DOWN)'", name);            return;        }    }    if (actions & ACTION_UP) {        msg.inject_keycode.action = AKEY_EVENT_ACTION_UP;        if (!controller_push_msg(controller, &msg)) {            LOGW("Cannot request 'inject %s (UP)'", name);        }    }}static inline voidaction_home(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_HOME, actions, "HOME");}static inline voidaction_back(struct controller *controller, int actions) {
set_screen_power_mode(struct controller *controller,                      enum screen_power_mode mode) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;    msg.set_screen_power_mode.mode = mode;    if (!controller_push_msg(controller, &msg)) {        LOGW("Cannot request 'set screen power mode'");    }}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+c\n"        "        copy device clipboard to computer\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    Ctrl+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    Ctrl+Shift+o\n"        "        turn device screen on\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+c\n"        "        copy device clipboard to computer\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
int main(void) {    test_serialize_inject_keycode();    test_serialize_inject_text();    test_serialize_inject_text_long();    test_serialize_inject_mouse_event();    test_serialize_inject_scroll_event();    test_serialize_back_or_screen_on();    test_serialize_expand_notification_panel();    test_serialize_collapse_notification_panel();    test_serialize_get_clipboard();    test_serialize_set_clipboard();    return 0;}
int main(void) {    test_serialize_inject_keycode();    test_serialize_inject_text();    test_serialize_inject_text_long();    test_serialize_inject_mouse_event();    test_serialize_inject_scroll_event();    test_serialize_back_or_screen_on();    test_serialize_expand_notification_panel();    test_serialize_collapse_notification_panel();    test_serialize_get_clipboard();    test_serialize_set_clipboard();    return 0;}
int main(void) {    test_serialize_inject_keycode();    test_serialize_inject_text();    test_serialize_inject_text_long();    test_serialize_inject_mouse_event();    test_serialize_inject_scroll_event();    test_serialize_back_or_screen_on();    test_serialize_expand_notification_panel();    test_serialize_collapse_notification_panel();    test_serialize_get_clipboard();    test_serialize_set_clipboard();    test_serialize_set_screen_power_mode();    return 0;}
static void test_serialize_set_screen_power_mode(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE,        .set_screen_power_mode = {            .mode = SCREEN_POWER_MODE_NORMAL,        },    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 2);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE,        0x02, // SCREEN_POWER_MODE_NORMAL    };    assert(!memcmp(buf, expected, sizeof(expected)));}
    public ControlMessage next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        ControlMessage msg;        switch (type) {            case ControlMessage.TYPE_INJECT_KEYCODE:                msg = parseInjectKeycode();                break;            case ControlMessage.TYPE_INJECT_TEXT:                msg = parseInjectText();                break;            case ControlMessage.TYPE_INJECT_MOUSE_EVENT:                msg = parseInjectMouseEvent();                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                msg = parseInjectScrollEvent();                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                msg = parseSetClipboard();                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:            case ControlMessage.TYPE_GET_CLIPBOARD:                msg = ControlMessage.createEmpty(type);                break;            default:                Ln.w("Unknown event type: " + type);                msg = null;                break;        }        if (msg == null) {            // failure, reset savedPosition            buffer.position(savedPosition);        }        return msg;    }
    public ControlMessage next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        ControlMessage msg;        switch (type) {            case ControlMessage.TYPE_INJECT_KEYCODE:                msg = parseInjectKeycode();                break;            case ControlMessage.TYPE_INJECT_TEXT:                msg = parseInjectText();                break;            case ControlMessage.TYPE_INJECT_MOUSE_EVENT:                msg = parseInjectMouseEvent();                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                msg = parseInjectScrollEvent();                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                msg = parseSetClipboard();                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                msg = parseSetScreenPowerMode();                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:            case ControlMessage.TYPE_GET_CLIPBOARD:                msg = ControlMessage.createEmpty(type);                break;            default:                Ln.w("Unknown event type: " + type);                msg = null;                break;        }        if (msg == null) {            // failure, reset savedPosition            buffer.position(savedPosition);        }        return msg;    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                break;            case ControlMessage.TYPE_INJECT_TEXT:                injectText(msg.getText());                break;            case ControlMessage.TYPE_INJECT_MOUSE_EVENT:                injectMouse(msg.getAction(), msg.getButtons(), msg.getPosition());                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                pressBackOrTurnScreenOn();                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                device.setClipboardText(msg.getText());                break;            default:                // do nothing        }    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                break;            case ControlMessage.TYPE_INJECT_TEXT:                injectText(msg.getText());                break;            case ControlMessage.TYPE_INJECT_MOUSE_EVENT:                injectMouse(msg.getAction(), msg.getButtons(), msg.getPosition());                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                pressBackOrTurnScreenOn();                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                device.setClipboardText(msg.getText());                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                device.setScreenPowerMode(msg.getAction());                break;            default:                // do nothing        }    }
    private static Size computeVideoSize(int w, int h, int maxSize) {        // Compute the video size and the padding of the content inside this video.        // Principle:        // - scale down the great side of the screen to maxSize (if necessary);        // - scale down the other side so that the aspect ratio is preserved;        // - round this value to the nearest multiple of 8 (H.264 only accepts multiples of 8)        w &= ~7; // in case it's not a multiple of 8        h &= ~7;        if (maxSize > 0) {            if (BuildConfig.DEBUG && maxSize % 8 != 0) {                throw new AssertionError("Max size must be a multiple of 8");            }            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;            if (major > maxSize) {                int minorExact = minor * maxSize / major;                // +4 to round the value to the nearest multiple of 8                minor = (minorExact + 4) & ~7;                major = maxSize;            }            w = portrait ? minor : major;            h = portrait ? major : minor;        }        return new Size(w, h);    }    public Point getPhysicalPoint(Position position) {        // it hides the field on purpose, to read it with a lock        @SuppressWarnings("checkstyle:HiddenField")        ScreenInfo screenInfo = getScreenInfo(); // read with synchronization        Size videoSize = screenInfo.getVideoSize();        Size clientVideoSize = position.getScreenSize();        if (!videoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event
    public void setScreenPowerMode(int mode) {        IBinder d = SurfaceControl.getBuiltInDisplay(0);        SurfaceControl.setDisplayPowerMode(d, mode);        Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));    }
        } catch (Exception e) {            throw new AssertionError(e);        }    }    public static void destroyDisplay(IBinder displayToken) {        try {            CLASS.getMethod("destroyDisplay", IBinder.class).invoke(null, displayToken);        } catch (Exception e) {            throw new AssertionError(e);        }    }}
        } catch (Exception e) {            throw new AssertionError(e);        }    }    public static void destroyDisplay(IBinder displayToken) {        try {            CLASS.getMethod("destroyDisplay", IBinder.class).invoke(null, displayToken);        } catch (Exception e) {            throw new AssertionError(e);        }    }}
    public static IBinder getBuiltInDisplay(int builtInDisplayId) {        try {            return (IBinder) CLASS.getMethod("getBuiltInDisplay", int.class).invoke(null, builtInDisplayId);        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public static void setDisplayPowerMode(IBinder displayToken, int mode) {        try {            CLASS.getMethod("setDisplayPowerMode", IBinder.class, int.class).invoke(null, displayToken, mode);        } catch (Exception e) {            throw new AssertionError(e);        }    }
        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_TEXT, event.getType());        Assert.assertEquals(new String(text, StandardCharsets.US_ASCII), event.getText());    }    @Test    public void testParseMouseEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }    @Test    @SuppressWarnings("checkstyle:MagicNumber")    public void testParseScrollEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();
    public void testParseSetScreenPowerMode() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_SET_SCREEN_POWER_MODE);        dos.writeByte(Device.POWER_MODE_NORMAL);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_SET_SCREEN_POWER_MODE, event.getType());        Assert.assertEquals(Device.POWER_MODE_NORMAL, event.getAction());    }
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options] [serial]\n"        "\n"        "    serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "Options:\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f: switch fullscreen mode\n"        "    Ctrl+g: resize window to 1:1 (pixel-perfect)\n"        "    Ctrl+x: resize window to optimal size (remove black borders)\n"        "\n",        arg0,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static int parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"help",     no_argument,       NULL, 'h'},        {"port",     required_argument, NULL, 'p'},        {"max-size", required_argument, NULL, 'm'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "hp:m:", long_options, NULL)) != -1) {        switch (c) {            case 'h': {                args->help = SDL_TRUE;                break;            }            case 'p': {                char *endptr;                if (*optarg == '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                if (*endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld", value);                    return -1;                }                args->port = (Uint16) value;                break;            }            case 'm': {                char *endptr;                if (*optarg == '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Max size parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                if (*endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid max size: %s", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Max size must be between 0 and 65535: %ld", value);                    return -1;                }                args->max_size = (Uint16) value;                break;            }            default:                // getopt prints the error message on stderr                return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s", argv[index]);        return -1;    }    return 0;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .help = SDL_FALSE,        .serial = NULL,        .max_size = DEFAULT_MAX_SIZE,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        usage(argv[0]);        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = scrcpy(args.serial, args.port, args.max_size) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options] [serial]\n"        "\n"        "    serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f: switch fullscreen mode\n"        "    Ctrl+g: resize window to 1:1 (pixel-perfect)\n"        "    Ctrl+x: resize window to optimal size (remove black borders)\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static int parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"help",     no_argument,       NULL, 'h'},        {"port",     required_argument, NULL, 'p'},        {"max-size", required_argument, NULL, 'm'},        {"bit-rate", required_argument, NULL, 'b'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "hp:m:b:", long_options, NULL)) != -1) {        switch (c) {            case 'h': {                args->help = SDL_TRUE;                break;            }            case 'p': {                char *endptr;                if (*optarg == '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                if (*endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld", value);                    return -1;                }                args->port = (Uint16) value;                break;            }            case 'm': {                char *endptr;                if (*optarg == '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Max size parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                if (*endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid max size: %s", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Max size must be between 0 and 65535: %ld", value);                    return -1;                }                args->max_size = (Uint16) value;                break;            }            case 'b': {                char *endptr;                if (*optarg == '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Bit-rate parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                int mul = 1;                if (*endptr != '\0') {                    if (optarg == endptr) {                        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid bit-rate: %s", optarg);                        return -1;                    }                    if ((*endptr == 'M' || *endptr == 'm') && endptr[1] == '\0') {                        mul = 1000000;                    } else if ((*endptr == 'K' || *endptr == 'k') && endptr[1] == '\0') {                        mul = 1000;                    } else {                        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid bit-rate unit: %s", optarg);                        return -1;                    }                }                if (value < 0 || ((Uint32) -1) / mul < value) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Bitrate must be positive and less than 2^32: %s", optarg);                    return -1;                }                args->bit_rate = (Uint32) value * mul;                break;            }            default:                // getopt prints the error message on stderr                return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s", argv[index]);        return -1;    }    return 0;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (parse_args(&args, argc, argv)) {        usage(argv[0]);        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = scrcpy(args.serial, args.port, args.max_size, args.bit_rate) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size) {    SDL_bool ret = 0;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, max_size);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size) {    SDL_bool ret = 0;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, max_size);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    SDL_bool ret = 0;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, max_size, bit_rate);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    SDL_bool ret = 0;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, max_size, bit_rate);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
process_t start_server(const char *serial, Uint16 max_size) {    char max_size_string[6];    sprintf(max_size_string, "%d", max_size);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy.apk",        "app_process",        "/", // unused        "com.genymobile.scrcpy.ScrCpyServer",        max_size_string,    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
process_t start_server(const char *serial, Uint16 max_size) {    char max_size_string[6];    sprintf(max_size_string, "%d", max_size);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy.apk",        "app_process",        "/", // unused        "com.genymobile.scrcpy.ScrCpyServer",        max_size_string,    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
process_t start_server(const char *serial, Uint16 max_size, Uint32 bit_rate) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy.apk",        "app_process",        "/", // unused        "com.genymobile.scrcpy.ScrCpyServer",        max_size_string,        bit_rate_string,    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
process_t start_server(const char *serial, Uint16 max_size, Uint32 bit_rate) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy.apk",        "app_process",        "/", // unused        "com.genymobile.scrcpy.ScrCpyServer",        max_size_string,        bit_rate_string,
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        try (DesktopConnection connection = DesktopConnection.open(device)) {            ScreenEncoder screenEncoder = new ScreenEncoder();            // asynchronous            startEventController(device, connection);            try {                // synchronous                screenEncoder.streamScreen(device, connection.getOutputStream());            } catch (IOException e) {                Ln.e("Screen streaming interrupted", e);            }        }    }
    private static Options createOptions(String... args) {        Options options = new Options();        if (args.length > 0) {            int maxSize = Integer.parseInt(args[0]) & ~7; // multiple of 8            options.setMaxSize(maxSize);        }        return options;    }
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        try (DesktopConnection connection = DesktopConnection.open(device)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getBitRate());            // asynchronous            startEventController(device, connection);            try {                // synchronous                screenEncoder.streamScreen(device, connection.getOutputStream());            } catch (IOException e) {                Ln.e("Screen streaming interrupted", e);            }        }    }
    private static Options createOptions(String... args) {        Options options = new Options();        if (args.length < 1) {            return options;        }        int maxSize = Integer.parseInt(args[0]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        if (args.length < 2) {            return options;        }        int bitRate = Integer.parseInt(args[1]);        options.setBitRate(bitRate);        return options;    }
    public ScreenEncoder() {        this(DEFAULT_BIT_RATE, DEFAULT_FRAME_RATE, DEFAULT_I_FRAME_INTERVAL);    }
    public ScreenEncoder(int bitRate) {        this(bitRate, DEFAULT_FRAME_RATE, DEFAULT_I_FRAME_INTERVAL);    }
uint64_t buffer_read64be(const uint8_t *buf) {    uint32_t msb = buffer_read32be(buf);    uint32_t lsb = buffer_read32be(&buf[4]);    return ((uint64_t) msb << 32) | lsb;}
buffer_read16be(const uint8_t *buf) {    return (buf[0] << 8) | buf[1];}
static SDL_bool read_initial_device_info(TCPsocket socket, char *device_name, struct size *size) {    unsigned char buf[DEVICE_NAME_FIELD_LENGTH + 4];    if (SDLNet_TCP_Recv(socket, buf, sizeof(buf)) <= 0) {        return SDL_FALSE;    }    buf[DEVICE_NAME_FIELD_LENGTH - 1] = '\0'; // in case the client sends garbage    // scrcpy is safe here, since name contains at least DEVICE_NAME_FIELD_LENGTH bytes    // and strlen(buf) < DEVICE_NAME_FIELD_LENGTH    strcpy(device_name, (char *) buf);    size->width = (buf[DEVICE_NAME_FIELD_LENGTH] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 1];    size->height = (buf[DEVICE_NAME_FIELD_LENGTH + 2] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 3];    return SDL_TRUE;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = server_connect_to(&server);    if (!device_socket) {        server_stop(&server, serial);        return SDL_FALSE;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        server_stop(&server, serial);        return SDL_FALSE;    }    if (!frames_init(&frames)) {        server_stop(&server, serial);        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    decoder.frames = &frames;    decoder.video_socket = device_socket;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server, serial);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    // kill the server before decoder_join() to wake up the decoder    server_stop(&server, serial);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);    return ret;}
    int y;    SDL_GetMouseState(&x, &y);    SDL_assert_release(x >= 0 && x < 0x10000 && y >= 0 && y < 0x10000);    return (struct point) {        .x = (Uint16) x,        .y = (Uint16) y,    };}static void send_keycode(enum android_keycode keycode, const char *name) {    // send DOWN event    struct control_event control_event = {        .type = CONTROL_EVENT_TYPE_KEYCODE,        .keycode_event = {
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = server_connect_to(&server);    if (!device_socket) {        server_stop(&server, serial);        return SDL_FALSE;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server, serial);        return SDL_FALSE;    }    if (!frames_init(&frames)) {        server_stop(&server, serial);        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    decoder.frames = &frames;    decoder.video_socket = device_socket;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server, serial);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    // kill the server before decoder_join() to wake up the decoder    server_stop(&server, serial);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);    return ret;}
        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s", argv[index]);        return -1;    }    return 0;}int main(int argc, char *argv[]) {    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (parse_args(&args, argc, argv)) {        usage(argv[0]);        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        fprintf(stderr, "scrcpy v%s\n", SCRCPY_VERSION);        return 0;    }
int main(int argc, char *argv[]) {    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (parse_args(&args, argc, argv)) {        usage(argv[0]);        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        fprintf(stderr, "scrcpy v%s\n", SCRCPY_VERSION);        return 0;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    int res = scrcpy(args.serial, args.port, args.max_size, args.bit_rate) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
static void print_version(void) {    fprintf(stderr, "scrcpy v%s\n\n", SCRCPY_VERSION);    fprintf(stderr, "dependencies:\n");    fprintf(stderr, " - SDL %d.%d.%d\n", SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL);    fprintf(stderr, " - SDL_net %d.%d.%d\n", SDL_NET_MAJOR_VERSION, SDL_NET_MINOR_VERSION, SDL_NET_PATCHLEVEL);    fprintf(stderr, " - libavcodec %d.%d.%d\n", LIBAVCODEC_VERSION_MAJOR, LIBAVCODEC_VERSION_MINOR, LIBAVCODEC_VERSION_MICRO);    fprintf(stderr, " - libavformat %d.%d.%d\n", LIBAVFORMAT_VERSION_MAJOR, LIBAVFORMAT_VERSION_MINOR, LIBAVFORMAT_VERSION_MICRO);    fprintf(stderr, " - libavutil %d.%d.%d\n", LIBAVUTIL_VERSION_MAJOR, LIBAVUTIL_VERSION_MINOR, LIBAVUTIL_VERSION_MICRO);}
int main(int argc, char *argv[]) {    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (parse_args(&args, argc, argv)) {        usage(argv[0]);        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    int res = scrcpy(args.serial, args.port, args.max_size, args.bit_rate) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
    public void collapsePanels() {        try {            collapsePanelsMethod.invoke(manager);        } catch (InvocationTargetException | IllegalAccessException e) {            throw new AssertionError(e);        }    }}
    public void expandNotificationsPanel() {        try {            expandNotificationsPanelMethod.invoke(manager);        } catch (InvocationTargetException | IllegalAccessException e) {            throw new AssertionError(e);        }    }
    public StatusBarManager(IInterface manager) {        this.manager = manager;        try {            expandNotificationsPanelMethod = manager.getClass().getMethod("expandNotificationsPanel");            collapsePanelsMethod = manager.getClass().getMethod("collapsePanels");        } catch (NoSuchMethodException e) {            throw new AssertionError(e);        }    }
    public void collapsePanels() {        if (collapsePanelsMethod == null) {            try {                collapsePanelsMethod = manager.getClass().getMethod("collapsePanels");            } catch (NoSuchMethodException e) {                Ln.e("ServiceBarManager.collapsePanels() is not available on this device");                return;            }        }        try {            collapsePanelsMethod.invoke(manager);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Cannot invoke ServiceBarManager.collapsePanels()", e);        }    }}
    public void expandNotificationsPanel() {        if (expandNotificationsPanelMethod == null) {            try {                expandNotificationsPanelMethod = manager.getClass().getMethod("expandNotificationsPanel");            } catch (NoSuchMethodException e) {                Ln.e("ServiceBarManager.expandNotificationsPanel() is not available on this device");                return;            }        }        try {            expandNotificationsPanelMethod.invoke(manager);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Cannot invoke ServiceBarManager.expandNotificationsPanel()", e);        }    }
    private Method collapsePanelsMethod;    public StatusBarManager(IInterface manager) {        this.manager = manager;    }    public void expandNotificationsPanel() {        if (expandNotificationsPanelMethod == null) {            try {                expandNotificationsPanelMethod = manager.getClass().getMethod("expandNotificationsPanel");
    public Point getPhysicalPoint(Position position) {        @SuppressWarnings("checkstyle:HiddenField") // it hides the field on purpose, to read it with a lock        ScreenInfo screenInfo = getScreenInfo(); // read with synchronization        Size videoSize = screenInfo.getVideoSize();        Size clientVideoSize = position.getScreenSize();        if (!videoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event            return null;        }        Size deviceSize = screenInfo.getDeviceSize();        Point point = position.getPoint();        int scaledX = point.x * deviceSize.getWidth() / videoSize.getWidth();        int scaledY = point.y * deviceSize.getHeight() / videoSize.getHeight();        return new Point(scaledX, scaledY);    }
    public Point getPhysicalPoint(Position position) {        // it hides the field on purpose, to read it with a lock        @SuppressWarnings("checkstyle:HiddenField")        ScreenInfo screenInfo = getScreenInfo(); // read with synchronization        Size videoSize = screenInfo.getVideoSize();        Size clientVideoSize = position.getScreenSize();        if (!videoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event            return null;        }        Size deviceSize = screenInfo.getDeviceSize();        Point point = position.getPoint();        int scaledX = point.x * deviceSize.getWidth() / videoSize.getWidth();        int scaledY = point.y * deviceSize.getHeight() / videoSize.getHeight();        return new Point(scaledX, scaledY);    }
    return SDL_TRUE;}socket_t server_connect_to(struct server *server, Uint32 timeout_ms) {    server->device_socket = net_accept(server->server_socket);    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    // we don't need the server socket anymore    close_socket(&server->server_socket);    // the server is started, we can clean up the jar from the temporary folder    remove_server(server->serial); // ignore failure    server->server_copied_to_device = SDL_FALSE;    // we don't need the adb tunnel anymore    disable_tunnel(server->serial); // ignore failure    server->adb_reverse_enabled = SDL_FALSE;
SDL_bool server_start(struct server *server, const char *serial, Uint16 local_port,                      Uint16 max_size, Uint32 bit_rate) {    if (serial) {        server->serial = SDL_strdup(serial);    }    if (!push_server(serial)) {        return SDL_FALSE;    }    server->server_copied_to_device = SDL_TRUE;    if (!enable_tunnel(serial, local_port)) {        return SDL_FALSE;    }    // At the application level, the device part is "the server" because it    // serves video stream and control. However, at the network level, the    // client listens and the server connects to the client. That way, the    // client can listen before starting the server app, so there is no need to    // try to connect until the server socket is listening on the device.    server->server_socket = listen_on_port(local_port);    if (server->server_socket == INVALID_SOCKET) {        LOGE("Could not listen on port %" PRIu16, local_port);        disable_tunnel(serial);        return SDL_FALSE;    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate);    if (server->process == PROCESS_NONE) {        close_socket(&server->server_socket);        disable_tunnel(serial);        return SDL_FALSE;    }    server->adb_reverse_enabled = SDL_TRUE;    return SDL_TRUE;}
SDL_bool server_start(struct server *server, const char *serial, Uint16 local_port,                      Uint16 max_size, Uint32 bit_rate) {    if (serial) {        server->serial = SDL_strdup(serial);    }    if (!push_server(serial)) {        return SDL_FALSE;    }    server->server_copied_to_device = SDL_TRUE;    if (!enable_tunnel(serial, local_port)) {        return SDL_FALSE;    }    // At the application level, the device part is "the server" because it    // serves video stream and control. However, at the network level, the    // client listens and the server connects to the client. That way, the    // client can listen before starting the server app, so there is no need to    // try to connect until the server socket is listening on the device.    server->server_socket = listen_on_port(local_port);    if (server->server_socket == INVALID_SOCKET) {        LOGE("Could not listen on port %" PRIu16, local_port);        disable_tunnel(serial);        return SDL_FALSE;    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate);    if (server->process == PROCESS_NONE) {        close_socket(&server->server_socket);        disable_tunnel(serial);        return SDL_FALSE;    }    server->adb_reverse_enabled = SDL_TRUE;    return SDL_TRUE;}
static SDL_bool enable_tunnel(const char *serial, Uint16 local_port) {    process_t process = adb_reverse(serial, SOCKET_NAME, local_port);    return process_check_success(process, "adb reverse");}
void server_stop(struct server *server) {    SDL_assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Cannot terminate server");    }    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->adb_reverse_enabled) {        // ignore failure        disable_tunnel(server->serial);    }    if (server->server_copied_to_device) {        remove_server(server->serial); // ignore failure    }}
static SDL_bool enable_tunnel(const char *serial, Uint16 local_port) {    process_t process = adb_reverse(serial, SOCKET_NAME, local_port);    return process_check_success(process, "adb reverse");}
static SDL_bool enable_tunnel(const char *serial, Uint16 local_port) {    process_t process = adb_reverse(serial, SOCKET_NAME, local_port);    return process_check_success(process, "adb reverse");}
static SDL_bool enable_tunnel(const char *serial, Uint16 local_port) {    process_t process = adb_reverse(serial, SOCKET_NAME, local_port);    return process_check_success(process, "adb reverse");}
static SDL_bool enable_tunnel(const char *serial, Uint16 local_port) {    process_t process = adb_reverse(serial, SOCKET_NAME, local_port);    return process_check_success(process, "adb reverse");}
static SDL_bool enable_tunnel(const char *serial, Uint16 local_port) {    process_t process = adb_reverse(serial, SOCKET_NAME, local_port);    return process_check_success(process, "adb reverse");}
static SDL_bool disable_tunnel(const char *serial) {    process_t process = adb_reverse_remove(serial, SOCKET_NAME);    return process_check_success(process, "adb reverse --remove");}
socket_t server_connect_to(struct server *server, Uint32 timeout_ms) {    server->device_socket = net_accept(server->server_socket);    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    // we don't need the server socket anymore    close_socket(&server->server_socket);    // the server is started, we can clean up the jar from the temporary folder    remove_server(server->serial); // ignore failure    server->server_copied_to_device = SDL_FALSE;    // we don't need the adb tunnel anymore    disable_tunnel(server->serial); // ignore failure    server->adb_reverse_enabled = SDL_FALSE;    return server->device_socket;}
static process_t execute_server(const char *serial, Uint16 max_size, Uint32 bit_rate) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
static process_t execute_server(const char *serial, Uint16 max_size, Uint32 bit_rate) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
static SDL_bool disable_tunnel(const char *serial) {    process_t process = adb_reverse_remove(serial, SOCKET_NAME);    return process_check_success(process, "adb reverse --remove");}
static socket_t listen_on_port(Uint16 port) {#define IPV4_LOCALHOST 0x7F000001    return net_listen(IPV4_LOCALHOST, port, 1);}
static socket_t connect_and_read_byte(Uint16 port) {    socket_t socket = net_connect(IPV4_LOCALHOST, port);    if (socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    char byte;    // the connection may succeed even if the server behind the "adb tunnel"    // is not listening, so read one byte to detect a working connection    if (net_recv_all(socket, &byte, 1) != 1) {        // the server is not listening yet behind the adb tunnel        return INVALID_SOCKET;    }    return socket;}
SDL_bool server_start(struct server *server, const char *serial, Uint16 local_port,                      Uint16 max_size, Uint32 bit_rate) {    server->local_port = local_port;    if (serial) {        server->serial = SDL_strdup(serial);    }    if (!push_server(serial)) {        return SDL_FALSE;    }    server->server_copied_to_device = SDL_TRUE;    if (!enable_tunnel(server)) {        return SDL_FALSE;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no need to        // try to connect until the server socket is listening on the device.        server->server_socket = listen_on_port(local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, local_port);            disable_tunnel(server);            return SDL_FALSE;        }    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate, server->tunnel_forward);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        return SDL_FALSE;    }    server->tunnel_enabled = SDL_TRUE;    return SDL_TRUE;}
static SDL_bool disable_tunnel_forward(const char *serial, Uint16 local_port) {    process_t process = adb_forward_remove(serial, local_port);    return process_check_success(process, "adb forward --remove");}
static SDL_bool enable_tunnel(struct server *server) {    if (enable_tunnel_reverse(server->serial, server->local_port)) {        return SDL_TRUE;    }    LOGW("'adb reverse' failed, fallback to 'adb forward'");    server->tunnel_forward = SDL_TRUE;    return enable_tunnel_forward(server->serial, server->local_port);}
void server_stop(struct server *server) {    SDL_assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Cannot terminate server");    }    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->tunnel_enabled) {        // ignore failure        disable_tunnel(server);    }    if (server->server_copied_to_device) {        remove_server(server->serial); // ignore failure    }}
static SDL_bool enable_tunnel_reverse(const char *serial, Uint16 local_port) {    process_t process = adb_reverse(serial, SOCKET_NAME, local_port);    return process_check_success(process, "adb reverse");}
static socket_t connect_to_server(Uint16 port, Uint32 attempts, Uint32 delay) {    do {        LOGD("Remaining connection attempts: %d", (int) attempts);        socket_t socket = connect_and_read_byte(port);        if (socket != INVALID_SOCKET) {            // it worked!            return socket;        }        if (attempts) {            SDL_Delay(delay);        }    } while (--attempts > 0);    return INVALID_SOCKET;}
static SDL_bool enable_tunnel_forward(const char *serial, Uint16 local_port) {    process_t process = adb_forward(serial, local_port, SOCKET_NAME);    return process_check_success(process, "adb forward");}
static SDL_bool disable_tunnel_reverse(const char *serial) {    process_t process = adb_reverse_remove(serial, SOCKET_NAME);    return process_check_success(process, "adb reverse --remove");}
static SDL_bool enable_tunnel_reverse(const char *serial, Uint16 local_port) {    process_t process = adb_reverse(serial, SOCKET_NAME, local_port);    return process_check_success(process, "adb reverse");}
static SDL_bool disable_tunnel_reverse(const char *serial) {    process_t process = adb_reverse_remove(serial, SOCKET_NAME);    return process_check_success(process, "adb reverse --remove");}
socket_t server_connect_to(struct server *server, Uint32 timeout_ms) {    if (!server->tunnel_forward) {        server->device_socket = net_accept(server->server_socket);    } else {        Uint32 attempts = 10;        Uint32 delay = 100; // ms        server->device_socket = connect_to_server(server->local_port, attempts, delay);    }    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    if (!server->tunnel_forward) {        // we don't need the server socket anymore        close_socket(&server->server_socket);    }    // the server is started, we can clean up the jar from the temporary folder    remove_server(server->serial); // ignore failure    server->server_copied_to_device = SDL_FALSE;    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = SDL_FALSE;    return server->device_socket;}
static SDL_bool enable_tunnel_forward(const char *serial, Uint16 local_port) {    process_t process = adb_forward(serial, local_port, SOCKET_NAME);    return process_check_success(process, "adb forward");}static SDL_bool disable_tunnel_forward(const char *serial, Uint16 local_port) {    process_t process = adb_forward_remove(serial, local_port);    return process_check_success(process, "adb forward --remove");}static SDL_bool enable_tunnel(struct server *server) {    if (enable_tunnel_reverse(server->serial, server->local_port)) {        return SDL_TRUE;    }    LOGW("'adb reverse' failed, fallback to 'adb forward'");
static process_t execute_server(const char *serial,                                Uint16 max_size, Uint32 bit_rate, SDL_bool tunnel_forward) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        tunnel_forward ? "true" : "false",    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
static SDL_bool disable_tunnel(struct server *server) {    if (server->tunnel_forward) {        return disable_tunnel_forward(server->serial, server->local_port);    }    return disable_tunnel_reverse(server->serial);}
static socket_t listen_on_port(Uint16 port) {    return net_listen(IPV4_LOCALHOST, port, 1);}
    public static DesktopConnection open(Device device) throws IOException {        LocalSocket socket = connect(SOCKET_NAME);        DesktopConnection connection = new DesktopConnection(socket);        Size videoSize = device.getScreenInfo().getVideoSize();        connection.send(Device.getDeviceName(), videoSize.getWidth(), videoSize.getHeight());        return connection;    }
    public static DesktopConnection open(Device device) throws IOException {        LocalSocket socket = connect(SOCKET_NAME);        DesktopConnection connection = new DesktopConnection(socket);        Size videoSize = device.getScreenInfo().getVideoSize();        connection.send(Device.getDeviceName(), videoSize.getWidth(), videoSize.getHeight());        return connection;    }
    public static DesktopConnection open(Device device) throws IOException {        LocalSocket socket = connect(SOCKET_NAME);        DesktopConnection connection = new DesktopConnection(socket);        Size videoSize = device.getScreenInfo().getVideoSize();        connection.send(Device.getDeviceName(), videoSize.getWidth(), videoSize.getHeight());        return connection;    }
    private static LocalSocket listenAndAccept(String abstractName) throws IOException {        LocalServerSocket localServerSocket = new LocalServerSocket(abstractName);        return localServerSocket.accept();    }    public static DesktopConnection open(Device device, boolean tunnelForward) throws IOException {        LocalSocket socket;        if (tunnelForward) {
    public static DesktopConnection open(Device device, boolean tunnelForward) throws IOException {        LocalSocket socket;        if (tunnelForward) {            socket = listenAndAccept(SOCKET_NAME);            // send one byte so the client may read() to detect a connection error            socket.getOutputStream().write(0);        } else {            socket = connect(SOCKET_NAME);        }        DesktopConnection connection = new DesktopConnection(socket);        Size videoSize = device.getScreenInfo().getVideoSize();        connection.send(Device.getDeviceName(), videoSize.getWidth(), videoSize.getHeight());        return connection;    }
    private static LocalSocket listenAndAccept(String abstractName) throws IOException {        LocalServerSocket localServerSocket = new LocalServerSocket(abstractName);        return localServerSocket.accept();    }
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        try (DesktopConnection connection = DesktopConnection.open(device)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getBitRate());            // asynchronous            startEventController(device, connection);            try {                // synchronous                screenEncoder.streamScreen(device, connection.getOutputStream());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    private static Options createOptions(String... args) {        Options options = new Options();        if (args.length < 1) {            return options;        }        int maxSize = Integer.parseInt(args[0]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        if (args.length < 2) {            return options;        }        int bitRate = Integer.parseInt(args[1]);        options.setBitRate(bitRate);        return options;    }
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getBitRate());            // asynchronous            startEventController(device, connection);            try {                // synchronous                screenEncoder.streamScreen(device, connection.getOutputStream());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    private static Options createOptions(String... args) {        Options options = new Options();        if (args.length < 1) {            return options;        }        int maxSize = Integer.parseInt(args[0]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        if (args.length < 2) {            return options;        }        int bitRate = Integer.parseInt(args[1]);        options.setBitRate(bitRate);        if (args.length < 3) {            return options;        }        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[2]);        options.setTunnelForward(tunnelForward);        return options;    }
static struct point get_mouse_point(void) {    int x;    int y;    SDL_GetMouseState(&x, &y);    SDL_assert_release(x >= 0 && x < 0x10000 && y >= 0 && y < 0x10000);    return (struct point) {        .x = (Uint16) x,        .y = (Uint16) y,    };}
static struct point get_mouse_point(void) {    int x;    int y;    SDL_GetMouseState(&x, &y);    SDL_assert_release(x >= 0 && x < 0x10000 && y >= 0 && y < 0x10000);    return (struct point) {        .x = (Uint16) x,        .y = (Uint16) y,    };}
void input_manager_process_mouse_wheel(struct input_manager *input_manager,                                       const SDL_MouseWheelEvent *event) {    struct position position = {        .screen_size = input_manager->screen->frame_size,        .point = get_mouse_point(),    };    struct control_event control_event;    if (mouse_wheel_from_sdl_to_android(event, position, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send wheel button event");        }    }}
void input_manager_process_mouse_wheel(struct input_manager *input_manager,                                       const SDL_MouseWheelEvent *event) {    struct position position = {        .screen_size = input_manager->screen->frame_size,        .point = get_mouse_point(),    };    struct control_event control_event;    if (mouse_wheel_from_sdl_to_android(event, position, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send wheel button event");        }    }}
static struct point get_mouse_point(struct screen *screen) {    int x;    int y;    SDL_GetMouseState(&x, &y);    convert_to_renderer_coordinates(screen->renderer, &x, &y);    SDL_assert_release(x >= 0 && x < 0x10000 && y >= 0 && y < 0x10000);    return (struct point) {        .x = (Uint16) x,        .y = (Uint16) y,    };}
// Convert window coordinates (as provided by SDL_GetMouseState() to renderer coordinates (as provided in SDL mouse events)//// See my question:// <https://stackoverflow.com/questions/49111054/how-to-get-mouse-position-on-mouse-wheel-event>static void convert_to_renderer_coordinates(SDL_Renderer *renderer, int *x, int *y) {    SDL_Rect viewport;    float scale_x, scale_y;    SDL_RenderGetViewport(renderer, &viewport);    SDL_RenderGetScale(renderer, &scale_x, &scale_y);    *x = (int) (*x / scale_x) - viewport.x;    *y = (int) (*y / scale_y) - viewport.y;
void input_manager_process_mouse_wheel(struct input_manager *input_manager,                                       const SDL_MouseWheelEvent *event) {    struct position position = {        .screen_size = input_manager->screen->frame_size,        .point = get_mouse_point(input_manager->screen),    };    struct control_event control_event;    if (mouse_wheel_from_sdl_to_android(event, position, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send wheel button event");        }    }}
static void convert_to_renderer_coordinates(SDL_Renderer *renderer, int *x, int *y) {    SDL_Rect viewport;    float scale_x, scale_y;    SDL_RenderGetViewport(renderer, &viewport);    SDL_RenderGetScale(renderer, &scale_x, &scale_y);    *x = (int) (*x / scale_x) - viewport.x;    *y = (int) (*y / scale_y) - viewport.y;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    int ret = 0;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        return -1;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        return -1;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        ret = -1;        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        ret = -1;        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        ret = -1;        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        ret = -1;        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    //const char *url = "tcp://127.0.0.1:1234";    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        ret = -1;        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet) && !avio_ctx->eof_reached) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57, 37, 0)        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#else        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        if ((ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame)) < 0) {            LOGE("Could not receive video frame: %d", ret);            goto run_quit;        }        push_frame(decoder);#endif    }    LOGD("End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    SDL_PushEvent(&(SDL_Event) {.type = EVENT_DECODER_STOPPED});    return ret;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    int ret = 0;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        return -1;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        return -1;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        ret = -1;        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        ret = -1;        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        ret = -1;        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        ret = -1;        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    //const char *url = "tcp://127.0.0.1:1234";    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        ret = -1;        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet) && !avio_ctx->eof_reached) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57, 37, 0)        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#else        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        if ((ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame)) < 0) {            LOGE("Could not receive video frame: %d", ret);            goto run_quit;        }        push_frame(decoder);#endif    }    LOGD("End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    SDL_PushEvent(&(SDL_Event) {.type = EVENT_DECODER_STOPPED});    return ret;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    int ret = 0;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        return -1;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        return -1;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        ret = -1;        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        ret = -1;        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        ret = -1;        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        ret = -1;        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    //const char *url = "tcp://127.0.0.1:1234";    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        ret = -1;        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet) && !avio_ctx->eof_reached) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57, 37, 0)        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#else        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        if ((ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame)) < 0) {            LOGE("Could not receive video frame: %d", ret);            goto run_quit;        }        push_frame(decoder);#endif    }    LOGD("End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();    return ret;}
static void notify_stopped(void) {    SDL_Event stop_event;    stop_event.type = EVENT_DECODER_STOPPED;    SDL_PushEvent(&stop_event);}
request_free(struct request *req) {    if (!req) {        return;    }    SDL_free((void *) req->file);    SDL_free((void *) req);}
request_free(struct request *req) {    if (!req) {        return;    }    SDL_free((void *) req->file);    SDL_free(req);}
server_start(struct server *server, const char *serial,             uint16_t local_port, uint16_t max_size, uint32_t bit_rate,             const char *crop, bool send_frame_meta) {    server->local_port = local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        SDL_free(server->serial);        return false;    }    if (!enable_tunnel(server)) {        SDL_free(server->serial);        return false;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, local_port);            disable_tunnel(server);            SDL_free(server->serial);            return false;        }    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate,                                     server->tunnel_forward, crop,                                     send_frame_meta);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free((void *) server->serial);        return false;    }    server->tunnel_enabled = true;    return true;}
server_start(struct server *server, const char *serial,             uint16_t local_port, uint16_t max_size, uint32_t bit_rate,             const char *crop, bool send_frame_meta) {    server->local_port = local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        SDL_free(server->serial);        return false;    }    if (!enable_tunnel(server)) {        SDL_free(server->serial);        return false;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, local_port);            disable_tunnel(server);            SDL_free(server->serial);            return false;        }    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate,                                     server->tunnel_forward, crop,                                     send_frame_meta);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free(server->serial);        return false;    }    server->tunnel_enabled = true;    return true;}
int main(int argc, char *argv[]) {    av_register_all();    avformat_network_init();    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    struct args args = {        .serial = NULL,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    return show_screen(args.serial, args.port) ? 0 : 1;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = show_screen(args.serial, args.port) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
        screen->texture = SDL_CreateTexture(screen->renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                                            new_frame_size.width, new_frame_size.height);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return SDL_FALSE;        }    }    return SDL_TRUE;}// write the frame into the texturestatic void update_texture(struct screen *screen, const AVFrame *frame) {    SDL_UpdateYUVTexture(screen->texture, NULL,            frame->data[0], frame->linesize[0],            frame->data[1], frame->linesize[1],            frame->data[2], frame->linesize[2]);}SDL_bool screen_update_frame(struct screen *screen, struct frames *frames) {    mutex_lock(frames->mutex);    const AVFrame *frame = frames_consume_rendered_frame(frames);    struct size new_frame_size = {frame->width, frame->height};    if (!prepare_for_frame(screen, new_frame_size)) {        mutex_unlock(frames->mutex);        return SDL_FALSE;    }    update_texture(screen, frame);    mutex_unlock(frames->mutex);
static SDL_bool prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width || screen->frame_size.height != new_frame_size.height) {        if (SDL_RenderSetLogicalSize(screen->renderer, new_frame_size.width, new_frame_size.height)) {            LOGE("Could not set renderer logical size: %s", SDL_GetError());            return SDL_FALSE;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        struct size current_size = get_window_size(screen);        struct size target_size = {            (Uint32) current_size.width * new_frame_size.width / screen->frame_size.width,            (Uint32) current_size.height * new_frame_size.height / screen->frame_size.height,        };        target_size = get_optimal_size(target_size, new_frame_size);        set_window_size(screen, target_size);        screen->frame_size = new_frame_size;        LOGD("New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = SDL_CreateTexture(screen->renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                                            new_frame_size.width, new_frame_size.height);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return SDL_FALSE;        }    }    return SDL_TRUE;}
SDL_bool screen_init_rendering(struct screen *screen, const char *device_name, struct size frame_size) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    Uint32 window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height, window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1, SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width, frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    screen->texture = SDL_CreateTexture(screen->renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                                        frame_size.width, frame_size.height);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    return SDL_TRUE;}
static inline SDL_Texture *create_texture(SDL_Renderer *renderer, struct size frame_size) {    return SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                             frame_size.width, frame_size.height);}
static SDL_bool prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width || screen->frame_size.height != new_frame_size.height) {        if (SDL_RenderSetLogicalSize(screen->renderer, new_frame_size.width, new_frame_size.height)) {            LOGE("Could not set renderer logical size: %s", SDL_GetError());            return SDL_FALSE;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        struct size current_size = get_window_size(screen);        struct size target_size = {            (Uint32) current_size.width * new_frame_size.width / screen->frame_size.width,            (Uint32) current_size.height * new_frame_size.height / screen->frame_size.height,        };        target_size = get_optimal_size(target_size, new_frame_size);        set_window_size(screen, target_size);        screen->frame_size = new_frame_size;        LOGD("New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = create_texture(screen->renderer, new_frame_size);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return SDL_FALSE;        }    }    return SDL_TRUE;}
SDL_bool screen_init_rendering(struct screen *screen, const char *device_name, struct size frame_size) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    Uint32 window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height, window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1, SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width, frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    return SDL_TRUE;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    LOGI("scrcpy " SCRCPY_VERSION " <https://github.com/Genymobile/scrcpy>");#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    int res = scrcpy(&args.opts) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    LOGI("scrcpy " SCRCPY_VERSION " <https://github.com/Genymobile/scrcpy>");#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifndef NDEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    int res = scrcpy(&args.opts) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
read_xpm(char *xpm[]) {#if SDL_ASSERT_LEVEL >= 2    // patch the XPM to change the icon color in debug mode    xpm[2] = ".	c #CC00CC";#endif    char *endptr;    // *** No error handling, assume the XPM source is valid ***    // (it's in our source repo)    // Assertions are only checked in debug    int width = strtol(xpm[0], &endptr, 10);    int height = strtol(endptr + 1, &endptr, 10);    int colors = strtol(endptr + 1, &endptr, 10);    int chars = strtol(endptr + 1, &endptr, 10);    // sanity checks    SDL_assert(0 <= width && width < 256);    SDL_assert(0 <= height && height < 256);    SDL_assert(0 <= colors && colors < 256);    SDL_assert(chars == 1); // this implementation does not support more    // init index    struct index index[colors];    for (int i = 0; i < colors; ++i) {        const char *line = xpm[1+i];        index[i].c = line[0];        SDL_assert(line[1] == '\t');        SDL_assert(line[2] == 'c');        SDL_assert(line[3] == ' ');        if (line[4] == '#') {            index[i].color = 0xff000000 | strtol(&line[5], &endptr, 0x10);            SDL_assert(*endptr == '\0');        } else {            SDL_assert(!strcmp("None", &line[4]));            index[i].color = 0;        }    }    // parse image    uint32_t *pixels = SDL_malloc(4 * width * height);    if (!pixels) {        LOGE("Could not allocate icon memory");        return NULL;    }    for (int y = 0; y < height; ++y) {        const char *line = xpm[1 + colors + y];        for (int x = 0; x < width; ++x) {            char c = line[x];            uint32_t color;            bool color_found = find_color(index, colors, c, &color);            SDL_assert(color_found);            pixels[y * width + x] = color;        }    }#if SDL_BYTEORDER == SDL_BIG_ENDIAN    uint32_t amask = 0x000000ff;    uint32_t rmask = 0x0000ff00;    uint32_t gmask = 0x00ff0000;    uint32_t bmask = 0xff000000;#else // little endian, like x86    uint32_t amask = 0xff000000;    uint32_t rmask = 0x00ff0000;    uint32_t gmask = 0x0000ff00;    uint32_t bmask = 0x000000ff;#endif    SDL_Surface *surface = SDL_CreateRGBSurfaceFrom(pixels,                                                    width, height,                                                    32, 4 * width,                                                    rmask, gmask, bmask, amask);    if (!surface) {        LOGE("Could not create icon surface");        return NULL;    }    // make the surface own the raw pixels    surface->flags &= ~SDL_PREALLOC;    return surface;}
read_xpm(char *xpm[]) {#ifndef NDEBUG    // patch the XPM to change the icon color in debug mode    xpm[2] = ".	c #CC00CC";#endif    char *endptr;    // *** No error handling, assume the XPM source is valid ***    // (it's in our source repo)    // Assertions are only checked in debug    int width = strtol(xpm[0], &endptr, 10);    int height = strtol(endptr + 1, &endptr, 10);    int colors = strtol(endptr + 1, &endptr, 10);    int chars = strtol(endptr + 1, &endptr, 10);    // sanity checks    SDL_assert(0 <= width && width < 256);    SDL_assert(0 <= height && height < 256);    SDL_assert(0 <= colors && colors < 256);    SDL_assert(chars == 1); // this implementation does not support more    // init index    struct index index[colors];    for (int i = 0; i < colors; ++i) {        const char *line = xpm[1+i];        index[i].c = line[0];        SDL_assert(line[1] == '\t');        SDL_assert(line[2] == 'c');        SDL_assert(line[3] == ' ');        if (line[4] == '#') {            index[i].color = 0xff000000 | strtol(&line[5], &endptr, 0x10);            SDL_assert(*endptr == '\0');        } else {            SDL_assert(!strcmp("None", &line[4]));            index[i].color = 0;        }    }    // parse image    uint32_t *pixels = SDL_malloc(4 * width * height);    if (!pixels) {        LOGE("Could not allocate icon memory");        return NULL;    }    for (int y = 0; y < height; ++y) {        const char *line = xpm[1 + colors + y];        for (int x = 0; x < width; ++x) {            char c = line[x];            uint32_t color;            bool color_found = find_color(index, colors, c, &color);            SDL_assert(color_found);            pixels[y * width + x] = color;        }    }#if SDL_BYTEORDER == SDL_BIG_ENDIAN    uint32_t amask = 0x000000ff;    uint32_t rmask = 0x0000ff00;    uint32_t gmask = 0x00ff0000;    uint32_t bmask = 0xff000000;#else // little endian, like x86    uint32_t amask = 0xff000000;    uint32_t rmask = 0x00ff0000;    uint32_t gmask = 0x0000ff00;    uint32_t bmask = 0x000000ff;#endif    SDL_Surface *surface = SDL_CreateRGBSurfaceFrom(pixels,                                                    width, height,                                                    32, 4 * width,                                                    rmask, gmask, bmask, amask);    if (!surface) {        LOGE("Could not create icon surface");        return NULL;    }    // make the surface own the raw pixels    surface->flags &= ~SDL_PREALLOC;    return surface;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    int ret = 0;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        return -1;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        return -1;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        ret = -1;        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        ret = -1;        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        ret = -1;        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        ret = -1;        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        ret = -1;        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet) && !avio_ctx->eof_reached) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57, 37, 0)        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#else        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        if ((ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame)) < 0) {            LOGE("Could not receive video frame: %d", ret);            goto run_quit;        }        push_frame(decoder);#endif    }    LOGD("End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();    return ret;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet) && !avio_ctx->eof_reached) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57, 37, 0)        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#else        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        if ((ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame)) < 0) {            LOGE("Could not receive video frame: %d", ret);            goto run_quit;        }        push_frame(decoder);#endif    }    LOGD("End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    int ret = 0;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        return -1;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        return -1;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        ret = -1;        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        ret = -1;        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        ret = -1;        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        ret = -1;        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    //const char *url = "tcp://127.0.0.1:1234";    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        ret = -1;        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet) && !avio_ctx->eof_reached) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57, 37, 0)        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#else        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        if ((ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame)) < 0) {            LOGE("Could not receive video frame: %d", ret);            goto run_quit;        }        push_frame(decoder);#endif    }    LOGD("End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();    return ret;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    int ret = 0;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        return -1;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        return -1;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        ret = -1;        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        ret = -1;        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        ret = -1;        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        ret = -1;        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        ret = -1;        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet) && !avio_ctx->eof_reached) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57, 37, 0)        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#else        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        if ((ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame)) < 0) {            LOGE("Could not receive video frame: %d", ret);            goto run_quit;        }        push_frame(decoder);#endif    }    LOGD("End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();    return ret;}void decoder_init(struct decoder *decoder, struct frames *frames, socket_t video_socket) {
static int parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"port",     required_argument, NULL, 'p'},        {"max-size", required_argument, NULL, 'm'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "p:m:", long_options, NULL)) != -1) {        switch (c) {            case 'p': {                char *endptr;                long value = strtol(optarg, &endptr, 0);                if (*optarg == '\0' || *endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s\n", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld\n", value);                    return -1;                }                args->port = (Uint16) value;                break;            }            case 'm': {                char *endptr;                long value = strtol(optarg, &endptr, 0);                if (*optarg == '\0' || *endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid max size: %s\n", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Max size must be between 0 and 65535: %ld\n", value);                    return -1;                }                args->max_size = (Uint16) value;                break;            }            default:                // getopt prints the error message on stderr                return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s\n", argv[index]);        return -1;    }    return 0;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .max_size = DEFAULT_MAX_SIZE,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = scrcpy(args.serial, args.port, args.max_size) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .max_size = DEFAULT_MAX_SIZE,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = scrcpy(args.serial, args.port, args.max_size) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
static int parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"help",     no_argument,       NULL, 'h'},        {"port",     required_argument, NULL, 'p'},        {"max-size", required_argument, NULL, 'm'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "hp:m:", long_options, NULL)) != -1) {        switch (c) {            case 'h': {                args->help = SDL_TRUE;                break;            }            case 'p': {                char *endptr;                long value = strtol(optarg, &endptr, 0);                if (*optarg == '\0' || *endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s\n", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld\n", value);                    return -1;                }                args->port = (Uint16) value;                break;            }            case 'm': {                char *endptr;                long value = strtol(optarg, &endptr, 0);                if (*optarg == '\0' || *endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid max size: %s\n", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Max size must be between 0 and 65535: %ld\n", value);                    return -1;                }                args->max_size = (Uint16) value;                break;            }            default:                // getopt prints the error message on stderr                return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s\n", argv[index]);        return -1;    }    return 0;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .help = SDL_FALSE,        .serial = NULL,        .max_size = DEFAULT_MAX_SIZE,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        usage(argv[0]);        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = scrcpy(args.serial, args.port, args.max_size) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options] [serial]\n"        "\n"        "    serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "Options:\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f: switch fullscreen mode\n"        "    Ctrl+g: resize window to 1:1 (pixel-perfect)\n"        "    Ctrl+x: resize window to optimal size (remove black borders)\n"        "\n",        arg0,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
screen_init_rendering(struct screen *screen, const char *device_name,                      struct size frame_size, bool always_on_top) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED,                                      SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    return true;}
screen_init_rendering(struct screen *screen, const char *device_name,                      struct size frame_size, bool always_on_top) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED,                                      SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    return true;}
SDL_bool recorder_open(struct recorder *recorder, AVCodec *input_codec) {    const char *format_name = recorder_get_format_name(recorder->format);    SDL_assert(format_name);    const AVOutputFormat *format = find_muxer(format_name);    if (!format) {        LOGE("Could not find muxer");        return SDL_FALSE;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return SDL_FALSE;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) format;    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }#ifdef LAVF_NEW_CODEC_API    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    return SDL_TRUE;}
void recorder_close(struct recorder *recorder) {    int ret = av_write_trailer(recorder->ctx);    if (ret < 0) {        LOGE("Failed to write trailer to %s", recorder->filename);    }    avio_close(recorder->ctx->pb);    avformat_free_context(recorder->ctx);}
SDL_bool recorder_open(struct recorder *recorder, AVCodec *input_codec) {    const char *format_name = recorder_get_format_name(recorder->format);    SDL_assert(format_name);    const AVOutputFormat *format = find_muxer(format_name);    if (!format) {        LOGE("Could not find muxer");        return SDL_FALSE;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return SDL_FALSE;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) format;    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }#ifdef LAVF_NEW_CODEC_API    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    LOGI("Recording started to %s file: %s", format_name, recorder->filename);    return SDL_TRUE;}
void recorder_close(struct recorder *recorder) {    int ret = av_write_trailer(recorder->ctx);    if (ret < 0) {        LOGE("Failed to write trailer to %s", recorder->filename);    }    avio_close(recorder->ctx->pb);    avformat_free_context(recorder->ctx);    const char *format_name = recorder_get_format_name(recorder->format);    LOGI("Recording complete to %s file: %s", format_name, recorder->filename);}
enum process_result cmd_execute(const char *path, const char *const argv[], HANDLE *handle) {    STARTUPINFO si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    // Windows command-line parsing is WTF:    // <http://daviddeley.com/autohotkey/parameters/parameters.htm#WINPASS>    // only make it work for this very specific program    // (don't handle escaping nor quotes)    char cmd[256];    size_t ret = xstrjoin(cmd, argv, ' ', sizeof(cmd));    if (ret >= sizeof(cmd)) {        LOGE("Command too long (%" PRIsizet " chars)", sizeof(cmd) - 1);        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, flags, NULL, NULL, &si, &pi)) {        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }    *handle = pi.hProcess;    return PROCESS_SUCCESS;}
enum process_result cmd_execute(const char *path, const char *const argv[], HANDLE *handle) {    STARTUPINFO si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    // Windows command-line parsing is WTF:    // <http://daviddeley.com/autohotkey/parameters/parameters.htm#WINPASS>    // only make it work for this very specific program    // (don't handle escaping nor quotes)    char cmd[256];    size_t ret = xstrjoin(cmd, argv, ' ', sizeof(cmd));    if (ret >= sizeof(cmd)) {        LOGE("Command too long (%" PRIsizet " chars)", sizeof(cmd) - 1);        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, flags, NULL, NULL, &si, &pi)) {        *handle = NULL;        if (GetLastError() == ERROR_FILE_NOT_FOUND) {            return PROCESS_ERROR_MISSING_BINARY;        }        return PROCESS_ERROR_GENERIC;    }    *handle = pi.hProcess;    return PROCESS_SUCCESS;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    int ret = 0;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "H.264 decoder not found");        return -1;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        SDL_LogCritical(SDL_LOG_CATEGORY_VIDEO, "Could not allocate decoder context");        return -1;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Could not open H.264 codec");        ret = -1;        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        SDL_LogCritical(SDL_LOG_CATEGORY_VIDEO, "Could not allocate format context");        ret = -1;        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        SDL_LogCritical(SDL_LOG_CATEGORY_VIDEO, "Could not allocate buffer");        ret = -1;        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        SDL_LogCritical(SDL_LOG_CATEGORY_VIDEO, "Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        ret = -1;        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    //const char *url = "tcp://127.0.0.1:1234";    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Could not open video stream");        ret = -1;        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57, 37, 0)        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#else        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Could not send video packet: %d", ret);            goto run_quit;        }        if ((ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame)) < 0) {            SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Could not receive video frame: %d", ret);            goto run_quit;        }        push_frame(decoder);#endif    }    SDL_LogDebug(SDL_LOG_CATEGORY_VIDEO, "End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    SDL_PushEvent(&(SDL_Event) {.type = EVENT_DECODER_STOPPED});    return ret;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    int ret = 0;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "H.264 decoder not found");        return -1;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        SDL_LogCritical(SDL_LOG_CATEGORY_VIDEO, "Could not allocate decoder context");        return -1;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Could not open H.264 codec");        ret = -1;        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        SDL_LogCritical(SDL_LOG_CATEGORY_VIDEO, "Could not allocate format context");        ret = -1;        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        SDL_LogCritical(SDL_LOG_CATEGORY_VIDEO, "Could not allocate buffer");        ret = -1;        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        SDL_LogCritical(SDL_LOG_CATEGORY_VIDEO, "Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        ret = -1;        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    //const char *url = "tcp://127.0.0.1:1234";    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Could not open video stream");        ret = -1;        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet) && !avio_ctx->eof_reached) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57, 37, 0)        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#else        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Could not send video packet: %d", ret);            goto run_quit;        }        if ((ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame)) < 0) {            SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Could not receive video frame: %d", ret);            goto run_quit;        }        push_frame(decoder);#endif    }    SDL_LogDebug(SDL_LOG_CATEGORY_VIDEO, "End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    SDL_PushEvent(&(SDL_Event) {.type = EVENT_DECODER_STOPPED});    return ret;}
    public Point getPhysicalPoint(Position position) {        // it hides the field on purpose, to read it with a lock        @SuppressWarnings("checkstyle:HiddenField")        ScreenInfo screenInfo = getScreenInfo(); // read with synchronization        Size videoSize = screenInfo.getVideoSize();        Size clientVideoSize = position.getScreenSize();        if (!videoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event            return null;        }        Rect contentRect = screenInfo.getContentRect();        Point point = position.getPoint();        int scaledX = contentRect.left + point.x * contentRect.width() / videoSize.getWidth();        int scaledY = contentRect.top + point.y * contentRect.height() / videoSize.getHeight();        return new Point(scaledX, scaledY);    }
    public Point getPhysicalPoint(Position position) {        // it hides the field on purpose, to read it with a lock        @SuppressWarnings("checkstyle:HiddenField")        ScreenInfo screenInfo = getScreenInfo(); // read with synchronization        Size videoSize = screenInfo.getVideoSize();        Size clientVideoSize = position.getScreenSize();        if (!videoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event            return null;        }        Rect contentRect = screenInfo.getContentRect();        Point point = position.getPoint();        int scaledX = contentRect.left + point.getX() * contentRect.width() / videoSize.getWidth();        int scaledY = contentRect.top + point.getY() * contentRect.height() / videoSize.getHeight();        return new Point(scaledX, scaledY);    }
    private void setPointerCoords(Point point) {        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.x = point.x;        coords.y = point.y;    }
    private void setPointerCoords(Point point) {        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.x = point.getX();        coords.y = point.getY();    }
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            write32(&buf[2], event->keycode_event.keycode);            write32(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (1 byte) + date (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > TEXT_MAX_LENGTH) {                len = TEXT_MAX_LENGTH;            }            buf[1] = (Uint8) len;            memcpy(&buf[2], &event->text_event.text, len);            return 2 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            write32(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 14;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            write32(&buf[9], (Uint32) event->scroll_event.hscroll);            write32(&buf[13], (Uint32) event->scroll_event.vscroll);            return 17;        default:            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Unknown event type: %u", (unsigned) event->type);            return 0;    }}
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            write32(&buf[2], event->keycode_event.keycode);            write32(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (1 byte) + date (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > TEXT_MAX_LENGTH) {                len = TEXT_MAX_LENGTH;            }            buf[1] = (Uint8) len;            memcpy(&buf[2], &event->text_event.text, len);            return 2 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            write32(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 14;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            write32(&buf[9], (Uint32) event->scroll_event.hscroll);            write32(&buf[13], (Uint32) event->scroll_event.vscroll);            return 17;        case CONTROL_EVENT_TYPE_COMMAND:            buf[1] = event->command_event.action;            return 2;        default:            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Unknown event type: %u", (unsigned) event->type);            return 0;    }}
static struct controller controller;static SDL_Window *window;static SDL_Renderer *renderer;static SDL_Texture *texture;static struct size frame_size;// used only in fullscreen mode to know the windowed window sizestatic struct size windowed_window_size;static SDL_bool texture_empty = SDL_TRUE;static SDL_bool fullscreen = SDL_FALSE;static long timestamp_ms(void) {    struct timeval tv;    gettimeofday(&tv, NULL);    return tv.tv_sec * 1000 + tv.tv_usec / 1000;}static void count_frame(void) {    static long ts = 0;    static int nbframes = 0;    long now = timestamp_ms();    ++nbframes;    if (now - ts > 1000) {        SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "%d fps", nbframes);        ts = now;        nbframes = 0;    }}static TCPsocket listen_on_port(Uint16 port) {    IPaddress addr = {        .host = INADDR_ANY,        .port = SDL_SwapBE16(port),    };
static void handle_mouse_button(const SDL_MouseButtonEvent *event, struct size screen_size) {    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, screen_size, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse button event");        }    }}
static void turn_screen_on(void) {    struct control_event control_event = {        .type = CONTROL_EVENT_TYPE_COMMAND,        .command_event = {            .action = CONTROL_EVENT_COMMAND_SCREEN_ON,        },    };    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot turn screen on");    }}
static void handle_mouse_button(const SDL_MouseButtonEvent *event, struct size screen_size) {    if (event->button == SDL_BUTTON_RIGHT) {        turn_screen_on();        return;    };    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, screen_size, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse button event");        }    }}
    public ControlEvent next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        switch (type) {            case ControlEvent.TYPE_KEYCODE: {                if (buffer.remaining() < KEYCODE_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                int keycode = buffer.getInt();                int metaState = buffer.getInt();                return ControlEvent.createKeycodeControlEvent(action, keycode, metaState);            }            case ControlEvent.TYPE_TEXT: {                if (buffer.remaining() < 1) {                    break;                }                int len = toUnsigned(buffer.get());                if (buffer.remaining() < len) {                    break;                }                buffer.get(textBuffer, 0, len);                String text = new String(textBuffer, 0, len, StandardCharsets.UTF_8);                return ControlEvent.createTextControlEvent(text);            }            case ControlEvent.TYPE_MOUSE: {                if (buffer.remaining() < MOUSE_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                int buttons = buffer.getInt();                Position position = readPosition(buffer);                return ControlEvent.createMotionControlEvent(action, buttons, position);            }            case ControlEvent.TYPE_SCROLL: {                if (buffer.remaining() < SCROLL_PAYLOAD_LENGTH) {                    break;                }                Position position = readPosition(buffer);                int hScroll = buffer.getInt();                int vScroll = buffer.getInt();                return ControlEvent.createScrollControlEvent(position, hScroll, vScroll);            }            default:                Ln.w("Unknown event type: " + type);        }        // failure, reset savedPosition        buffer.position(savedPosition);        return null;    }
    public ControlEvent next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        switch (type) {            case ControlEvent.TYPE_KEYCODE: {                if (buffer.remaining() < KEYCODE_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                int keycode = buffer.getInt();                int metaState = buffer.getInt();                return ControlEvent.createKeycodeControlEvent(action, keycode, metaState);            }            case ControlEvent.TYPE_TEXT: {                if (buffer.remaining() < 1) {                    break;                }                int len = toUnsigned(buffer.get());                if (buffer.remaining() < len) {                    break;                }                buffer.get(textBuffer, 0, len);                String text = new String(textBuffer, 0, len, StandardCharsets.UTF_8);                return ControlEvent.createTextControlEvent(text);            }            case ControlEvent.TYPE_MOUSE: {                if (buffer.remaining() < MOUSE_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                int buttons = buffer.getInt();                Position position = readPosition(buffer);                return ControlEvent.createMotionControlEvent(action, buttons, position);            }            case ControlEvent.TYPE_SCROLL: {                if (buffer.remaining() < SCROLL_PAYLOAD_LENGTH) {                    break;                }                Position position = readPosition(buffer);                int hScroll = buffer.getInt();                int vScroll = buffer.getInt();                return ControlEvent.createScrollControlEvent(position, hScroll, vScroll);            }            case ControlEvent.TYPE_COMMAND: {                if (buffer.remaining() < COMMAND_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                return ControlEvent.createCommandControlEvent(action);            }            default:                Ln.w("Unknown event type: " + type);        }        // failure, reset savedPosition        buffer.position(savedPosition);        return null;    }
    private ScreenInfo computeScreenInfo(int maxSize) {        // Compute the video size and the padding of the content inside this video.        // Principle:        // - scale down the great side of the screen to maxSize (if necessary);        // - scale down the other side so that the aspect ratio is preserved;        // - round this value to the nearest multiple of 8 (H.264 only accepts multiples of 8)        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        int w = deviceSize.getWidth();        int h = deviceSize.getHeight();        if (maxSize > 0) {            assert maxSize % 8 == 0;            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;            if (major > maxSize) {                int minorExact = minor * maxSize / major;                // +4 to round the value to the nearest multiple of 8                minor = (minorExact + 4) & ~7;                major = maxSize;            }            w = portrait ? minor : major;            h = portrait ? major : minor;        }        Size videoSize = new Size(w, h);        return new ScreenInfo(deviceSize, videoSize, rotated);    }    public Point getPhysicalPoint(Position position) {        ScreenInfo screenInfo = getScreenInfo(); // read with synchronization        Size videoSize = screenInfo.getVideoSize();        Size clientVideoSize = position.getScreenSize();        if (!videoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event            return null;        }        Size deviceSize = screenInfo.getDeviceSize();        Point point = position.getPoint();        int scaledX = point.x * deviceSize.getWidth() / videoSize.getWidth();        int scaledY = point.y * deviceSize.getHeight() / videoSize.getHeight();        return new Point(scaledX, scaledY);    }    public static String getDeviceName() {        return Build.MODEL;    }    public InputManager getInputManager() {        return serviceManager.getInputManager();    }    public void registerRotationWatcher(IRotationWatcher rotationWatcher) {        serviceManager.getWindowManager().registerRotationWatcher(rotationWatcher);
    public PowerManager getPowerManager() {        return serviceManager.getPowerManager();    }
    private boolean injectKeycode(int action, int keycode, int metaState) {        return injectKeyEvent(action, keycode, 0, metaState);    }
    private boolean injectKeycode(int action, int keycode, int metaState) {        return injectKeyEvent(action, keycode, 0, metaState);    }
    public EventController(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;        inputManager = device.getInputManager();        initPointer();    }
    private boolean handleEvent() throws IOException {        ControlEvent controlEvent = connection.receiveControlEvent();        if (controlEvent == null) {            return false;        }        switch (controlEvent.getType()) {            case ControlEvent.TYPE_KEYCODE:                injectKeycode(controlEvent.getAction(), controlEvent.getKeycode(), controlEvent.getMetaState());                break;            case ControlEvent.TYPE_TEXT:                injectText(controlEvent.getText());                break;            case ControlEvent.TYPE_MOUSE:                injectMouse(controlEvent.getAction(), controlEvent.getButtons(), controlEvent.getPosition());                break;            case ControlEvent.TYPE_SCROLL:                injectScroll(controlEvent.getPosition(), controlEvent.getHScroll(), controlEvent.getVScroll());        }        return true;    }
    private boolean handleEvent() throws IOException {        ControlEvent controlEvent = connection.receiveControlEvent();        if (controlEvent == null) {            return false;        }        switch (controlEvent.getType()) {            case ControlEvent.TYPE_KEYCODE:                injectKeycode(controlEvent.getAction(), controlEvent.getKeycode(), controlEvent.getMetaState());                break;            case ControlEvent.TYPE_TEXT:                injectText(controlEvent.getText());                break;            case ControlEvent.TYPE_MOUSE:                injectMouse(controlEvent.getAction(), controlEvent.getButtons(), controlEvent.getPosition());                break;            case ControlEvent.TYPE_SCROLL:                injectScroll(controlEvent.getPosition(), controlEvent.getHScroll(), controlEvent.getVScroll());        }        return true;    }
    private boolean injectKeycode(int keyCode) {        return injectKeyEvent(KeyEvent.ACTION_DOWN, keyCode, 0, 0)                && injectKeyEvent(KeyEvent.ACTION_UP, keyCode, 0, 0);    }
    private boolean executeCommand(int action) {        switch (action) {            case ControlEvent.COMMAND_SCREEN_ON:                return turnScreenOn();        }        return false;    }}
    public EventController(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;        inputManager = device.getInputManager();        powerManager = device.getPowerManager();        initPointer();    }
    private boolean handleEvent() throws IOException {        ControlEvent controlEvent = connection.receiveControlEvent();        if (controlEvent == null) {            return false;        }        switch (controlEvent.getType()) {            case ControlEvent.TYPE_KEYCODE:                injectKeycode(controlEvent.getAction(), controlEvent.getKeycode(), controlEvent.getMetaState());                break;            case ControlEvent.TYPE_TEXT:                injectText(controlEvent.getText());                break;            case ControlEvent.TYPE_MOUSE:                injectMouse(controlEvent.getAction(), controlEvent.getButtons(), controlEvent.getPosition());                break;            case ControlEvent.TYPE_SCROLL:                injectScroll(controlEvent.getPosition(), controlEvent.getHScroll(), controlEvent.getVScroll());                break;            case ControlEvent.TYPE_COMMAND:                executeCommand(controlEvent.getAction());                break;        }        return true;    }
    private boolean turnScreenOn() {        return powerManager.isScreenOn() || injectKeycode(KeyEvent.KEYCODE_POWER);    }
SDL_bool recorder_open(struct recorder *recorder, AVCodec *input_codec) {    const char *format_name = recorder_get_format_name(recorder->format);    SDL_assert(format_name);    const AVOutputFormat *format = find_muxer(format_name);    if (!format) {        LOGE("Could not find muxer");        return SDL_FALSE;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return SDL_FALSE;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) format;    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }#ifdef LAVF_NEW_CODEC_API    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    return SDL_TRUE;}
void recorder_close(struct recorder *recorder) {    int ret = av_write_trailer(recorder->ctx);    if (ret < 0) {        LOGE("Failed to write trailer to %s", recorder->filename);    }    avio_close(recorder->ctx->pb);    avformat_free_context(recorder->ctx);}
SDL_bool recorder_open(struct recorder *recorder, AVCodec *input_codec) {    const char *format_name = recorder_get_format_name(recorder->format);    SDL_assert(format_name);    const AVOutputFormat *format = find_muxer(format_name);    if (!format) {        LOGE("Could not find muxer");        return SDL_FALSE;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return SDL_FALSE;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) format;    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }#ifdef LAVF_NEW_CODEC_API    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    LOGI("Recording started to %s file: %s", format_name, recorder->filename);    return SDL_TRUE;}
void recorder_close(struct recorder *recorder) {    int ret = av_write_trailer(recorder->ctx);    if (ret < 0) {        LOGE("Failed to write trailer to %s", recorder->filename);    }    avio_close(recorder->ctx->pb);    avformat_free_context(recorder->ctx);    const char *format_name = recorder_get_format_name(recorder->format);    LOGI("Recording complete to %s file: %s", format_name, recorder->filename);}
static int read_packet(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    uint8_t header[HEADER_SIZE];    int remaining;    int ret;    remaining = decoder->remaining;    if (remaining == 0) {        // the previous PTS read is now for the current frame        decoder->pts = decoder->next_pts;        // FIXME what if only part of the header is available?        ret = net_recv(decoder->video_socket, header, HEADER_SIZE);        if (ret <= 0)            return ret;        // read the PTS for the next frame        decoder->next_pts = from_be(header, 8);        remaining = from_be(header + 8, 4);    }    if (buf_size > remaining)        buf_size = remaining;    ret = net_recv(decoder->video_socket, buf, buf_size);    if (ret <= 0)        return ret;    remaining -= ret;    decoder->remaining = remaining;    return ret;}
static inline uint64_t from_be(uint8_t *b, int size){    uint64_t x = 0;    int i;    for (i = 0; i < size; i += 1) {        x <<= 8;        x |= b[i];    }    return x;}
static int read_packet(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    uint8_t header[HEADER_SIZE];    int remaining;    int ret;    remaining = decoder->remaining;    if (remaining == 0) {        // the previous PTS read is now for the current frame        decoder->pts = decoder->next_pts;        // FIXME what if only part of the header is available?        ret = net_recv(decoder->video_socket, header, HEADER_SIZE);        if (ret <= 0)            return ret;        // read the PTS for the next frame        decoder->next_pts = buffer_read64be(header);        remaining = buffer_read32be(&header[8]);    }    if (buf_size > remaining)        buf_size = remaining;    ret = net_recv(decoder->video_socket, buf, buf_size);    if (ret <= 0)        return ret;    remaining -= ret;    decoder->remaining = remaining;    return ret;}
#define HEADER_SIZE 12static int read_packet(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    uint8_t header[HEADER_SIZE];    int remaining;    int ret;    remaining = decoder->remaining;    if (remaining == 0) {        // the previous PTS read is now for the current frame        decoder->pts = decoder->next_pts;
    public static ControlMessage createInjectTouchEvent(int action, long pointerId, Position position, float pressure,            int buttons) {        ControlMessage msg = new ControlMessage();        msg.type = TYPE_INJECT_TOUCH_EVENT;        msg.action = action;        msg.pointerId = pointerId;        msg.pressure = pressure;        msg.position = position;        msg.buttons = buttons;        return msg;    }
    public static ControlMessage createInjectTouchEvent(int action, long pointerId, Position position, float pressure, int buttons) {        ControlMessage msg = new ControlMessage();        msg.type = TYPE_INJECT_TOUCH_EVENT;        msg.action = action;        msg.pointerId = pointerId;        msg.pressure = pressure;        msg.position = position;        msg.buttons = buttons;        return msg;    }
    private boolean injectKeyEvent(int action, int keyCode, int repeat, int metaState) {        long now = SystemClock.uptimeMillis();        KeyEvent event = new KeyEvent(now, now, action, keyCode, repeat, metaState, KeyCharacterMap.VIRTUAL_KEYBOARD,                0, 0, InputDevice.SOURCE_KEYBOARD);        return injectEvent(event);    }
    private boolean injectTouch(int action, long pointerId, Position position, float pressure, int buttons) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        int pointerIndex = pointersState.getPointerIndex(pointerId);        if (pointerIndex == -1) {            Ln.w("Too many pointers for touch event");            return false;        }        Pointer pointer = pointersState.get(pointerIndex);        pointer.setPoint(point);        pointer.setPressure(pressure);        pointer.setUp(action == MotionEvent.ACTION_UP);        int pointerCount = pointersState.update(pointerProperties, pointerCoords);        if (pointerCount == 1) {            if (action == MotionEvent.ACTION_DOWN) {                lastTouchDown = now;            }        } else {            // secondary pointers must use ACTION_POINTER_* ORed with the pointerIndex            if (action == MotionEvent.ACTION_UP) {                action = MotionEvent.ACTION_POINTER_UP | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            } else if (action == MotionEvent.ACTION_DOWN) {                action = MotionEvent.ACTION_POINTER_DOWN | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            }        }        MotionEvent event = MotionEvent.obtain(lastTouchDown, now, action, pointerCount, pointerProperties,                pointerCoords, 0, buttons, 1f, 1f, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
    private boolean injectScroll(Position position, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        MotionEvent.PointerProperties props = pointerProperties[0];        props.id = 0;        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.x = point.getX();        coords.y = point.getY();        coords.setAxisValue(MotionEvent.AXIS_HSCROLL, hScroll);        coords.setAxisValue(MotionEvent.AXIS_VSCROLL, vScroll);        MotionEvent event = MotionEvent.obtain(lastTouchDown, now, MotionEvent.ACTION_SCROLL, 1, pointerProperties,                pointerCoords, 0, 0, 1f, 1f, 0, 0, InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
    private boolean injectKeyEvent(int action, int keyCode, int repeat, int metaState) {        long now = SystemClock.uptimeMillis();        KeyEvent event = new KeyEvent(now, now, action, keyCode, repeat, metaState, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, 0,                InputDevice.SOURCE_KEYBOARD);        return injectEvent(event);    }
    private boolean injectTouch(int action, long pointerId, Position position, float pressure, int buttons) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        int pointerIndex = pointersState.getPointerIndex(pointerId);        if (pointerIndex == -1) {            Ln.w("Too many pointers for touch event");            return false;        }        Pointer pointer = pointersState.get(pointerIndex);        pointer.setPoint(point);        pointer.setPressure(pressure);        pointer.setUp(action == MotionEvent.ACTION_UP);        int pointerCount = pointersState.update(pointerProperties, pointerCoords);        if (pointerCount == 1) {            if (action == MotionEvent.ACTION_DOWN) {                lastTouchDown = now;            }        } else {            // secondary pointers must use ACTION_POINTER_* ORed with the pointerIndex            if (action == MotionEvent.ACTION_UP) {                action = MotionEvent.ACTION_POINTER_UP | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            } else if (action == MotionEvent.ACTION_DOWN) {                action = MotionEvent.ACTION_POINTER_DOWN | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            }        }        MotionEvent event = MotionEvent.obtain(lastTouchDown, now, action, pointerCount, pointerProperties, pointerCoords, 0, buttons, 1f, 1f, 0, 0,                InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
    private boolean injectScroll(Position position, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        MotionEvent.PointerProperties props = pointerProperties[0];        props.id = 0;        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.x = point.getX();        coords.y = point.getY();        coords.setAxisValue(MotionEvent.AXIS_HSCROLL, hScroll);        coords.setAxisValue(MotionEvent.AXIS_VSCROLL, vScroll);        MotionEvent event = MotionEvent.obtain(lastTouchDown, now, MotionEvent.ACTION_SCROLL, 1, pointerProperties, pointerCoords, 0, 0, 1f, 1f, 0, 0,                InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
    public String toString() {        return "Point{"                + "x=" + x                + ", y=" + y                + '}';    }}
    public boolean equals(Object o) {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        Point point = (Point) o;        return x == point.x                && y == point.y;    }
    public String toString() {        return "Point{" + "x=" + x + ", y=" + y + '}';    }}
    public boolean equals(Object o) {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        Point point = (Point) o;        return x == point.x && y == point.y;    }
    public boolean equals(Object o) {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        Position position = (Position) o;        return Objects.equals(point, position.point)                && Objects.equals(screenSize, position.screenSize);    }
    public String toString() {        return "Position{"                + "point=" + point                + ", screenSize=" + screenSize                + '}';    }
    public boolean equals(Object o) {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        Position position = (Position) o;        return Objects.equals(point, position.point) && Objects.equals(screenSize, position.screenSize);    }
    public String toString() {        return "Position{" + "point=" + point + ", screenSize=" + screenSize + '}';    }
    private static Options createOptions(String... args) {        if (args.length < 1) {            throw new IllegalArgumentException("Missing client version");        }        String clientVersion = args[0];        if (!clientVersion.equals(BuildConfig.VERSION_NAME)) {            throw new IllegalArgumentException("The server version (" + clientVersion + ") does not match the client "                    + "(" + BuildConfig.VERSION_NAME + ")");        }        if (args.length != 8) {            throw new IllegalArgumentException("Expecting 8 parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[1]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[2]);        options.setBitRate(bitRate);        int maxFps = Integer.parseInt(args[3]);        options.setMaxFps(maxFps);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[4]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[5]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[6]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[7]);        options.setControl(control);        return options;    }
    private static Options createOptions(String... args) {        if (args.length < 1) {            throw new IllegalArgumentException("Missing client version");        }        String clientVersion = args[0];        if (!clientVersion.equals(BuildConfig.VERSION_NAME)) {            throw new IllegalArgumentException(                    "The server version (" + clientVersion + ") does not match the client " + "(" + BuildConfig.VERSION_NAME + ")");        }        if (args.length != 8) {            throw new IllegalArgumentException("Expecting 8 parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[1]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[2]);        options.setBitRate(bitRate);        int maxFps = Integer.parseInt(args[3]);        options.setMaxFps(maxFps);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[4]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[5]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[6]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[7]);        options.setControl(control);        return options;    }
    public String toString() {        return "Size{"                + "width=" + width                + ", height=" + height                + '}';    }}
    public boolean equals(Object o) {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        Size size = (Size) o;        return width == size.width                && height == size.height;    }
    public String toString() {        return "Size{" + "width=" + width + ", height=" + height + '}';    }}
    public boolean equals(Object o) {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        Size size = (Size) o;        return width == size.width && height == size.height;    }
    private static void setPrimaryClip(Method method, IInterface manager, ClipData clipData) throws InvocationTargetException,            IllegalAccessException {        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {            method.invoke(manager, clipData, PACKAGE_NAME);        } else {            method.invoke(manager, clipData, PACKAGE_NAME, USER_ID);        }    }
    private Method getSetPrimaryClipMethod() {        if (setPrimaryClipMethod == null) {            try {                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                    setPrimaryClipMethod = manager.getClass().getMethod("setPrimaryClip", ClipData.class, String.class);                } else {                    setPrimaryClipMethod = manager.getClass().getMethod("setPrimaryClip", ClipData.class,                            String.class, int.class);                }            } catch (NoSuchMethodException e) {                Ln.e("Could not find method", e);            }        }        return setPrimaryClipMethod;    }
    private static ClipData getPrimaryClip(Method method, IInterface manager) throws InvocationTargetException,            IllegalAccessException {        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {            return (ClipData) method.invoke(manager, PACKAGE_NAME);        }        return (ClipData) method.invoke(manager, PACKAGE_NAME, USER_ID);    }
    private static void setPrimaryClip(Method method, IInterface manager, ClipData clipData)            throws InvocationTargetException, IllegalAccessException {        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {            method.invoke(manager, clipData, PACKAGE_NAME);        } else {            method.invoke(manager, clipData, PACKAGE_NAME, USER_ID);        }    }
    private Method getSetPrimaryClipMethod() {        if (setPrimaryClipMethod == null) {            try {                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                    setPrimaryClipMethod = manager.getClass().getMethod("setPrimaryClip", ClipData.class, String.class);                } else {                    setPrimaryClipMethod = manager.getClass().getMethod("setPrimaryClip", ClipData.class, String.class, int.class);                }            } catch (NoSuchMethodException e) {                Ln.e("Could not find method", e);            }        }        return setPrimaryClipMethod;    }
    private static ClipData getPrimaryClip(Method method, IInterface manager) throws InvocationTargetException, IllegalAccessException {        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {            return (ClipData) method.invoke(manager, PACKAGE_NAME);        }        return (ClipData) method.invoke(manager, PACKAGE_NAME, USER_ID);    }
int main(int argc, char *argv[]) {    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        usage(argv[0]);        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    int res = scrcpy(args.serial, args.port, args.max_size, args.bit_rate) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    int res = scrcpy(args.serial, args.port, args.max_size, args.bit_rate) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(void) {    test_serialize_keycode_event();    test_serialize_text_event();    test_serialize_long_text_event();    test_serialize_mouse_event();    test_serialize_scroll_event();}
int main(void) {    test_serialize_keycode_event();    test_serialize_text_event();    test_serialize_long_text_event();    test_serialize_mouse_event();    test_serialize_scroll_event();    return 0;}
control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            buffer_write32be(&buf[2], event->keycode_event.keycode);            buffer_write32be(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (2 bytes) + string (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > TEXT_MAX_LENGTH) {                // injecting a text takes time, so limit the text length                len = TEXT_MAX_LENGTH;            }            buffer_write16be(&buf[1], (uint16_t) len);            memcpy(&buf[3], event->text_event.text, len);            return 3 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            buffer_write32be(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 18;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            buffer_write32be(&buf[13], (uint32_t) event->scroll_event.hscroll);            buffer_write32be(&buf[17], (uint32_t) event->scroll_event.vscroll);            return 21;        case CONTROL_EVENT_TYPE_COMMAND:            buf[1] = event->command_event.action;            return 2;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            buffer_write32be(&buf[2], event->keycode_event.keycode);            buffer_write32be(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (2 bytes) + string (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > CONTROL_EVENT_TEXT_MAX_LENGTH) {                // injecting a text takes time, so limit the text length                len = CONTROL_EVENT_TEXT_MAX_LENGTH;            }            buffer_write16be(&buf[1], (uint16_t) len);            memcpy(&buf[3], event->text_event.text, len);            return 3 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            buffer_write32be(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 18;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            buffer_write32be(&buf[13], (uint32_t) event->scroll_event.hscroll);            buffer_write32be(&buf[17], (uint32_t) event->scroll_event.vscroll);            return 21;        case CONTROL_EVENT_TYPE_COMMAND:            buf[1] = event->command_event.action;            return 2;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
process_event(struct controller *controller,              const struct control_event *event) {    unsigned char serialized_event[SERIALIZED_EVENT_MAX_SIZE];    int length = control_event_serialize(event, serialized_event);    if (!length) {        return false;    }    int w = net_send_all(controller->video_socket, serialized_event, length);    return w == length;}
process_event(struct controller *controller,              const struct control_event *event) {    unsigned char serialized_event[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int length = control_event_serialize(event, serialized_event);    if (!length) {        return false;    }    int w = net_send_all(controller->video_socket, serialized_event, length);    return w == length;}
static void test_serialize_long_text_event(void) {    struct control_event event;    event.type = CONTROL_EVENT_TYPE_TEXT;    char text[TEXT_MAX_LENGTH + 1];    memset(text, 'a', sizeof(text));    text[TEXT_MAX_LENGTH] = '\0';    event.text_event.text = text;    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 3 + TEXT_MAX_LENGTH);    unsigned char expected[3 + TEXT_MAX_LENGTH];    expected[0] = 0x01; // CONTROL_EVENT_TYPE_KEYCODE    expected[1] = 0x01;    expected[2] = 0x2c; // text length (16 bits)    memset(&expected[3], 'a', TEXT_MAX_LENGTH);    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_keycode_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_KEYCODE,        .keycode_event = {            .action = AKEY_EVENT_ACTION_UP,            .keycode = AKEYCODE_ENTER,            .metastate = AMETA_SHIFT_ON | AMETA_SHIFT_LEFT_ON,        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 10);    const unsigned char expected[] = {        0x00, // CONTROL_EVENT_TYPE_KEYCODE        0x01, // AKEY_EVENT_ACTION_UP        0x00, 0x00, 0x00, 0x42, // AKEYCODE_ENTER        0x00, 0x00, 0x00, 0x41, // AMETA_SHIFT_ON | AMETA_SHIFT_LEFT_ON    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_text_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_TEXT,        .text_event = {            .text = "hello, world!",        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 16);    const unsigned char expected[] = {        0x01, // CONTROL_EVENT_TYPE_KEYCODE        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_scroll_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_SCROLL,        .scroll_event = {            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },            .hscroll = 1,            .vscroll = -1,        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 21);    const unsigned char expected[] = {        0x03, // CONTROL_EVENT_TYPE_SCROLL        0x00, 0x00, 0x01, 0x04, 0x00, 0x00, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920        0x00, 0x00, 0x00, 0x01, // 1        0xFF, 0xFF, 0xFF, 0xFF, // -1    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_mouse_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_MOUSE,        .mouse_event = {            .action = AMOTION_EVENT_ACTION_DOWN,            .buttons = AMOTION_EVENT_BUTTON_PRIMARY,            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 18);    const unsigned char expected[] = {        0x02, // CONTROL_EVENT_TYPE_MOUSE        0x00, // AKEY_EVENT_ACTION_DOWN        0x00, 0x00, 0x00, 0x01, // AMOTION_EVENT_BUTTON_PRIMARY        0x00, 0x00, 0x01, 0x04, 0x00, 0x00, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_long_text_event(void) {    struct control_event event;    event.type = CONTROL_EVENT_TYPE_TEXT;    char text[CONTROL_EVENT_TEXT_MAX_LENGTH + 1];    memset(text, 'a', sizeof(text));    text[CONTROL_EVENT_TEXT_MAX_LENGTH] = '\0';    event.text_event.text = text;    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 3 + CONTROL_EVENT_TEXT_MAX_LENGTH);    unsigned char expected[3 + CONTROL_EVENT_TEXT_MAX_LENGTH];    expected[0] = 0x01; // CONTROL_EVENT_TYPE_KEYCODE    expected[1] = 0x01;    expected[2] = 0x2c; // text length (16 bits)    memset(&expected[3], 'a', CONTROL_EVENT_TEXT_MAX_LENGTH);    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_keycode_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_KEYCODE,        .keycode_event = {            .action = AKEY_EVENT_ACTION_UP,            .keycode = AKEYCODE_ENTER,            .metastate = AMETA_SHIFT_ON | AMETA_SHIFT_LEFT_ON,        },    };    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 10);    const unsigned char expected[] = {        0x00, // CONTROL_EVENT_TYPE_KEYCODE        0x01, // AKEY_EVENT_ACTION_UP        0x00, 0x00, 0x00, 0x42, // AKEYCODE_ENTER        0x00, 0x00, 0x00, 0x41, // AMETA_SHIFT_ON | AMETA_SHIFT_LEFT_ON    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_text_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_TEXT,        .text_event = {            .text = "hello, world!",        },    };    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 16);    const unsigned char expected[] = {        0x01, // CONTROL_EVENT_TYPE_KEYCODE        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_scroll_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_SCROLL,        .scroll_event = {            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },            .hscroll = 1,            .vscroll = -1,        },    };    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 21);    const unsigned char expected[] = {        0x03, // CONTROL_EVENT_TYPE_SCROLL        0x00, 0x00, 0x01, 0x04, 0x00, 0x00, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920        0x00, 0x00, 0x00, 0x01, // 1        0xFF, 0xFF, 0xFF, 0xFF, // -1    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_mouse_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_MOUSE,        .mouse_event = {            .action = AMOTION_EVENT_ACTION_DOWN,            .buttons = AMOTION_EVENT_BUTTON_PRIMARY,            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },        },    };    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 18);    const unsigned char expected[] = {        0x02, // CONTROL_EVENT_TYPE_MOUSE        0x00, // AKEY_EVENT_ACTION_DOWN        0x00, 0x00, 0x00, 0x01, // AMOTION_EVENT_BUTTON_PRIMARY        0x00, 0x00, 0x01, 0x04, 0x00, 0x00, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920    };    assert(!memcmp(buf, expected, sizeof(expected)));}
    public int getRotation() {        try {            Class<?> cls = manager.getClass();            try {                return (Integer) manager.getClass().getMethod("getRotation").invoke(manager);            } catch (NoSuchMethodException e) {                // method changed since this commit:                // https://android.googlesource.com/platform/frameworks/base/+/8ee7285128c3843401d4c4d0412cd66e86ba49e3%5E%21/#F2                return (Integer) cls.getMethod("getDefaultDisplayRotation").invoke(manager);            }        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public int getRotation() {        try {            Class<?> cls = manager.getClass();            try {                return (Integer) cls.getMethod("getRotation").invoke(manager);            } catch (NoSuchMethodException e) {                // method changed since this commit:                // https://android.googlesource.com/platform/frameworks/base/+/8ee7285128c3843401d4c4d0412cd66e86ba49e3%5E%21/#F2                return (Integer) cls.getMethod("getDefaultDisplayRotation").invoke(manager);            }        } catch (Exception e) {            throw new AssertionError(e);        }    }
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, 'T'},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, 'c'},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"push-target",           required_argument, NULL,                                                 OPT_PUSH_TARGET},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, 'f'},        {"render-expired-frames", no_argument,       NULL,                                                 OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL,                                                 OPT_WINDOW_TITLE},        {NULL,                    0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return false;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = true;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return false;                }                break;            case 'n':                args->no_control = true;                break;            case 'N':                args->no_display = true;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return false;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 'S':                args->turn_screen_off = true;                break;            case 't':                args->show_touches = true;                break;            case 'T':                args->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                args->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                args->window_title = optarg;                break;            case OPT_PUSH_TARGET:                args->push_target = optarg;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (args->no_display && !args->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (args->no_display && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return false;        }    }    if (args->no_control && args->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, 'T'},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, 'c'},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"push-target",           required_argument, NULL,                                                 OPT_PUSH_TARGET},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, 'F'},        {"render-expired-frames", no_argument,       NULL,                                                 OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL,                                                 OPT_WINDOW_TITLE},        {NULL,                    0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return false;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = true;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return false;                }                break;            case 'n':                args->no_control = true;                break;            case 'N':                args->no_display = true;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return false;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 'S':                args->turn_screen_off = true;                break;            case 't':                args->show_touches = true;                break;            case 'T':                args->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                args->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                args->window_title = optarg;                break;            case OPT_PUSH_TARGET:                args->push_target = optarg;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (args->no_display && !args->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (args->no_display && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return false;        }    }    if (args->no_control && args->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        MediaFormat format = createFormat(bitRate, frameRate, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                Rect contentRect = device.getScreenInfo().getContentRect();                Rect videoRect = device.getScreenInfo().getVideoSize().toRect();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, contentRect, videoRect);                codec.start();                try {                    alive = encode(codec, fd);                } finally {                    codec.stop();                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        MediaFormat format = createFormat(bitRate, frameRate, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                Rect contentRect = device.getScreenInfo().getContentRect();                Rect videoRect = device.getScreenInfo().getVideoSize().toRect();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, contentRect, videoRect);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
static int read_packet_with_meta(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    struct receiver_state *state = &decoder->receiver_state;    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    if (!state->remaining) {#define HEADER_SIZE 12        uint8_t header[HEADER_SIZE];        ssize_t ret = net_recv_all(decoder->video_socket, header, HEADER_SIZE);        if (ret <= 0) {            return ret;        }        // no partial read (net_recv_all())        SDL_assert_release(ret == HEADER_SIZE);        uint64_t pts = buffer_read64be(header);        state->remaining = buffer_read32be(&header[8]);        if (pts != NO_PTS && !receiver_state_push_meta(state, pts)) {            LOGE("Could not store PTS for recording");            // we cannot save the PTS, the recording would be broken            return -1;        }    }    SDL_assert(state->remaining);    if (buf_size > state->remaining)        buf_size = state->remaining;    ssize_t ret = net_recv(decoder->video_socket, buf, buf_size);    if (ret <= 0) {        return ret;    }    SDL_assert(state->remaining >= ret);    state->remaining -= ret;    return ret;}
static int read_raw_packet(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    return net_recv(decoder->video_socket, buf, buf_size);}
static int read_packet_with_meta(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    struct receiver_state *state = &decoder->receiver_state;    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    if (!state->remaining) {#define HEADER_SIZE 12        uint8_t header[HEADER_SIZE];        ssize_t r = net_recv_all(decoder->video_socket, header, HEADER_SIZE);        if (r == -1) {            return AVERROR(errno);        }        if (r == 0) {            return AVERROR_EOF;        }        // no partial read (net_recv_all())        SDL_assert_release(r == HEADER_SIZE);        uint64_t pts = buffer_read64be(header);        state->remaining = buffer_read32be(&header[8]);        if (pts != NO_PTS && !receiver_state_push_meta(state, pts)) {            LOGE("Could not store PTS for recording");            // we cannot save the PTS, the recording would be broken            return AVERROR(ENOMEM);        }    }    SDL_assert(state->remaining);    if (buf_size > state->remaining)        buf_size = state->remaining;    ssize_t r = net_recv(decoder->video_socket, buf, buf_size);    if (r == -1) {        return AVERROR(errno);    }    if (r == 0) {        return AVERROR_EOF;    }    SDL_assert(state->remaining >= r);    state->remaining -= r;    return r;}
static int read_raw_packet(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    ssize_t r = net_recv(decoder->video_socket, buf, buf_size);    if (r == -1) {        return AVERROR(errno);    }    if (r == 0) {        return AVERROR_EOF;    }    return r;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    SDL_bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!video_buffer_init(&video_buffer)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_video_buffer;    }    decoder_init(&decoder, &video_buffer);    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, &decoder, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_stream;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size, options->always_on_top)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_stream:    stream_stop(&stream);    // stop the server before stream_join() to wake up the stream    server_stop(&server);    stream_join(&stream);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_video_buffer:    video_buffer_destroy(&video_buffer);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    SDL_bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    SDL_bool display = !options->no_window;    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            server_stop(&server);            ret = SDL_FALSE;            goto finally_destroy_server;        }        if (!file_handler_init(&file_handler, server.serial)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_video_buffer;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (display) {        if (!controller_init(&controller, device_socket)) {            ret = SDL_FALSE;            goto finally_stop_stream;        }        if (!controller_start(&controller)) {            ret = SDL_FALSE;            goto finally_destroy_controller;        }        if (!screen_init_rendering(&screen, device_name, frame_size, options->always_on_top)) {            ret = SDL_FALSE;            goto finally_stop_and_join_controller;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    if (display) {        controller_stop(&controller);        controller_join(&controller);    }finally_destroy_controller:    if (display) {        controller_destroy(&controller);    }finally_stop_stream:    stream_stop(&stream);    // stop the server before stream_join() to wake up the stream    server_stop(&server);    stream_join(&stream);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    if (display) {        file_handler_stop(&file_handler);        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }finally_destroy_video_buffer:    if (display) {        video_buffer_destroy(&video_buffer);    }finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet) && !avio_ctx->eof_reached) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        if ((ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame)) < 0) {            LOGE("Could not receive video frame: %d", ret);            goto run_quit;        }        push_frame(decoder);#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif    }    LOGD("End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet) && !avio_ctx->eof_reached) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif    }    LOGD("End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, OPT_CROP},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"push-target",           required_argument, NULL, OPT_PUSH_TARGET},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, OPT_RECORD_FORMAT},        {"render-expired-frames", no_argument,       NULL,                                                     OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"prefer-text",           no_argument,       NULL, OPT_PREFER_TEXT},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",              required_argument, NULL, OPT_WINDOW_X},        {"window-y",              required_argument, NULL, OPT_WINDOW_Y},        {"window-width",          required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",         required_argument, NULL, OPT_WINDOW_HEIGHT},        {NULL,                    0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port(optarg, &opts->port)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
static void usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is -1 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, OPT_CROP},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"push-target",           required_argument, NULL, OPT_PUSH_TARGET},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, OPT_RECORD_FORMAT},        {"render-expired-frames", no_argument,       NULL,                                                     OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"prefer-text",           no_argument,       NULL, OPT_PREFER_TEXT},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",              required_argument, NULL, OPT_WINDOW_X},        {"window-y",              required_argument, NULL, OPT_WINDOW_Y},        {"window-width",          required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",         required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",     no_argument,       NULL,                                                     OPT_WINDOW_BORDERLESS},        {NULL,                    0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port(optarg, &opts->port)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
static void usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is -1 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height) {    screen->frame_size = frame_size;    struct size window_size =        get_initial_optimal_size(frame_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    int x = window_x != -1 ? window_x : SDL_WINDOWPOS_UNDEFINED;    int y = window_y != -1 ? window_y : SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height) {    screen->frame_size = frame_size;    struct size window_size =        get_initial_optimal_size(frame_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    int x = window_x != -1 ? window_x : SDL_WINDOWPOS_UNDEFINED;    int y = window_y != -1 ? window_y : SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless) {    screen->frame_size = frame_size;    struct size window_size =        get_initial_optimal_size(frame_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != -1 ? window_x : SDL_WINDOWPOS_UNDEFINED;    int y = window_y != -1 ? window_y : SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;    return true;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top,                      int16_t window_x, int16_t window_y, uint16_t window_width,                      uint16_t window_height, bool window_borderless) {    screen->frame_size = frame_size;    struct size window_size =        get_initial_optimal_size(frame_size, window_width, window_height);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    if (window_borderless) {        window_flags |= SDL_WINDOW_BORDERLESS;    }    int x = window_x != -1 ? window_x : SDL_WINDOWPOS_UNDEFINED;    int y = window_y != -1 ? window_y : SDL_WINDOWPOS_UNDEFINED;    screen->window = SDL_CreateWindow(window_title, x, y,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    screen->windowed_window_size = window_size;
    public boolean readFrom(InputStream input) throws IOException {        if (isFull()) {            throw new IllegalStateException("Buffer full, call next() to consume");        }        buffer.compact();        int head = buffer.position();        int r = input.read(rawBuffer, head, rawBuffer.length - head);        if (r == -1) {            return false;        }        buffer.position(head + r);        buffer.flip();        return true;    }
    public void readFrom(InputStream input) throws IOException {        if (isFull()) {            throw new IllegalStateException("Buffer full, call next() to consume");        }        buffer.compact();        int head = buffer.position();        int r = input.read(rawBuffer, head, rawBuffer.length - head);        if (r == -1) {            throw new EOFException("Event controller socket closed");        }        buffer.position(head + r);        buffer.flip();    }
    public static void main(String... args) throws Exception {        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {            @Override            public void uncaughtException(Thread t, Throwable e) {                if (e instanceof AssertionError && e.getCause() instanceof InvocationTargetException) {                    // WORKAROUND                    // When we call a method of the framework by reflection, it may throw an InvocationTargetException                    // (that we wrap into an AssertionError) if this process is being killed.                    // To avoid the stacktrace on close, do not log these errors.                    return;                }                Ln.e("Exception on thread " + t, e);            }        });        Options options = createOptions(args);        scrcpy(options);    }}
        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {            @Override            public void uncaughtException(Thread t, Throwable e) {                Ln.e("Exception on thread " + t, e);            }        });        Options options = createOptions(args);        scrcpy(options);    }}
static void event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, screen.window);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return;            case SDL_QUIT:                LOGD("User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;                }                break;            case SDL_TEXTINPUT: {                input_manager_process_text_input(&input_manager, &event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL: {                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                input_manager_process_mouse_button(&input_manager, &event.button);                break;            }        }    }}
static int event_watcher(void* data, SDL_Event* event) {    if (event->type == SDL_WINDOWEVENT && event->window.event == SDL_WINDOWEVENT_RESIZED) {        // called from another thread, not very safe, but it's a workaround!        screen_render(&screen);    }    return 0;}#endif
static void event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return;            case SDL_QUIT:                LOGD("User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;                }                break;            case SDL_TEXTINPUT: {                input_manager_process_text_input(&input_manager, &event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL: {                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                input_manager_process_mouse_button(&input_manager, &event.button);                break;            }        }    }}
static int event_watcher(void *data, SDL_Event *event) {    if (event->type == SDL_WINDOWEVENT && event->window.event == SDL_WINDOWEVENT_RESIZED) {        // called from another thread, not very safe, but it's a workaround!        screen_render(&screen);    }    return 0;}#endif
    public static IBinder getBuiltInDisplay(int builtInDisplayId) {        try {            // the method signature has changed in Android Q            // <https://github.com/Genymobile/scrcpy/issues/586>            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                return (IBinder) CLASS.getMethod("getBuiltInDisplay", int.class).invoke(null, builtInDisplayId);            } else {                return (IBinder) CLASS.getMethod("getPhysicalDisplayToken", long.class).invoke(null, builtInDisplayId);            }        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public static IBinder getBuiltInDisplay(int builtInDisplayId) {        try {            // the method signature has changed in Android Q            // <https://github.com/Genymobile/scrcpy/issues/586>            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                return (IBinder) CLASS.getMethod("getBuiltInDisplay", int.class).invoke(null, builtInDisplayId);            }            return (IBinder) CLASS.getMethod("getPhysicalDisplayToken", long.class).invoke(null, builtInDisplayId);        } catch (Exception e) {            throw new AssertionError(e);        }    }
void input_manager_process_mouse_wheel(struct input_manager *input_manager,                                       const SDL_MouseWheelEvent *event) {    struct position position = {        .screen_size = input_manager->screen->frame_size,        .point = get_mouse_point(input_manager->screen),    };    struct control_event control_event;    if (mouse_wheel_from_sdl_to_android(event, position, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send wheel button event");        }    }}
void input_manager_process_mouse_wheel(struct input_manager *input_manager,                                       const SDL_MouseWheelEvent *event) {    struct position position = {        .screen_size = input_manager->screen->frame_size,        .point = get_mouse_point(input_manager->screen),    };    struct control_event control_event;    if (mouse_wheel_from_sdl_to_android(event, position, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send mouse wheel event");        }    }}
static void test_control_event_queue_push_take(void) {    struct control_event_queue queue;    SDL_bool init_ok = control_event_queue_init(&queue);    assert(init_ok);    struct control_event event = {        .type = CONTROL_EVENT_TYPE_KEYCODE,        .keycode_event = {            .action = AKEY_EVENT_ACTION_DOWN,            .keycode = AKEYCODE_ENTER,            .metastate = AMETA_CTRL_LEFT_ON | AMETA_CTRL_ON,        },    };    SDL_bool push1_ok = control_event_queue_push(&queue, &event);    assert(push1_ok);    event = (struct control_event) {        .type = CONTROL_EVENT_TYPE_TEXT,        .text_event = {            .text = "abc",        },    };    SDL_bool push2_ok = control_event_queue_push(&queue, &event);    assert(push2_ok);    // overwrite event    SDL_bool take1_ok = control_event_queue_take(&queue, &event);    assert(take1_ok);    assert(event.type == CONTROL_EVENT_TYPE_KEYCODE);    assert(event.keycode_event.action == AKEY_EVENT_ACTION_DOWN);    assert(event.keycode_event.keycode == AKEYCODE_ENTER);    assert(event.keycode_event.metastate == (AMETA_CTRL_LEFT_ON | AMETA_CTRL_ON));    // overwrite event    SDL_bool take2_ok = control_event_queue_take(&queue, &event);    assert(take2_ok);    assert(event.type == CONTROL_EVENT_TYPE_TEXT);    assert(!strcmp(event.text_event.text, "abc"));    control_event_queue_destroy(&queue);}
static void test_control_event_queue_empty(void) {    struct control_event_queue queue;    SDL_bool init_ok = control_event_queue_init(&queue);    assert(init_ok);    assert(control_event_queue_is_empty(&queue));    struct control_event dummy_event;    SDL_bool push_ok = control_event_queue_push(&queue, &dummy_event);    assert(push_ok);    assert(!control_event_queue_is_empty(&queue));    SDL_bool take_ok = control_event_queue_take(&queue, &dummy_event);    assert(take_ok);    assert(control_event_queue_is_empty(&queue));    SDL_bool take_empty_ok = control_event_queue_take(&queue, &dummy_event);    assert(!take_empty_ok); // the queue is empty    control_event_queue_destroy(&queue);}
static void test_control_event_queue_full(void) {    struct control_event_queue queue;    SDL_bool init_ok = control_event_queue_init(&queue);    assert(init_ok);    assert(!control_event_queue_is_full(&queue));    struct control_event dummy_event;    // fill the queue    while (control_event_queue_push(&queue, &dummy_event));    SDL_bool take_ok = control_event_queue_take(&queue, &dummy_event);    assert(take_ok);    assert(!control_event_queue_is_full(&queue));    control_event_queue_destroy(&queue);}
static void test_control_event_queue_push_take(void) {    struct control_event_queue queue;    bool init_ok = control_event_queue_init(&queue);    assert(init_ok);    struct control_event event = {        .type = CONTROL_EVENT_TYPE_KEYCODE,        .keycode_event = {            .action = AKEY_EVENT_ACTION_DOWN,            .keycode = AKEYCODE_ENTER,            .metastate = AMETA_CTRL_LEFT_ON | AMETA_CTRL_ON,        },    };    bool push1_ok = control_event_queue_push(&queue, &event);    assert(push1_ok);    event = (struct control_event) {        .type = CONTROL_EVENT_TYPE_TEXT,        .text_event = {            .text = "abc",        },    };    bool push2_ok = control_event_queue_push(&queue, &event);    assert(push2_ok);    // overwrite event    bool take1_ok = control_event_queue_take(&queue, &event);    assert(take1_ok);    assert(event.type == CONTROL_EVENT_TYPE_KEYCODE);    assert(event.keycode_event.action == AKEY_EVENT_ACTION_DOWN);    assert(event.keycode_event.keycode == AKEYCODE_ENTER);    assert(event.keycode_event.metastate == (AMETA_CTRL_LEFT_ON | AMETA_CTRL_ON));    // overwrite event    bool take2_ok = control_event_queue_take(&queue, &event);    assert(take2_ok);    assert(event.type == CONTROL_EVENT_TYPE_TEXT);    assert(!strcmp(event.text_event.text, "abc"));    control_event_queue_destroy(&queue);}
static void test_control_event_queue_empty(void) {    struct control_event_queue queue;    bool init_ok = control_event_queue_init(&queue);    assert(init_ok);    assert(control_event_queue_is_empty(&queue));    struct control_event dummy_event;    bool push_ok = control_event_queue_push(&queue, &dummy_event);    assert(push_ok);    assert(!control_event_queue_is_empty(&queue));    bool take_ok = control_event_queue_take(&queue, &dummy_event);    assert(take_ok);    assert(control_event_queue_is_empty(&queue));    bool take_empty_ok = control_event_queue_take(&queue, &dummy_event);    assert(!take_empty_ok); // the queue is empty    control_event_queue_destroy(&queue);}
static void test_control_event_queue_full(void) {    struct control_event_queue queue;    bool init_ok = control_event_queue_init(&queue);    assert(init_ok);    assert(!control_event_queue_is_full(&queue));    struct control_event dummy_event;    // fill the queue    while (control_event_queue_push(&queue, &dummy_event));    bool take_ok = control_event_queue_take(&queue, &dummy_event);    assert(take_ok);    assert(!control_event_queue_is_full(&queue));    control_event_queue_destroy(&queue);}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .send_frame_meta = record,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!video_buffer_init(&video_buffer, options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            if (!controller_start(&controller)) {                goto end;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Cannot request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .send_frame_meta = record,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!video_buffer_init(&video_buffer, options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Cannot request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
static void push_frame(struct decoder *decoder) {    struct frames *frames = decoder->frames;    mutex_lock(frames->mutex);    if (!decoder->skip_frames) {        while (!frames->rendering_frame_consumed) {            cond_wait(frames->rendering_frame_consumed_cond, frames->mutex);        }    } else if (!frames->rendering_frame_consumed) {        SDL_LogInfo(SDL_LOG_CATEGORY_RENDER, "Skip frame");    }    frames_swap(frames);    frames->rendering_frame_consumed = SDL_FALSE;    mutex_unlock(frames->mutex);    static SDL_Event new_frame_event = {        .type = EVENT_NEW_FRAME,    };    SDL_PushEvent(&new_frame_event);}
static void push_frame(struct decoder *decoder) {    struct frames *frames = decoder->frames;    mutex_lock(frames->mutex);#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then the decoder must wait for the current    // frame to be consumed    while (!frames->rendering_frame_consumed) {        cond_wait(frames->rendering_frame_consumed_cond, frames->mutex);    }#else    if (!frames->rendering_frame_consumed) {        SDL_LogInfo(SDL_LOG_CATEGORY_RENDER, "Skip frame");    }#endif    frames_swap(frames);    frames->rendering_frame_consumed = SDL_FALSE;    mutex_unlock(frames->mutex);    static SDL_Event new_frame_event = {        .type = EVENT_NEW_FRAME,    };    SDL_PushEvent(&new_frame_event);}
void frames_destroy(struct frames *frames) {    SDL_DestroyCond(frames->rendering_frame_consumed_cond);    SDL_DestroyMutex(frames->mutex);    av_frame_free(&frames->rendering_frame);    av_frame_free(&frames->decoding_frame);}
SDL_bool frames_init(struct frames *frames) {    if (!(frames->decoding_frame = av_frame_alloc())) {        goto error_0;    }    if (!(frames->rendering_frame = av_frame_alloc())) {        goto error_1;    }    if (!(frames->mutex = SDL_CreateMutex())) {        goto error_2;    }    if (!(frames->rendering_frame_consumed_cond = SDL_CreateCond())) {        goto error_3;    }    frames->rendering_frame_consumed = SDL_TRUE;    return SDL_TRUE;error_3:    SDL_DestroyMutex(frames->mutex);error_2:    av_frame_free(&frames->rendering_frame);error_1:    av_frame_free(&frames->decoding_frame);error_0:    return SDL_FALSE;}
void frames_destroy(struct frames *frames) {#ifndef SKIP_FRAMES    SDL_DestroyCond(frames->rendering_frame_consumed_cond);#endif    SDL_DestroyMutex(frames->mutex);    av_frame_free(&frames->rendering_frame);    av_frame_free(&frames->decoding_frame);}
SDL_bool frames_init(struct frames *frames) {    if (!(frames->decoding_frame = av_frame_alloc())) {        goto error_0;    }    if (!(frames->rendering_frame = av_frame_alloc())) {        goto error_1;    }    if (!(frames->mutex = SDL_CreateMutex())) {        goto error_2;    }#ifndef SKIP_FRAMES    if (!(frames->rendering_frame_consumed_cond = SDL_CreateCond())) {        SDL_DestroyMutex(frames->mutex);        goto error_2;    }#endif    frames->rendering_frame_consumed = SDL_TRUE;    return SDL_TRUE;error_2:    av_frame_free(&frames->rendering_frame);error_1:    av_frame_free(&frames->decoding_frame);error_0:    return SDL_FALSE;}
static SDL_bool handle_new_frame(void) {    mutex_lock(frames.mutex);    AVFrame *frame = frames.rendering_frame;    frames.rendering_frame_consumed = SDL_TRUE;    if (!decoder.skip_frames) {        cond_signal(frames.rendering_frame_consumed_cond);    }    struct size current_frame_size = {frame->width, frame->height};    if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {        return SDL_FALSE;    }    frame_size = current_frame_size;    update_texture(frame, texture);    mutex_unlock(frames.mutex);    render(renderer, texture);    return SDL_TRUE;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    SDL_bool ret = SDL_TRUE;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, max_size, bit_rate);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }#if SDL_VERSION_ATLEAST(2, 0, 5)    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable mouse focus clickthrough");    }#endif    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not load icon: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_SetWindowIcon(window, icon);    SDL_FreeSurface(icon);    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
static SDL_bool handle_new_frame(void) {    mutex_lock(frames.mutex);    AVFrame *frame = frames.rendering_frame;    frames.rendering_frame_consumed = SDL_TRUE;#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then notify the decoder the current frame is    // consumed, so that it may push a new one    cond_signal(frames.rendering_frame_consumed_cond);#endif    struct size current_frame_size = {frame->width, frame->height};    if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {        return SDL_FALSE;    }    frame_size = current_frame_size;    update_texture(frame, texture);    mutex_unlock(frames.mutex);    render(renderer, texture);    return SDL_TRUE;}
}SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    SDL_bool ret = SDL_TRUE;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, max_size, bit_rate);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }#if SDL_VERSION_ATLEAST(2, 0, 5)    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable mouse focus clickthrough");    }#endif    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not load icon: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_SetWindowIcon(window, icon);    SDL_FreeSurface(icon);    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
int main(int argc, char *argv[]) {    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        usage(argv[0]);        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    int res = scrcpy(args.serial, args.port, args.max_size, args.bit_rate) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        usage(argv[0]);        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    int res = scrcpy(args.serial, args.port, args.max_size, args.bit_rate) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        usage(argv[0]);        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    int res = scrcpy(args.serial, args.port, args.max_size, args.bit_rate) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"bit-rate", required_argument, NULL, 'b'},        {"help",     no_argument,       NULL, 'h'},        {"max-size", required_argument, NULL, 'm'},        {"port",     required_argument, NULL, 'p'},        {"version",  no_argument,       NULL, 'v'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:hm:p:v", long_options, NULL)) != -1) {        switch (c) {            case 'b': {                char *endptr;                if (*optarg == '\0') {                    LOGE("Bit-rate parameter is empty");                    return SDL_FALSE;                }                long value = strtol(optarg, &endptr, 0);                int mul = 1;                if (*endptr != '\0') {                    if (optarg == endptr) {                        LOGE("Invalid bit-rate: %s", optarg);                        return SDL_FALSE;                    }                    if ((*endptr == 'M' || *endptr == 'm') && endptr[1] == '\0') {                        mul = 1000000;                    } else if ((*endptr == 'K' || *endptr == 'k') && endptr[1] == '\0') {                        mul = 1000;                    } else {                        LOGE("Invalid bit-rate unit: %s", optarg);                        return SDL_FALSE;                    }                }                if (value < 0 || ((Uint32) -1) / mul < value) {                    LOGE("Bitrate must be positive and less than 2^32: %s", optarg);                    return SDL_FALSE;                }                args->bit_rate = (Uint32) value * mul;                break;            }            case 'h': {                args->help = SDL_TRUE;                break;            }            case 'm': {                char *endptr;                if (*optarg == '\0') {                    LOGE("Max size parameter is empty");                    return SDL_FALSE;                }                long value = strtol(optarg, &endptr, 0);                if (*endptr != '\0') {                    LOGE("Invalid max size: %s", optarg);                    return SDL_FALSE;                }                if (value & ~0xffff) {                    LOGE("Max size must be between 0 and 65535: %ld", value);                    return SDL_FALSE;                }                args->max_size = (Uint16) value;                break;            }            case 'p': {                char *endptr;                if (*optarg == '\0') {                    LOGE("Invalid port parameter is empty");                    return SDL_FALSE;                }                long value = strtol(optarg, &endptr, 0);                if (*endptr != '\0') {                    LOGE("Invalid port: %s", optarg);                    return SDL_FALSE;                }                if (value & ~0xffff) {                    LOGE("Port out of range: %ld", value);                    return SDL_FALSE;                }                args->port = (Uint16) value;                break;            }            case 'v': {                args->version = SDL_TRUE;                break;            }            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    return SDL_TRUE;}
static SDL_bool parse_port(char *optarg, Uint16 *port) {    char *endptr;    if (*optarg == '\0') {        LOGE("Invalid port parameter is empty");        return SDL_FALSE;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid port: %s", optarg);        return SDL_FALSE;    }    if (value & ~0xffff) {        LOGE("Port out of range: %ld", value);        return SDL_FALSE;    }    *port = (Uint16) value;    return SDL_TRUE;}
static SDL_bool parse_bit_rate(char *optarg, Uint32 *bit_rate) {    char *endptr;    if (*optarg == '\0') {        LOGE("Bit-rate parameter is empty");        return SDL_FALSE;    }    long value = strtol(optarg, &endptr, 0);    int mul = 1;    if (*endptr != '\0') {        if (optarg == endptr) {            LOGE("Invalid bit-rate: %s", optarg);            return SDL_FALSE;        }        if ((*endptr == 'M' || *endptr == 'm') && endptr[1] == '\0') {            mul = 1000000;        } else if ((*endptr == 'K' || *endptr == 'k') && endptr[1] == '\0') {            mul = 1000;        } else {            LOGE("Invalid bit-rate unit: %s", optarg);            return SDL_FALSE;        }    }    if (value < 0 || ((Uint32) -1) / mul < value) {        LOGE("Bitrate must be positive and less than 2^32: %s", optarg);        return SDL_FALSE;    }    *bit_rate = (Uint32) value * mul;    return SDL_TRUE;}
static SDL_bool parse_max_size(char *optarg, Uint16 *max_size) {    char *endptr;    if (*optarg == '\0') {        LOGE("Max size parameter is empty");        return SDL_FALSE;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid max size: %s", optarg);        return SDL_FALSE;    }    if (value & ~0xffff) {        LOGE("Max size must be between 0 and 65535: %ld", value);        return SDL_FALSE;    }    *max_size = (Uint16) value;    return SDL_TRUE;}
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"bit-rate", required_argument, NULL, 'b'},        {"help",     no_argument,       NULL, 'h'},        {"max-size", required_argument, NULL, 'm'},        {"port",     required_argument, NULL, 'p'},        {"version",  no_argument,       NULL, 'v'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:hm:p:v", long_options, NULL)) != -1) {        switch (c) {            case 'b': {                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            }            case 'h': {                args->help = SDL_TRUE;                break;            }            case 'm': {                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            }            case 'p': {                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            }            case 'v': {                args->version = SDL_TRUE;                break;            }            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    return SDL_TRUE;}
    private static Options createOptions(String... args) {        Options options = new Options();        if (args.length < 1) {            return options;        }        int maxSize = Integer.parseInt(args[0]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        if (args.length < 2) {            return options;        }        int bitRate = Integer.parseInt(args[1]);        options.setBitRate(bitRate);        if (args.length < 3) {            return options;        }        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[2]);        options.setTunnelForward(tunnelForward);        if (args.length < 4) {            return options;        }        Rect crop = parseCrop(args[3]);        options.setCrop(crop);        if (args.length < 5) {            return options;        }        boolean sendFrameMeta = Boolean.parseBoolean(args[4]);        options.setSendFrameMeta(sendFrameMeta);        return options;    }
    private static Options createOptions(String... args) {        if (args.length != 5)            throw new IllegalArgumentException("Expecting 5 parameters");        Options options = new Options();        int maxSize = Integer.parseInt(args[0]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[1]);        options.setBitRate(bitRate);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[2]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[3]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[4]);        options.setSendFrameMeta(sendFrameMeta);        return options;    }
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top", no_argument,       NULL, 'T'},        {"bit-rate",      required_argument, NULL, 'b'},        {"crop",          required_argument, NULL, 'c'},        {"fullscreen",    no_argument,       NULL, 'f'},        {"help",          no_argument,       NULL, 'h'},        {"max-size",      required_argument, NULL, 'm'},        {"port",          required_argument, NULL, 'p'},        {"record",        required_argument, NULL, 'r'},        {"record-format", required_argument, NULL, 'f'},        {"serial",        required_argument, NULL, 's'},        {"show-touches",  no_argument,       NULL, 't'},        {"version",       no_argument,       NULL, 'v'},        {NULL,            0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:p:r:s:tTv", long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = SDL_TRUE;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return SDL_FALSE;                }                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = SDL_TRUE;                break;            case 'T':                args->always_on_top = SDL_TRUE;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return SDL_FALSE;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return SDL_FALSE;        }    }    return SDL_TRUE;}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .record_format = 0,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = SDL_FALSE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top", no_argument,       NULL, 'T'},        {"bit-rate",      required_argument, NULL, 'b'},        {"crop",          required_argument, NULL, 'c'},        {"fullscreen",    no_argument,       NULL, 'f'},        {"help",          no_argument,       NULL, 'h'},        {"max-size",      required_argument, NULL, 'm'},        {"no-window",     no_argument,       NULL, 'n'},        {"port",          required_argument, NULL, 'p'},        {"record",        required_argument, NULL, 'r'},        {"record-format", required_argument, NULL, 'f'},        {"serial",        required_argument, NULL, 's'},        {"show-touches",  no_argument,       NULL, 't'},        {"version",       no_argument,       NULL, 'v'},        {NULL,            0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:np:r:s:tTv", long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = SDL_TRUE;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return SDL_FALSE;                }                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'n':                args->no_window = SDL_TRUE;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = SDL_TRUE;                break;            case 'T':                args->always_on_top = SDL_TRUE;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    if (args->no_window && !args->record_filename) {        LOGE("-n/--no-window requires screen recording (-r/--record)");        return SDL_FALSE;    }    if (args->no_window && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -n/--no-window");        return SDL_FALSE;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return SDL_FALSE;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return SDL_FALSE;        }    }    return SDL_TRUE;}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .record_format = 0,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = SDL_FALSE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,        .no_window = args.no_window,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-window\n"        "        Do not show window (only when screen recording is enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
process_t push_server(const char *serial) {    const char *apk_path = getenv("SCRCPY_APK");    if (!apk_path) {        apk_path = "scrcpy.apk";    }    return adb_push(serial, apk_path, "/data/local/tmp/");}
process_t push_server(const char *serial) {    const char *apk_path = getenv("SCRCPY_APK");    if (!apk_path) {        apk_path = "scrcpy.apk";    }    return adb_push(serial, apk_path, "/data/local/tmp/scrcpy.apk");}
void decoder_stop(struct decoder *decoder) {    video_buffer_stop(decoder->video_buffer);}
void decoder_stop(struct decoder *decoder) {    video_buffer_interrupt(decoder->video_buffer);}
void video_buffer_stop(struct video_buffer *vb) {#ifdef SKIP_FRAMES    (void) vb; // unused#else    mutex_lock(vb->mutex);    vb->stopped = SDL_TRUE;    mutex_unlock(vb->mutex);    // wake up blocking wait    cond_signal(vb->rendering_frame_consumed_cond);#endif}
SDL_bool video_buffer_offer_decoded_frame(struct video_buffer *vb) {    mutex_lock(vb->mutex);#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then the decoder must wait for the current    // frame to be consumed    while (!vb->rendering_frame_consumed && !vb->stopped) {        cond_wait(vb->rendering_frame_consumed_cond, vb->mutex);    }#else    if (vb->fps_counter.started && !vb->rendering_frame_consumed) {        fps_counter_add_skipped_frame(&vb->fps_counter);    }#endif    video_buffer_swap_frames(vb);    SDL_bool previous_frame_consumed = vb->rendering_frame_consumed;    vb->rendering_frame_consumed = SDL_FALSE;    mutex_unlock(vb->mutex);    return previous_frame_consumed;}
SDL_bool video_buffer_init(struct video_buffer *vb) {    if (!(vb->decoding_frame = av_frame_alloc())) {        goto error_0;    }    if (!(vb->rendering_frame = av_frame_alloc())) {        goto error_1;    }    if (!(vb->mutex = SDL_CreateMutex())) {        goto error_2;    }#ifndef SKIP_FRAMES    if (!(vb->rendering_frame_consumed_cond = SDL_CreateCond())) {        SDL_DestroyMutex(vb->mutex);        goto error_2;    }    vb->stopped = SDL_FALSE;#endif    // there is initially no rendering frame, so consider it has already been    // consumed    vb->rendering_frame_consumed = SDL_TRUE;    fps_counter_init(&vb->fps_counter);    return SDL_TRUE;error_2:    av_frame_free(&vb->rendering_frame);error_1:    av_frame_free(&vb->decoding_frame);error_0:    return SDL_FALSE;}
SDL_bool video_buffer_init(struct video_buffer *vb) {    if (!(vb->decoding_frame = av_frame_alloc())) {        goto error_0;    }    if (!(vb->rendering_frame = av_frame_alloc())) {        goto error_1;    }    if (!(vb->mutex = SDL_CreateMutex())) {        goto error_2;    }#ifndef SKIP_FRAMES    if (!(vb->rendering_frame_consumed_cond = SDL_CreateCond())) {        SDL_DestroyMutex(vb->mutex);        goto error_2;    }    vb->stopped = SDL_FALSE;#endif    // there is initially no rendering frame, so consider it has already been    // consumed    vb->rendering_frame_consumed = SDL_TRUE;    fps_counter_init(&vb->fps_counter);    return SDL_TRUE;error_2:    av_frame_free(&vb->rendering_frame);error_1:    av_frame_free(&vb->decoding_frame);error_0:    return SDL_FALSE;}
void video_buffer_interrupt(struct video_buffer *vb) {#ifdef SKIP_FRAMES    (void) vb; // unused#else    mutex_lock(vb->mutex);    vb->interrupted = SDL_TRUE;    mutex_unlock(vb->mutex);    // wake up blocking wait    cond_signal(vb->rendering_frame_consumed_cond);#endif}
SDL_bool video_buffer_offer_decoded_frame(struct video_buffer *vb) {    mutex_lock(vb->mutex);#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then the decoder must wait for the current    // frame to be consumed    while (!vb->rendering_frame_consumed && !vb->interrupted) {        cond_wait(vb->rendering_frame_consumed_cond, vb->mutex);    }#else    if (vb->fps_counter.started && !vb->rendering_frame_consumed) {        fps_counter_add_skipped_frame(&vb->fps_counter);    }#endif    video_buffer_swap_frames(vb);    SDL_bool previous_frame_consumed = vb->rendering_frame_consumed;    vb->rendering_frame_consumed = SDL_FALSE;    mutex_unlock(vb->mutex);    return previous_frame_consumed;}
SDL_bool video_buffer_init(struct video_buffer *vb) {    if (!(vb->decoding_frame = av_frame_alloc())) {        goto error_0;    }    if (!(vb->rendering_frame = av_frame_alloc())) {        goto error_1;    }    if (!(vb->mutex = SDL_CreateMutex())) {        goto error_2;    }#ifndef SKIP_FRAMES    if (!(vb->rendering_frame_consumed_cond = SDL_CreateCond())) {        SDL_DestroyMutex(vb->mutex);        goto error_2;    }    vb->interrupted = SDL_FALSE;#endif    // there is initially no rendering frame, so consider it has already been    // consumed    vb->rendering_frame_consumed = SDL_TRUE;    fps_counter_init(&vb->fps_counter);    return SDL_TRUE;error_2:    av_frame_free(&vb->rendering_frame);error_1:    av_frame_free(&vb->decoding_frame);error_0:    return SDL_FALSE;}
void video_buffer_interrupt(struct video_buffer *vb) {#ifdef SKIP_FRAMES    (void) vb; // unused#else    mutex_lock(vb->mutex);    vb->interrupted = SDL_TRUE;    mutex_unlock(vb->mutex);    // wake up blocking wait    cond_signal(vb->rendering_frame_consumed_cond);#endif}
    public static void main(String... args) throws Exception {        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {            @Override            public void uncaughtException(Thread t, Throwable e) {                Ln.e("Exception on thread " + t, e);            }        });        unlinkSelf();        Options options = createOptions(args);        scrcpy(options);    }}
    public static void main(String... args) throws Exception {        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {            @Override            public void uncaughtException(Thread t, Throwable e) {                Ln.e("Exception on thread " + t, e);            }        });        unlinkSelf();        Options options = createOptions(args);        scrcpy(options);    }}
    public static void main(String... args) throws Exception {        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {            @Override            public void uncaughtException(Thread t, Throwable e) {                Ln.e("Exception on thread " + t, e);                suggestFix(e);            }        });        unlinkSelf();        Options options = createOptions(args);        scrcpy(options);    }}
    private static void suggestFix(Throwable e) {        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {            if (e instanceof MediaCodec.CodecException) {                MediaCodec.CodecException mce = (MediaCodec.CodecException) e;                if (mce.getErrorCode() == 0xfffffc0e) {                    Ln.e("The hardware encoder is not able to encode at the given definition.");                    Ln.e("Try with a lower definition:");                    Ln.e("    scrcpy -m 1024");                }            }        }    }
    public static void d(String message) {        if (isEnabled(Level.DEBUG)) {            Log.d(TAG, message);            System.out.println("DEBUG: " + message);        }    }
    public static void w(String message) {        if (isEnabled(Level.WARN)) {            Log.w(TAG, message);            System.out.println("WARN: " + message);        }    }
    public static void e(String message, Throwable throwable) {        if (isEnabled(Level.ERROR)) {            Log.e(TAG, message, throwable);            System.out.println("ERROR: " + message);            if (throwable != null) {                throwable.printStackTrace();            }        }    }
    public static void i(String message) {        if (isEnabled(Level.INFO)) {            Log.i(TAG, message);            System.out.println("INFO: " + message);        }    }
    public static void d(String message) {        if (isEnabled(Level.DEBUG)) {            Log.d(TAG, message);            System.out.println(PREFIX + "DEBUG: " + message);        }    }
    public static void w(String message) {        if (isEnabled(Level.WARN)) {            Log.w(TAG, message);            System.out.println(PREFIX + "WARN: " + message);        }    }
    public static void e(String message, Throwable throwable) {        if (isEnabled(Level.ERROR)) {            Log.e(TAG, message, throwable);            System.out.println(PREFIX + "ERROR: " + message);            if (throwable != null) {                throwable.printStackTrace();            }        }    }
    public static void i(String message) {        if (isEnabled(Level.INFO)) {            Log.i(TAG, message);            System.out.println(PREFIX + "INFO: " + message);        }    }
    public static DesktopConnection open(String deviceName, int width, int height) throws IOException {        LocalSocket socket = connect(SOCKET_NAME);        DesktopConnection connection = new DesktopConnection(socket);        connection.send(deviceName, width, height);        return connection;    }
    public static DesktopConnection open(String deviceName, int width, int height) throws IOException {        LocalSocket socket = connect(SOCKET_NAME);        DesktopConnection connection = new DesktopConnection(socket);        connection.send(deviceName, width, height);        return connection;    }
    public static DesktopConnection open(Device device) throws IOException {        LocalSocket socket = connect(SOCKET_NAME);        ScreenInfo initialScreenInfo = device.getScreenInfo();        int width = initialScreenInfo.getLogicalWidth();        int height = initialScreenInfo.getLogicalHeight();        DesktopConnection connection = new DesktopConnection(socket);        connection.send(Device.getDeviceName(), width, height);        return connection;    }
    public static DesktopConnection open(Device device) throws IOException {        LocalSocket socket = connect(SOCKET_NAME);        ScreenInfo initialScreenInfo = device.getScreenInfo();        int width = initialScreenInfo.getLogicalWidth();        int height = initialScreenInfo.getLogicalHeight();
    public static Device getInstance() {        return INSTANCE;    }
    private Device() {        screenInfo = readScreenInfo();        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    // update screenInfo cache                    screenInfo = screenInfo.withRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        });    }
        if (screenInfo == null) {            screenInfo = readScreenInfo();        }        return screenInfo;
    public Device() {        screenInfo = readScreenInfo();        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    // update screenInfo cache                    screenInfo = screenInfo.withRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        });    }
    private boolean injectScroll(Position position, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        Point point = Device.getInstance().getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        setPointerCoords(point);        setScroll(hScroll, vScroll);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, MotionEvent.ACTION_SCROLL, 1, pointerProperties, pointerCoords, 0, 0, 1f, 1f, 0, 0, InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
    public EventController(DesktopConnection connection) {        this.connection = connection;        inputManager = Device.getInstance().getInputManager();        initPointer();    }
    public EventController(DesktopConnection connection) {        this.connection = connection;        inputManager = Device.getInstance().getInputManager();        initPointer();    }
    private boolean injectMouse(int action, int buttons, Position position) {        long now = SystemClock.uptimeMillis();        if (action == MotionEvent.ACTION_DOWN) {            lastMouseDown = now;        }        Point point = Device.getInstance().getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        setPointerCoords(point);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, action, 1, pointerProperties, pointerCoords, 0, buttons, 1f, 1f, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
    private boolean injectScroll(Position position, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        setPointerCoords(point);        setScroll(hScroll, vScroll);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, MotionEvent.ACTION_SCROLL, 1, pointerProperties, pointerCoords, 0, 0, 1f, 1f, 0, 0, InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
    public EventController(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;        inputManager = device.getInputManager();        initPointer();    }
    public EventController(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;        inputManager = device.getInputManager();        initPointer();
    private boolean injectMouse(int action, int buttons, Position position) {        long now = SystemClock.uptimeMillis();        if (action == MotionEvent.ACTION_DOWN) {            lastMouseDown = now;        }        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        setPointerCoords(point);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, action, 1, pointerProperties, pointerCoords, 0, buttons, 1f, 1f, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
    private static void startEventController(final DesktopConnection connection) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    new EventController(connection).control();                } catch (IOException e) {                    e.printStackTrace();                }            }        }).start();    }
    private static void startEventController(final DesktopConnection connection) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    new EventController(connection).control();                } catch (IOException e) {                    e.printStackTrace();                }            }        }).start();    }
    private static void scrcpy() throws IOException {        String deviceName = Device.getDeviceName();        ScreenInfo initialScreenInfo = Device.getInstance().getScreenInfo();        int width = initialScreenInfo.getLogicalWidth();        int height = initialScreenInfo.getLogicalHeight();        try (DesktopConnection connection = DesktopConnection.open(deviceName, width, height)) {            final ScreenStreamer streamer = new ScreenStreamer(connection);            Device.getInstance().setRotationListener(new Device.RotationListener() {                @Override                public void onRotationChanged(int rotation) {                    streamer.reset();                }            });            // asynchronous            startEventController(connection);            try {                // synchronous                streamer.streamScreen();            } catch (IOException e) {                Ln.e("Screen streaming interrupted", e);            }        }    }
    private static void startEventController(final Device device, final DesktopConnection connection) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    new EventController(device, connection).control();                } catch (IOException e) {                    e.printStackTrace();                }            }        }).start();    }
            public void run() {                try {                    new EventController(device, connection).control();                } catch (IOException e) {                    e.printStackTrace();                }            }        }).start();    }    public static void main(String... args) throws Exception {        try {            scrcpy();
    private static void scrcpy() throws IOException {        final Device device = new Device();        try (DesktopConnection connection = DesktopConnection.open(device)) {            final ScreenStreamer streamer = new ScreenStreamer(connection);            device.setRotationListener(new Device.RotationListener() {                @Override                public void onRotationChanged(int rotation) {                    streamer.reset();                }            });            // asynchronous            startEventController(device, connection);            try {                // synchronous                streamer.streamScreen();            } catch (IOException e) {                Ln.e("Screen streaming interrupted", e);            }        }    }
SDL_bool cmd_terminate(HANDLE handle) {    return CloseHandle(handle);}
SDL_bool cmd_terminate(HANDLE handle) {    return TerminateProcess(handle, 1) && CloseHandle(handle);}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    Ctrl+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+c\n"        "        copy device clipboard to computer\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",   no_argument,       NULL, 'T'},        {"bit-rate",        required_argument, NULL, 'b'},        {"crop",            required_argument, NULL, 'c'},        {"fullscreen",      no_argument,       NULL, 'f'},        {"help",            no_argument,       NULL, 'h'},        {"max-size",        required_argument, NULL, 'm'},        {"no-control",      no_argument,       NULL, 'n'},        {"no-display",      no_argument,       NULL, 'N'},        {"port",            required_argument, NULL, 'p'},        {"record",          required_argument, NULL, 'r'},        {"record-format",   required_argument, NULL, 'f'},        {"serial",          required_argument, NULL, 's'},        {"show-touches",    no_argument,       NULL, 't'},        {"version",         no_argument,       NULL, 'v'},        {NULL,              0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:tTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return false;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = true;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return false;                }                break;            case 'n':                args->no_control = true;                break;            case 'N':                args->no_display = true;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return false;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = true;                break;            case 'T':                args->always_on_top = true;                break;            case 'v':                args->version = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (args->no_display && !args->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (args->no_display && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return false;        }    }    return true;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .record_format = 0,        .help = false,        .version = false,        .show_touches = false,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = false,        .no_control = false,        .no_display = false,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,        .control = !args.no_control,        .display = !args.no_display,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    Ctrl+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+c\n"        "        copy device clipboard to computer\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",   no_argument,       NULL, 'T'},        {"bit-rate",        required_argument, NULL, 'b'},        {"crop",            required_argument, NULL, 'c'},        {"fullscreen",      no_argument,       NULL, 'f'},        {"help",            no_argument,       NULL, 'h'},        {"max-size",        required_argument, NULL, 'm'},        {"no-control",      no_argument,       NULL, 'n'},        {"no-display",      no_argument,       NULL, 'N'},        {"port",            required_argument, NULL, 'p'},        {"record",          required_argument, NULL, 'r'},        {"record-format",   required_argument, NULL, 'f'},        {"serial",          required_argument, NULL, 's'},        {"show-touches",    no_argument,       NULL, 't'},        {"turn-screen-off", no_argument,       NULL, 'S'},        {"version",         no_argument,       NULL, 'v'},        {NULL,              0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return false;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = true;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return false;                }                break;            case 'n':                args->no_control = true;                break;            case 'N':                args->no_display = true;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return false;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 'S':                args->turn_screen_off = true;                break;            case 't':                args->show_touches = true;                break;            case 'T':                args->always_on_top = true;                break;            case 'v':                args->version = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (args->no_display && !args->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (args->no_display && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return false;        }    }    return true;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .record_format = 0,        .help = false,        .version = false,        .show_touches = false,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = false,        .no_control = false,        .no_display = false,        .turn_screen_off = false,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,        .control = !args.no_control,        .display = !args.no_display,        .turn_screen_off = args.turn_screen_off,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .send_frame_meta = record,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!video_buffer_init(&video_buffer)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            if (!controller_start(&controller)) {                goto end;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .send_frame_meta = record,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!video_buffer_init(&video_buffer)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            if (!controller_start(&controller)) {                goto end;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Cannot request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
    public void control() throws IOException {        // on start, power on the device        powerOn();        while (true) {            handleEvent();        }    }
    private boolean powerOn() {        return device.isScreenOn() || injectKeycode(KeyEvent.KEYCODE_POWER);    }
    public void control() throws IOException {        // on start, power on the device        if (!device.isScreenOn()) {            injectKeycode(KeyEvent.KEYCODE_POWER);            // dirty hack            // After POWER is injected, the device is powered on asynchronously.            // To turn the device screen off while mirroring, the client will send a message that            // would be handled before the device is actually powered on, so its effect would            // be "canceled" once the device is turned back on.            // Adding this delay prevents to handle the message before the device is actually            // powered on.            SystemClock.sleep(500);        }        while (true) {            handleEvent();        }    }
        return injectEvent(event);    }    private boolean injectKeycode(int keyCode) {
recorder_write_header(struct recorder *recorder, const AVPacket *packet) {    AVStream *ostream = recorder->ctx->streams[0];    uint8_t *extradata = av_malloc(packet->size * sizeof(uint8_t));    if (!extradata) {        LOGC("Could not allocate extradata");        return false;    }    // copy the first packet to the extra data    memcpy(extradata, packet->data, packet->size);#ifdef SCRCPY_LAVF_HAS_NEW_CODEC_PARAMS_API    ostream->codecpar->extradata = extradata;    ostream->codecpar->extradata_size = packet->size;#else    ostream->codec->extradata = extradata;    ostream->codec->extradata_size = packet->size;#endif    int ret = avformat_write_header(recorder->ctx, NULL);    if (ret < 0) {        LOGE("Failed to write header to %s", recorder->filename);        SDL_free(extradata);        avio_closep(&recorder->ctx->pb);        avformat_free_context(recorder->ctx);        return false;    }    return true;}
recorder_write_header(struct recorder *recorder, const AVPacket *packet) {    AVStream *ostream = recorder->ctx->streams[0];    uint8_t *extradata = av_malloc(packet->size * sizeof(uint8_t));    if (!extradata) {        LOGC("Could not allocate extradata");        return false;    }    // copy the first packet to the extra data    memcpy(extradata, packet->data, packet->size);#ifdef SCRCPY_LAVF_HAS_NEW_CODEC_PARAMS_API    ostream->codecpar->extradata = extradata;    ostream->codecpar->extradata_size = packet->size;#else    ostream->codec->extradata = extradata;    ostream->codec->extradata_size = packet->size;#endif    int ret = avformat_write_header(recorder->ctx, NULL);    if (ret < 0) {        LOGE("Failed to write header to %s", recorder->filename);        return false;    }    return true;}static voidrecorder_rescale_packet(struct recorder *recorder, AVPacket *packet) {    AVStream *ostream = recorder->ctx->streams[0];
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top", no_argument,       NULL, 'T'},        {"bit-rate",      required_argument, NULL, 'b'},        {"crop",          required_argument, NULL, 'c'},        {"fullscreen",    no_argument,       NULL, 'f'},        {"help",          no_argument,       NULL, 'h'},        {"max-size",      required_argument, NULL, 'm'},        {"no-control",    no_argument,       NULL, 'n'},        {"no-display",    no_argument,       NULL, 'N'},        {"port",          required_argument, NULL, 'p'},        {"record",        required_argument, NULL, 'r'},        {"record-format", required_argument, NULL, 'f'},        {"serial",        required_argument, NULL, 's'},        {"show-touches",  no_argument,       NULL, 't'},        {"version",       no_argument,       NULL, 'v'},        {NULL,            0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:tTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return false;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = true;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return false;                }                break;            case 'n':                args->no_control = true;                break;            case 'N':                args->no_display = true;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return false;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = true;                break;            case 'T':                args->always_on_top = true;                break;            case 'v':                args->version = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (args->no_display && !args->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (args->no_display && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return false;        }    }    return true;}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",   no_argument,       NULL, 'T'},        {"bit-rate",        required_argument, NULL, 'b'},        {"crop",            required_argument, NULL, 'c'},        {"fullscreen",      no_argument,       NULL, 'f'},        {"help",            no_argument,       NULL, 'h'},        {"max-size",        required_argument, NULL, 'm'},        {"no-control",      no_argument,       NULL, 'n'},        {"no-display",      no_argument,       NULL, 'N'},        {"port",            required_argument, NULL, 'p'},        {"record",          required_argument, NULL, 'r'},        {"record-format",   required_argument, NULL, 'f'},        {"serial",          required_argument, NULL, 's'},        {"show-touches",    no_argument,       NULL, 't'},        {"version",         no_argument,       NULL, 'v'},        {NULL,              0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:tTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return false;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = true;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return false;                }                break;            case 'n':                args->no_control = true;                break;            case 'N':                args->no_display = true;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return false;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = true;                break;            case 'T':                args->always_on_top = true;                break;            case 'v':                args->version = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (args->no_display && !args->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (args->no_display && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return false;        }    }    return true;}
                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &video_buffer)) {                    return SDL_FALSE;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                    case SDL_WINDOWEVENT_EXPOSED:                    case SDL_WINDOWEVENT_SIZE_CHANGED:                        screen_render(&screen);
event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_STREAM_STOPPED:                LOGD("Video stream stopped");                return SDL_FALSE;            case SDL_QUIT:                LOGD("User requested to quit");                return SDL_TRUE;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &video_buffer)) {                    return SDL_FALSE;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                    case SDL_WINDOWEVENT_EXPOSED:                    case SDL_WINDOWEVENT_SIZE_CHANGED:                        screen_render(&screen);                        break;                }                break;            case SDL_TEXTINPUT:                input_manager_process_text_input(&input_manager, &event.text);                break;            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager,                                                   &event.motion);                break;            case SDL_MOUSEWHEEL:                input_manager_process_mouse_wheel(&input_manager,                                                  &event.wheel);                break;            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP:                input_manager_process_mouse_button(&input_manager,                                                   &event.button);                break;            case SDL_DROPFILE: {                file_handler_action_t action;                if (is_apk(event.drop.file)) {                    action = ACTION_INSTALL_APK;                } else {                    action = ACTION_PUSH_FILE;                }                file_handler_request(&file_handler, action, event.drop.file);                break;            }        }    }    return SDL_FALSE;}
handle_event(SDL_Event *event) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = SDL_TRUE;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return SDL_FALSE;            }            break;        case SDL_WINDOWEVENT:            switch (event->window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;            }            break;        case SDL_TEXTINPUT:            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            input_manager_process_key(&input_manager, &event->key);            break;        case SDL_MOUSEMOTION:            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            input_manager_process_mouse_button(&input_manager, &event->button);            break;        case SDL_DROPFILE: {            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        enum event_result result = handle_event(&event);        switch (result) {            case EVENT_RESULT_STOPPED_BY_USER:                return SDL_TRUE;            case EVENT_RESULT_STOPPED_BY_EOS:                return SDL_FALSE;            case EVENT_RESULT_CONTINUE:                break;        }    }    return SDL_FALSE;}
sdl_init_and_configure(bool display) {    uint32_t flags = display ? SDL_INIT_VIDEO : SDL_INIT_EVENTS;    if (SDL_Init(flags)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return false;    }    atexit(SDL_Quit);    if (!display) {        return true;    }    // Use the best available scale quality    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "2")) {        LOGW("Could not enable bilinear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return true;}
sdl_init_and_configure(bool display) {    uint32_t flags = display ? SDL_INIT_VIDEO : SDL_INIT_EVENTS;    if (SDL_Init(flags)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return false;    }    atexit(SDL_Quit);    if (!display) {        return true;    }    // Use the best available scale quality    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "2")) {        LOGW("Could not enable bilinear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif#ifdef SCRCPY_SDL_HAS_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR    // Disable compositor bypassing on X11    if (!SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, "0")) {        LOGW("Could not disable X11 compositor bypass");    }#endif    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return true;}
static inline void action_shake(struct controller *controller) {    send_keycode(controller, AKEYCODE_MENU, "SHAKE");}
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    // capture all Ctrl events    if (ctrl) {        SDL_bool repeat = event->repeat;        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        SDL_Keycode keycode = event->keysym.sym;        switch (keycode) {            case SDLK_h:                action_home(input_manager->controller);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(input_manager->controller);                return;            case SDLK_m:                action_app_switch(input_manager->controller);                return;            case SDLK_s:                action_shake(input_manager->controller);                return;            case SDLK_p:                action_power(input_manager->controller);                return;            case SDLK_v:                clipboard_paste(input_manager->controller);                return;            case SDLK_f:                screen_switch_fullscreen(input_manager->screen);                return;            case SDLK_x:                screen_resize_to_fit(input_manager->screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(input_manager->screen);                return;            case SDLK_i:                switch_fps_counter_state(input_manager->frames);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    // capture all Ctrl events    if (ctrl) {        SDL_bool repeat = event->repeat;        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        SDL_Keycode keycode = event->keysym.sym;        switch (keycode) {            case SDLK_h:                action_home(input_manager->controller);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(input_manager->controller);                return;            case SDLK_m:                action_app_switch(input_manager->controller);                return;            case SDLK_s:                action_shake(input_manager->controller);                return;            case SDLK_p:                action_power(input_manager->controller);                return;            case SDLK_v:                clipboard_paste(input_manager->controller);                return;            case SDLK_f:                screen_switch_fullscreen(input_manager->screen);                return;            case SDLK_x:                screen_resize_to_fit(input_manager->screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(input_manager->screen);                return;            case SDLK_i:                switch_fps_counter_state(input_manager->frames);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
static inline void action_menu(struct controller *controller) {    send_keycode(controller, AKEYCODE_MENU, "MENU");}
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    // capture all Ctrl events    if (ctrl) {        SDL_bool repeat = event->repeat;        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        SDL_Keycode keycode = event->keysym.sym;        switch (keycode) {            case SDLK_h:                action_home(input_manager->controller);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(input_manager->controller);                return;            case SDLK_m:                action_app_switch(input_manager->controller);                return;            case SDLK_s:                action_menu(input_manager->controller);                return;            case SDLK_p:                action_power(input_manager->controller);                return;            case SDLK_v:                clipboard_paste(input_manager->controller);                return;            case SDLK_f:                screen_switch_fullscreen(input_manager->screen);                return;            case SDLK_x:                screen_resize_to_fit(input_manager->screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(input_manager->screen);                return;            case SDLK_i:                switch_fps_counter_state(input_manager->frames);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
static inline void action_menu(struct controller *controller) {    send_keycode(controller, AKEYCODE_MENU, "MENU");}
static process_t execute_server(const char *serial,                                Uint16 max_size, Uint32 bit_rate,                                SDL_bool tunnel_forward, const char *crop,                                SDL_bool send_frame_meta) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        tunnel_forward ? "true" : "false",        crop ? crop : "''",        send_frame_meta ? "true" : "false",    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
static process_t execute_server(const char *serial,                                Uint16 max_size, Uint32 bit_rate,                                SDL_bool tunnel_forward, const char *crop,                                SDL_bool send_frame_meta) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        tunnel_forward ? "true" : "false",        crop ? crop : "-",        send_frame_meta ? "true" : "false",    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
    private static Rect parseCrop(String crop) {        if (crop.isEmpty()) {            return null;        }        // input format: "width:height:x:y"        String[] tokens = crop.split(":");        if (tokens.length != 4) {            throw new IllegalArgumentException("Crop must contains 4 values separated by colons: \"" + crop + "\"");        }        int width = Integer.parseInt(tokens[0]);        int height = Integer.parseInt(tokens[1]);        int x = Integer.parseInt(tokens[2]);        int y = Integer.parseInt(tokens[3]);        return new Rect(x, y, x + width, y + height);    }
    private static Rect parseCrop(String crop) {        if ("-".equals(crop)) {            return null;        }        // input format: "width:height:x:y"        String[] tokens = crop.split(":");        if (tokens.length != 4) {            throw new IllegalArgumentException("Crop must contains 4 values separated by colons: \"" + crop + "\"");        }        int width = Integer.parseInt(tokens[0]);        int height = Integer.parseInt(tokens[1]);        int x = Integer.parseInt(tokens[2]);        int y = Integer.parseInt(tokens[3]);        return new Rect(x, y, x + width, y + height);    }
        screen->texture = SDL_CreateTexture(screen->renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                                            new_frame_size.width, new_frame_size.height);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return SDL_FALSE;        }    }    return SDL_TRUE;}// write the frame into the texturestatic void update_texture(struct screen *screen, const AVFrame *frame) {    SDL_UpdateYUVTexture(screen->texture, NULL,            frame->data[0], frame->linesize[0],            frame->data[1], frame->linesize[1],            frame->data[2], frame->linesize[2]);}SDL_bool screen_update_frame(struct screen *screen, struct frames *frames) {    mutex_lock(frames->mutex);    const AVFrame *frame = frames_consume_rendered_frame(frames);    struct size new_frame_size = {frame->width, frame->height};    if (!prepare_for_frame(screen, new_frame_size)) {        mutex_unlock(frames->mutex);        return SDL_FALSE;    }    update_texture(screen, frame);    mutex_unlock(frames->mutex);
static SDL_bool prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width || screen->frame_size.height != new_frame_size.height) {        if (SDL_RenderSetLogicalSize(screen->renderer, new_frame_size.width, new_frame_size.height)) {            LOGE("Could not set renderer logical size: %s", SDL_GetError());            return SDL_FALSE;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        struct size current_size = get_window_size(screen);        struct size target_size = {            (Uint32) current_size.width * new_frame_size.width / screen->frame_size.width,            (Uint32) current_size.height * new_frame_size.height / screen->frame_size.height,        };        target_size = get_optimal_size(target_size, new_frame_size);        set_window_size(screen, target_size);        screen->frame_size = new_frame_size;        LOGD("New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = SDL_CreateTexture(screen->renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                                            new_frame_size.width, new_frame_size.height);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return SDL_FALSE;        }    }    return SDL_TRUE;}
SDL_bool screen_init_rendering(struct screen *screen, const char *device_name, struct size frame_size) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    Uint32 window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height, window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1, SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width, frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    screen->texture = SDL_CreateTexture(screen->renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                                        frame_size.width, frame_size.height);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    return SDL_TRUE;}
static inline SDL_Texture *create_texture(SDL_Renderer *renderer, struct size frame_size) {    return SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                             frame_size.width, frame_size.height);}
static SDL_bool prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width || screen->frame_size.height != new_frame_size.height) {        if (SDL_RenderSetLogicalSize(screen->renderer, new_frame_size.width, new_frame_size.height)) {            LOGE("Could not set renderer logical size: %s", SDL_GetError());            return SDL_FALSE;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        struct size current_size = get_window_size(screen);        struct size target_size = {            (Uint32) current_size.width * new_frame_size.width / screen->frame_size.width,            (Uint32) current_size.height * new_frame_size.height / screen->frame_size.height,        };        target_size = get_optimal_size(target_size, new_frame_size);        set_window_size(screen, target_size);        screen->frame_size = new_frame_size;        LOGD("New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = create_texture(screen->renderer, new_frame_size);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return SDL_FALSE;        }    }    return SDL_TRUE;}
SDL_bool screen_init_rendering(struct screen *screen, const char *device_name, struct size frame_size) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    Uint32 window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height, window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1, SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width, frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    return SDL_TRUE;}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/" SERVER_FILENAME,        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",    };    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/" SERVER_FILENAME,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
    public Controller(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;        initTouchPointers();        sender = new DeviceMessageSender(connection);    }
    private void initTouchPointers() {        for (int i = 0; i < PointersState.MAX_POINTERS; ++i) {            MotionEvent.PointerProperties props = new MotionEvent.PointerProperties();            props.toolType = MotionEvent.TOOL_TYPE_FINGER;            MotionEvent.PointerCoords coords = new MotionEvent.PointerCoords();            coords.orientation = 0;            coords.size = 1;            touchPointerProperties[i] = props;            touchPointerCoords[i] = coords;        }    }
    private void initTouchPointers() {        for (int i = 0; i < PointersState.MAX_POINTERS; ++i) {            MotionEvent.PointerProperties props = new MotionEvent.PointerProperties();            props.toolType = MotionEvent.TOOL_TYPE_FINGER;            MotionEvent.PointerCoords coords = new MotionEvent.PointerCoords();            coords.orientation = 0;            coords.size = 1;            touchPointerProperties[i] = props;            touchPointerCoords[i] = coords;        }    }
    private boolean injectTouch(int action, long pointerId, Position position, float pressure, int buttons) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        int pointerIndex = pointersState.getPointerIndex(pointerId);        if (pointerIndex == -1) {            Ln.w("Too many pointers for touch event");            return false;        }        Pointer pointer = pointersState.get(pointerIndex);        pointer.setPoint(point);        pointer.setPressure(pressure);        pointer.setUp(action == MotionEvent.ACTION_UP);        int pointerCount = pointersState.update(touchPointerProperties, touchPointerCoords);        if (pointerCount == 1) {            if (action == MotionEvent.ACTION_DOWN) {                lastTouchDown = now;            }        } else {            // secondary pointers must use ACTION_POINTER_* ORed with the pointerIndex            if (action == MotionEvent.ACTION_UP) {                action = MotionEvent.ACTION_POINTER_UP | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            } else if (action == MotionEvent.ACTION_DOWN) {                action = MotionEvent.ACTION_POINTER_DOWN | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            }        }        MotionEvent event = MotionEvent.obtain(lastTouchDown, now, action, pointerCount, touchPointerProperties,                touchPointerCoords, 0, 0, 1f, 1f, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
    private boolean injectScroll(Position position, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        MotionEvent.PointerProperties props = touchPointerProperties[0];        props.id = 0;        MotionEvent.PointerCoords coords = touchPointerCoords[0];        coords.x = point.getX();        coords.y = point.getY();        coords.setAxisValue(MotionEvent.AXIS_HSCROLL, hScroll);        coords.setAxisValue(MotionEvent.AXIS_VSCROLL, vScroll);        MotionEvent event = MotionEvent.obtain(lastTouchDown, now, MotionEvent.ACTION_SCROLL, 1,                touchPointerProperties, touchPointerCoords, 0, 0, 1f, 1f, 0, 0, InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
    public Controller(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;        initPointers();        sender = new DeviceMessageSender(connection);    }
    private void initPointers() {        for (int i = 0; i < PointersState.MAX_POINTERS; ++i) {            MotionEvent.PointerProperties props = new MotionEvent.PointerProperties();            props.toolType = MotionEvent.TOOL_TYPE_FINGER;            MotionEvent.PointerCoords coords = new MotionEvent.PointerCoords();            coords.orientation = 0;            coords.size = 1;            pointerProperties[i] = props;            pointerCoords[i] = coords;        }    }
    private void initPointers() {        for (int i = 0; i < PointersState.MAX_POINTERS; ++i) {            MotionEvent.PointerProperties props = new MotionEvent.PointerProperties();            props.toolType = MotionEvent.TOOL_TYPE_FINGER;            MotionEvent.PointerCoords coords = new MotionEvent.PointerCoords();            coords.orientation = 0;            coords.size = 1;            pointerProperties[i] = props;            pointerCoords[i] = coords;        }    }
    private boolean injectTouch(int action, long pointerId, Position position, float pressure, int buttons) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        int pointerIndex = pointersState.getPointerIndex(pointerId);        if (pointerIndex == -1) {            Ln.w("Too many pointers for touch event");            return false;        }        Pointer pointer = pointersState.get(pointerIndex);        pointer.setPoint(point);        pointer.setPressure(pressure);        pointer.setUp(action == MotionEvent.ACTION_UP);        int pointerCount = pointersState.update(pointerProperties, pointerCoords);        if (pointerCount == 1) {            if (action == MotionEvent.ACTION_DOWN) {                lastTouchDown = now;            }        } else {            // secondary pointers must use ACTION_POINTER_* ORed with the pointerIndex            if (action == MotionEvent.ACTION_UP) {                action = MotionEvent.ACTION_POINTER_UP | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            } else if (action == MotionEvent.ACTION_DOWN) {                action = MotionEvent.ACTION_POINTER_DOWN | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            }        }        MotionEvent event = MotionEvent.obtain(lastTouchDown, now, action, pointerCount, pointerProperties,                pointerCoords, 0, 0, 1f, 1f, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
    private boolean injectScroll(Position position, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        MotionEvent.PointerProperties props = pointerProperties[0];        props.id = 0;        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.x = point.getX();        coords.y = point.getY();        coords.setAxisValue(MotionEvent.AXIS_HSCROLL, hScroll);        coords.setAxisValue(MotionEvent.AXIS_VSCROLL, vScroll);        MotionEvent event = MotionEvent.obtain(lastTouchDown, now, MotionEvent.ACTION_SCROLL, 1, pointerProperties,                pointerCoords, 0, 0, 1f, 1f, 0, 0, InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
void server_stop(struct server *server, const char *serial) {    SDL_assert(server->process != PROCESS_NONE);    if (server->server_socket) {        SDLNet_TCP_Close(server->server_socket);    }    if (server->device_socket) {        SDLNet_TCP_Close(server->device_socket);    }    // let the server some time to print any exception trace before killing it    struct timespec timespec = {        .tv_sec = 0,        .tv_nsec = 100000000, // 100ms    };    nanosleep(&timespec, NULL); // ignore error    terminate_server(server->process);    if (server->adb_reverse_enabled) {        // ignore failure        disable_tunnel(serial);    }}
    SDL_assert(server->process != PROCESS_NONE);    if (server->server_socket) {        SDLNet_TCP_Close(server->server_socket);    }    if (server->device_socket) {        SDLNet_TCP_Close(server->device_socket);    }    terminate_server(server->process);    if (server->adb_reverse_enabled) {        // ignore failure        disable_tunnel(serial);    }}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        if (decoder->recorder) {            // do not record configuration packets            // (they contain no media data and have no PTS/DTS)            // FIXME do not use MediaCodec specific flags            if (!(decoder->buffer_info_flags & MEDIA_CODEC_FLAG_CONFIG)) {                packet.pts = decoder->pts;                packet.dts = decoder->pts;                // no need to rescale with av_packet_rescale_ts(), the timestamps                // are in microseconds both in input and output                if (!recorder_write(decoder->recorder, &packet)) {                    LOGE("Could not write frame to output file");                    av_packet_unref(&packet);                    goto run_quit;                }            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static int read_packet(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    uint8_t header[HEADER_SIZE];    int remaining;    int ret;    remaining = decoder->remaining;    if (remaining == 0) {        // the previous PTS read is now for the current frame        decoder->pts = decoder->next_pts;        // FIXME what if only part of the header is available?        ret = net_recv(decoder->video_socket, header, HEADER_SIZE);        if (ret <= 0)            return ret;        // read the PTS for the next frame        decoder->next_pts = from_be(header, 8);        decoder->buffer_info_flags = from_be(header + 8, 4);        remaining = from_be(header + 12, 4);    }    if (buf_size > remaining)        buf_size = remaining;    ret = net_recv(decoder->video_socket, buf, buf_size);    if (ret <= 0)        return ret;    remaining -= ret;    decoder->remaining = remaining;    return ret;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        if (decoder->recorder) {            packet.pts = decoder->pts;            packet.dts = decoder->pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(decoder->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto run_quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static int read_packet(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    uint8_t header[HEADER_SIZE];    int remaining;    int ret;    remaining = decoder->remaining;    if (remaining == 0) {        // the previous PTS read is now for the current frame        decoder->pts = decoder->next_pts;        // FIXME what if only part of the header is available?        ret = net_recv(decoder->video_socket, header, HEADER_SIZE);        if (ret <= 0)            return ret;        // read the PTS for the next frame        decoder->next_pts = from_be(header, 8);        remaining = from_be(header + 8, 4);    }    if (buf_size > remaining)        buf_size = remaining;    ret = net_recv(decoder->video_socket, buf, buf_size);    if (ret <= 0)        return ret;    remaining -= ret;    decoder->remaining = remaining;    return ret;}
    private boolean encode(MediaCodec codec, FileDescriptor fd) throws IOException {        boolean eof = false;        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();        ByteBuffer bBuffer = ByteBuffer.allocate(16);        while (!consumeRotationChange() && !eof) {            int outputBufferId = codec.dequeueOutputBuffer(bufferInfo, -1);            eof = (bufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;            try {                if (consumeRotationChange()) {                    // must restart encoding with new size                    break;                }                if (outputBufferId >= 0) {                    ByteBuffer codecBuffer = codec.getOutputBuffer(outputBufferId);                    bBuffer.clear();                    long pts;                    if ((bufferInfo.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {                        pts = 0; // non-media data packet                    } else {                        if (ptsOrigin == 0) {                            ptsOrigin = bufferInfo.presentationTimeUs;                        }                        pts = bufferInfo.presentationTimeUs - ptsOrigin;                    }                    bBuffer.putLong(pts);                    bBuffer.putInt(bufferInfo.flags);                    bBuffer.putInt(codecBuffer.remaining());                    bBuffer.flip();                    IO.writeFully(fd, bBuffer);                    IO.writeFully(fd, codecBuffer);                }            } finally {                if (outputBufferId >= 0) {                    codec.releaseOutputBuffer(outputBufferId, false);                }            }        }        return !eof;    }
    private boolean encode(MediaCodec codec, FileDescriptor fd) throws IOException {        boolean eof = false;        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();        ByteBuffer bBuffer = ByteBuffer.allocate(12);        while (!consumeRotationChange() && !eof) {            int outputBufferId = codec.dequeueOutputBuffer(bufferInfo, -1);            eof = (bufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;            try {                if (consumeRotationChange()) {                    // must restart encoding with new size                    break;                }                if (outputBufferId >= 0) {                    ByteBuffer codecBuffer = codec.getOutputBuffer(outputBufferId);                    bBuffer.clear();                    long pts;                    if ((bufferInfo.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {                        pts = 0; // non-media data packet                    } else {                        if (ptsOrigin == 0) {                            ptsOrigin = bufferInfo.presentationTimeUs;                        }                        pts = bufferInfo.presentationTimeUs - ptsOrigin;                    }                    bBuffer.putLong(pts);                    bBuffer.putInt(codecBuffer.remaining());                    bBuffer.flip();                    IO.writeFully(fd, bBuffer);                    IO.writeFully(fd, codecBuffer);                }            } finally {                if (outputBufferId >= 0) {                    codec.releaseOutputBuffer(outputBufferId, false);                }            }        }        return !eof;    }
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = server_connect_to(&server, serial);    if (!device_socket) {        server_stop(&server, serial);        return SDL_FALSE;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server, serial);        return SDL_FALSE;    }    if (!frames_init(&frames)) {        server_stop(&server, serial);        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    decoder.frames = &frames;    decoder.video_socket = device_socket;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server, serial);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // kill the server before decoder_join() to wake up the decoder    server_stop(&server, serial);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = server_connect_to(&server, serial);    if (!device_socket) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server, serial);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // kill the server before decoder_join() to wake up the decoder    server_stop(&server, serial);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
void server_stop(struct server *server, const char *serial) {    SDL_assert(server->process != PROCESS_NONE);    if (server->server_socket) {        SDLNet_TCP_Close(server->server_socket);    }    if (server->device_socket) {        SDLNet_TCP_Close(server->device_socket);    }    terminate_server(server->process);    if (server->adb_reverse_enabled) {        // ignore failure        disable_tunnel(serial);    }}
void server_stop(struct server *server, const char *serial) {    SDL_assert(server->process != PROCESS_NONE);    if (server->server_socket) {        SDLNet_TCP_Close(server->server_socket);    }    if (server->device_socket) {        SDLNet_TCP_Close(server->device_socket);    }    terminate_server(server->process);    if (server->adb_reverse_enabled) {        // ignore failure        disable_tunnel(serial);    }}
void server_stop(struct server *server, const char *serial) {    SDL_assert(server->process != PROCESS_NONE);    terminate_server(server->process);    if (server->adb_reverse_enabled) {        // ignore failure        disable_tunnel(serial);    }}void server_destroy(struct server *server) {    if (server->server_socket) {        SDLNet_TCP_Close(server->server_socket);    }    if (server->device_socket) {        SDLNet_TCP_Close(server->device_socket);    }
void server_destroy(struct server *server) {    if (server->server_socket) {        SDLNet_TCP_Close(server->server_socket);    }    if (server->device_socket) {        SDLNet_TCP_Close(server->device_socket);    }}
static int read_packet(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    uint8_t header[HEADER_SIZE];    int remaining;    int ret;    remaining = decoder->remaining;    if (remaining == 0) {        // the previous PTS read is now for the current frame        decoder->pts = decoder->next_pts;        ret = net_recv_all(decoder->video_socket, header, HEADER_SIZE);        if (ret <= 0)            return ret;        // no partial read (net_recv_all())        SDL_assert_release(ret == HEADER_SIZE);        // read the PTS for the next frame        decoder->next_pts = buffer_read64be(header);        remaining = buffer_read32be(&header[8]);    }    if (buf_size > remaining)        buf_size = remaining;    ret = net_recv(decoder->video_socket, buf, buf_size);    if (ret <= 0)        return ret;    remaining -= ret;    decoder->remaining = remaining;    return ret;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        if (decoder->recorder) {            packet.pts = decoder->pts;            packet.dts = decoder->pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(decoder->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto run_quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static int read_packet(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    struct receiver_state *state = &decoder->receiver_state;    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    if (!state->remaining) {        // the next PTS is now for the current frame        state->pts = state->next_pts;#define HEADER_SIZE 12        uint8_t header[HEADER_SIZE];        ssize_t ret = net_recv_all(decoder->video_socket, header, HEADER_SIZE);        if (ret <= 0) {            return ret;        }        // no partial read (net_recv_all())        SDL_assert_release(ret == HEADER_SIZE);        state->next_pts = buffer_read64be(header);        state->remaining = buffer_read32be(&header[8]);    }    SDL_assert(state->remaining);    if (buf_size > state->remaining)        buf_size = state->remaining;    ssize_t ret = net_recv(decoder->video_socket, buf, buf_size);    if (ret <= 0) {        return ret;    }    SDL_assert(state->remaining >= ret);    state->remaining -= ret;    return ret;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    // initialize the receiver state    decoder->receiver_state.remaining = 0;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        if (decoder->recorder) {            packet.pts = decoder->receiver_state.pts;            packet.dts = decoder->receiver_state.pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(decoder->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto run_quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static int run_installer(void *data) {    struct installer *installer = data;    for (;;) {        mutex_lock(installer->mutex);        while (!installer->stopped && apk_queue_is_empty(&installer->queue)) {            cond_wait(installer->event_cond, installer->mutex);        }        if (installer->stopped) {            // stop immediately, do not process further events            mutex_unlock(installer->mutex);            break;        }        char *current_apk;#ifdef BUILD_DEBUG        bool non_empty = apk_queue_take(&installer->queue, &current_apk);        SDL_assert(non_empty);#else        apk_queue_take(&installer->queue, &current_apk);#endif        LOGI("Installing %s...", current_apk);        process_t process = adb_install(installer->serial, current_apk);        installer->current_process = process;        mutex_unlock(installer->mutex);        if (process_check_success(process, "adb install")) {            LOGI("%s installed successfully", current_apk);        } else {            LOGE("Failed to install %s", current_apk);        }        SDL_free(current_apk);    }    return 0;}
static int run_installer(void *data) {    struct installer *installer = data;    for (;;) {        mutex_lock(installer->mutex);        installer->current_process = PROCESS_NONE;        while (!installer->stopped && apk_queue_is_empty(&installer->queue)) {            cond_wait(installer->event_cond, installer->mutex);        }        if (installer->stopped) {            // stop immediately, do not process further events            mutex_unlock(installer->mutex);            break;        }        char *current_apk;#ifdef BUILD_DEBUG        bool non_empty = apk_queue_take(&installer->queue, &current_apk);        SDL_assert(non_empty);#else        apk_queue_take(&installer->queue, &current_apk);#endif        LOGI("Installing %s...", current_apk);        process_t process = adb_install(installer->serial, current_apk);        installer->current_process = process;        mutex_unlock(installer->mutex);        if (process_check_success(process, "adb install")) {            LOGI("%s installed successfully", current_apk);        } else {            LOGE("Failed to install %s", current_apk);        }        SDL_free(current_apk);    }    return 0;}
server_connect_to(struct server *server) {    if (!server->tunnel_forward) {        server->device_socket = net_accept(server->server_socket);    } else {        uint32_t attempts = 100;        uint32_t delay = 100; // ms        server->device_socket = connect_to_server(server->local_port, attempts,                                                  delay);    }    if (server->device_socket == INVALID_SOCKET) {        return false;    }    if (!server->tunnel_forward) {        // we don't need the server socket anymore        close_socket(&server->server_socket);    }    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = false;    return true;}
server_connect_to(struct server *server) {    if (!server->tunnel_forward) {        server->device_socket = net_accept(server->server_socket);        if (server->device_socket == INVALID_SOCKET) {            return false;        }        // we don't need the server socket anymore        close_socket(&server->server_socket);    } else {        uint32_t attempts = 100;        uint32_t delay = 100; // ms        server->device_socket = connect_to_server(server->local_port, attempts,                                                  delay);        if (server->device_socket == INVALID_SOCKET) {            return false;        }    }    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = false;    return true;}
    public int getRotation() {        try {            Class<?> cls = manager.getClass();            try {                return (Integer) manager.getClass().getMethod("getRotation").invoke(manager);            } catch (NoSuchMethodException e) {                // method changed since this commit:                // https://android.googlesource.com/platform/frameworks/base/+/8ee7285128c3843401d4c4d0412cd66e86ba49e3%5E%21/#F2                return (Integer) cls.getMethod("getDefaultDisplayRotation").invoke(manager);            }        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public int getRotation() {        try {            Class<?> cls = manager.getClass();            try {                return (Integer) cls.getMethod("getRotation").invoke(manager);            } catch (NoSuchMethodException e) {                // method changed since this commit:                // https://android.googlesource.com/platform/frameworks/base/+/8ee7285128c3843401d4c4d0412cd66e86ba49e3%5E%21/#F2                return (Integer) cls.getMethod("getDefaultDisplayRotation").invoke(manager);            }        } catch (Exception e) {            throw new AssertionError(e);        }    }
parse_port(char *optarg, uint16_t *port) {    char *endptr;    if (*optarg == '\0') {        LOGE("Port parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid port: %s", optarg);        return false;    }    if (value & ~0xffff) {        LOGE("Port out of range: %ld", value);        return false;    }    *port = (uint16_t) value;    return true;}
parse_max_size(char *optarg, uint16_t *max_size) {    char *endptr;    if (*optarg == '\0') {        LOGE("Max size parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid max size: %s", optarg);        return false;    }    if (value & ~0xffff) {        LOGE("Max size must be between 0 and 65535: %ld", value);        return false;    }    *max_size = (uint16_t) value;    return true;}
parse_max_size(char *optarg, uint16_t *max_size) {    char *endptr;    if (*optarg == '\0') {        LOGE("Max size parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid max size: %s", optarg);        return false;    }    if (value & ~0xffff) {        LOGE("Max size must be between 0 and 65535: %ld", value);        return false;    }    *max_size = (uint16_t) value;    return true;}
parse_window_dimension(char *optarg, uint16_t *dimension) {    char *endptr;    if (*optarg == '\0') {        LOGE("Window dimension parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid window dimension: %s", optarg);        return false;    }    if (value & ~0xffff) {        LOGE("Window position must be between 0 and 65535: %ld", value);        return false;    }    *dimension = (uint16_t) value;    return true;}
parse_window_dimension(char *optarg, uint16_t *dimension) {    char *endptr;    if (*optarg == '\0') {        LOGE("Window dimension parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid window dimension: %s", optarg);        return false;    }    if (value & ~0xffff) {        LOGE("Window position must be between 0 and 65535: %ld", value);        return false;    }    *dimension = (uint16_t) value;    return true;}
parse_bit_rate(char *optarg, uint32_t *bit_rate) {    char *endptr;    if (*optarg == '\0') {        LOGE("Bit-rate parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    int mul = 1;    if (*endptr != '\0') {        if (optarg == endptr) {            LOGE("Invalid bit-rate: %s", optarg);            return false;        }        if ((*endptr == 'M' || *endptr == 'm') && endptr[1] == '\0') {            mul = 1000000;        } else if ((*endptr == 'K' || *endptr == 'k') && endptr[1] == '\0') {            mul = 1000;        } else {            LOGE("Invalid bit-rate unit: %s", optarg);            return false;        }    }    if (value < 0 || ((uint32_t) -1) / mul < (unsigned long) value) {        LOGE("Bitrate must be positive and less than 2^32: %s", optarg);        return false;    }    *bit_rate = (uint32_t) value * mul;    return true;}
parse_max_fps(const char *optarg, uint16_t *max_fps) {    char *endptr;    if (*optarg == '\0') {        LOGE("Max FPS parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid max FPS: %s", optarg);        return false;    }    if (value & ~0xffff) {        // in practice, it should not be higher than 60        LOGE("Max FPS value is invalid: %ld", value);        return false;    }    *max_fps = (uint16_t) value;    return true;}
parse_window_position(char *optarg, int16_t *position) {    char *endptr;    if (*optarg == '\0') {        LOGE("Window position parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid window position: %s", optarg);        return false;    }    if (value < -1 || value > 0x7fff) {        LOGE("Window position must be between -1 and 32767: %ld", value);        return false;    }    *position = (int16_t) value;    return true;}
parse_bit_rate(char *optarg, uint32_t *bit_rate) {    char *endptr;    if (*optarg == '\0') {        LOGE("Bit-rate parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    int mul = 1;    if (*endptr != '\0') {        if (optarg == endptr) {            LOGE("Invalid bit-rate: %s", optarg);            return false;        }        if ((*endptr == 'M' || *endptr == 'm') && endptr[1] == '\0') {            mul = 1000000;        } else if ((*endptr == 'K' || *endptr == 'k') && endptr[1] == '\0') {            mul = 1000;        } else {            LOGE("Invalid bit-rate unit: %s", optarg);            return false;        }    }    if (value < 0 || ((uint32_t) -1) / mul < (unsigned long) value) {        LOGE("Bitrate must be positive and less than 2^32: %s", optarg);        return false;    }    *bit_rate = (uint32_t) value * mul;    return true;}
parse_window_position(char *optarg, int16_t *position) {    char *endptr;    if (*optarg == '\0') {        LOGE("Window position parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid window position: %s", optarg);        return false;    }    if (value < -1 || value > 0x7fff) {        LOGE("Window position must be between -1 and 32767: %ld", value);        return false;    }    *position = (int16_t) value;    return true;}
parse_max_fps(const char *optarg, uint16_t *max_fps) {    char *endptr;    if (*optarg == '\0') {        LOGE("Max FPS parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid max FPS: %s", optarg);        return false;    }    if (value & ~0xffff) {        // in practice, it should not be higher than 60        LOGE("Max FPS value is invalid: %ld", value);        return false;    }    *max_fps = (uint16_t) value;    return true;}
parse_port(char *optarg, uint16_t *port) {    char *endptr;    if (*optarg == '\0') {        LOGE("Port parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid port: %s", optarg);        return false;    }    if (value & ~0xffff) {        LOGE("Port out of range: %ld", value);        return false;    }    *port = (uint16_t) value;    return true;}
parse_port(char *optarg, uint16_t *port) {    char *endptr;    if (*optarg == '\0') {        LOGE("Port parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid port: %s", optarg);        return false;    }    if (value & ~0xffff) {        LOGE("Port out of range: %ld", value);        return false;    }    *port = (uint16_t) value;    return true;}
parse_port(char *s, uint16_t *port) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF, "port");    if (!ok) {        return false;    }    *port = (uint16_t) value;    return true;}
parse_max_size(char *s, uint16_t *max_size) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF, "max size");    if (!ok) {        return false;    }    *max_size = (uint16_t) value;    return true;}
    *bit_rate = (uint32_t) value;    return true;}static boolparse_max_size(char *s, uint16_t *max_size) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF, "max size");    if (!ok) {        return false;    }    *max_size = (uint16_t) value;    return true;}static boolparse_max_fps(const char *s, uint16_t *max_fps) {    long value;
    return true;}static boolparse_record_format(const char *optarg, enum recorder_format *format) {    if (!strcmp(optarg, "mp4")) {        *format = RECORDER_FORMAT_MP4;        return true;    }    if (!strcmp(optarg, "mkv")) {        *format = RECORDER_FORMAT_MKV;        return true;    }    LOGE("Unsupported format: %s (expected mp4 or mkv)", optarg);    return false;}static enum recorder_formatguess_record_format(const char *filename) {    size_t len = strlen(filename);
parse_window_dimension(char *s, uint16_t *dimension) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF,                                "window dimension");    if (!ok) {        return false;    }    *dimension = (uint16_t) value;    return true;}
parse_bit_rate(const char *s, uint32_t *bit_rate) {    long value;    bool ok = parse_integer_arg(s, &value, true, 0, 0xFFFF, "bit-rate");    if (!ok) {        return false;    }    *bit_rate = (uint32_t) value;    return true;}
parse_max_fps(const char *s, uint16_t *max_fps) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 1000, "max fps");    if (!ok) {        return false;    }    *max_fps = (uint16_t) value;    return true;}
parse_window_dimension(char *s, uint16_t *dimension) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF,                                "window dimension");    if (!ok) {        return false;    }    *dimension = (uint16_t) value;    return true;}static boolparse_port(char *s, uint16_t *port) {    long value;    bool ok = parse_integer_arg(s, &value, false, 0, 0xFFFF, "port");    if (!ok) {        return false;    }
static boolparse_integer_arg(const char *s, long *out, bool accept_suffix, long min,                  long max, const char *name) {    long value;    bool ok;    if (accept_suffix) {        ok = parse_integer_with_suffix(s, &value);    } else {        ok = parse_integer(s, &value);    }    if (!ok) {        LOGE("Could not parse %s: %s", name, s);        return false;    }    if (value < min || value > max) {        LOGE("Could not parse %s: value (%ld) out-of-range (%ld; %ld)",             name, value, min, max);        return false;    }    *out = value;    return true;}static boolparse_bit_rate(const char *s, uint32_t *bit_rate) {    long value;    bool ok = parse_integer_arg(s, &value, true, 0, 0xFFFF, "bit-rate");    if (!ok) {        return false;
parse_window_position(char *s, int16_t *position) {    long value;    bool ok = parse_integer_arg(s, &value, false, -1, 0x7FFF,                                "window position");    if (!ok) {        return false;    }    *position = (int16_t) value;    return true;}
    if (!ok) {        return false;    }    *max_fps = (uint16_t) value;    return true;}static boolparse_window_position(char *s, int16_t *position) {    long value;    bool ok = parse_integer_arg(s, &value, false, -1, 0x7FFF,                                "window position");    if (!ok) {        return false;    }    *position = (int16_t) value;    return true;}
        return 0;    }    const char *ext = &filename[len - 4];    if (!strcmp(ext, ".mp4")) {        return RECORDER_FORMAT_MP4;    }    if (!strcmp(ext, ".mkv")) {        return RECORDER_FORMAT_MKV;    }    return 0;}#define OPT_RENDER_EXPIRED_FRAMES 1000#define OPT_WINDOW_TITLE          1001#define OPT_PUSH_TARGET           1002#define OPT_ALWAYS_ON_TOP         1003#define OPT_CROP                  1004#define OPT_RECORD_FORMAT         1005#define OPT_PREFER_TEXT           1006#define OPT_WINDOW_X              1007
parse_integer_arg(const char *s, long *out, bool accept_suffix, long min,                  long max, const char *name) {    long value;    bool ok;    if (accept_suffix) {        ok = parse_integer_with_suffix(s, &value);    } else {        ok = parse_integer(s, &value);    }    if (!ok) {        LOGE("Could not parse %s: %s", name, s);        return false;    }    if (value < min || value > max) {        LOGE("Could not parse %s: value (%ld) out-of-range (%ld; %ld)",             name, value, min, max);        return false;    }    *out = value;    return true;}
int main(void) {    test_xstrncpy_simple();    test_xstrncpy_just_fit();    test_xstrncpy_truncated();    test_xstrjoin_simple();    test_xstrjoin_just_fit();    test_xstrjoin_truncated_in_token();    test_xstrjoin_truncated_before_sep();    test_xstrjoin_truncated_after_sep();    test_strquote();    test_utf8_truncate();    return 0;}
int main(void) {    test_xstrncpy_simple();    test_xstrncpy_just_fit();    test_xstrncpy_truncated();    test_xstrjoin_simple();    test_xstrjoin_just_fit();    test_xstrjoin_truncated_in_token();    test_xstrjoin_truncated_before_sep();    test_xstrjoin_truncated_after_sep();    test_strquote();    test_utf8_truncate();    test_parse_integer();    test_parse_integer_with_suffix();    return 0;}
int main(int argc, char *argv[]) {    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    int res = scrcpy(args.serial, args.port, args.max_size, args.bit_rate) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    int res = scrcpy(args.serial, args.port, args.max_size, args.bit_rate) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
SDL_bool file_handler_init(struct file_handler *file_handler, const char *serial) {    if (!file_queue_init(&file_handler->queue)) {        return SDL_FALSE;    }    if (!(file_handler->mutex = SDL_CreateMutex())) {        return SDL_FALSE;    }    if (!(file_handler->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(file_handler->mutex);        return SDL_FALSE;    }    if (serial) {        file_handler->serial = SDL_strdup(serial);        if (!file_handler->serial) {            LOGW("Cannot strdup serial");            SDL_DestroyMutex(file_handler->mutex);            return SDL_FALSE;        }    } else {        file_handler->serial = NULL;    }    // lazy initialization    file_handler->initialized = SDL_FALSE;    file_handler->stopped = SDL_FALSE;    file_handler->current_process = PROCESS_NONE;    return SDL_TRUE;}
SDL_bool file_handler_init(struct file_handler *file_handler, const char *serial) {    if (!file_queue_init(&file_handler->queue)) {        return SDL_FALSE;    }    if (!(file_handler->mutex = SDL_CreateMutex())) {        return SDL_FALSE;    }    if (!(file_handler->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(file_handler->mutex);        return SDL_FALSE;    }    if (serial) {        file_handler->serial = SDL_strdup(serial);        if (!file_handler->serial) {            LOGW("Cannot strdup serial");            SDL_DestroyMutex(file_handler->mutex);            return SDL_FALSE;        }    } else {        file_handler->serial = NULL;    }    // lazy initialization    file_handler->initialized = SDL_FALSE;    file_handler->stopped = SDL_FALSE;    file_handler->current_process = PROCESS_NONE;    return SDL_TRUE;}
SDL_bool file_handler_init(struct file_handler *file_handler, const char *serial) {    if (!file_queue_init(&file_handler->queue)) {        return SDL_FALSE;    }    if (!(file_handler->mutex = SDL_CreateMutex())) {        return SDL_FALSE;    }    if (!(file_handler->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(file_handler->mutex);        return SDL_FALSE;    }    if (serial) {        file_handler->serial = SDL_strdup(serial);        if (!file_handler->serial) {            LOGW("Cannot strdup serial");            SDL_DestroyMutex(file_handler->mutex);            return SDL_FALSE;        }    } else {        file_handler->serial = NULL;    }    // lazy initialization    file_handler->initialized = SDL_FALSE;    file_handler->stopped = SDL_FALSE;    file_handler->current_process = PROCESS_NONE;    return SDL_TRUE;}
static int run_file_handler(void *data) {    struct file_handler *file_handler = data;    for (;;) {        mutex_lock(file_handler->mutex);        file_handler->current_process = PROCESS_NONE;        while (!file_handler->stopped && file_queue_is_empty(&file_handler->queue)) {            cond_wait(file_handler->event_cond, file_handler->mutex);        }        if (file_handler->stopped) {            // stop immediately, do not process further events            mutex_unlock(file_handler->mutex);            break;        }        char *current_apk;#ifdef BUILD_DEBUG        bool non_empty = file_queue_take(&file_handler->queue, &current_apk);        SDL_assert(non_empty);#else        file_queue_take(&file_handler->queue, &current_apk);#endif        LOGI("Installing %s...", current_apk);        process_t process = adb_install(file_handler->serial, current_apk);        file_handler->current_process = process;        mutex_unlock(file_handler->mutex);        if (process_check_success(process, "adb install")) {            LOGI("%s installed successfully", current_apk);        } else {            LOGE("Failed to install %s", current_apk);        }        SDL_free(current_apk);    }    return 0;}
void file_handler_destroy(struct file_handler *file_handler) {    SDL_DestroyCond(file_handler->event_cond);    SDL_DestroyMutex(file_handler->mutex);    file_queue_destroy(&file_handler->queue);    SDL_free((void *) file_handler->serial);}
void file_handler_destroy(struct file_handler *file_handler) {    SDL_DestroyCond(file_handler->event_cond);    SDL_DestroyMutex(file_handler->mutex);    file_queue_destroy(&file_handler->queue);    SDL_free((void *) file_handler->serial);}
void file_handler_destroy(struct file_handler *file_handler) {    SDL_DestroyCond(file_handler->event_cond);    SDL_DestroyMutex(file_handler->mutex);    file_queue_destroy(&file_handler->queue);    SDL_free((void *) file_handler->serial);}
SDL_bool file_queue_is_empty(const struct file_queue *queue) {    return queue->head == queue->tail;}
SDL_bool file_queue_is_empty(const struct file_queue *queue) {    return queue->head == queue->tail;}
SDL_bool file_handler_do(struct file_handler *file_handler, const char *file) {    SDL_bool res;    // start file_handler if it's used for the first time    if (!file_handler->initialized) {        if (!file_handler_start(file_handler)) {            return SDL_FALSE;        }        file_handler->initialized = SDL_TRUE;    }    mutex_lock(file_handler->mutex);    SDL_bool was_empty = file_queue_is_empty(&file_handler->queue);    res = file_queue_push(&file_handler->queue, file);    if (was_empty) {        cond_signal(file_handler->event_cond);    }    mutex_unlock(file_handler->mutex);    return res;}
SDL_bool file_handler_do(struct file_handler *file_handler, const char *file) {    SDL_bool res;    // start file_handler if it's used for the first time    if (!file_handler->initialized) {        if (!file_handler_start(file_handler)) {            return SDL_FALSE;        }        file_handler->initialized = SDL_TRUE;    }    mutex_lock(file_handler->mutex);    SDL_bool was_empty = file_queue_is_empty(&file_handler->queue);    res = file_queue_push(&file_handler->queue, file);    if (was_empty) {        cond_signal(file_handler->event_cond);    }    mutex_unlock(file_handler->mutex);    return res;}
SDL_bool file_queue_is_full(const struct file_queue *queue) {    return (queue->head + 1) % FILE_QUEUE_SIZE == queue->tail;}
SDL_bool file_queue_init(struct file_queue *queue) {    queue->head = 0;    queue->tail = 0;    return SDL_TRUE;}
SDL_bool file_queue_init(struct file_queue *queue) {    queue->head = 0;    queue->tail = 0;    return SDL_TRUE;}
SDL_bool file_queue_push(struct file_queue *queue, const char *file) {    if (file_queue_is_full(queue)) {        return SDL_FALSE;    }    queue->data[queue->head] = SDL_strdup(file);    queue->head = (queue->head + 1) % FILE_QUEUE_SIZE;    return SDL_TRUE;}
SDL_bool file_queue_push(struct file_queue *queue, const char *file) {    if (file_queue_is_full(queue)) {        return SDL_FALSE;    }    queue->data[queue->head] = SDL_strdup(file);    queue->head = (queue->head + 1) % FILE_QUEUE_SIZE;    return SDL_TRUE;}
SDL_bool file_queue_push(struct file_queue *queue, const char *file) {    if (file_queue_is_full(queue)) {        return SDL_FALSE;    }    queue->data[queue->head] = SDL_strdup(file);    queue->head = (queue->head + 1) % FILE_QUEUE_SIZE;    return SDL_TRUE;}
SDL_bool file_queue_take(struct file_queue *queue, char **file) {    if (file_queue_is_empty(queue)) {        return SDL_FALSE;    }    // transfer ownership    *file = queue->data[queue->tail];    queue->tail = (queue->tail + 1) % FILE_QUEUE_SIZE;    return SDL_TRUE;}
SDL_bool file_queue_take(struct file_queue *queue, char **file) {    if (file_queue_is_empty(queue)) {        return SDL_FALSE;    }    // transfer ownership    *file = queue->data[queue->tail];    queue->tail = (queue->tail + 1) % FILE_QUEUE_SIZE;    return SDL_TRUE;}
SDL_bool file_queue_take(struct file_queue *queue, char **file) {    if (file_queue_is_empty(queue)) {        return SDL_FALSE;    }    // transfer ownership    *file = queue->data[queue->tail];    queue->tail = (queue->tail + 1) % FILE_QUEUE_SIZE;    return SDL_TRUE;}
void file_queue_destroy(struct file_queue *queue) {    int i = queue->tail;    while (i != queue->head) {        SDL_free(queue->data[i]);        i = (i + 1) % FILE_QUEUE_SIZE;    }}
SDL_bool file_handler_init(struct file_handler *file_handler, const char *serial) {    if (!request_queue_init(&file_handler->queue)) {        return SDL_FALSE;    }    if (!(file_handler->mutex = SDL_CreateMutex())) {        return SDL_FALSE;    }    if (!(file_handler->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(file_handler->mutex);        return SDL_FALSE;    }    if (serial) {        file_handler->serial = SDL_strdup(serial);        if (!file_handler->serial) {            LOGW("Cannot strdup serial");            SDL_DestroyMutex(file_handler->mutex);            return SDL_FALSE;        }    } else {        file_handler->serial = NULL;    }    // lazy initialization    file_handler->initialized = SDL_FALSE;    file_handler->stopped = SDL_FALSE;    file_handler->current_process = PROCESS_NONE;    return SDL_TRUE;}
SDL_bool request_queue_init(struct request_queue *queue) {    queue->head = 0;    queue->tail = 0;    return SDL_TRUE;}
static struct request *request_new(file_handler_action_t action, const char *file) {    struct request *req = SDL_malloc(sizeof(*req));    if (!req) {        return NULL;    }    req->action = action;    req->file = file;    return req;}
static int run_file_handler(void *data) {    struct file_handler *file_handler = data;    for (;;) {        mutex_lock(file_handler->mutex);        file_handler->current_process = PROCESS_NONE;        while (!file_handler->stopped && request_queue_is_empty(&file_handler->queue)) {            cond_wait(file_handler->event_cond, file_handler->mutex);        }        if (file_handler->stopped) {            // stop immediately, do not process further events            mutex_unlock(file_handler->mutex);            break;        }        struct request *req;#ifdef BUILD_DEBUG        bool non_empty = request_queue_take(&file_handler->queue, &req);        SDL_assert(non_empty);#else        request_queue_take(&file_handler->queue, &req);#endif        process_t process;        if (req->action == ACTION_INSTALL_APK) {            LOGI("Installing %s...", req->file);            process = install_apk(file_handler->serial, req->file);        } else {            LOGI("Pushing %s...", req->file);            process = push_file(file_handler->serial, req->file);        }        file_handler->current_process = process;        mutex_unlock(file_handler->mutex);        if (req->action == ACTION_INSTALL_APK) {            if (process_check_success(process, "adb install")) {                LOGI("%s successfully installed", req->file);            } else {                LOGE("Failed to install %s", req->file);            }        } else {            if (process_check_success(process, "adb push")) {                LOGI("%s successfully pushed to /sdcard/", req->file);            } else {                LOGE("Failed to push %s to /sdcard/", req->file);            }        }        request_free(req);    }    return 0;}
void file_handler_destroy(struct file_handler *file_handler) {    SDL_DestroyCond(file_handler->event_cond);    SDL_DestroyMutex(file_handler->mutex);    request_queue_destroy(&file_handler->queue);    SDL_free((void *) file_handler->serial);}
SDL_bool file_handler_request(struct file_handler *file_handler,                              file_handler_action_t action,                              const char *file) {    SDL_bool res;    // start file_handler if it's used for the first time    if (!file_handler->initialized) {        if (!file_handler_start(file_handler)) {            return SDL_FALSE;        }        file_handler->initialized = SDL_TRUE;    }    LOGI("Request to %s %s", action == ACTION_INSTALL_APK ? "install" : "push", file);    struct request *req = request_new(action, file);    if (!req) {        LOGE("Could not create request");        return SDL_FALSE;    }    mutex_lock(file_handler->mutex);    SDL_bool was_empty = request_queue_is_empty(&file_handler->queue);    res = request_queue_push(&file_handler->queue, req);    if (was_empty) {        cond_signal(file_handler->event_cond);    }    mutex_unlock(file_handler->mutex);    return res;}
static process_t push_file(const char *serial, const char *file) {    return adb_push(serial, file, DEVICE_SDCARD_PATH);}
};static struct request *request_new(file_handler_action_t action, const char *file) {    struct request *req = SDL_malloc(sizeof(*req));
SDL_bool request_queue_is_full(const struct request_queue *queue) {    return (queue->head + 1) % REQUEST_QUEUE_SIZE == queue->tail;}
    } else {        file_handler->serial = NULL;    }    // lazy initialization    file_handler->initialized = SDL_FALSE;    file_handler->stopped = SDL_FALSE;    file_handler->current_process = PROCESS_NONE;    return SDL_TRUE;}void file_handler_destroy(struct file_handler *file_handler) {    SDL_DestroyCond(file_handler->event_cond);    SDL_DestroyMutex(file_handler->mutex);    request_queue_destroy(&file_handler->queue);    SDL_free((void *) file_handler->serial);}static process_t install_apk(const char *serial, const char *file) {
static process_t install_apk(const char *serial, const char *file) {    return adb_install(serial, file);}
    if (!req) {        return NULL;    }    req->action = action;
    req->file = file;    return req;}static void request_free(struct request *req) {    if (!req) {
SDL_bool request_queue_take(struct request_queue *queue, struct request **req) {    if (request_queue_is_empty(queue)) {        return SDL_FALSE;    }    // transfer ownership    *req = queue->reqs[queue->tail];    queue->tail = (queue->tail + 1) % REQUEST_QUEUE_SIZE;    return SDL_TRUE;}
}SDL_bool request_queue_is_full(const struct request_queue *queue) {    return (queue->head + 1) % REQUEST_QUEUE_SIZE == queue->tail;}SDL_bool request_queue_init(struct request_queue *queue) {    queue->head = 0;    queue->tail = 0;
static void request_free(struct request *req) {    if (!req) {        return;    }    SDL_free((void *) req->file);    SDL_free((void *) req);}
SDL_bool request_queue_is_empty(const struct request_queue *queue) {    return queue->head == queue->tail;}
    return SDL_TRUE;}void request_queue_destroy(struct request_queue *queue) {    int i = queue->tail;    while (i != queue->head) {        request_free(queue->reqs[i]);        i = (i + 1) % REQUEST_QUEUE_SIZE;    }}
void request_queue_destroy(struct request_queue *queue) {    int i = queue->tail;    while (i != queue->head) {        request_free(queue->reqs[i]);        i = (i + 1) % REQUEST_QUEUE_SIZE;    }}
SDL_bool request_queue_push(struct request_queue *queue, struct request *req) {    if (request_queue_is_full(queue)) {        return SDL_FALSE;    }    queue->reqs[queue->head] = req;    queue->head = (queue->head + 1) % REQUEST_QUEUE_SIZE;    return SDL_TRUE;}
        return;    }    SDL_free((void *) req->file);    SDL_free((void *) req);}SDL_bool request_queue_is_empty(const struct request_queue *queue) {    return queue->head == queue->tail;
static SDL_bool event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return SDL_FALSE;            case SDL_QUIT:                LOGD("User requested to quit");                return SDL_TRUE;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return SDL_FALSE;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                    case SDL_WINDOWEVENT_EXPOSED:                    case SDL_WINDOWEVENT_SIZE_CHANGED:                        screen_render(&screen);                        break;                }                break;            case SDL_TEXTINPUT:                input_manager_process_text_input(&input_manager, &event.text);                break;            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL:                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP:                input_manager_process_mouse_button(&input_manager, &event.button);                break;            case SDL_DROPFILE:                file_handler_do(&file_handler, event.drop.file);                break;        }    }    return SDL_FALSE;}
static SDL_bool event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return SDL_FALSE;            case SDL_QUIT:                LOGD("User requested to quit");                return SDL_TRUE;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return SDL_FALSE;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                    case SDL_WINDOWEVENT_EXPOSED:                    case SDL_WINDOWEVENT_SIZE_CHANGED:                        screen_render(&screen);                        break;                }                break;            case SDL_TEXTINPUT:                input_manager_process_text_input(&input_manager, &event.text);                break;            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL:                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP:                input_manager_process_mouse_button(&input_manager, &event.button);                break;            case SDL_DROPFILE:                file_handler_do(&file_handler, event.drop.file);                break;        }    }    return SDL_FALSE;}
static SDL_bool event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return SDL_FALSE;            case SDL_QUIT:                LOGD("User requested to quit");                return SDL_TRUE;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return SDL_FALSE;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                    case SDL_WINDOWEVENT_EXPOSED:                    case SDL_WINDOWEVENT_SIZE_CHANGED:                        screen_render(&screen);                        break;                }                break;            case SDL_TEXTINPUT:                input_manager_process_text_input(&input_manager, &event.text);                break;            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL:                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP:                input_manager_process_mouse_button(&input_manager, &event.button);                break;            case SDL_DROPFILE: {                file_handler_action_t action;                if (is_apk(event.drop.file)) {                    action = ACTION_INSTALL_APK;                } else {                    action = ACTION_PUSH_FILE;                }                file_handler_request(&file_handler, action, event.drop.file);                break;            }        }    }    return SDL_FALSE;}
static SDL_bool is_apk(const char *file) {    const char *ext = strrchr(file, '.');    return ext && !strcmp(ext, ".apk");}
SDL_bool screen_init_rendering(struct screen *screen, const char *device_name, struct size frame_size) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height, SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1, SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width, frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    screen->texture = SDL_CreateTexture(screen->renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                                        frame_size.width, frame_size.height);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    return SDL_TRUE;}
SDL_bool screen_init_rendering(struct screen *screen, const char *device_name, struct size frame_size) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    Uint32 window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height, window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1, SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width, frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    screen->texture = SDL_CreateTexture(screen->renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                                        frame_size.width, frame_size.height);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    return SDL_TRUE;}
static void stop_server(process_t server) {    if (!cmd_terminate(server)) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not kill: %s", strerror(errno));    }}
static process_t start_server(const char *serial) {    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/system/bin",        "com.genymobile.scrcpy.ScrCpyServer"    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
    size->width = (buf[DEVICE_NAME_FIELD_LENGTH] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 1];    size->height = (buf[DEVICE_NAME_FIELD_LENGTH + 2] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 3];    return SDL_TRUE;}#if SDL_VERSION_ATLEAST(2, 0, 5)
// name must be at least DEVICE_NAME_FIELD_LENGTH bytesSDL_bool read_initial_device_info(TCPsocket socket, char *device_name, struct size *size) {    unsigned char buf[DEVICE_NAME_FIELD_LENGTH + 4];    if (SDLNet_TCP_Recv(socket, buf, sizeof(buf)) <= 0) {        return SDL_FALSE;    }    buf[DEVICE_NAME_FIELD_LENGTH - 1] = '\0'; // in case the client sends garbage    // scrcpy is safe here, since name contains at least DEVICE_NAME_FIELD_LENGTH bytes    // and strlen(buf) < DEVICE_NAME_FIELD_LENGTH    strcpy(device_name, (char *) buf);
    private boolean injectText(String text) {        for (char c : text.toCharArray()) {            if (!injectChar(c)) {                return false;            }        }        return true;    }
    private int injectText(String text) {        int successCount = 0;        for (char c : text.toCharArray()) {            if (!injectChar(c)) {                continue;            }            successCount++;        }        return successCount;    }
parse_port(char *optarg, uint16_t *port) {    char *endptr;    if (*optarg == '\0') {        LOGE("Invalid port parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid port: %s", optarg);        return false;    }    if (value & ~0xffff) {        LOGE("Port out of range: %ld", value);        return false;    }    *port = (uint16_t) value;    return true;}
parse_port(char *optarg, uint16_t *port) {    char *endptr;    if (*optarg == '\0') {        LOGE("Port parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid port: %s", optarg);        return false;    }    if (value & ~0xffff) {        LOGE("Port out of range: %ld", value);        return false;    }    *port = (uint16_t) value;    return true;}
    private static IBinder createDisplay() {        return SurfaceControl.createDisplay("scrcpy", false);    }
    private static IBinder createDisplay() {        return SurfaceControl.createDisplay("scrcpy", true);    }
file_handler_init(struct file_handler *file_handler, const char *serial) {    if (!request_queue_init(&file_handler->queue)) {        return false;    }    if (!(file_handler->mutex = SDL_CreateMutex())) {        return false;    }    if (!(file_handler->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(file_handler->mutex);        return false;    }    if (serial) {        file_handler->serial = SDL_strdup(serial);        if (!file_handler->serial) {            LOGW("Cannot strdup serial");            SDL_DestroyMutex(file_handler->mutex);            return false;        }    } else {        file_handler->serial = NULL;    }    // lazy initialization    file_handler->initialized = false;    file_handler->stopped = false;    file_handler->current_process = PROCESS_NONE;    return true;}
file_handler_init(struct file_handler *file_handler, const char *serial) {    if (!request_queue_init(&file_handler->queue)) {        return false;    }    if (!(file_handler->mutex = SDL_CreateMutex())) {        return false;    }    if (!(file_handler->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(file_handler->mutex);        return false;    }    if (serial) {        file_handler->serial = SDL_strdup(serial);        if (!file_handler->serial) {            LOGW("Cannot strdup serial");            SDL_DestroyCond(file_handler->event_cond);            SDL_DestroyMutex(file_handler->mutex);            return false;        }    } else {        file_handler->serial = NULL;    }    // lazy initialization    file_handler->initialized = false;    file_handler->stopped = false;    file_handler->current_process = PROCESS_NONE;    return true;}
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        // Some devices internally create a Handler when creating an input Surface, causing an exception:        //   "Can't create handler inside thread that has not called Looper.prepare()"        // <https://github.com/Genymobile/scrcpy/issues/240>        //        // Use Looper.prepareMainLooper() instead of Looper.prepare() to avoid a NullPointerException:        //   "Attempt to read from field 'android.os.MessageQueue android.os.Looper.mQueue'        //    on a null object reference"        // <https://github.com/Genymobile/scrcpy/issues/921>        Looper.prepareMainLooper();        MediaFormat format = createFormat(bitRate, maxFps, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                Rect contentRect = device.getScreenInfo().getContentRect();                Rect videoRect = device.getScreenInfo().getVideoSize().toRect();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, contentRect, videoRect);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        Workarounds.prepareMainLooper();        MediaFormat format = createFormat(bitRate, maxFps, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                Rect contentRect = device.getScreenInfo().getContentRect();                Rect videoRect = device.getScreenInfo().getVideoSize().toRect();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, contentRect, videoRect);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    int res = scrcpy(args.serial, args.port, args.max_size, args.bit_rate) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .port = args.port,        .max_size = args.max_size,        .bit_rate = args.bit_rate,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
import java.io.IOException;public class EventController {    private final Device device;    private final DesktopConnection connection;    private final KeyCharacterMap charMap = KeyCharacterMap.load(KeyCharacterMap.VIRTUAL_KEYBOARD);    private long lastMouseDown;    private final MotionEvent.PointerProperties[] pointerProperties = {new MotionEvent.PointerProperties()};    private final MotionEvent.PointerCoords[] pointerCoords = {new MotionEvent.PointerCoords()};    public EventController(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;        initPointer();    }    private void initPointer() {        MotionEvent.PointerProperties props = pointerProperties[0];        props.id = 0;        props.toolType = MotionEvent.TOOL_TYPE_FINGER;
    private boolean injectText(String text) {        KeyEvent[] events = charMap.getEvents(text.toCharArray());        if (events == null) {            return false;        }        for (KeyEvent event : events) {            if (!injectEvent(event)) {                return false;            }        }        return true;    }
    private boolean injectText(String text) {        KeyEvent[] events = charMap.getEvents(text.toCharArray());        if (events == null) {            return false;        }        for (KeyEvent event : events) {            if (!injectEvent(event)) {                return false;            }        }        return true;    }
    private boolean injectDecomposition(String text) {        for (char c : text.toCharArray()) {            String composedText = KeyComposition.decompose(c);            if (composedText == null || !injectText(composedText, false)) {                return false;            }        }        return true;    }
    private boolean injectText(String text, boolean decomposeOnFailure) {        KeyEvent[] events = charMap.getEvents(text.toCharArray());        if (events == null) {            return decomposeOnFailure ? injectDecomposition(text) : false;        }        for (KeyEvent event : events) {            if (!injectEvent(event)) {                return false;            }        }        return true;    }
    private boolean injectText(String text) {        return injectText(text, true);    }
typedef struct SDL_cond SDL_cond;voidmutex_lock(SDL_mutex *mutex);voidmutex_unlock(SDL_mutex *mutex);
typedef struct SDL_cond SDL_cond;voidmutex_lock(SDL_mutex *mutex);voidmutex_unlock(SDL_mutex *mutex);
typedef struct SDL_cond SDL_cond;voidmutex_lock(SDL_mutex *mutex);voidmutex_unlock(SDL_mutex *mutex);
typedef struct SDL_cond SDL_cond;voidmutex_lock(SDL_mutex *mutex);voidmutex_unlock(SDL_mutex *mutex);
typedef struct SDL_cond SDL_cond;voidmutex_lock(SDL_mutex *mutex);voidmutex_unlock(SDL_mutex *mutex);
cond_wait_timeout(SDL_cond *cond, SDL_mutex *mutex, uint32_t ms) {    int r = SDL_CondWaitTimeout(cond, mutex, ms);    if (r < 0) {        LOGC("Could not wait on condition with timeout");        abort();    }    return r;}
cond_wait(SDL_cond *cond, SDL_mutex *mutex) {    if (SDL_CondWait(cond, mutex)) {        LOGC("Could not wait on condition");        abort();    }}
mutex_lock(SDL_mutex *mutex) {    if (SDL_LockMutex(mutex)) {        LOGC("Could not lock mutex");        abort();    }}
cond_signal(SDL_cond *cond) {    if (SDL_CondSignal(cond)) {        LOGC("Could not signal a condition");        abort();    }}
mutex_unlock(SDL_mutex *mutex) {    if (SDL_UnlockMutex(mutex)) {        LOGC("Could not unlock mutex");        abort();    }}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (parse_args(&args, argc, argv)) {        usage(argv[0]);        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = scrcpy(args.serial, args.port, args.max_size, args.bit_rate) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (parse_args(&args, argc, argv)) {        usage(argv[0]);        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    int res = scrcpy(args.serial, args.port, args.max_size, args.bit_rate) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    SDL_bool ret = 0;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, max_size, bit_rate);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable mouse focus clickthrough");    }    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    SDL_bool ret = SDL_TRUE;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, max_size, bit_rate);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable mouse focus clickthrough");    }    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
adb_execute(const char *serial, const char *const adb_cmd[], int len) {    const char *cmd[len + 4];    int i;    process_t process;    cmd[0] = get_adb_command();    if (serial) {        cmd[1] = "-s";        cmd[2] = serial;        i = 3;    } else {        i = 1;    }    memcpy(&cmd[i], adb_cmd, len * sizeof(const char *));    cmd[len + i] = NULL;    enum process_result r = cmd_execute(cmd[0], cmd, &process);    if (r != PROCESS_SUCCESS) {        show_adb_err_msg(r);        return PROCESS_NONE;    }    return process;}
adb_execute(const char *serial, const char *const adb_cmd[], int len) {    const char *cmd[len + 4];    int i;    process_t process;    cmd[0] = get_adb_command();    if (serial) {        cmd[1] = "-s";        cmd[2] = serial;        i = 3;    } else {        i = 1;    }    memcpy(&cmd[i], adb_cmd, len * sizeof(const char *));    cmd[len + i] = NULL;    enum process_result r = cmd_execute(cmd[0], cmd, &process);    if (r != PROCESS_SUCCESS) {        show_adb_err_msg(r);        return PROCESS_NONE;    }    return process;}
adb_execute(const char *serial, const char *const adb_cmd[], size_t len) {    const char *cmd[len + 4];    int i;    process_t process;    cmd[0] = get_adb_command();    if (serial) {        cmd[1] = "-s";        cmd[2] = serial;        i = 3;    } else {        i = 1;    }    memcpy(&cmd[i], adb_cmd, len * sizeof(const char *));    cmd[len + i] = NULL;    enum process_result r = cmd_execute(cmd[0], cmd, &process);    if (r != PROCESS_SUCCESS) {        show_adb_err_msg(r);        return PROCESS_NONE;    }    return process;}
adb_execute(const char *serial, const char *const adb_cmd[], size_t len) {    const char *cmd[len + 4];    int i;    process_t process;    cmd[0] = get_adb_command();    if (serial) {        cmd[1] = "-s";        cmd[2] = serial;        i = 3;    } else {        i = 1;    }    memcpy(&cmd[i], adb_cmd, len * sizeof(const char *));    cmd[len + i] = NULL;    enum process_result r = cmd_execute(cmd[0], cmd, &process);    if (r != PROCESS_SUCCESS) {        show_adb_err_msg(r);        return PROCESS_NONE;    }    return process;}
SDL_bool decoder_start(struct decoder *decoder) {    LOGD("Starting decoder thread");    decoder->thread = SDL_CreateThread(run_decoder, "video_decoder", decoder);    if (!decoder->thread) {        LOGC("Could not start decoder thread");        return SDL_FALSE;    }    return SDL_TRUE;}
void decoder_init(struct decoder *decoder, struct frames *frames, socket_t video_socket) {    decoder->frames = frames;    decoder->video_socket = video_socket;}
void decoder_init(struct decoder *decoder, struct frames *frames, socket_t video_socket) {    decoder->frames = frames;    decoder->video_socket = video_socket;}
SDL_bool decoder_start(struct decoder *decoder) {    LOGD("Starting decoder thread");    decoder->thread = SDL_CreateThread(run_decoder, "video_decoder", decoder);    if (!decoder->thread) {        LOGC("Could not start decoder thread");        return SDL_FALSE;    }    return SDL_TRUE;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
void decoder_init(struct decoder *decoder, struct frames *frames, socket_t video_socket) {    decoder->frames = frames;    decoder->video_socket = video_socket;}
static int read_packet(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    return net_recv(decoder->video_socket, buf, buf_size);}
SDL_bool decoder_start(struct decoder *decoder, const char *out_filename) {    LOGD("Starting decoder thread");    decoder->out_filename = out_filename;    decoder->thread = SDL_CreateThread(run_decoder, "video_decoder", decoder);    if (!decoder->thread) {        LOGC("Could not start decoder thread");        return SDL_FALSE;    }    return SDL_TRUE;}
            if (ret < 0) {                LOGE("Failed to open output file");                goto run_finally_free_output_ctx;            }            ret = avformat_write_header(output_ctx, NULL);
static inline uint64_t from_be(uint8_t *b, int size){    uint64_t x = 0;    int i;    for (i = 0; i < size; i += 1) {        x <<= 8;        x |= b[i];    }    return x;}
            if (ret < 0) {                LOGE("Error writing output header");                avio_closep(&output_ctx->pb);                goto run_finally_free_output_ctx;            }        }    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;
static int run_decoder(void *data) {    struct decoder *decoder = data;    int ret;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    AVStream *outstream = NULL;    AVFormatContext *output_ctx = NULL;    if (decoder->out_filename) {        avformat_alloc_output_context2(&output_ctx, NULL, NULL, decoder->out_filename);        if (!output_ctx) {            LOGE("Could not allocate output format context");            goto run_finally_free_avio_ctx;        } else {            outstream = avformat_new_stream(output_ctx, codec);            if (!outstream) {                LOGE("Could not allocate output stream");                goto run_finally_free_output_ctx;            }            outstream->codec = avcodec_alloc_context3(codec);            outstream->codec->pix_fmt = AV_PIX_FMT_YUV420P;            outstream->codec->width = decoder->frame_size.width;            outstream->codec->height = decoder->frame_size.height;            outstream->time_base = (AVRational) {1, 60};            outstream->codec->flags |= AV_CODEC_FLAG_GLOBAL_HEADER;            ret = avio_open(&output_ctx->pb, decoder->out_filename, AVIO_FLAG_WRITE);            if (ret < 0) {                LOGE("Failed to open output file");                goto run_finally_free_output_ctx;            }            ret = avformat_write_header(output_ctx, NULL);            if (ret < 0) {                LOGE("Error writing output header");                avio_closep(&output_ctx->pb);                goto run_finally_free_output_ctx;            }        }    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {        if (output_ctx) {            packet.pts = decoder->pts;            av_packet_rescale_ts(&packet, us, outstream->time_base);            ret = av_write_frame(output_ctx, &packet);        }// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (output_ctx) {        ret = av_write_trailer(output_ctx);        avio_closep(&output_ctx->pb);    }    avformat_close_input(&format_ctx);run_finally_free_output_ctx:    if (output_ctx)        avformat_free_context(output_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
void decoder_init(struct decoder *decoder, struct frames *frames, socket_t video_socket, struct size frame_size) {    decoder->frames = frames;    decoder->video_socket = video_socket;    decoder->frame_size = frame_size;}
static int read_packet(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    uint8_t header[HEADER_SIZE];    int remaining;    int ret;    remaining = decoder->remaining;    if (remaining == 0) {        ret = net_recv(decoder->video_socket, header, HEADER_SIZE);        if (ret <= 0)            return ret;        decoder->pts = from_be(header, 8);        remaining = from_be(header + 12, 4);    }    if (buf_size > remaining)        buf_size = remaining;    ret = net_recv(decoder->video_socket, buf, buf_size);    if (ret <= 0)        return ret;    remaining -= ret;    decoder->remaining = remaining;    return ret;}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"bit-rate",     required_argument, NULL, 'b'},        {"crop",         required_argument, NULL, 'c'},        {"fullscreen",   no_argument,       NULL, 'f'},        {"help",         no_argument,       NULL, 'h'},        {"max-size",     required_argument, NULL, 'm'},        {"port",         required_argument, NULL, 'p'},        {"serial",       required_argument, NULL, 's'},        {"show-touches", no_argument,       NULL, 't'},        {"version",      no_argument,       NULL, 'v'},        {NULL,           0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fhm:p:s:tv", long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = SDL_TRUE;                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = SDL_TRUE;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    return SDL_TRUE;}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .out_filename = args.out_filename,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -o, --output-file\n"        "        Write video output to file.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"bit-rate",     required_argument, NULL, 'b'},        {"crop",         required_argument, NULL, 'c'},        {"fullscreen",   no_argument,       NULL, 'f'},        {"help",         no_argument,       NULL, 'h'},        {"max-size",     required_argument, NULL, 'm'},        {"output-file",  required_argument, NULL, 'o'},        {"port",         required_argument, NULL, 'p'},        {"serial",       required_argument, NULL, 's'},        {"show-touches", no_argument,       NULL, 't'},        {"version",      no_argument,       NULL, 'v'},        {NULL,           0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fhm:o:p:s:tv", long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = SDL_TRUE;                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'o':                args->out_filename = optarg;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = SDL_TRUE;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    return SDL_TRUE;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_file_handler;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    decoder_init(&decoder, &frames, device_socket, frame_size);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder, options->out_filename)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_file_handler;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
    private boolean encode(MediaCodec codec, FileDescriptor fd) throws IOException {        boolean eof = false;        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();        while (!consumeRotationChange() && !eof) {            int outputBufferId = codec.dequeueOutputBuffer(bufferInfo, -1);            eof = (bufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;            try {                if (consumeRotationChange()) {                    // must restart encoding with new size                    break;                }                if (outputBufferId >= 0) {                    ByteBuffer codecBuffer = codec.getOutputBuffer(outputBufferId);                    IO.writeFully(fd, codecBuffer);                }            } finally {                if (outputBufferId >= 0) {                    codec.releaseOutputBuffer(outputBufferId, false);                }            }        }        return !eof;    }
    private boolean encode(MediaCodec codec, FileDescriptor fd) throws IOException {        boolean eof = false;        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();        ByteBuffer bBuffer = ByteBuffer.allocate(16);        while (!consumeRotationChange() && !eof) {            int outputBufferId = codec.dequeueOutputBuffer(bufferInfo, -1);            eof = (bufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;            try {                if (consumeRotationChange()) {                    // must restart encoding with new size                    break;                }                if (outputBufferId >= 0) {                    ByteBuffer codecBuffer = codec.getOutputBuffer(outputBufferId);                    bBuffer.position(0);                    bBuffer.putLong(bufferInfo.presentationTimeUs);                    bBuffer.putInt(bufferInfo.flags);                    bBuffer.putInt(codecBuffer.remaining());                    bBuffer.position(0);                    IO.writeFully(fd, bBuffer);                    IO.writeFully(fd, codecBuffer);                }            } finally {                if (outputBufferId >= 0) {                    codec.releaseOutputBuffer(outputBufferId, false);                }            }        }        return !eof;    }
SDL_bool installer_init(struct installer *installer, const char *serial) {    if (!apk_queue_init(&installer->queue)) {        return SDL_FALSE;    }    if (!(installer->mutex = SDL_CreateMutex())) {        return SDL_FALSE;    }    if (!(installer->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(installer->mutex);        return SDL_FALSE;    }    if (serial) {        installer->serial = SDL_strdup(serial);        if (!installer->serial) {            LOGW("Cannot strdup serial");            return SDL_FALSE;        }    } else {        installer->serial = NULL;    }    // lazy initialization    installer->initialized = SDL_FALSE;    installer->stopped = SDL_FALSE;    return SDL_TRUE;}
SDL_bool installer_init(struct installer *installer, const char *serial) {    if (!apk_queue_init(&installer->queue)) {        return SDL_FALSE;    }    if (!(installer->mutex = SDL_CreateMutex())) {        return SDL_FALSE;    }    if (!(installer->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(installer->mutex);        return SDL_FALSE;    }    if (serial) {        installer->serial = SDL_strdup(serial);        if (!installer->serial) {            LOGW("Cannot strdup serial");            return SDL_FALSE;        }    } else {        installer->serial = NULL;    }    // lazy initialization    installer->initialized = SDL_FALSE;    installer->stopped = SDL_FALSE;    installer->current_process = PROCESS_NONE;    return SDL_TRUE;}
void input_manager_process_text_input(struct input_manager *input_manager,                                      const SDL_TextInputEvent *event) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    control_event.text_event.text = SDL_strdup(event->text);    if (!control_event.text_event.text) {        LOGW("Cannot strdup input text");        return;    }    if (!controller_push_event(input_manager->controller, &control_event)) {        LOGW("Cannot send text event");    }}
void input_manager_process_text_input(struct input_manager *input_manager,                                      const SDL_TextInputEvent *event) {    char c = event->text[0];    if (isalpha(c) || c == ' ') {        SDL_assert(event->text[1] == '\0');        // letters and space are handled as raw key event        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    control_event.text_event.text = SDL_strdup(event->text);    if (!control_event.text_event.text) {        LOGW("Cannot strdup input text");        return;    }    if (!controller_push_event(input_manager->controller, &control_event)) {        LOGW("Cannot send text event");    }}
static process_t execute_server(const char *serial, Uint16 max_size, Uint32 bit_rate) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.ScrCpyServer",        max_size_string,        bit_rate_string,    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
static process_t execute_server(const char *serial, Uint16 max_size, Uint32 bit_rate) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
    @SuppressWarnings("checkstyle:MagicNumber")    private static Options createOptions(String... args) {        Options options = new Options();        if (args.length < 1) {            return options;        }        int maxSize = Integer.parseInt(args[0]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        if (args.length < 2) {            return options;        }        int bitRate = Integer.parseInt(args[1]);        options.setBitRate(bitRate);        return options;    }
    private ScrCpyServer() {        // not instantiable    }
    private Server() {        // not instantiable    }
    private Server() {        // not instantiable    }
    private static LocalSocket listenAndAccept(String abstractName) throws IOException {        LocalServerSocket localServerSocket = new LocalServerSocket(abstractName);        return localServerSocket.accept();    }
    private static LocalSocket listenAndAccept(String abstractName) throws IOException {        LocalServerSocket localServerSocket = new LocalServerSocket(abstractName);        try {            return localServerSocket.accept();        } finally {            localServerSocket.close();        }    }
static const AVOutputFormat *find_mp4_muxer(void) {    void *opaque = NULL;    const AVOutputFormat *oformat;    do {        oformat = av_muxer_iterate(&opaque);        // until null or with name "mp4"    } while (oformat && strcmp(oformat->name, "mp4"));    return oformat;}
static const AVOutputFormat *find_mp4_muxer(void) {#if LIBAVFORMAT_VERSION_INT >= AV_VERSION_INT(58, 9, 100)    void *opaque = NULL;#endif    const AVOutputFormat *oformat = NULL;    do {#if LIBAVFORMAT_VERSION_INT >= AV_VERSION_INT(58, 9, 100)        oformat = av_muxer_iterate(&opaque);#else        oformat = av_oformat_next(oformat);#endif        // until null or with name "mp4"    } while (oformat && strcmp(oformat->name, "mp4"));    return oformat;}
#include <SDL2/SDL_net.h>#include "command.h"#include "common.h"#include "control.h"#include "convert.h"#include "decoder.h"#include "events.h"
static void handle_text_input(const SDL_TextInputEvent *event) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    strncpy(control_event.text_event.text, event->text, TEXT_MAX_LENGTH);    control_event.text_event.text[TEXT_MAX_LENGTH] = '\0';    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send text event");    }}
static void handle_text_input(const SDL_TextInputEvent *event) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    strncpy(control_event.text_event.text, event->text, TEXT_MAX_LENGTH);    control_event.text_event.text[TEXT_MAX_LENGTH] = '\0';    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send text event");    }}
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        // Ctrl+x: optimal size        if (keycode == SDLK_x && !shift) {            if (!fullscreen) {                struct size optimal_size = get_optimal_window_size(window, frame_size);                SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Resized to optimal size");            }            return;        }        // Ctrl+g: pixel-perfect (ratio 1:1)        if (keycode == SDLK_g && !shift) {            if (!fullscreen) {                SDL_SetWindowSize(window, frame_size.width, frame_size.height);                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Resized to pixel-perfect");            }            return;        }        // Ctrl+f: switch fullscreen        if (keycode == SDLK_f && !shift) {            if (switch_fullscreen()) {                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Switched to %s mode", fullscreen ? "fullscreen" : "windowed");            } else {                SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());            }            return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
static void send_keycode(enum android_keycode keycode, const char *name) {    // send DOWN event    struct control_event control_event = {        .type = CONTROL_EVENT_TYPE_KEYCODE,        .keycode_event = {            .action = AKEY_EVENT_ACTION_DOWN,            .keycode = keycode,            .metastate = 0,        },    };    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send %s (DOWN)", name);        return;    }    // send UP event    control_event.keycode_event.action = AKEY_EVENT_ACTION_UP;    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send %s (UP)", name);    }}
static void handle_text_input(const SDL_TextInputEvent *event) {    if (is_ctrl_down()) {        char c = event->text[0];        switch (c) {            case '+':                send_keycode(AKEYCODE_VOLUME_UP, "VOLUME_UP");                break;            case '-':                send_keycode(AKEYCODE_VOLUME_DOWN, "VOLUME_DOWN");                break;        }        // ignore        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    strncpy(control_event.text_event.text, event->text, TEXT_MAX_LENGTH);    control_event.text_event.text[TEXT_MAX_LENGTH] = '\0';    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send text event");    }}
static SDL_bool is_ctrl_down(void) {    const Uint8 *state = SDL_GetKeyboardState(NULL);    return state[SDL_SCANCODE_LCTRL] || state[SDL_SCANCODE_RCTRL];}
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        // Ctrl+x: optimal size        if (keycode == SDLK_x && !shift) {            if (!fullscreen) {                struct size optimal_size = get_optimal_window_size(window, frame_size);                SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Resized to optimal size");            }            return;        }        // Ctrl+g: pixel-perfect (ratio 1:1)        if (keycode == SDLK_g && !shift) {            if (!fullscreen) {                SDL_SetWindowSize(window, frame_size.width, frame_size.height);                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Resized to pixel-perfect");            }            return;        }        // Ctrl+f: switch fullscreen        if (keycode == SDLK_f && !shift) {            if (switch_fullscreen()) {                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Switched to %s mode", fullscreen ? "fullscreen" : "windowed");            } else {                SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());            }            return;        }        // Ctrl+h: HOME (the HOME key also works natively)        if (keycode == SDLK_h && !shift) {             send_keycode(AKEYCODE_HOME, "HOME");             return;        }        // Ctrl+b or Ctrl+BACKSPACE: BACK (the ESCAPE key also works natively)        if ((keycode == SDLK_b && !shift) || keycode == SDLK_BACKSPACE) {            send_keycode(AKEYCODE_BACK, "BACK");            return;        }        // Ctrl+m: APP_SWITCH        if (keycode == SDLK_m && !shift) {            send_keycode(AKEYCODE_APP_SWITCH, "APP_SWITCH");            return;        }        // Ctrl+p: POWER        if (keycode == SDLK_p && !shift) {            send_keycode(AKEYCODE_POWER, "POWER");            return;        }        // volume shortcuts are handled in handle_text_input()        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
SDL_bool show_screen(const char *serial, Uint16 local_port) {    SDL_bool ret = 0;    const char *server_jar_path = getenv("SCRCPY_SERVER_JAR");    if (!server_jar_path) {        server_jar_path = "scrcpy-server.jar";    }    process_t push_proc = adb_push(serial, server_jar_path, "/data/local/tmp/");    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = adb_reverse(serial, SOCKET_NAME, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    struct size frame_size;    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    SDL_Window *window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    SDL_Texture *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    long ts = timestamp_ms();    int nbframes = 0;    SDL_bool texture_empty = SDL_TRUE;    SDL_bool fullscreen = SDL_FALSE;    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            goto screen_quit;        case EVENT_NEW_FRAME:            mutex_lock(frames.mutex);            AVFrame *frame = frames.rendering_frame;            frames.rendering_frame_consumed = SDL_TRUE;            if (!decoder.skip_frames) {                cond_signal(frames.rendering_frame_consumed_cond);            }            struct size current_frame_size = {frame->width, frame->height};            if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {                goto screen_quit;            }            frame_size = current_frame_size;            update_texture(frame, texture);            mutex_unlock(frames.mutex);            texture_empty = SDL_FALSE;            long now = timestamp_ms();            ++nbframes;            if (now - ts > 1000) {                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "%d fps", nbframes);                ts = now;                nbframes = 0;            }            render(renderer, texture);            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_KEYDOWN: {            SDL_bool ctrl = SDL_GetModState() & (KMOD_LCTRL | KMOD_RCTRL);            SDL_bool shift = SDL_GetModState() & (KMOD_LSHIFT | KMOD_RSHIFT);            SDL_bool repeat = event.key.repeat;            switch (event.key.keysym.sym) {            case SDLK_x:                if (!repeat && ctrl && !shift) {                    // Ctrl+x                    struct size optimal_size = get_optimal_window_size(window, frame_size);                    SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                }                break;            case SDLK_f:                if (!repeat && ctrl && !shift) {                    // Ctrl+f                    Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;                    if (!SDL_SetWindowFullscreen(window, new_mode)) {                        fullscreen = !fullscreen;                        render(renderer, texture_empty ? NULL : texture);                    } else {                        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());                    }                }                break;            }            break;        }        }    }screen_quit:    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = adb_reverse_remove(serial, SOCKET_NAME);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool show_screen(const char *serial, Uint16 local_port) {    SDL_bool ret = 0;    const char *server_jar_path = getenv("SCRCPY_SERVER_JAR");    if (!server_jar_path) {        server_jar_path = "scrcpy-server.jar";    }    process_t push_proc = adb_push(serial, server_jar_path, "/data/local/tmp/");    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = adb_reverse(serial, SOCKET_NAME, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    struct size frame_size;    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    SDL_Window *window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    SDL_Texture *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    long ts = timestamp_ms();    int nbframes = 0;    SDL_bool texture_empty = SDL_TRUE;    SDL_bool fullscreen = SDL_FALSE;    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            goto screen_quit;        case EVENT_NEW_FRAME:            mutex_lock(frames.mutex);            AVFrame *frame = frames.rendering_frame;            frames.rendering_frame_consumed = SDL_TRUE;            if (!decoder.skip_frames) {                cond_signal(frames.rendering_frame_consumed_cond);            }            struct size current_frame_size = {frame->width, frame->height};            if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {                goto screen_quit;            }            frame_size = current_frame_size;            update_texture(frame, texture);            mutex_unlock(frames.mutex);            texture_empty = SDL_FALSE;            long now = timestamp_ms();            ++nbframes;            if (now - ts > 1000) {                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "%d fps", nbframes);                ts = now;                nbframes = 0;            }            render(renderer, texture);            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_KEYDOWN: {            SDL_bool ctrl = SDL_GetModState() & (KMOD_LCTRL | KMOD_RCTRL);            SDL_bool shift = SDL_GetModState() & (KMOD_LSHIFT | KMOD_RSHIFT);            SDL_bool repeat = event.key.repeat;            switch (event.key.keysym.sym) {            case SDLK_x:                if (!repeat && ctrl && !shift) {                    // Ctrl+x                    struct size optimal_size = get_optimal_window_size(window, frame_size);                    SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                }                break;            case SDLK_f:                if (!repeat && ctrl && !shift) {                    // Ctrl+f                    Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;                    if (!SDL_SetWindowFullscreen(window, new_mode)) {                        fullscreen = !fullscreen;                        render(renderer, texture_empty ? NULL : texture);                    } else {                        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());                    }                }                break;            }            break;        }        }    }screen_quit:    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = adb_reverse_remove(serial, SOCKET_NAME);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
    private boolean encode(MediaCodec codec, OutputStream outputStream) throws IOException {        @SuppressWarnings("checkstyle:MagicNumber")        byte[] buf = new byte[bitRate / 8]; // may contain up to 1 second of video        boolean eof = false;        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();        while (!checkRotationChanged() && !eof) {            int outputBufferId = codec.dequeueOutputBuffer(bufferInfo, -1);            try {                if (checkRotationChanged()) {                    // must restart encoding with new size                    break;                }                if (outputBufferId >= 0) {                    ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);                    while (outputBuffer.hasRemaining()) {                        int remaining = outputBuffer.remaining();                        int len = Math.min(buf.length, remaining);                        // the outputBuffer is probably direct (it has no underlying array), and LocalSocket does not expose channels,                        // so we must copy the data locally to write them manually to the output stream                        outputBuffer.get(buf, 0, len);                        outputStream.write(buf, 0, len);                    }                }            } finally {                if (outputBufferId >= 0) {                    codec.releaseOutputBuffer(outputBufferId, false);                }            }        }        return !eof;    }
    private boolean encode(MediaCodec codec, OutputStream outputStream) throws IOException {        @SuppressWarnings("checkstyle:MagicNumber")        byte[] buf = new byte[bitRate / 8]; // may contain up to 1 second of video        boolean eof = false;        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();        while (!checkRotationChanged() && !eof) {            int outputBufferId = codec.dequeueOutputBuffer(bufferInfo, -1);            eof = (bufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;            try {                if (checkRotationChanged()) {                    // must restart encoding with new size                    break;                }                if (outputBufferId >= 0) {                    ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);                    while (outputBuffer.hasRemaining()) {                        int remaining = outputBuffer.remaining();                        int len = Math.min(buf.length, remaining);                        // the outputBuffer is probably direct (it has no underlying array), and LocalSocket does not expose channels,                        // so we must copy the data locally to write them manually to the output stream                        outputBuffer.get(buf, 0, len);                        outputStream.write(buf, 0, len);                    }                }            } finally {                if (outputBufferId >= 0) {                    codec.releaseOutputBuffer(outputBufferId, false);                }            }        }        return !eof;    }
run_recorder(void *data) {    struct recorder *recorder = data;    for (;;) {        mutex_lock(recorder->mutex);        while (!recorder->stopped && queue_is_empty(&recorder->queue)) {            cond_wait(recorder->queue_cond, recorder->mutex);        }        // if stopped is set, continue to process the remaining events (to        // finish the recording) before actually stopping        if (recorder->stopped && queue_is_empty(&recorder->queue)) {            mutex_unlock(recorder->mutex);            struct record_packet *last = recorder->previous;            if (last) {                // assign an arbitrary duration to the last packet                last->packet.duration = 100000;                bool ok = recorder_write(recorder, &last->packet);                if (!ok) {                    // failing to write the last frame is not very serious, no                    // future frame may depend on it, so the resulting file                    // will still be valid                    LOGW("Could not record last packet");                }                record_packet_delete(last);            }            break;        }        struct record_packet *rec;        queue_take(&recorder->queue, next, &rec);        mutex_unlock(recorder->mutex);        // recorder->previous is only written from this thread, no need to lock        struct record_packet *previous = recorder->previous;        recorder->previous = rec;        if (!previous) {            // we just received the first packet            continue;        }        // we now know the duration of the previous packet        previous->packet.duration = rec->packet.pts - previous->packet.pts;        bool ok = recorder_write(recorder, &previous->packet);        record_packet_delete(previous);        if (!ok) {            LOGE("Could not record packet");            mutex_lock(recorder->mutex);            recorder->failed = true;            // discard pending packets            recorder_queue_clear(&recorder->queue);            mutex_unlock(recorder->mutex);            break;        }    }    LOGD("Recorder thread ended");    return 0;}
run_recorder(void *data) {    struct recorder *recorder = data;    for (;;) {        mutex_lock(recorder->mutex);        while (!recorder->stopped && queue_is_empty(&recorder->queue)) {            cond_wait(recorder->queue_cond, recorder->mutex);        }        // if stopped is set, continue to process the remaining events (to        // finish the recording) before actually stopping        if (recorder->stopped && queue_is_empty(&recorder->queue)) {            mutex_unlock(recorder->mutex);            struct record_packet *last = recorder->previous;            if (last) {                // assign an arbitrary duration to the last packet                last->packet.duration = 100000;                bool ok = recorder_write(recorder, &last->packet);                if (!ok) {                    // failing to write the last frame is not very serious, no                    // future frame may depend on it, so the resulting file                    // will still be valid                    LOGW("Could not record last packet");                }                record_packet_delete(last);            }            break;        }        struct record_packet *rec;        queue_take(&recorder->queue, next, &rec);        mutex_unlock(recorder->mutex);        // recorder->previous is only written from this thread, no need to lock        struct record_packet *previous = recorder->previous;        recorder->previous = rec;        if (!previous) {            // we just received the first packet            continue;        }        // config packets have no PTS, we must ignore them        if (rec->packet.pts != AV_NOPTS_VALUE            && previous->packet.pts != AV_NOPTS_VALUE) {            // we now know the duration of the previous packet            previous->packet.duration = rec->packet.pts - previous->packet.pts;        }        bool ok = recorder_write(recorder, &previous->packet);        record_packet_delete(previous);        if (!ok) {            LOGE("Could not record packet");            mutex_lock(recorder->mutex);            recorder->failed = true;            // discard pending packets            recorder_queue_clear(&recorder->queue);            mutex_unlock(recorder->mutex);            break;        }    }    LOGD("Recorder thread ended");    return 0;}
enum process_result cmd_execute(const char *path, const char *const argv[], HANDLE *handle) {    STARTUPINFO si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    char cmd[256];    if (build_cmd(cmd, sizeof(cmd), argv)) {        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, flags, NULL, NULL, &si, &pi)) {        *handle = NULL;        if (GetLastError() == ERROR_FILE_NOT_FOUND) {            return PROCESS_ERROR_MISSING_BINARY;        }        return PROCESS_ERROR_GENERIC;    }    *handle = pi.hProcess;    return PROCESS_SUCCESS;}
enum process_result cmd_execute(const char *path, const char *const argv[], HANDLE *handle) {    STARTUPINFOW si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    char cmd[256];    if (build_cmd(cmd, sizeof(cmd), argv)) {        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }    wchar_t *wide = utf8_to_wide_char(cmd);    if (!wide) {        LOGC("Cannot allocate wide char string");        return PROCESS_ERROR_GENERIC;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcessW(NULL, wide, NULL, NULL, FALSE, flags, NULL, NULL, &si, &pi)) {        free(wide);        *handle = NULL;        if (GetLastError() == ERROR_FILE_NOT_FOUND) {            return PROCESS_ERROR_MISSING_BINARY;        }        return PROCESS_ERROR_GENERIC;    }    free(wide);    *handle = pi.hProcess;    return PROCESS_SUCCESS;}
static void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");                return;            case SDL_QUIT:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!handle_new_frame()) {                    return;                }                count_frame(); // display fps for debug                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;                }                break;            case SDL_TEXTINPUT: {                screencontrol_handle_text_input(&controller, &screen, &event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                screencontrol_handle_key(&controller, &screen, &event.key);                break;            case SDL_MOUSEMOTION:                screencontrol_handle_mouse_motion(&controller, &screen, &event.motion);                break;            case SDL_MOUSEWHEEL: {                screencontrol_handle_mouse_wheel(&controller, &screen, &event.wheel);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                screencontrol_handle_mouse_button(&controller, &screen, &event.button);                break;            }        }    }}
static SDL_bool handle_new_frame(void) {    mutex_lock(frames.mutex);    const AVFrame *frame = frames_consume_rendered_frame(&frames);    if (!screen_update(&screen, frame)){        mutex_unlock(frames.mutex);        return SDL_FALSE;    }    mutex_unlock(frames.mutex);    screen_render(&screen);    return SDL_TRUE;}
static void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");                return;            case SDL_QUIT:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!screen_update_frame(&screen, &frames)) {                    return;                }                count_frame(); // display fps for debug                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;                }                break;            case SDL_TEXTINPUT: {                screencontrol_handle_text_input(&controller, &screen, &event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                screencontrol_handle_key(&controller, &screen, &event.key);                break;            case SDL_MOUSEMOTION:                screencontrol_handle_mouse_motion(&controller, &screen, &event.motion);                break;            case SDL_MOUSEWHEEL: {                screencontrol_handle_mouse_wheel(&controller, &screen, &event.wheel);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                screencontrol_handle_mouse_button(&controller, &screen, &event.button);                break;            }        }    }}
static void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");                return;            case SDL_QUIT:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!screen_update_frame(&screen, &frames)) {                    return;
SDL_bool screen_update(struct screen *screen, const AVFrame *frame) {    struct size new_frame_size = {frame->width, frame->height};    if (!prepare_for_frame(screen, new_frame_size)) {        return SDL_FALSE;    }    update_texture(screen, frame);    return SDL_TRUE;}
SDL_bool screen_update(struct screen *screen, const AVFrame *frame) {    struct size new_frame_size = {frame->width, frame->height};    if (!prepare_for_frame(screen, new_frame_size)) {        return SDL_FALSE;    }    update_texture(screen, frame);    return SDL_TRUE;}
SDL_bool screen_update_frame(struct screen *screen, struct frames *frames) {    mutex_lock(frames->mutex);    const AVFrame *frame = frames_consume_rendered_frame(frames);    struct size new_frame_size = {frame->width, frame->height};    if (!prepare_for_frame(screen, new_frame_size)) {        mutex_unlock(frames->mutex);        return SDL_FALSE;    }
SDL_bool screen_update_frame(struct screen *screen, struct frames *frames) {    mutex_lock(frames->mutex);    const AVFrame *frame = frames_consume_rendered_frame(frames);    struct size new_frame_size = {frame->width, frame->height};    if (!prepare_for_frame(screen, new_frame_size)) {        mutex_unlock(frames->mutex);        return SDL_FALSE;    }    update_texture(screen, frame);    mutex_unlock(frames->mutex);    screen_render(screen);    return SDL_TRUE;}
server_destroy(struct server *server) {    if (server->server_socket != INVALID_SOCKET) {        close_socket(&server->server_socket);    }    if (server->device_socket != INVALID_SOCKET) {        close_socket(&server->device_socket);    }    SDL_free((void *) server->serial);}
server_start(struct server *server, const char *serial,             uint16_t local_port, uint16_t max_size, uint32_t bit_rate,             const char *crop, bool send_frame_meta) {    server->local_port = local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        SDL_free((void *) server->serial);        return false;    }    if (!enable_tunnel(server)) {        SDL_free((void *) server->serial);        return false;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, local_port);            disable_tunnel(server);            SDL_free((void *) server->serial);            return false;        }    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate,                                     server->tunnel_forward, crop,                                     send_frame_meta);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free((void *) server->serial);        return false;    }    server->tunnel_enabled = true;    return true;}
server_destroy(struct server *server) {    if (server->server_socket != INVALID_SOCKET) {        close_socket(&server->server_socket);    }    if (server->device_socket != INVALID_SOCKET) {        close_socket(&server->device_socket);    }    SDL_free(server->serial);}
server_start(struct server *server, const char *serial,             uint16_t local_port, uint16_t max_size, uint32_t bit_rate,             const char *crop, bool send_frame_meta) {    server->local_port = local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        SDL_free(server->serial);        return false;    }    if (!enable_tunnel(server)) {        SDL_free(server->serial);        return false;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, local_port);            disable_tunnel(server);            SDL_free(server->serial);            return false;        }    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate,                                     server->tunnel_forward, crop,                                     send_frame_meta);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free((void *) server->serial);        return false;    }    server->tunnel_enabled = true;    return true;}
recorder_close(struct recorder *recorder) {    int ret = av_write_trailer(recorder->ctx);    if (ret < 0) {        LOGE("Failed to write trailer to %s", recorder->filename);        recorder->failed = true;    }    avio_close(recorder->ctx->pb);    avformat_free_context(recorder->ctx);    if (recorder->failed) {        LOGE("Recording failed to %s", recorder->filename);    } else {        const char *format_name = recorder_get_format_name(recorder->format);        LOGI("Recording complete to %s file: %s", format_name, recorder->filename);    }}
recorder_close(struct recorder *recorder) {    if (recorder->header_written) {        int ret = av_write_trailer(recorder->ctx);        if (ret < 0) {            LOGE("Failed to write trailer to %s", recorder->filename);            recorder->failed = true;        }    } else {        // the recorded file is empty        recorder->failed = true;    }    avio_close(recorder->ctx->pb);    avformat_free_context(recorder->ctx);    if (recorder->failed) {        LOGE("Recording failed to %s", recorder->filename);    } else {        const char *format_name = recorder_get_format_name(recorder->format);        LOGI("Recording complete to %s file: %s", format_name, recorder->filename);    }}
    test_xstrjoin_truncated_before_sep();    test_xstrjoin_truncated_after_sep();    return 0;}
int main(void) {    test_xstrncpy_simple();    test_xstrncpy_just_fit();    test_xstrncpy_truncated();    test_xstrjoin_simple();    test_xstrjoin_just_fit();    test_xstrjoin_truncated_in_token();    test_xstrjoin_truncated_before_sep();    test_xstrjoin_truncated_after_sep();    return 0;}
static void test_utf8_truncate(void) {    const char *s = "aÉbÔc";    assert(strlen(s) == 7); // É and Ô are 2 bytes-wide    size_t count;    count = utf8_truncation_index(s, 1);    assert(count == 1);    count = utf8_truncation_index(s, 2);    assert(count == 1); // É is 2 bytes-wide    count = utf8_truncation_index(s, 3);    assert(count == 3);    count = utf8_truncation_index(s, 4);    assert(count == 4);    count = utf8_truncation_index(s, 5);    assert(count == 4); // Ô is 2 bytes-wide    count = utf8_truncation_index(s, 6);    assert(count == 6);    count = utf8_truncation_index(s, 7);    assert(count == 7);    count = utf8_truncation_index(s, 8);    assert(count == 7); // no more chars}
int main(void) {    test_xstrncpy_simple();    test_xstrncpy_just_fit();    test_xstrncpy_truncated();    test_xstrjoin_simple();    test_xstrjoin_just_fit();    test_xstrjoin_truncated_in_token();    test_xstrjoin_truncated_before_sep();    test_xstrjoin_truncated_after_sep();    test_utf8_truncate();    return 0;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    SDL_bool ret = SDL_TRUE;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, max_size, bit_rate);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable mouse focus clickthrough");    }    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    SDL_bool ret = SDL_TRUE;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, max_size, bit_rate);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable mouse focus clickthrough");    }    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_Surface *icon = IMG_ReadXPMFromArray(icon_xpm);    if (!icon) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not load icon: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_SetWindowIcon(window, icon);    SDL_FreeSurface(icon);    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
    public Controller(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;        initMousePointer();        sender = new DeviceMessageSender(connection);    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                break;            case ControlMessage.TYPE_INJECT_TEXT:                injectText(msg.getText());                break;            case ControlMessage.TYPE_INJECT_MOUSE_EVENT:                injectMouse(msg.getAction(), msg.getButtons(), msg.getPosition());                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                pressBackOrTurnScreenOn();                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                device.setClipboardText(msg.getText());                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                device.setScreenPowerMode(msg.getAction());                break;            default:                // do nothing        }    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                break;            case ControlMessage.TYPE_INJECT_TEXT:                injectText(msg.getText());                break;            case ControlMessage.TYPE_INJECT_MOUSE_EVENT:                injectMouse(msg.getAction(), msg.getButtons(), msg.getPosition());                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                pressBackOrTurnScreenOn();                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                device.setClipboardText(msg.getText());                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                device.setScreenPowerMode(msg.getAction());                break;            default:                // do nothing        }    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                break;            case ControlMessage.TYPE_INJECT_TEXT:                injectText(msg.getText());                break;            case ControlMessage.TYPE_INJECT_MOUSE_EVENT:                injectMouse(msg.getAction(), msg.getButtons(), msg.getPosition());                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                pressBackOrTurnScreenOn();                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                device.setClipboardText(msg.getText());                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                device.setScreenPowerMode(msg.getAction());                break;            default:                // do nothing        }    }
    public Controller(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;        initMousePointer();        initTouchPointers();        sender = new DeviceMessageSender(connection);    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                break;            case ControlMessage.TYPE_INJECT_TEXT:                injectText(msg.getText());                break;            case ControlMessage.TYPE_INJECT_MOUSE_EVENT:                injectMouse(msg.getAction(), msg.getButtons(), msg.getPosition());                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure());                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                pressBackOrTurnScreenOn();                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                device.setClipboardText(msg.getText());                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                device.setScreenPowerMode(msg.getAction());                break;            default:                // do nothing        }    }
    private boolean injectTouch(int action, long pointerId, Position position, float pressure) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        int pointerIndex = pointersState.getPointerIndex(pointerId);        if (pointerIndex == -1) {            Ln.w("Too many pointers for touch event");            return false;        }        Pointer pointer = pointersState.get(pointerIndex);        pointer.setPoint(point);        pointer.setPressure(pressure);        pointer.setUp(action == MotionEvent.ACTION_UP);        int pointerCount = pointersState.update(touchPointerProperties, touchPointerCoords);        if (pointerCount == 1) {            if (action == MotionEvent.ACTION_DOWN) {                lastTouchDown = now;            }        } else {            // secondary pointers must use ACTION_POINTER_* ORed with the pointerIndex            if (action == MotionEvent.ACTION_UP) {                action = MotionEvent.ACTION_POINTER_UP | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            } else if (action == MotionEvent.ACTION_DOWN) {                action = MotionEvent.ACTION_POINTER_DOWN | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            }        }        MotionEvent event = MotionEvent.obtain(lastTouchDown, now, action, pointerCount, touchPointerProperties,                touchPointerCoords, 0, 0, 1f, 1f, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
    private void initTouchPointers() {        for (int i = 0; i < PointersState.MAX_POINTERS; ++i) {            MotionEvent.PointerProperties props = new MotionEvent.PointerProperties();            props.toolType = MotionEvent.TOOL_TYPE_FINGER;            MotionEvent.PointerCoords coords = new MotionEvent.PointerCoords();            coords.orientation = 0;            coords.size = 1;            touchPointerProperties[i] = props;            touchPointerCoords[i] = coords;        }    }
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    SDL_bool ret = SDL_TRUE;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, max_size, bit_rate);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }#if SDL_VERSION_ATLEAST(2, 0, 5)    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable mouse focus clickthrough");    }#endif    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not load icon: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_SetWindowIcon(window, icon);    SDL_FreeSurface(icon);    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);    // at least we hide it    SDL_HideWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // let the server some time to print any exception trace before killing it    struct timespec timespec = {        .tv_sec = 0,        .tv_nsec = 100000000, // 100ms    };    nanosleep(&timespec, NULL); // ignore error    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
static inline struct size get_window_size(SDL_Window *window) {    int width;    int height;    SDL_GetWindowSize(window, &width, &height);    struct size size;    size.width = width;    size.height = height;    return size;}
static SDL_bool handle_new_frame(void) {    mutex_lock(frames.mutex);    AVFrame *frame = frames.rendering_frame;    frames.rendering_frame_consumed = SDL_TRUE;#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then notify the decoder the current frame is    // consumed, so that it may push a new one    cond_signal(frames.rendering_frame_consumed_cond);#endif    struct size current_frame_size = {frame->width, frame->height};    if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {        return SDL_FALSE;    }    frame_size = current_frame_size;    update_texture(frame, texture);    mutex_unlock(frames.mutex);    render(renderer, texture);    return SDL_TRUE;}
static struct size get_optimal_size(struct size current_size, struct size frame_size) {    struct size display_size;    // 32 bits because we need to multiply two 16 bits values    Uint32 w;    Uint32 h;    if (!get_preferred_display_bounds(&display_size)) {        // cannot get display bounds, do not constraint the size        w = current_size.width;        h = current_size.height;    } else {        w = MIN(current_size.width, display_size.width);        h = MIN(current_size.height, display_size.height);    }    SDL_bool keep_width = frame_size.width * h > frame_size.height * w;    if (keep_width) {        // remove black borders on top and bottom        h = frame_size.height * w / frame_size.width;    } else {        // remove black borders on left and right (or none at all if it already fits)        w = frame_size.width * h / frame_size.height;    }    // w and h must fit into 16 bits    SDL_assert_release(w < 0x10000 && h < 0x10000);    return (struct size) {w, h};}
static void switch_fullscreen(void) {    if (!fullscreen) {        // going to fullscreen, store the current windowed window size        windowed_window_size = get_window_size(window);    }    Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;    if (SDL_SetWindowFullscreen(window, new_mode)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());        return;    }    fullscreen = !fullscreen;    if (!fullscreen) {        // fullscreen disabled, restore expected windowed window size        SDL_SetWindowSize(window, windowed_window_size.width, windowed_window_size.height);    }    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Switched to %s mode", fullscreen ? "fullscreen" : "windowed");    render(renderer, texture_empty ? NULL : texture);}
static void update_texture(const AVFrame *frame, SDL_Texture *texture) {    SDL_UpdateYUVTexture(texture, NULL,            frame->data[0], frame->linesize[0],            frame->data[1], frame->linesize[1],            frame->data[2], frame->linesize[2]);}
static inline struct point get_mouse_point() {    int x;    int y;    SDL_GetMouseState(&x, &y);    SDL_assert_release(x >= 0 && x < 0x10000 && y >= 0 && y < 0x10000);    return (struct point) {        .x = (Uint16) x,        .y = (Uint16) y,    };}
static void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");                return;            case SDL_QUIT:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!handle_new_frame()) {                    return;                }                texture_empty = SDL_FALSE;                count_frame(); // display fps for debug                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    render(renderer, texture_empty ? NULL : texture);                    break;                }                break;            case SDL_TEXTINPUT: {                handle_text_input(&event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                handle_key(&event.key);                break;            case SDL_MOUSEMOTION:                handle_mouse_motion(&event.motion, frame_size);                break;            case SDL_MOUSEWHEEL: {                struct position position = {                    .screen_size = frame_size,                    .point = get_mouse_point(),                };                handle_mouse_wheel(&event.wheel, position);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                handle_mouse_button(&event.button, frame_size);                break;            }        }    }}
static void resize_to_fit(void) {    if (!fullscreen) {        struct size optimal_size = get_optimal_window_size(window, frame_size);        SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);        SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Resized to optimal size");    }}
static void render(SDL_Renderer *renderer, SDL_Texture *texture) {    SDL_RenderClear(renderer);    if (texture) {        SDL_RenderCopy(renderer, texture, NULL, NULL);    }    SDL_RenderPresent(renderer);}
static inline struct point get_mouse_point() {    int x;    int y;    SDL_GetMouseState(&x, &y);    SDL_assert_release(x >= 0 && x < 0x10000 && y >= 0 && y < 0x10000);    return (struct point) {        .x = (Uint16) x,        .y = (Uint16) y,    };}
static SDL_bool get_preferred_display_bounds(struct size *bounds) {    SDL_Rect rect;    if (GET_DISPLAY_BOUNDS(0, &rect)) {        SDL_LogWarn(SDL_LOG_CATEGORY_SYSTEM, "Could not get display usable bounds: %s", SDL_GetError());        return SDL_FALSE;    }    bounds->width = MAX(0, rect.w - DISPLAY_MARGINS);    bounds->height = MAX(0, rect.h - DISPLAY_MARGINS);    return SDL_TRUE;}
static inline struct size get_initial_optimal_size(struct size frame_size) {    return get_optimal_size(frame_size, frame_size);}
static void resize_to_pixel_perfect(void) {    if (!fullscreen) {        SDL_SetWindowSize(window, frame_size.width, frame_size.height);        SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Resized to pixel-perfect");    }}
static void set_window_size(SDL_Window *window, struct size new_size) {    // setting the window size during fullscreen is implementation defined,    // so apply the resize only after fullscreen is disabled    if (fullscreen) {        // SDL_SetWindowSize will be called when fullscreen will be disabled        windowed_window_size = new_size;    } else {        SDL_SetWindowSize(window, new_size.width, new_size.height);    }}
static inline struct size get_optimal_window_size(SDL_Window *window, struct size frame_size) {    struct size current_size = get_window_size(window);    return get_optimal_size(current_size, frame_size);}
static SDL_bool prepare_for_frame(SDL_Window *window, SDL_Renderer *renderer, SDL_Texture **texture,                                  struct size old_frame_size, struct size frame_size) {    if (old_frame_size.width != frame_size.width || old_frame_size.height != frame_size.height) {        if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {            SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());            return SDL_FALSE;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(*texture);        struct size current_size = get_window_size(window);        struct size target_size = {            (Uint32) current_size.width * frame_size.width / old_frame_size.width,            (Uint32) current_size.height * frame_size.height / old_frame_size.height,        };        target_size = get_optimal_size(target_size, frame_size);        set_window_size(window, target_size);        SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "New texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);        *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);        if (!*texture) {            SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());            return SDL_FALSE;        }    }    return SDL_TRUE;}
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        switch (keycode) {            case SDLK_h:                action_home();                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back();                return;            case SDLK_m:                action_app_switch();                return;            case SDLK_p:                action_power();                return;            case SDLK_f:                switch_fullscreen();                return;            case SDLK_x:                resize_to_fit();                return;            case SDLK_g:                resize_to_pixel_perfect();                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    SDL_bool ret = SDL_TRUE;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, max_size, bit_rate);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto finally_destroy_controller;    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // let the server some time to print any exception trace before killing it    struct timespec timespec = {        .tv_sec = 0,        .tv_nsec = 100000000, // 100ms    };    nanosleep(&timespec, NULL); // ignore error    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
    // send DOWN event    struct control_event control_event = {        .type = CONTROL_EVENT_TYPE_KEYCODE,        .keycode_event = {            .action = AKEY_EVENT_ACTION_DOWN,            .keycode = keycode,            .metastate = 0,        },    };    if (!controller_push_event(&controller, &control_event)) {
static SDL_bool handle_new_frame(void) {    mutex_lock(frames.mutex);    AVFrame *frame = frames.rendering_frame;    frames.rendering_frame_consumed = SDL_TRUE;#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then notify the decoder the current frame is    // consumed, so that it may push a new one    cond_signal(frames.rendering_frame_consumed_cond);#endif    if (!screen_update(&screen, frame)){        return SDL_FALSE;    }    mutex_unlock(frames.mutex);    screen_render(&screen);    return SDL_TRUE;}
static inline void action_volume_up(void) {    send_keycode(AKEYCODE_VOLUME_UP, "VOLUME_UP");}static inline void action_volume_down(void) {    send_keycode(AKEYCODE_VOLUME_DOWN, "VOLUME_DOWN");}static void turn_screen_on(void) {    struct control_event control_event = {        .type = CONTROL_EVENT_TYPE_COMMAND,        .command_event = {            .action = CONTROL_EVENT_COMMAND_SCREEN_ON,        },    };    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot turn screen on");    }}static SDL_bool handle_new_frame(void) {    mutex_lock(frames.mutex);    AVFrame *frame = frames.rendering_frame;    frames.rendering_frame_consumed = SDL_TRUE;#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then notify the decoder the current frame is    // consumed, so that it may push a new one    cond_signal(frames.rendering_frame_consumed_cond);
        switch (keycode) {            case SDLK_h:                action_home();                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back();                return;            case SDLK_m:                action_app_switch();                return;            case SDLK_p:                action_power();                return;            case SDLK_f:                screen_switch_fullscreen(&screen);                return;            case SDLK_x:                screen_resize_to_fit(&screen);                return;            case SDLK_g:
    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {
static struct point get_mouse_point(void) {    int x;    int y;    SDL_GetMouseState(&x, &y);    SDL_assert_release(x >= 0 && x < 0x10000 && y >= 0 && y < 0x10000);    return (struct point) {        .x = (Uint16) x,        .y = (Uint16) y,    };}
static void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");                return;            case SDL_QUIT:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!handle_new_frame()) {                    return;                }                count_frame(); // display fps for debug                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;                }                break;            case SDL_TEXTINPUT: {                handle_text_input(&event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                handle_key(&event.key);                break;            case SDL_MOUSEMOTION:                handle_mouse_motion(&event.motion, screen.frame_size);                break;            case SDL_MOUSEWHEEL: {                struct position position = {                    .screen_size = screen.frame_size,                    .point = get_mouse_point(),                };                handle_mouse_wheel(&event.wheel, position);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                handle_mouse_button(&event.button, screen.frame_size);                break;            }        }    }}
                screen_resize_to_pixel_perfect(&screen);                return;        }        return;    }    struct control_event control_event;
            return;        }        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }
static inline void action_home(void) {    send_keycode(AKEYCODE_HOME, "HOME");}static inline void action_back(void) {    send_keycode(AKEYCODE_BACK, "BACK");}static inline void action_app_switch(void) {    send_keycode(AKEYCODE_APP_SWITCH, "APP_SWITCH");}
    if (!cmd_simple_wait(proc, &exit_code)) {        if (exit_code != NO_EXIT_CODE) {            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "\"%s\" returned with value %" PRIexitcode, name, exit_code);        } else {            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "\"%s\" exited unexpectedly", name);        }        return -1;    }    return 0;}static void send_keycode(enum android_keycode keycode, const char *name) {
    if (!screen_update(&screen, frame)){        return SDL_FALSE;    }
    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send %s (DOWN)", name);        return;    }    // send UP event    control_event.keycode_event.action = AKEY_EVENT_ACTION_UP;    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send %s (UP)", name);    }}
    screen_render(&screen);    return SDL_TRUE;}
static SDL_bool is_ctrl_down(void) {    const Uint8 *state = SDL_GetKeyboardState(NULL);    return state[SDL_SCANCODE_LCTRL] || state[SDL_SCANCODE_RCTRL];}static void handle_text_input(const SDL_TextInputEvent *event) {    if (is_ctrl_down()) {        switch (event->text[0]) {            case '+':                action_volume_up();                break;            case '-':                action_volume_down();                break;        }        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    strncpy(control_event.text_event.text, event->text, TEXT_MAX_LENGTH);    control_event.text_event.text[TEXT_MAX_LENGTH] = '\0';    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send text event");    }}static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        switch (keycode) {            case SDLK_h:                action_home();                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back();                return;            case SDLK_m:                action_app_switch();                return;            case SDLK_p:                action_power();                return;            case SDLK_f:                screen_switch_fullscreen(&screen);                return;            case SDLK_x:                screen_resize_to_fit(&screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(&screen);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"bit-rate",     required_argument, NULL, 'b'},        {"crop",         required_argument, NULL, 'c'},        {"fullscreen",   no_argument,       NULL, 'f'},        {"help",         no_argument,       NULL, 'h'},        {"max-size",     required_argument, NULL, 'm'},        {"port",         required_argument, NULL, 'p'},        {"record",       required_argument, NULL, 'r'},        {"serial",       required_argument, NULL, 's'},        {"show-touches", no_argument,       NULL, 't'},        {"version",      no_argument,       NULL, 'v'},        {NULL,           0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fhm:p:r:s:tv", long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = SDL_TRUE;                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = SDL_TRUE;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    return SDL_TRUE;}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = SDL_FALSE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top", no_argument,       NULL, 'T'},        {"bit-rate",      required_argument, NULL, 'b'},        {"crop",          required_argument, NULL, 'c'},        {"fullscreen",    no_argument,       NULL, 'f'},        {"help",          no_argument,       NULL, 'h'},        {"max-size",      required_argument, NULL, 'm'},        {"port",          required_argument, NULL, 'p'},        {"record",        required_argument, NULL, 'r'},        {"serial",        required_argument, NULL, 's'},        {"show-touches",  no_argument,       NULL, 't'},        {"version",       no_argument,       NULL, 'v'},        {NULL,            0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fhm:p:r:s:tTv", long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = SDL_TRUE;                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = SDL_TRUE;                break;            case 'T':                args->always_on_top = SDL_TRUE;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    return SDL_TRUE;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    SDL_bool send_frame_meta = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      send_frame_meta)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    struct recorder *rec = NULL;    if (options->record_filename) {        if (!recorder_init(&recorder, options->record_filename, frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    decoder_init(&decoder, &frames, device_socket, rec);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_recorder:    if (options->record_filename) {        recorder_destroy(&recorder);    }finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    SDL_bool send_frame_meta = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      send_frame_meta)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    struct recorder *rec = NULL;    if (options->record_filename) {        if (!recorder_init(&recorder, options->record_filename, frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    decoder_init(&decoder, &frames, device_socket, rec);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size, options->always_on_top)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_recorder:    if (options->record_filename) {        recorder_destroy(&recorder);    }finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
SDL_bool screen_init_rendering(struct screen *screen, const char *device_name, struct size frame_size) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    Uint32 window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height, window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1, SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width, frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    return SDL_TRUE;}
SDL_bool screen_init_rendering(struct screen *screen, const char *device_name, struct size frame_size) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    Uint32 window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height, window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1, SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width, frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    return SDL_TRUE;}
SDL_bool screen_init_rendering(struct screen *screen,                               const char *device_name,                               struct size frame_size,                               SDL_bool always_on_top) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    Uint32 window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;    }    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height, window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1, SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width, frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());
SDL_bool screen_init_rendering(struct screen *screen,                               const char *device_name,                               struct size frame_size,                               SDL_bool always_on_top) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    Uint32 window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;    }    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height, window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1, SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width, frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    return SDL_TRUE;}
    private static Options createOptions(String... args) {        if (args.length != 5)            throw new IllegalArgumentException("Expecting 5 parameters");        Options options = new Options();        int maxSize = Integer.parseInt(args[0]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[1]);        options.setBitRate(bitRate);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[2]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[3]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[4]);        options.setSendFrameMeta(sendFrameMeta);        return options;    }
    private static Options createOptions(String... args) {        if (args.length != 5) {            throw new IllegalArgumentException("Expecting 5 parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[0]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[1]);        options.setBitRate(bitRate);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[2]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[3]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[4]);        options.setSendFrameMeta(sendFrameMeta);        return options;    }
#include <sys/time.h>#include <SDL2/SDL.h>#include <SDL2/SDL_net.h>#include "command.h"#include "decoder.h"#include "events.h"#include "frames.h"#include "lockutil.h"#include "netutil.h"#define DEVICE_NAME_FIELD_LENGTH 64#define SOCKET_NAME "scrcpy"#define DISPLAY_MARGINS 96#define MIN(X,Y) (X) < (Y) ? (X) : (Y)
SDL_bool show_screen(const char *serial, Uint16 local_port) {    SDL_bool ret = 0;    const char *server_jar_path = getenv("SCRCPY_SERVER_JAR");    if (!server_jar_path) {        server_jar_path = "scrcpy-server.jar";    }    process_t push_proc = adb_push(serial, server_jar_path, "/data/local/tmp/");    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = adb_reverse(serial, SOCKET_NAME, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    struct size frame_size;    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    SDL_Window *window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    SDL_Texture *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    long ts = timestamp_ms();    int nbframes = 0;    SDL_bool texture_empty = SDL_TRUE;    SDL_bool fullscreen = SDL_FALSE;    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            goto screen_quit;        case EVENT_NEW_FRAME:            mutex_lock(frames.mutex);            AVFrame *frame = frames.rendering_frame;            frames.rendering_frame_consumed = SDL_TRUE;            if (!decoder.skip_frames) {                cond_signal(frames.rendering_frame_consumed_cond);            }            struct size current_frame_size = {frame->width, frame->height};            if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {                goto screen_quit;            }            frame_size = current_frame_size;            update_texture(frame, texture);            mutex_unlock(frames.mutex);            texture_empty = SDL_FALSE;            long now = timestamp_ms();            ++nbframes;            if (now - ts > 1000) {                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "%d fps", nbframes);                ts = now;                nbframes = 0;            }            render(renderer, texture);            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_KEYDOWN: {            SDL_bool ctrl = SDL_GetModState() & (KMOD_LCTRL | KMOD_RCTRL);            SDL_bool shift = SDL_GetModState() & (KMOD_LSHIFT | KMOD_RSHIFT);            SDL_bool repeat = event.key.repeat;            switch (event.key.keysym.sym) {            case SDLK_x:                if (!repeat && ctrl && !shift) {                    // Ctrl+x                    struct size optimal_size = get_optimal_window_size(window, frame_size);                    SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                }                break;            case SDLK_f:                if (!repeat && ctrl && !shift) {                    // Ctrl+f                    Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;                    if (!SDL_SetWindowFullscreen(window, new_mode)) {                        fullscreen = !fullscreen;                        render(renderer, texture_empty ? NULL : texture);                    } else {                        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());                    }                }                break;            }            break;        }        }    }screen_quit:    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = adb_reverse_remove(serial, SOCKET_NAME);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool show_screen(const char *serial, Uint16 local_port) {    SDL_bool ret = 0;    const char *server_jar_path = getenv("SCRCPY_SERVER_JAR");    if (!server_jar_path) {        server_jar_path = "scrcpy-server.jar";    }    process_t push_proc = adb_push(serial, server_jar_path, "/data/local/tmp/");    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = adb_reverse(serial, SOCKET_NAME, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    struct size frame_size;    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    SDL_Window *window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    SDL_Texture *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    long ts = timestamp_ms();    int nbframes = 0;    SDL_bool texture_empty = SDL_TRUE;    SDL_bool fullscreen = SDL_FALSE;    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            goto screen_quit;        case EVENT_NEW_FRAME:            mutex_lock(frames.mutex);            AVFrame *frame = frames.rendering_frame;            frames.rendering_frame_consumed = SDL_TRUE;            if (!decoder.skip_frames) {                cond_signal(frames.rendering_frame_consumed_cond);            }            struct size current_frame_size = {frame->width, frame->height};            if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {                goto screen_quit;            }            frame_size = current_frame_size;            update_texture(frame, texture);            mutex_unlock(frames.mutex);            texture_empty = SDL_FALSE;            long now = timestamp_ms();            ++nbframes;            if (now - ts > 1000) {                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "%d fps", nbframes);                ts = now;                nbframes = 0;            }            render(renderer, texture);            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_KEYDOWN: {            SDL_bool ctrl = SDL_GetModState() & (KMOD_LCTRL | KMOD_RCTRL);            SDL_bool shift = SDL_GetModState() & (KMOD_LSHIFT | KMOD_RSHIFT);            SDL_bool repeat = event.key.repeat;            switch (event.key.keysym.sym) {            case SDLK_x:                if (!repeat && ctrl && !shift) {                    // Ctrl+x                    struct size optimal_size = get_optimal_window_size(window, frame_size);                    SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                }                break;            case SDLK_f:                if (!repeat && ctrl && !shift) {                    // Ctrl+f                    Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;                    if (!SDL_SetWindowFullscreen(window, new_mode)) {                        fullscreen = !fullscreen;                        render(renderer, texture_empty ? NULL : texture);                    } else {                        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());                    }                }                break;            }            break;        }        }    }screen_quit:    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = adb_reverse_remove(serial, SOCKET_NAME);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool show_screen(const char *serial, Uint16 local_port) {    SDL_bool ret = 0;    const char *server_jar_path = getenv("SCRCPY_SERVER_JAR");    if (!server_jar_path) {        server_jar_path = "scrcpy-server.jar";    }    process_t push_proc = adb_push(serial, server_jar_path, "/data/local/tmp/");    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = adb_reverse(serial, SOCKET_NAME, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    struct size frame_size;    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    SDL_Window *window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    SDL_Texture *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    long ts = timestamp_ms();    int nbframes = 0;    SDL_bool texture_empty = SDL_TRUE;    SDL_bool fullscreen = SDL_FALSE;    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            goto screen_quit;        case EVENT_NEW_FRAME:            mutex_lock(frames.mutex);            AVFrame *frame = frames.rendering_frame;            frames.rendering_frame_consumed = SDL_TRUE;            if (!decoder.skip_frames) {                cond_signal(frames.rendering_frame_consumed_cond);            }            struct size current_frame_size = {frame->width, frame->height};            if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {                goto screen_quit;            }            frame_size = current_frame_size;            update_texture(frame, texture);            mutex_unlock(frames.mutex);            texture_empty = SDL_FALSE;            long now = timestamp_ms();            ++nbframes;            if (now - ts > 1000) {                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "%d fps", nbframes);                ts = now;                nbframes = 0;            }            render(renderer, texture);            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_KEYDOWN: {            SDL_bool ctrl = SDL_GetModState() & (KMOD_LCTRL | KMOD_RCTRL);            SDL_bool shift = SDL_GetModState() & (KMOD_LSHIFT | KMOD_RSHIFT);            SDL_bool repeat = event.key.repeat;            switch (event.key.keysym.sym) {            case SDLK_x:                if (!repeat && ctrl && !shift) {                    // Ctrl+x                    struct size optimal_size = get_optimal_window_size(window, frame_size);                    SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                }                break;            case SDLK_f:                if (!repeat && ctrl && !shift) {                    // Ctrl+f                    Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;                    if (!SDL_SetWindowFullscreen(window, new_mode)) {                        fullscreen = !fullscreen;                        render(renderer, texture_empty ? NULL : texture);                    } else {                        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());                    }                }                break;            }            break;        }        }    }screen_quit:    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = adb_reverse_remove(serial, SOCKET_NAME);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool show_screen(const char *serial, Uint16 local_port) {    SDL_bool ret = 0;    const char *server_jar_path = getenv("SCRCPY_SERVER_JAR");    if (!server_jar_path) {        server_jar_path = "scrcpy-server.jar";    }    process_t push_proc = adb_push(serial, server_jar_path, "/data/local/tmp/");    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = adb_reverse(serial, SOCKET_NAME, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    struct size frame_size;    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    SDL_Window *window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    SDL_Texture *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    long ts = timestamp_ms();    int nbframes = 0;    SDL_bool texture_empty = SDL_TRUE;    SDL_bool fullscreen = SDL_FALSE;    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            goto screen_quit;        case EVENT_NEW_FRAME:            mutex_lock(frames.mutex);            AVFrame *frame = frames.rendering_frame;            frames.rendering_frame_consumed = SDL_TRUE;            if (!decoder.skip_frames) {                cond_signal(frames.rendering_frame_consumed_cond);            }            struct size current_frame_size = {frame->width, frame->height};            if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {                goto screen_quit;            }            frame_size = current_frame_size;            update_texture(frame, texture);            mutex_unlock(frames.mutex);            texture_empty = SDL_FALSE;            long now = timestamp_ms();            ++nbframes;            if (now - ts > 1000) {                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "%d fps", nbframes);                ts = now;                nbframes = 0;            }            render(renderer, texture);            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_KEYDOWN: {            SDL_bool ctrl = SDL_GetModState() & (KMOD_LCTRL | KMOD_RCTRL);            SDL_bool shift = SDL_GetModState() & (KMOD_LSHIFT | KMOD_RSHIFT);            SDL_bool repeat = event.key.repeat;            switch (event.key.keysym.sym) {            case SDLK_x:                if (!repeat && ctrl && !shift) {                    // Ctrl+x                    struct size optimal_size = get_optimal_window_size(window, frame_size);                    SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                }                break;            case SDLK_f:                if (!repeat && ctrl && !shift) {                    // Ctrl+f                    Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;                    if (!SDL_SetWindowFullscreen(window, new_mode)) {                        fullscreen = !fullscreen;                        render(renderer, texture_empty ? NULL : texture);                    } else {                        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());                    }                }                break;            }            break;        }        }    }screen_quit:    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = adb_reverse_remove(serial, SOCKET_NAME);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool show_screen(const char *serial, Uint16 local_port) {    SDL_bool ret = 0;    const char *server_jar_path = getenv("SCRCPY_SERVER_JAR");    if (!server_jar_path) {        server_jar_path = "scrcpy-server.jar";    }    process_t push_proc = adb_push(serial, server_jar_path, "/data/local/tmp/");    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = adb_reverse(serial, SOCKET_NAME, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    struct size frame_size;    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    SDL_Window *window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    SDL_Texture *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    long ts = timestamp_ms();    int nbframes = 0;    SDL_bool texture_empty = SDL_TRUE;    SDL_bool fullscreen = SDL_FALSE;    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            goto screen_quit;        case EVENT_NEW_FRAME:            mutex_lock(frames.mutex);            AVFrame *frame = frames.rendering_frame;            frames.rendering_frame_consumed = SDL_TRUE;            if (!decoder.skip_frames) {                cond_signal(frames.rendering_frame_consumed_cond);            }            struct size current_frame_size = {frame->width, frame->height};            if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {                goto screen_quit;            }            frame_size = current_frame_size;            update_texture(frame, texture);            mutex_unlock(frames.mutex);            texture_empty = SDL_FALSE;            long now = timestamp_ms();            ++nbframes;            if (now - ts > 1000) {                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "%d fps", nbframes);                ts = now;                nbframes = 0;            }            render(renderer, texture);            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_KEYDOWN: {            SDL_bool ctrl = SDL_GetModState() & (KMOD_LCTRL | KMOD_RCTRL);            SDL_bool shift = SDL_GetModState() & (KMOD_LSHIFT | KMOD_RSHIFT);            SDL_bool repeat = event.key.repeat;            switch (event.key.keysym.sym) {            case SDLK_x:                if (!repeat && ctrl && !shift) {                    // Ctrl+x                    struct size optimal_size = get_optimal_window_size(window, frame_size);                    SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                }                break;            case SDLK_f:                if (!repeat && ctrl && !shift) {                    // Ctrl+f                    Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;                    if (!SDL_SetWindowFullscreen(window, new_mode)) {                        fullscreen = !fullscreen;                        render(renderer, texture_empty ? NULL : texture);                    } else {                        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());                    }                }                break;            }            break;        }        }    }screen_quit:    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = adb_reverse_remove(serial, SOCKET_NAME);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool show_screen(const char *serial, Uint16 local_port) {    SDL_bool ret = 0;    const char *server_jar_path = getenv("SCRCPY_SERVER_JAR");    if (!server_jar_path) {        server_jar_path = "scrcpy-server.jar";    }    process_t push_proc = adb_push(serial, server_jar_path, "/data/local/tmp/");    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = adb_reverse(serial, SOCKET_NAME, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    struct size frame_size;    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    SDL_Window *window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    SDL_Texture *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    long ts = timestamp_ms();    int nbframes = 0;    SDL_bool texture_empty = SDL_TRUE;    SDL_bool fullscreen = SDL_FALSE;    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            goto screen_quit;        case EVENT_NEW_FRAME:            mutex_lock(frames.mutex);            AVFrame *frame = frames.rendering_frame;            frames.rendering_frame_consumed = SDL_TRUE;            if (!decoder.skip_frames) {                cond_signal(frames.rendering_frame_consumed_cond);            }            struct size current_frame_size = {frame->width, frame->height};            if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {                goto screen_quit;            }            frame_size = current_frame_size;            update_texture(frame, texture);            mutex_unlock(frames.mutex);            texture_empty = SDL_FALSE;            long now = timestamp_ms();            ++nbframes;            if (now - ts > 1000) {                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "%d fps", nbframes);                ts = now;                nbframes = 0;            }            render(renderer, texture);            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_KEYDOWN: {            SDL_bool ctrl = SDL_GetModState() & (KMOD_LCTRL | KMOD_RCTRL);            SDL_bool shift = SDL_GetModState() & (KMOD_LSHIFT | KMOD_RSHIFT);            SDL_bool repeat = event.key.repeat;            switch (event.key.keysym.sym) {            case SDLK_x:                if (!repeat && ctrl && !shift) {                    // Ctrl+x                    struct size optimal_size = get_optimal_window_size(window, frame_size);                    SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                }                break;            case SDLK_f:                if (!repeat && ctrl && !shift) {                    // Ctrl+f                    Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;                    if (!SDL_SetWindowFullscreen(window, new_mode)) {                        fullscreen = !fullscreen;                        render(renderer, texture_empty ? NULL : texture);                    } else {                        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());                    }                }                break;            }            break;        }        }    }screen_quit:    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = adb_reverse_remove(serial, SOCKET_NAME);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool show_screen(const char *serial, Uint16 local_port) {    SDL_bool ret = 0;    const char *server_jar_path = getenv("SCRCPY_SERVER_JAR");    if (!server_jar_path) {        server_jar_path = "scrcpy-server.jar";    }    process_t push_proc = adb_push(serial, server_jar_path, "/data/local/tmp/");    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = adb_reverse(serial, SOCKET_NAME, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    struct size frame_size;    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    SDL_Window *window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    SDL_Texture *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    long ts = timestamp_ms();    int nbframes = 0;    SDL_bool texture_empty = SDL_TRUE;    SDL_bool fullscreen = SDL_FALSE;    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            goto screen_quit;        case EVENT_NEW_FRAME:            mutex_lock(frames.mutex);            AVFrame *frame = frames.rendering_frame;            frames.rendering_frame_consumed = SDL_TRUE;            if (!decoder.skip_frames) {                cond_signal(frames.rendering_frame_consumed_cond);            }            struct size current_frame_size = {frame->width, frame->height};            if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {                goto screen_quit;            }            frame_size = current_frame_size;            update_texture(frame, texture);            mutex_unlock(frames.mutex);            texture_empty = SDL_FALSE;            long now = timestamp_ms();            ++nbframes;            if (now - ts > 1000) {                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "%d fps", nbframes);                ts = now;                nbframes = 0;            }            render(renderer, texture);            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_KEYDOWN: {            SDL_bool ctrl = SDL_GetModState() & (KMOD_LCTRL | KMOD_RCTRL);            SDL_bool shift = SDL_GetModState() & (KMOD_LSHIFT | KMOD_RSHIFT);            SDL_bool repeat = event.key.repeat;            switch (event.key.keysym.sym) {            case SDLK_x:                if (!repeat && ctrl && !shift) {                    // Ctrl+x                    struct size optimal_size = get_optimal_window_size(window, frame_size);                    SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                }                break;            case SDLK_f:                if (!repeat && ctrl && !shift) {                    // Ctrl+f                    Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;                    if (!SDL_SetWindowFullscreen(window, new_mode)) {                        fullscreen = !fullscreen;                        render(renderer, texture_empty ? NULL : texture);                    } else {                        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());                    }                }                break;            }            break;        }        }    }screen_quit:    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = adb_reverse_remove(serial, SOCKET_NAME);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool show_screen(const char *serial, Uint16 local_port) {    SDL_bool ret = 0;    const char *server_jar_path = getenv("SCRCPY_SERVER_JAR");    if (!server_jar_path) {        server_jar_path = "scrcpy-server.jar";    }    process_t push_proc = adb_push(serial, server_jar_path, "/data/local/tmp/");    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = adb_reverse(serial, SOCKET_NAME, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    struct size frame_size;    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    SDL_Window *window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    SDL_Texture *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    long ts = timestamp_ms();    int nbframes = 0;    SDL_bool texture_empty = SDL_TRUE;    SDL_bool fullscreen = SDL_FALSE;    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            goto screen_quit;        case EVENT_NEW_FRAME:            mutex_lock(frames.mutex);            AVFrame *frame = frames.rendering_frame;            frames.rendering_frame_consumed = SDL_TRUE;            if (!decoder.skip_frames) {                cond_signal(frames.rendering_frame_consumed_cond);            }            struct size current_frame_size = {frame->width, frame->height};            if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {                goto screen_quit;            }            frame_size = current_frame_size;            update_texture(frame, texture);            mutex_unlock(frames.mutex);            texture_empty = SDL_FALSE;            long now = timestamp_ms();            ++nbframes;            if (now - ts > 1000) {                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "%d fps", nbframes);                ts = now;                nbframes = 0;            }            render(renderer, texture);            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_KEYDOWN: {            SDL_bool ctrl = SDL_GetModState() & (KMOD_LCTRL | KMOD_RCTRL);            SDL_bool shift = SDL_GetModState() & (KMOD_LSHIFT | KMOD_RSHIFT);            SDL_bool repeat = event.key.repeat;            switch (event.key.keysym.sym) {            case SDLK_x:                if (!repeat && ctrl && !shift) {                    // Ctrl+x                    struct size optimal_size = get_optimal_window_size(window, frame_size);                    SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                }                break;            case SDLK_f:                if (!repeat && ctrl && !shift) {                    // Ctrl+f                    Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;                    if (!SDL_SetWindowFullscreen(window, new_mode)) {                        fullscreen = !fullscreen;                        render(renderer, texture_empty ? NULL : texture);                    } else {                        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());                    }                }                break;            }            break;        }        }    }screen_quit:    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = adb_reverse_remove(serial, SOCKET_NAME);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
static void count_frame(void) {    static long ts = 0;    static int nbframes = 0;    long now = timestamp_ms();    ++nbframes;    if (now - ts > 1000) {        SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "%d fps", nbframes);        ts = now;        nbframes = 0;    }}
SDL_bool show_screen(const char *serial, Uint16 local_port) {    SDL_bool ret = 0;    const char *server_jar_path = getenv("SCRCPY_SERVER_JAR");    if (!server_jar_path) {        server_jar_path = "scrcpy-server.jar";    }    process_t push_proc = adb_push(serial, server_jar_path, "/data/local/tmp/");    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = adb_reverse(serial, SOCKET_NAME, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = adb_reverse_remove(serial, SOCKET_NAME);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
static void handle_text_input(SDL_TextInputEvent *event) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    strncpy(control_event.text_event.text, event->text, TEXT_MAX_LENGTH);    control_event.text_event.text[TEXT_MAX_LENGTH] = '\0';    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send text event");    }}
static SDL_bool handle_new_frame(void) {    mutex_lock(frames.mutex);    AVFrame *frame = frames.rendering_frame;    frames.rendering_frame_consumed = SDL_TRUE;    if (!decoder.skip_frames) {        cond_signal(frames.rendering_frame_consumed_cond);    }    struct size current_frame_size = {frame->width, frame->height};    if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {        return SDL_FALSE;    }    frame_size = current_frame_size;    update_texture(frame, texture);    mutex_unlock(frames.mutex);    render(renderer, texture);    return SDL_TRUE;}
static void handle_mouse_wheel(struct complete_mouse_wheel_event *event) {    struct control_event control_event;    if (mouse_wheel_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send wheel button event");        }    }}
static void handle_mouse_motion(SDL_MouseMotionEvent *event) {    struct control_event control_event;    if (mouse_motion_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse motion event");        }    }}
static void handle_mouse_button(SDL_MouseButtonEvent *event) {    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse button event");        }    }}
void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            return;        case EVENT_NEW_FRAME:            if (!handle_new_frame()) {                return;            }            texture_empty = SDL_FALSE;            count_frame(); // display fps for debug            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_TEXTINPUT: {            handle_text_input(&event.text);            break;        }        case SDL_KEYDOWN:        case SDL_KEYUP:            handle_key(&event.key);            break;        case SDL_MOUSEMOTION:            handle_mouse_motion(&event.motion);            break;        case SDL_MOUSEWHEEL: {            struct complete_mouse_wheel_event complete_event;            complete_event.mouse_wheel_event = &event.wheel;            int x;            int y;            SDL_GetMouseState(&x, &y);            complete_event.x = (Sint32) x;            complete_event.y = (Sint32) y;            handle_mouse_wheel(&complete_event);            break;        }        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            handle_mouse_button(&event.button);            break;        }    }}
static void handle_key(SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // Capture Ctrl+x: optimal size    if (keycode == SDLK_x && !repeat && ctrl && !shift) {        if (event->type == SDL_KEYDOWN) {            struct size optimal_size = get_optimal_window_size(window, frame_size);            SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);        }        return;    }    // Capture Ctrl+f: switch fullscreen    if (keycode == SDLK_f && !repeat && ctrl && !shift) {        if (event->type == SDL_KEYDOWN) {            Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;            if (!SDL_SetWindowFullscreen(window, new_mode)) {                fullscreen = !fullscreen;                render(renderer, texture_empty ? NULL : texture);            } else {                SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());            }        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
    public static DesktopConnection open(String deviceName, int width, int height) throws IOException {        LocalSocket socket = connect(SOCKET_NAME);        send(socket, deviceName, width, height);        return new DesktopConnection(socket);    }
    private static void send(LocalSocket socket, String deviceName, int width, int height) throws IOException {        assert width < 0x10000 : "width may not be stored on 16 bits";        assert height < 0x10000 : "height may not be stored on 16 bits";        byte[] buffer = new byte[DEVICE_NAME_FIELD_LENGTH + 4];        byte[] deviceNameBytes = deviceName.getBytes(StandardCharsets.UTF_8);        int len = Math.min(DEVICE_NAME_FIELD_LENGTH - 1, deviceNameBytes.length);        System.arraycopy(deviceNameBytes, 0, buffer, 0, len);        // byte[] are always 0-initialized in java, no need to set '\0' explicitly        buffer[DEVICE_NAME_FIELD_LENGTH] = (byte) (width >> 8);        buffer[DEVICE_NAME_FIELD_LENGTH + 1] = (byte) width;        buffer[DEVICE_NAME_FIELD_LENGTH + 2] = (byte) (height >> 8);        buffer[DEVICE_NAME_FIELD_LENGTH + 3] = (byte) height;        socket.getOutputStream().write(buffer, 0, buffer.length);    }
    private DesktopConnection(LocalSocket socket) throws IOException {        this.socket = socket;    }
    public void sendVideoStream(byte[] videoStreamBuffer, int len) throws IOException {        socket.getOutputStream().write(videoStreamBuffer, 0, len);    }}
    public void sendVideoStream(byte[] videoStreamBuffer, int len) throws IOException {        socket.getOutputStream().write(videoStreamBuffer, 0, len);    }}
    private static void send(LocalSocket socket, String deviceName, int width, int height) throws IOException {        assert width < 0x10000 : "width may not be stored on 16 bits";        assert height < 0x10000 : "height may not be stored on 16 bits";        byte[] buffer = new byte[DEVICE_NAME_FIELD_LENGTH + 4];        byte[] deviceNameBytes = deviceName.getBytes(StandardCharsets.UTF_8);        int len = Math.min(DEVICE_NAME_FIELD_LENGTH - 1, deviceNameBytes.length);        System.arraycopy(deviceNameBytes, 0, buffer, 0, len);        // byte[] are always 0-initialized in java, no need to set '\0' explicitly        buffer[DEVICE_NAME_FIELD_LENGTH] = (byte) (width >> 8);        buffer[DEVICE_NAME_FIELD_LENGTH + 1] = (byte) width;        buffer[DEVICE_NAME_FIELD_LENGTH + 2] = (byte) (height >> 8);        buffer[DEVICE_NAME_FIELD_LENGTH + 3] = (byte) height;        socket.getOutputStream().write(buffer, 0, buffer.length);    }
    public static DesktopConnection open(String deviceName, int width, int height) throws IOException {        LocalSocket socket = connect(SOCKET_NAME);        DesktopConnection connection = new DesktopConnection(socket);        connection.send(deviceName, width, height);        return connection;    }
    private void send(String deviceName, int width, int height) throws IOException {        assert width < 0x10000 : "width may not be stored on 16 bits";        assert height < 0x10000 : "height may not be stored on 16 bits";        byte[] buffer = new byte[DEVICE_NAME_FIELD_LENGTH + 4];        byte[] deviceNameBytes = deviceName.getBytes(StandardCharsets.UTF_8);        int len = Math.min(DEVICE_NAME_FIELD_LENGTH - 1, deviceNameBytes.length);        System.arraycopy(deviceNameBytes, 0, buffer, 0, len);        // byte[] are always 0-initialized in java, no need to set '\0' explicitly        buffer[DEVICE_NAME_FIELD_LENGTH] = (byte) (width >> 8);        buffer[DEVICE_NAME_FIELD_LENGTH + 1] = (byte) width;        buffer[DEVICE_NAME_FIELD_LENGTH + 2] = (byte) (height >> 8);        buffer[DEVICE_NAME_FIELD_LENGTH + 3] = (byte) height;        outputStream.write(buffer, 0, buffer.length);    }
    private DesktopConnection(LocalSocket socket) throws IOException {        this.socket = socket;        inputStream = socket.getInputStream();        outputStream = socket.getOutputStream();    }
    public void sendVideoStream(byte[] videoStreamBuffer, int len) throws IOException {        outputStream.write(videoStreamBuffer, 0, len);    }
    public ControlEvent receiveControlEvent() throws IOException {        ControlEvent event = reader.next();        while (event == null) {            reader.readFrom(inputStream);            event = reader.next();        }        return event;    }}
        return connection;    }    public void close() throws IOException {        socket.shutdownInput();        socket.shutdownOutput();        socket.close();    }    private void send(String deviceName, int width, int height) throws IOException {        assert width < 0x10000 : "width may not be stored on 16 bits";        assert height < 0x10000 : "height may not be stored on 16 bits";        byte[] buffer = new byte[DEVICE_NAME_FIELD_LENGTH + 4];        byte[] deviceNameBytes = deviceName.getBytes(StandardCharsets.UTF_8);        int len = Math.min(DEVICE_NAME_FIELD_LENGTH - 1, deviceNameBytes.length);        System.arraycopy(deviceNameBytes, 0, buffer, 0, len);
    public static void scrcpy() throws IOException {        String deviceName = DeviceUtil.getDeviceName();        ScreenInfo initialScreenInfo = DeviceUtil.getScreenInfo();        int width = initialScreenInfo.getLogicalWidth();        int height = initialScreenInfo.getLogicalHeight();        try (DesktopConnection connection = DesktopConnection.open(deviceName, width, height)) {            try {                new ScreenStreamer(connection).streamScreen();            } catch (IOException e) {                Ln.e("Screen streaming interrupted", e);            }        }    }
    private static void scrcpy() throws IOException {        String deviceName = DeviceUtil.getDeviceName();        ScreenInfo initialScreenInfo = DeviceUtil.getScreenInfo();        int width = initialScreenInfo.getLogicalWidth();        int height = initialScreenInfo.getLogicalHeight();        try (DesktopConnection connection = DesktopConnection.open(deviceName, width, height)) {            try {                // asynchronous                startEventController(connection);                // synchronous                new ScreenStreamer(connection).streamScreen();            } catch (IOException e) {                Ln.e("Screen streaming interrupted", e);            }        }    }
    private final Method getServiceMethod;    public ServiceManager() {        try {            getServiceMethod = Class.forName("android.os.ServiceManager").getDeclaredMethod("getService", String.class);        } catch (Exception e) {            throw new AssertionError(e);        }    }    private IInterface getService(String service, String type) {        try {            IBinder binder = (IBinder) getServiceMethod.invoke(null, service);            Method asInterfaceMethod = Class.forName(type + "$Stub").getMethod("asInterface", IBinder.class);
    public InputManager getInputManager() {        return new InputManager(getService("input", "android.hardware.input.IInputManager"));    }}
int cmd_execute(const char *path, const char *const argv[], HANDLE *handle) {    STARTUPINFO si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    // Windows command-line parsing is WTF:    // <http://daviddeley.com/autohotkey/parameters/parameters.htm#WINPASS>    // only make it work for this very specific program    // (don't handle escaping nor quotes)    char cmd[256];    size_t ret = xstrjoin(cmd, argv, ' ', sizeof(cmd));    if (ret >= sizeof(cmd)) {        LOGE("Command too long (%" PRIsizet " chars)", sizeof(cmd) - 1);        *handle = NULL;        return -1;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, flags, NULL, NULL, &si, &pi)) {        *handle = NULL;        return -1;    }    *handle = pi.hProcess;    return 0;}
enum process_result cmd_execute(const char *path, const char *const argv[], HANDLE *handle) {    STARTUPINFO si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    // Windows command-line parsing is WTF:    // <http://daviddeley.com/autohotkey/parameters/parameters.htm#WINPASS>    // only make it work for this very specific program    // (don't handle escaping nor quotes)    char cmd[256];    size_t ret = xstrjoin(cmd, argv, ' ', sizeof(cmd));    if (ret >= sizeof(cmd)) {        LOGE("Command too long (%" PRIsizet " chars)", sizeof(cmd) - 1);        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, flags, NULL, NULL, &si, &pi)) {        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }    *handle = pi.hProcess;    return PROCESS_SUCCESS;}
static SDL_bool switch_fullscreen(void) {    if (!fullscreen) {        // going to fullscreen, store the current windowed window size        windowed_window_size = get_window_size(window);    }    Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;    if (SDL_SetWindowFullscreen(window, new_mode)) {        return SDL_FALSE;    }    fullscreen = !fullscreen;    if (!fullscreen) {        // fullscreen disabled, restore expected windowed window size        SDL_SetWindowSize(window, windowed_window_size.width, windowed_window_size.height);    }    render(renderer, texture_empty ? NULL : texture);    return SDL_TRUE;}
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        // Ctrl+x: optimal size        if (keycode == SDLK_x && !shift) {            if (!fullscreen) {                struct size optimal_size = get_optimal_window_size(window, frame_size);                SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Resized to optimal size");            }            return;        }        // Ctrl+g: pixel-perfect (ratio 1:1)        if (keycode == SDLK_g && !shift) {            if (!fullscreen) {                SDL_SetWindowSize(window, frame_size.width, frame_size.height);                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Resized to pixel-perfect");            }            return;        }        // Ctrl+f: switch fullscreen        if (keycode == SDLK_f && !shift) {            if (switch_fullscreen()) {                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Switched to %s mode", fullscreen ? "fullscreen" : "windowed");            } else {                SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());            }            return;        }        // Ctrl+h: HOME (the HOME key also works natively)        if (keycode == SDLK_h && !shift) {             send_keycode(AKEYCODE_HOME, "HOME");             return;        }        // Ctrl+b or Ctrl+BACKSPACE: BACK (the ESCAPE key also works natively)        if ((keycode == SDLK_b && !shift) || keycode == SDLK_BACKSPACE) {            send_keycode(AKEYCODE_BACK, "BACK");            return;        }        // Ctrl+m: APP_SWITCH        if (keycode == SDLK_m && !shift) {            send_keycode(AKEYCODE_APP_SWITCH, "APP_SWITCH");            return;        }        // Ctrl+p: POWER        if (keycode == SDLK_p && !shift) {            send_keycode(AKEYCODE_POWER, "POWER");            return;        }        // volume shortcuts are handled in handle_text_input()        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
static void switch_fullscreen(void) {    if (!fullscreen) {        // going to fullscreen, store the current windowed window size        windowed_window_size = get_window_size(window);    }    Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;    if (SDL_SetWindowFullscreen(window, new_mode)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());        return;    }    fullscreen = !fullscreen;    if (!fullscreen) {        // fullscreen disabled, restore expected windowed window size        SDL_SetWindowSize(window, windowed_window_size.width, windowed_window_size.height);    }    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Switched to %s mode", fullscreen ? "fullscreen" : "windowed");    render(renderer, texture_empty ? NULL : texture);}
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        // Ctrl+x: optimal size        if (keycode == SDLK_x && !shift) {            if (!fullscreen) {                struct size optimal_size = get_optimal_window_size(window, frame_size);                SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Resized to optimal size");            }            return;        }        // Ctrl+g: pixel-perfect (ratio 1:1)        if (keycode == SDLK_g && !shift) {            if (!fullscreen) {                SDL_SetWindowSize(window, frame_size.width, frame_size.height);                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Resized to pixel-perfect");            }            return;        }        // Ctrl+f: switch fullscreen        if (keycode == SDLK_f && !shift) {            switch_fullscreen();            return;        }        // Ctrl+h: HOME (the HOME key also works natively)        if (keycode == SDLK_h && !shift) {             send_keycode(AKEYCODE_HOME, "HOME");             return;        }        // Ctrl+b or Ctrl+BACKSPACE: BACK (the ESCAPE key also works natively)        if ((keycode == SDLK_b && !shift) || keycode == SDLK_BACKSPACE) {            send_keycode(AKEYCODE_BACK, "BACK");            return;        }        // Ctrl+m: APP_SWITCH        if (keycode == SDLK_m && !shift) {            send_keycode(AKEYCODE_APP_SWITCH, "APP_SWITCH");            return;        }        // Ctrl+p: POWER        if (keycode == SDLK_p && !shift) {            send_keycode(AKEYCODE_POWER, "POWER");            return;        }        // volume shortcuts are handled in handle_text_input()        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        LOGI("Enable show_touches");        set_show_touches_enabled(options->serial, SDL_TRUE);    }    event_loop();    LOGD("quit...");    if (options->show_touches) {        LOGI("Disable show_touches");        set_show_touches_enabled(options->serial, SDL_FALSE);    }    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        LOGI("Enable show_touches");        set_show_touches_enabled(options->serial, SDL_TRUE);    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);    if (options->show_touches) {        LOGI("Disable show_touches");        set_show_touches_enabled(options->serial, SDL_FALSE);    }finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    // capture all Ctrl events    if (ctrl) {        SDL_bool repeat = event->repeat;        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        if (shift) {            // currently, there is no shortcut involving SHIFT            return;        }        SDL_Keycode keycode = event->keysym.sym;        switch (keycode) {            case SDLK_h:                action_home(input_manager->controller);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(input_manager->controller);                return;            case SDLK_s:                action_app_switch(input_manager->controller);                return;            case SDLK_m:                action_menu(input_manager->controller);                return;            case SDLK_p:                action_power(input_manager->controller);                return;            case SDLK_DOWN:                action_volume_down(input_manager->controller);                return;            case SDLK_UP:                action_volume_up(input_manager->controller);                return;            case SDLK_v:                clipboard_paste(input_manager->controller);                return;            case SDLK_f:                screen_switch_fullscreen(input_manager->screen);                return;            case SDLK_x:                screen_resize_to_fit(input_manager->screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(input_manager->screen);                return;            case SDLK_i:                switch_fps_counter_state(input_manager->frames);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
static inline void action_back(struct controller *controller) {    send_keycode(controller, AKEYCODE_BACK, "BACK");}
static inline void action_menu(struct controller *controller) {    send_keycode(controller, AKEYCODE_MENU, "MENU");}
static inline void action_power(struct controller *controller) {    send_keycode(controller, AKEYCODE_POWER, "POWER");}
static inline void action_app_switch(struct controller *controller) {    send_keycode(controller, AKEYCODE_APP_SWITCH, "APP_SWITCH");}
static inline void action_volume_down(struct controller *controller) {    send_keycode(controller, AKEYCODE_VOLUME_DOWN, "VOLUME_DOWN");}
static void send_keycode(struct controller *controller, enum android_keycode keycode, const char *name) {    // send DOWN event    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_KEYCODE;    control_event.keycode_event.action = AKEY_EVENT_ACTION_DOWN;    control_event.keycode_event.keycode = keycode;    control_event.keycode_event.metastate = 0;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot send %s (DOWN)", name);        return;    }    // send UP event    control_event.keycode_event.action = AKEY_EVENT_ACTION_UP;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot send %s (UP)", name);    }}
static inline void action_home(struct controller *controller) {    send_keycode(controller, AKEYCODE_HOME, "HOME");}
static void send_keycode(struct controller *controller, enum android_keycode keycode, const char *name) {    // send DOWN event    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_KEYCODE;    control_event.keycode_event.action = AKEY_EVENT_ACTION_DOWN;    control_event.keycode_event.keycode = keycode;    control_event.keycode_event.metastate = 0;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot send %s (DOWN)", name);        return;    }    // send UP event    control_event.keycode_event.action = AKEY_EVENT_ACTION_UP;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot send %s (UP)", name);    }}
void input_manager_process_mouse_button(struct input_manager *input_manager,                                        const SDL_MouseButtonEvent *event) {    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(input_manager->controller);            return;        }        if (event->button == SDL_BUTTON_MIDDLE) {            action_home(input_manager->controller);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            SDL_bool outside_device_screen =                    event->x < 0 || event->x >= input_manager->screen->frame_size.width ||                    event->y < 0 || event->y >= input_manager->screen->frame_size.height;            if (outside_device_screen) {                screen_resize_to_fit(input_manager->screen);                return;            }            // otherwise, send the click event to the device        }    };    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, input_manager->screen->frame_size, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send mouse button event");        }    }}
static inline void action_volume_down(struct controller *controller) {    send_keycode(controller, AKEYCODE_VOLUME_DOWN, "VOLUME_DOWN");}
static inline void action_back(struct controller *controller) {    send_keycode(controller, AKEYCODE_BACK, "BACK");}
static inline void action_home(struct controller *controller) {    send_keycode(controller, AKEYCODE_HOME, "HOME");}
static inline void action_menu(struct controller *controller) {    send_keycode(controller, AKEYCODE_MENU, "MENU");}
static inline void action_app_switch(struct controller *controller) {    send_keycode(controller, AKEYCODE_APP_SWITCH, "APP_SWITCH");}
static inline void action_volume_up(struct controller *controller) {    send_keycode(controller, AKEYCODE_VOLUME_UP, "VOLUME_UP");}
static inline void action_volume_up(struct controller *controller) {    send_keycode(controller, AKEYCODE_VOLUME_UP, "VOLUME_UP");}
static inline void action_power(struct controller *controller) {    send_keycode(controller, AKEYCODE_POWER, "POWER");}
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    // capture all Ctrl events    if (ctrl) {        SDL_bool repeat = event->repeat;        // ignore repeated events        if (repeat) {            return;        }        SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        if (shift) {            // currently, there is no shortcut involving SHIFT            return;        }        SDL_Keycode keycode = event->keysym.sym;        int action = event->type == SDL_KEYDOWN ? ACTION_DOWN : ACTION_UP;        switch (keycode) {            case SDLK_h:                action_home(input_manager->controller, action);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(input_manager->controller, action);                return;            case SDLK_s:                action_app_switch(input_manager->controller, action);                return;            case SDLK_m:                action_menu(input_manager->controller, action);                return;            case SDLK_p:                action_power(input_manager->controller, action);                return;            case SDLK_DOWN:                action_volume_down(input_manager->controller, action);                return;            case SDLK_UP:                action_volume_up(input_manager->controller, action);                return;            case SDLK_v:                if (event->type == SDL_KEYDOWN) {                    clipboard_paste(input_manager->controller);                }                return;            case SDLK_f:                if (event->type == SDL_KEYDOWN) {                    screen_switch_fullscreen(input_manager->screen);                }                return;            case SDLK_x:                if (event->type == SDL_KEYDOWN) {                    screen_resize_to_fit(input_manager->screen);                }                return;            case SDLK_g:                if (event->type == SDL_KEYDOWN) {                    screen_resize_to_pixel_perfect(input_manager->screen);                }                return;            case SDLK_i:                if (event->type == SDL_KEYDOWN) {                    switch_fps_counter_state(input_manager->frames);                }                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
static inline void action_back(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_BACK, actions, "BACK");}
}static inline void action_volume_down(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_VOLUME_DOWN, actions, "VOLUME_DOWN");
static inline void action_power(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_POWER, actions, "POWER");}
}static inline void action_back(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_BACK, actions, "BACK");
}static inline void action_volume_up(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_VOLUME_UP, actions, "VOLUME_UP");
static const int ACTION_DOWN = 1;static const int ACTION_UP = 1 << 1;static void send_keycode(struct controller *controller, enum android_keycode keycode, int actions, const char *name) {    // send DOWN event    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_KEYCODE;    control_event.keycode_event.keycode = keycode;    control_event.keycode_event.metastate = 0;    if (actions & ACTION_DOWN) {        control_event.keycode_event.action = AKEY_EVENT_ACTION_DOWN;        if (!controller_push_event(controller, &control_event)) {            LOGW("Cannot send %s (DOWN)", name);            return;        }    }    if (actions & ACTION_UP) {        control_event.keycode_event.action = AKEY_EVENT_ACTION_UP;
static inline void action_home(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_HOME, actions, "HOME");}
static void send_keycode(struct controller *controller, enum android_keycode keycode, int actions, const char *name) {    // send DOWN event    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_KEYCODE;    control_event.keycode_event.keycode = keycode;    control_event.keycode_event.metastate = 0;    if (actions & ACTION_DOWN) {        control_event.keycode_event.action = AKEY_EVENT_ACTION_DOWN;        if (!controller_push_event(controller, &control_event)) {            LOGW("Cannot send %s (DOWN)", name);            return;        }    }    if (actions & ACTION_UP) {        control_event.keycode_event.action = AKEY_EVENT_ACTION_UP;        if (!controller_push_event(controller, &control_event)) {            LOGW("Cannot send %s (UP)", name);        }    }}
void input_manager_process_mouse_button(struct input_manager *input_manager,                                        const SDL_MouseButtonEvent *event) {    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(input_manager->controller);            return;        }        if (event->button == SDL_BUTTON_MIDDLE) {            action_home(input_manager->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            SDL_bool outside_device_screen =                    event->x < 0 || event->x >= input_manager->screen->frame_size.width ||                    event->y < 0 || event->y >= input_manager->screen->frame_size.height;            if (outside_device_screen) {                screen_resize_to_fit(input_manager->screen);                return;            }            // otherwise, send the click event to the device        }    };    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, input_manager->screen->frame_size, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send mouse button event");        }    }}
static inline void action_volume_down(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_VOLUME_DOWN, actions, "VOLUME_DOWN");}
}static inline void action_home(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_HOME, actions, "HOME");
        if (!controller_push_event(controller, &control_event)) {            LOGW("Cannot send %s (UP)", name);        }    }
static inline void action_menu(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_MENU, actions, "MENU");}
static inline void action_app_switch(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_APP_SWITCH, actions, "APP_SWITCH");}
static inline void action_volume_up(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_VOLUME_UP, actions, "VOLUME_UP");}
}static inline void action_power(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_POWER, actions, "POWER");
}static inline void action_app_switch(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_APP_SWITCH, actions, "APP_SWITCH");
convert_keycode(SDL_Keycode from, enum android_keycode *to, uint16_t mod) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_HOME,         AKEYCODE_HOME);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);    }    if (mod & (KMOD_LALT | KMOD_RALT | KMOD_LGUI | KMOD_RGUI)) {        return false;    }    // if ALT and META are not pressed, also handle letters and space    switch (from) {        MAP(SDLK_a,            AKEYCODE_A);        MAP(SDLK_b,            AKEYCODE_B);        MAP(SDLK_c,            AKEYCODE_C);        MAP(SDLK_d,            AKEYCODE_D);        MAP(SDLK_e,            AKEYCODE_E);        MAP(SDLK_f,            AKEYCODE_F);        MAP(SDLK_g,            AKEYCODE_G);        MAP(SDLK_h,            AKEYCODE_H);        MAP(SDLK_i,            AKEYCODE_I);        MAP(SDLK_j,            AKEYCODE_J);        MAP(SDLK_k,            AKEYCODE_K);        MAP(SDLK_l,            AKEYCODE_L);        MAP(SDLK_m,            AKEYCODE_M);        MAP(SDLK_n,            AKEYCODE_N);        MAP(SDLK_o,            AKEYCODE_O);        MAP(SDLK_p,            AKEYCODE_P);        MAP(SDLK_q,            AKEYCODE_Q);        MAP(SDLK_r,            AKEYCODE_R);        MAP(SDLK_s,            AKEYCODE_S);        MAP(SDLK_t,            AKEYCODE_T);        MAP(SDLK_u,            AKEYCODE_U);        MAP(SDLK_v,            AKEYCODE_V);        MAP(SDLK_w,            AKEYCODE_W);        MAP(SDLK_x,            AKEYCODE_X);        MAP(SDLK_y,            AKEYCODE_Y);        MAP(SDLK_z,            AKEYCODE_Z);        MAP(SDLK_SPACE,        AKEYCODE_SPACE);        FAIL;    }}
convert_keycode(SDL_Keycode from, enum android_keycode *to, uint16_t mod) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_HOME,         AKEYCODE_MOVE_HOME);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);    }    if (mod & (KMOD_LALT | KMOD_RALT | KMOD_LGUI | KMOD_RGUI)) {        return false;    }    // if ALT and META are not pressed, also handle letters and space    switch (from) {        MAP(SDLK_a,            AKEYCODE_A);        MAP(SDLK_b,            AKEYCODE_B);        MAP(SDLK_c,            AKEYCODE_C);        MAP(SDLK_d,            AKEYCODE_D);        MAP(SDLK_e,            AKEYCODE_E);        MAP(SDLK_f,            AKEYCODE_F);        MAP(SDLK_g,            AKEYCODE_G);        MAP(SDLK_h,            AKEYCODE_H);        MAP(SDLK_i,            AKEYCODE_I);        MAP(SDLK_j,            AKEYCODE_J);        MAP(SDLK_k,            AKEYCODE_K);        MAP(SDLK_l,            AKEYCODE_L);        MAP(SDLK_m,            AKEYCODE_M);        MAP(SDLK_n,            AKEYCODE_N);        MAP(SDLK_o,            AKEYCODE_O);        MAP(SDLK_p,            AKEYCODE_P);        MAP(SDLK_q,            AKEYCODE_Q);        MAP(SDLK_r,            AKEYCODE_R);        MAP(SDLK_s,            AKEYCODE_S);        MAP(SDLK_t,            AKEYCODE_T);        MAP(SDLK_u,            AKEYCODE_U);        MAP(SDLK_v,            AKEYCODE_V);        MAP(SDLK_w,            AKEYCODE_W);        MAP(SDLK_x,            AKEYCODE_X);        MAP(SDLK_y,            AKEYCODE_Y);        MAP(SDLK_z,            AKEYCODE_Z);        MAP(SDLK_SPACE,        AKEYCODE_SPACE);        FAIL;    }}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}static void
static int parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"help",     no_argument,       NULL, 'h'},        {"port",     required_argument, NULL, 'p'},        {"max-size", required_argument, NULL, 'm'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "hp:m:", long_options, NULL)) != -1) {        switch (c) {            case 'h': {                args->help = SDL_TRUE;                break;            }            case 'p': {                char *endptr;                long value = strtol(optarg, &endptr, 0);                if (*optarg == '\0' || *endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld", value);                    return -1;                }                args->port = (Uint16) value;                break;            }            case 'm': {                char *endptr;                long value = strtol(optarg, &endptr, 0);                if (*optarg == '\0' || *endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid max size: %s", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Max size must be between 0 and 65535: %ld", value);                    return -1;                }                args->max_size = (Uint16) value;                break;            }            default:                // getopt prints the error message on stderr                return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s", argv[index]);        return -1;    }    return 0;}
static int parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"help",     no_argument,       NULL, 'h'},        {"port",     required_argument, NULL, 'p'},        {"max-size", required_argument, NULL, 'm'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "hp:m:", long_options, NULL)) != -1) {        switch (c) {            case 'h': {                args->help = SDL_TRUE;                break;            }            case 'p': {                char *endptr;                if (*optarg == '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                if (*endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld", value);                    return -1;                }                args->port = (Uint16) value;                break;            }            case 'm': {                char *endptr;                if (*optarg == '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Max size parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                if (*endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid max size: %s", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Max size must be between 0 and 65535: %ld", value);                    return -1;                }                args->max_size = (Uint16) value;                break;            }            default:                // getopt prints the error message on stderr                return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s", argv[index]);        return -1;    }    return 0;}
static void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");                return;            case SDL_QUIT:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!handle_new_frame()) {                    return;                }                count_frame(); // display fps for debug                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;                }                break;            case SDL_TEXTINPUT: {                handle_text_input(&event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                handle_key(&event.key);                break;            case SDL_MOUSEMOTION:                handle_mouse_motion(&event.motion, screen.frame_size);                break;            case SDL_MOUSEWHEEL: {                struct position position = {                    .screen_size = screen.frame_size,                    .point = get_mouse_point(),                };                handle_mouse_wheel(&event.wheel, position);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                handle_mouse_button(&event.button, screen.frame_size);                break;            }        }    }}
static inline void action_home(void) {    send_keycode(AKEYCODE_HOME, "HOME");}
static inline void action_volume_up(void) {    send_keycode(AKEYCODE_VOLUME_UP, "VOLUME_UP");}
static inline void action_app_switch(void) {    send_keycode(AKEYCODE_APP_SWITCH, "APP_SWITCH");}
static inline void action_back(void) {    send_keycode(AKEYCODE_BACK, "BACK");}
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        switch (keycode) {            case SDLK_h:                action_home();                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back();                return;            case SDLK_m:                action_app_switch();                return;            case SDLK_p:                action_power();                return;            case SDLK_f:                screen_switch_fullscreen(&screen);                return;            case SDLK_x:                screen_resize_to_fit(&screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(&screen);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
static void turn_screen_on(void) {    struct control_event control_event = {        .type = CONTROL_EVENT_TYPE_COMMAND,        .command_event = {            .action = CONTROL_EVENT_COMMAND_SCREEN_ON,        },    };    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot turn screen on");    }}
static inline void action_power(void) {    send_keycode(AKEYCODE_POWER, "POWER");}
static struct point get_mouse_point(void) {    int x;    int y;    SDL_GetMouseState(&x, &y);    SDL_assert_release(x >= 0 && x < 0x10000 && y >= 0 && y < 0x10000);    return (struct point) {        .x = (Uint16) x,        .y = (Uint16) y,    };}
static void send_keycode(enum android_keycode keycode, const char *name) {    // send DOWN event    struct control_event control_event = {        .type = CONTROL_EVENT_TYPE_KEYCODE,        .keycode_event = {            .action = AKEY_EVENT_ACTION_DOWN,            .keycode = keycode,            .metastate = 0,        },    };    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send %s (DOWN)", name);        return;    }    // send UP event    control_event.keycode_event.action = AKEY_EVENT_ACTION_UP;    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send %s (UP)", name);    }}
static inline void action_volume_down(void) {    send_keycode(AKEYCODE_VOLUME_DOWN, "VOLUME_DOWN");}
static void handle_text_input(const SDL_TextInputEvent *event) {    if (is_ctrl_down()) {        switch (event->text[0]) {            case '+':                action_volume_up();                break;            case '-':                action_volume_down();                break;        }        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    strncpy(control_event.text_event.text, event->text, TEXT_MAX_LENGTH);    control_event.text_event.text[TEXT_MAX_LENGTH] = '\0';    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send text event");    }}
static SDL_bool is_ctrl_down(void) {    const Uint8 *state = SDL_GetKeyboardState(NULL);    return state[SDL_SCANCODE_LCTRL] || state[SDL_SCANCODE_RCTRL];}
static void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");                return;            case SDL_QUIT:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!handle_new_frame()) {                    return;                }                count_frame(); // display fps for debug                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;                }                break;            case SDL_TEXTINPUT: {                screencontrol_handle_text_input(&controller, &screen, &event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                screencontrol_handle_key(&controller, &screen, &event.key);                break;            case SDL_MOUSEMOTION:                screencontrol_handle_mouse_motion(&controller, &screen, &event.motion);                break;            case SDL_MOUSEWHEEL: {                screencontrol_handle_mouse_wheel(&controller, &screen, &event.wheel);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                screencontrol_handle_mouse_button(&controller, &screen, &event.button);                break;            }        }    }}
                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:
                break;            case SDL_MOUSEMOTION:                screencontrol_handle_mouse_motion(&controller, &screen, &event.motion);                break;
                break;            case SDL_TEXTINPUT: {                screencontrol_handle_text_input(&controller, &screen, &event.text);                break;
                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;                }
        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    // kill the server before decoder_join() to wake up the decoder    server_stop(&server, serial);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);    return ret;}
            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                screencontrol_handle_mouse_button(&controller, &screen, &event.button);                break;            }        }    }}SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;
            }            case SDL_KEYDOWN:            case SDL_KEYUP:                screencontrol_handle_key(&controller, &screen, &event.key);
static SDL_bool handle_new_frame(void) {    mutex_lock(frames.mutex);    AVFrame *frame = frames.rendering_frame;    frames.rendering_frame_consumed = SDL_TRUE;#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then notify the decoder the current frame is    // consumed, so that it may push a new one    cond_signal(frames.rendering_frame_consumed_cond);#endif    if (!screen_update(&screen, frame)){
        return SDL_FALSE;    }    mutex_unlock(frames.mutex);    screen_render(&screen);    return SDL_TRUE;}static void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");                return;            case SDL_QUIT:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!handle_new_frame()) {                    return;                }                count_frame(); // display fps for debug
            case SDL_MOUSEWHEEL: {                screencontrol_handle_mouse_wheel(&controller, &screen, &event.wheel);                break;            }
        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    decoder.frames = &frames;    decoder.video_socket = device_socket;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server, serial);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {
        return SDL_FALSE;    }    if (!frames_init(&frames)) {        server_stop(&server, serial);
SDL_bool controller_push_event(struct controller *controller, struct control_event *event) {    SDL_bool res;    mutex_lock(controller->mutex);    SDL_bool was_empty = control_event_queue_is_empty(&controller->queue);    res = control_event_queue_push(&controller->queue, event);    if (was_empty) {        cond_signal(controller->event_cond);    }    mutex_unlock(controller->mutex);    return res;}
static SDL_bool process_event(struct controller *controller, struct control_event *event) {    unsigned char serialized_event[SERIALIZED_EVENT_MAX_SIZE];    int length = control_event_serialize(event, serialized_event);    if (!length) {        return SDL_FALSE;    }    int w = SDLNet_TCP_Send(controller->video_socket, serialized_event, length);    return w == length;}
static SDL_bool process_event(struct controller *controller, struct control_event *event) {    unsigned char serialized_event[SERIALIZED_EVENT_MAX_SIZE];    int length = control_event_serialize(event, serialized_event);    if (!length) {        return SDL_FALSE;    }    int w = SDLNet_TCP_Send(controller->video_socket, serialized_event, length);    return w == length;}
SDL_bool controller_push_event(struct controller *controller, struct control_event *event) {    SDL_bool res;    mutex_lock(controller->mutex);    SDL_bool was_empty = control_event_queue_is_empty(&controller->queue);    res = control_event_queue_push(&controller->queue, event);    if (was_empty) {        cond_signal(controller->event_cond);    }    mutex_unlock(controller->mutex);    return res;}
SDL_bool controller_push_event(struct controller *controller, const struct control_event *event) {    SDL_bool res;    mutex_lock(controller->mutex);    SDL_bool was_empty = control_event_queue_is_empty(&controller->queue);    res = control_event_queue_push(&controller->queue, event);    if (was_empty) {        cond_signal(controller->event_cond);    }    mutex_unlock(controller->mutex);    return res;}
static SDL_bool process_event(struct controller *controller, const struct control_event *event) {    unsigned char serialized_event[SERIALIZED_EVENT_MAX_SIZE];    int length = control_event_serialize(event, serialized_event);    if (!length) {        return SDL_FALSE;    }    int w = SDLNet_TCP_Send(controller->video_socket, serialized_event, length);    return w == length;}
static SDL_bool process_event(struct controller *controller, const struct control_event *event) {    unsigned char serialized_event[SERIALIZED_EVENT_MAX_SIZE];    int length = control_event_serialize(event, serialized_event);    if (!length) {        return SDL_FALSE;    }    int w = SDLNet_TCP_Send(controller->video_socket, serialized_event, length);    return w == length;}
SDL_bool controller_push_event(struct controller *controller, const struct control_event *event) {    SDL_bool res;    mutex_lock(controller->mutex);    SDL_bool was_empty = control_event_queue_is_empty(&controller->queue);    res = control_event_queue_push(&controller->queue, event);    if (was_empty) {        cond_signal(controller->event_cond);    }    mutex_unlock(controller->mutex);    return res;}
SDL_bool control_event_queue_is_full(struct control_event_queue *queue) {    return (queue->head + 1) % CONTROL_EVENT_QUEUE_SIZE == queue->tail;}
SDL_bool control_event_queue_is_empty(struct control_event_queue *queue) {    return queue->head == queue->tail;}
SDL_bool control_event_queue_push(struct control_event_queue *queue, struct control_event *event) {    if (control_event_queue_is_full(queue)) {        return SDL_FALSE;    }    queue->data[queue->head] = *event;    queue->head = (queue->head + 1) % CONTROL_EVENT_QUEUE_SIZE;    return SDL_TRUE;}
SDL_bool control_event_queue_push(struct control_event_queue *queue, struct control_event *event) {    if (control_event_queue_is_full(queue)) {        return SDL_FALSE;    }    queue->data[queue->head] = *event;    queue->head = (queue->head + 1) % CONTROL_EVENT_QUEUE_SIZE;    return SDL_TRUE;}
SDL_bool control_event_queue_is_full(struct control_event_queue *queue) {    return (queue->head + 1) % CONTROL_EVENT_QUEUE_SIZE == queue->tail;}
SDL_bool control_event_queue_is_empty(struct control_event_queue *queue) {    return queue->head == queue->tail;}
int control_event_serialize(struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {    case CONTROL_EVENT_TYPE_KEYCODE:        buf[1] = event->keycode_event.action;        write32(&buf[2], event->keycode_event.keycode);        write32(&buf[6], event->keycode_event.metastate);        return 10;    case CONTROL_EVENT_TYPE_TEXT: {        // write length (1 byte) + date (non nul-terminated)        size_t len = strlen(event->text_event.text);        if (len > TEXT_MAX_LENGTH) {            len = TEXT_MAX_LENGTH;        }        buf[1] = (Uint8) len;        memcpy(&buf[2], &event->text_event.text, len);        return 2 + len;    }    case CONTROL_EVENT_TYPE_MOUSE:        buf[1] = event->mouse_event.action;        write32(&buf[2], event->mouse_event.buttons);        write32(&buf[6], (Uint32) event->mouse_event.x);        write32(&buf[10], (Uint32) event->mouse_event.y);        return 14;    case CONTROL_EVENT_TYPE_SCROLL:        write32(&buf[1], (Uint32) event->scroll_event.x);        write32(&buf[5], (Uint32) event->scroll_event.y);        write32(&buf[9], (Uint32) event->scroll_event.hscroll);        write32(&buf[13], (Uint32) event->scroll_event.vscroll);        return 17;    default:        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Unknown event type: %u\n", (unsigned) event->type);        return 0;    }}
int control_event_serialize(struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {    case CONTROL_EVENT_TYPE_KEYCODE:        buf[1] = event->keycode_event.action;        write32(&buf[2], event->keycode_event.keycode);        write32(&buf[6], event->keycode_event.metastate);        return 10;    case CONTROL_EVENT_TYPE_TEXT: {        // write length (1 byte) + date (non nul-terminated)        size_t len = strlen(event->text_event.text);        if (len > TEXT_MAX_LENGTH) {            len = TEXT_MAX_LENGTH;        }        buf[1] = (Uint8) len;        memcpy(&buf[2], &event->text_event.text, len);        return 2 + len;    }    case CONTROL_EVENT_TYPE_MOUSE:        buf[1] = event->mouse_event.action;        write32(&buf[2], event->mouse_event.buttons);        write32(&buf[6], (Uint32) event->mouse_event.x);        write32(&buf[10], (Uint32) event->mouse_event.y);        return 14;    case CONTROL_EVENT_TYPE_SCROLL:        write32(&buf[1], (Uint32) event->scroll_event.x);        write32(&buf[5], (Uint32) event->scroll_event.y);        write32(&buf[9], (Uint32) event->scroll_event.hscroll);        write32(&buf[13], (Uint32) event->scroll_event.vscroll);        return 17;    default:        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Unknown event type: %u\n", (unsigned) event->type);        return 0;    }}
SDL_bool control_event_queue_is_full(const struct control_event_queue *queue) {    return (queue->head + 1) % CONTROL_EVENT_QUEUE_SIZE == queue->tail;}
SDL_bool control_event_queue_is_empty(const struct control_event_queue *queue) {    return queue->head == queue->tail;}
SDL_bool control_event_queue_push(struct control_event_queue *queue, const struct control_event *event) {    if (control_event_queue_is_full(queue)) {        return SDL_FALSE;    }    queue->data[queue->head] = *event;    queue->head = (queue->head + 1) % CONTROL_EVENT_QUEUE_SIZE;    return SDL_TRUE;}
SDL_bool control_event_queue_push(struct control_event_queue *queue, const struct control_event *event) {    if (control_event_queue_is_full(queue)) {        return SDL_FALSE;    }    queue->data[queue->head] = *event;    queue->head = (queue->head + 1) % CONTROL_EVENT_QUEUE_SIZE;    return SDL_TRUE;}
SDL_bool control_event_queue_is_full(const struct control_event_queue *queue) {    return (queue->head + 1) % CONTROL_EVENT_QUEUE_SIZE == queue->tail;}
SDL_bool control_event_queue_is_empty(const struct control_event_queue *queue) {    return queue->head == queue->tail;}
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {    case CONTROL_EVENT_TYPE_KEYCODE:        buf[1] = event->keycode_event.action;        write32(&buf[2], event->keycode_event.keycode);        write32(&buf[6], event->keycode_event.metastate);        return 10;    case CONTROL_EVENT_TYPE_TEXT: {        // write length (1 byte) + date (non nul-terminated)        size_t len = strlen(event->text_event.text);        if (len > TEXT_MAX_LENGTH) {            len = TEXT_MAX_LENGTH;        }        buf[1] = (Uint8) len;        memcpy(&buf[2], &event->text_event.text, len);        return 2 + len;    }    case CONTROL_EVENT_TYPE_MOUSE:        buf[1] = event->mouse_event.action;        write32(&buf[2], event->mouse_event.buttons);        write32(&buf[6], (Uint32) event->mouse_event.x);        write32(&buf[10], (Uint32) event->mouse_event.y);        return 14;    case CONTROL_EVENT_TYPE_SCROLL:        write32(&buf[1], (Uint32) event->scroll_event.x);        write32(&buf[5], (Uint32) event->scroll_event.y);        write32(&buf[9], (Uint32) event->scroll_event.hscroll);        write32(&buf[13], (Uint32) event->scroll_event.vscroll);        return 17;    default:        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Unknown event type: %u\n", (unsigned) event->type);        return 0;    }}
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {    case CONTROL_EVENT_TYPE_KEYCODE:        buf[1] = event->keycode_event.action;        write32(&buf[2], event->keycode_event.keycode);        write32(&buf[6], event->keycode_event.metastate);        return 10;    case CONTROL_EVENT_TYPE_TEXT: {        // write length (1 byte) + date (non nul-terminated)        size_t len = strlen(event->text_event.text);        if (len > TEXT_MAX_LENGTH) {            len = TEXT_MAX_LENGTH;        }        buf[1] = (Uint8) len;        memcpy(&buf[2], &event->text_event.text, len);        return 2 + len;    }    case CONTROL_EVENT_TYPE_MOUSE:        buf[1] = event->mouse_event.action;        write32(&buf[2], event->mouse_event.buttons);        write32(&buf[6], (Uint32) event->mouse_event.x);        write32(&buf[10], (Uint32) event->mouse_event.y);        return 14;    case CONTROL_EVENT_TYPE_SCROLL:        write32(&buf[1], (Uint32) event->scroll_event.x);        write32(&buf[5], (Uint32) event->scroll_event.y);        write32(&buf[9], (Uint32) event->scroll_event.hscroll);        write32(&buf[13], (Uint32) event->scroll_event.vscroll);        return 17;    default:        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Unknown event type: %u\n", (unsigned) event->type);        return 0;    }}
SDL_bool input_key_from_sdl_to_android(SDL_KeyboardEvent *from, struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_KEYCODE;    if (!convert_keycode_action(from->type, &to->keycode_event.action)) {        return SDL_FALSE;    }    if (!convert_keycode(from->keysym.sym, &to->keycode_event.keycode)) {        return SDL_FALSE;    }    to->keycode_event.metastate = convert_meta_state(from->keysym.mod);    return SDL_TRUE;}
SDL_bool mouse_button_from_sdl_to_android(SDL_MouseButtonEvent *from, struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    if (!convert_mouse_action(from->type, &to->mouse_event.action)) {        return SDL_FALSE;    }    to->mouse_event.buttons = convert_mouse_buttons(SDL_BUTTON(from->button));    to->mouse_event.x = from->x;    to->mouse_event.y = from->y;    return SDL_TRUE;}
SDL_bool mouse_motion_from_sdl_to_android(SDL_MouseMotionEvent *from, struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    to->mouse_event.action = AMOTION_EVENT_ACTION_MOVE;    to->mouse_event.buttons = convert_mouse_buttons(from->state);    to->mouse_event.x = from->x;    to->mouse_event.y = from->y;    return SDL_TRUE;}
SDL_bool input_key_from_sdl_to_android(SDL_KeyboardEvent *from, struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_KEYCODE;    if (!convert_keycode_action(from->type, &to->keycode_event.action)) {        return SDL_FALSE;    }    if (!convert_keycode(from->keysym.sym, &to->keycode_event.keycode)) {        return SDL_FALSE;    }    to->keycode_event.metastate = convert_meta_state(from->keysym.mod);    return SDL_TRUE;}
SDL_bool mouse_wheel_from_sdl_to_android(struct complete_mouse_wheel_event *from, struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_SCROLL;    to->scroll_event.x = from->x;    to->scroll_event.y = from->y;    SDL_MouseWheelEvent *wheel = from->mouse_wheel_event;    int mul = wheel->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    to->scroll_event.hscroll = mul * wheel->x;    to->scroll_event.vscroll = mul * wheel->y;    return SDL_TRUE;}
SDL_bool mouse_button_from_sdl_to_android(SDL_MouseButtonEvent *from, struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    if (!convert_mouse_action(from->type, &to->mouse_event.action)) {        return SDL_FALSE;    }    to->mouse_event.buttons = convert_mouse_buttons(SDL_BUTTON(from->button));    to->mouse_event.x = from->x;    to->mouse_event.y = from->y;    return SDL_TRUE;}
SDL_bool mouse_wheel_from_sdl_to_android(struct complete_mouse_wheel_event *from, struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_SCROLL;    to->scroll_event.x = from->x;    to->scroll_event.y = from->y;    SDL_MouseWheelEvent *wheel = from->mouse_wheel_event;    int mul = wheel->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    to->scroll_event.hscroll = mul * wheel->x;    to->scroll_event.vscroll = mul * wheel->y;    return SDL_TRUE;}
SDL_bool mouse_motion_from_sdl_to_android(SDL_MouseMotionEvent *from, struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    to->mouse_event.action = AMOTION_EVENT_ACTION_MOVE;    to->mouse_event.buttons = convert_mouse_buttons(from->state);    to->mouse_event.x = from->x;    to->mouse_event.y = from->y;    return SDL_TRUE;}
SDL_bool input_key_from_sdl_to_android(const SDL_KeyboardEvent *from, struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_KEYCODE;    if (!convert_keycode_action(from->type, &to->keycode_event.action)) {        return SDL_FALSE;    }    if (!convert_keycode(from->keysym.sym, &to->keycode_event.keycode)) {        return SDL_FALSE;    }    to->keycode_event.metastate = convert_meta_state(from->keysym.mod);    return SDL_TRUE;}
SDL_bool mouse_button_from_sdl_to_android(const SDL_MouseButtonEvent *from, struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    if (!convert_mouse_action(from->type, &to->mouse_event.action)) {        return SDL_FALSE;    }    to->mouse_event.buttons = convert_mouse_buttons(SDL_BUTTON(from->button));    to->mouse_event.x = from->x;    to->mouse_event.y = from->y;    return SDL_TRUE;}
SDL_bool mouse_motion_from_sdl_to_android(const SDL_MouseMotionEvent *from, struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    to->mouse_event.action = AMOTION_EVENT_ACTION_MOVE;    to->mouse_event.buttons = convert_mouse_buttons(from->state);    to->mouse_event.x = from->x;    to->mouse_event.y = from->y;    return SDL_TRUE;}
SDL_bool input_key_from_sdl_to_android(const SDL_KeyboardEvent *from, struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_KEYCODE;    if (!convert_keycode_action(from->type, &to->keycode_event.action)) {        return SDL_FALSE;    }    if (!convert_keycode(from->keysym.sym, &to->keycode_event.keycode)) {        return SDL_FALSE;    }    to->keycode_event.metastate = convert_meta_state(from->keysym.mod);    return SDL_TRUE;}
SDL_bool mouse_wheel_from_sdl_to_android(const struct complete_mouse_wheel_event *from, struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_SCROLL;    to->scroll_event.x = from->x;    to->scroll_event.y = from->y;    SDL_MouseWheelEvent *wheel = from->mouse_wheel_event;    int mul = wheel->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    to->scroll_event.hscroll = mul * wheel->x;    to->scroll_event.vscroll = mul * wheel->y;    return SDL_TRUE;}
SDL_bool mouse_button_from_sdl_to_android(const SDL_MouseButtonEvent *from, struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    if (!convert_mouse_action(from->type, &to->mouse_event.action)) {        return SDL_FALSE;    }    to->mouse_event.buttons = convert_mouse_buttons(SDL_BUTTON(from->button));    to->mouse_event.x = from->x;    to->mouse_event.y = from->y;    return SDL_TRUE;}
SDL_bool mouse_wheel_from_sdl_to_android(const struct complete_mouse_wheel_event *from, struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_SCROLL;    to->scroll_event.x = from->x;    to->scroll_event.y = from->y;    SDL_MouseWheelEvent *wheel = from->mouse_wheel_event;    int mul = wheel->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    to->scroll_event.hscroll = mul * wheel->x;    to->scroll_event.vscroll = mul * wheel->y;    return SDL_TRUE;}
SDL_bool mouse_motion_from_sdl_to_android(const SDL_MouseMotionEvent *from, struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    to->mouse_event.action = AMOTION_EVENT_ACTION_MOVE;    to->mouse_event.buttons = convert_mouse_buttons(from->state);    to->mouse_event.x = from->x;    to->mouse_event.y = from->y;    return SDL_TRUE;}
static void handle_mouse_motion(SDL_MouseMotionEvent *event) {    struct control_event control_event;    if (mouse_motion_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse motion event");        }    }}
static void update_texture(AVFrame *frame, SDL_Texture *texture) {    SDL_UpdateYUVTexture(texture, NULL,            frame->data[0], frame->linesize[0],            frame->data[1], frame->linesize[1],            frame->data[2], frame->linesize[2]);}
static void handle_key(SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // Capture Ctrl+x: optimal size    if (keycode == SDLK_x && !repeat && ctrl && !shift) {        if (event->type == SDL_KEYDOWN) {            struct size optimal_size = get_optimal_window_size(window, frame_size);            SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);        }        return;    }    // Capture Ctrl+f: switch fullscreen    if (keycode == SDLK_f && !repeat && ctrl && !shift) {        if (event->type == SDL_KEYDOWN) {            Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;            if (!SDL_SetWindowFullscreen(window, new_mode)) {                fullscreen = !fullscreen;                render(renderer, texture_empty ? NULL : texture);            } else {                SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());            }        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
static void update_texture(AVFrame *frame, SDL_Texture *texture) {    SDL_UpdateYUVTexture(texture, NULL,            frame->data[0], frame->linesize[0],            frame->data[1], frame->linesize[1],            frame->data[2], frame->linesize[2]);}
static void handle_mouse_button(SDL_MouseButtonEvent *event) {    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse button event");        }    }}
static void handle_text_input(SDL_TextInputEvent *event) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    strncpy(control_event.text_event.text, event->text, TEXT_MAX_LENGTH);    control_event.text_event.text[TEXT_MAX_LENGTH] = '\0';    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send text event");    }}
static void handle_mouse_wheel(struct complete_mouse_wheel_event *event) {    struct control_event control_event;    if (mouse_wheel_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send wheel button event");        }    }}
static void handle_key(SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // Capture Ctrl+x: optimal size    if (keycode == SDLK_x && !repeat && ctrl && !shift) {        if (event->type == SDL_KEYDOWN) {            struct size optimal_size = get_optimal_window_size(window, frame_size);            SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);        }        return;    }    // Capture Ctrl+f: switch fullscreen    if (keycode == SDLK_f && !repeat && ctrl && !shift) {        if (event->type == SDL_KEYDOWN) {            Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;            if (!SDL_SetWindowFullscreen(window, new_mode)) {                fullscreen = !fullscreen;                render(renderer, texture_empty ? NULL : texture);            } else {                SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());            }        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
static void handle_text_input(SDL_TextInputEvent *event) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    strncpy(control_event.text_event.text, event->text, TEXT_MAX_LENGTH);    control_event.text_event.text[TEXT_MAX_LENGTH] = '\0';    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send text event");    }}
static void handle_mouse_button(SDL_MouseButtonEvent *event) {    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse button event");        }    }}
static void handle_mouse_wheel(struct complete_mouse_wheel_event *event) {    struct control_event control_event;    if (mouse_wheel_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send wheel button event");        }    }}
static void handle_mouse_motion(SDL_MouseMotionEvent *event) {    struct control_event control_event;    if (mouse_motion_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse motion event");        }    }}
    struct control_event control_event;    if (mouse_motion_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse motion event");        }    }}static void handle_mouse_button(const SDL_MouseButtonEvent *event) {
static void update_texture(const AVFrame *frame, SDL_Texture *texture) {    SDL_UpdateYUVTexture(texture, NULL,            frame->data[0], frame->linesize[0],            frame->data[1], frame->linesize[1],            frame->data[2], frame->linesize[2]);}
    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // Capture Ctrl+x: optimal size    if (keycode == SDLK_x && !repeat && ctrl && !shift) {        if (event->type == SDL_KEYDOWN) {            struct size optimal_size = get_optimal_window_size(window, frame_size);            SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);        }        return;    }    // Capture Ctrl+f: switch fullscreen    if (keycode == SDLK_f && !repeat && ctrl && !shift) {        if (event->type == SDL_KEYDOWN) {            Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;            if (!SDL_SetWindowFullscreen(window, new_mode)) {                fullscreen = !fullscreen;                render(renderer, texture_empty ? NULL : texture);            } else {                SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());            }        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}static void handle_mouse_motion(const SDL_MouseMotionEvent *event) {
    SDL_UpdateYUVTexture(texture, NULL,            frame->data[0], frame->linesize[0],            frame->data[1], frame->linesize[1],            frame->data[2], frame->linesize[2]);}static void render(SDL_Renderer *renderer, SDL_Texture *texture) {
    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse button event");        }    }}static void handle_mouse_wheel(const struct complete_mouse_wheel_event *event) {
static void handle_text_input(const SDL_TextInputEvent *event) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    strncpy(control_event.text_event.text, event->text, TEXT_MAX_LENGTH);    control_event.text_event.text[TEXT_MAX_LENGTH] = '\0';    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send text event");    }}
static void handle_mouse_wheel(const struct complete_mouse_wheel_event *event) {    struct control_event control_event;    if (mouse_wheel_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send wheel button event");        }    }}
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // Capture Ctrl+x: optimal size    if (keycode == SDLK_x && !repeat && ctrl && !shift) {        if (event->type == SDL_KEYDOWN) {            struct size optimal_size = get_optimal_window_size(window, frame_size);            SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);        }        return;    }    // Capture Ctrl+f: switch fullscreen    if (keycode == SDLK_f && !repeat && ctrl && !shift) {        if (event->type == SDL_KEYDOWN) {            Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;            if (!SDL_SetWindowFullscreen(window, new_mode)) {                fullscreen = !fullscreen;                render(renderer, texture_empty ? NULL : texture);            } else {                SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());            }        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    strncpy(control_event.text_event.text, event->text, TEXT_MAX_LENGTH);    control_event.text_event.text[TEXT_MAX_LENGTH] = '\0';    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send text event");    }}static void handle_key(const SDL_KeyboardEvent *event) {
static void handle_mouse_button(const SDL_MouseButtonEvent *event) {    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse button event");        }    }}
    struct control_event control_event;    if (mouse_wheel_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send wheel button event");        }    }}void event_loop(void) {
static void handle_mouse_motion(const SDL_MouseMotionEvent *event) {    struct control_event control_event;    if (mouse_motion_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse motion event");        }    }}
TCPsocket server_socket_accept(TCPsocket server_socket) {    SDLNet_SocketSet set = SDLNet_AllocSocketSet(1);    if (!set) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not allocate socket set");        return NULL;    }    if (SDLNet_TCP_AddSocket(set, server_socket) == -1) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not add socket to set");        SDLNet_FreeSocketSet(set);        return NULL;    }    // timeout is (2^32-1) milliseconds, this should be sufficient    if (SDLNet_CheckSockets(set, -1) != 1) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not check socket");        SDLNet_FreeSocketSet(set);        return NULL;    }    SDLNet_FreeSocketSet(set);    return SDLNet_TCP_Accept(server_socket);}
TCPsocket server_socket_accept(TCPsocket server_socket) {    SDLNet_SocketSet set = SDLNet_AllocSocketSet(1);    if (!set) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not allocate socket set");        return NULL;    }    if (SDLNet_TCP_AddSocket(set, server_socket) == -1) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not add socket to set");        SDLNet_FreeSocketSet(set);        return NULL;    }    // timeout is (2^32-1) milliseconds, this should be sufficient    if (SDLNet_CheckSockets(set, -1) != 1) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not check socket");        SDLNet_FreeSocketSet(set);        return NULL;    }    SDLNet_FreeSocketSet(set);    return SDLNet_TCP_Accept(server_socket);}
TCPsocket server_socket_accept(TCPsocket server_socket, Uint32 timeout_ms) {    SDLNet_SocketSet set = SDLNet_AllocSocketSet(1);    if (!set) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not allocate socket set");        return NULL;    }    if (SDLNet_TCP_AddSocket(set, server_socket) == -1) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not add socket to set");        SDLNet_FreeSocketSet(set);        return NULL;    }    if (SDLNet_CheckSockets(set, timeout_ms) != 1) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "No connection to accept");        SDLNet_FreeSocketSet(set);        return NULL;    }    SDLNet_FreeSocketSet(set);    return SDLNet_TCP_Accept(server_socket);}
TCPsocket server_socket_accept(TCPsocket server_socket, Uint32 timeout_ms) {    SDLNet_SocketSet set = SDLNet_AllocSocketSet(1);    if (!set) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not allocate socket set");        return NULL;    }    if (SDLNet_TCP_AddSocket(set, server_socket) == -1) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not add socket to set");        SDLNet_FreeSocketSet(set);        return NULL;    }    if (SDLNet_CheckSockets(set, timeout_ms) != 1) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "No connection to accept");        SDLNet_FreeSocketSet(set);        return NULL;    }    SDLNet_FreeSocketSet(set);    return SDLNet_TCP_Accept(server_socket);}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = server_connect_to(&server, serial);    if (!device_socket) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server, serial);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // kill the server before decoder_join() to wake up the decoder    server_stop(&server, serial);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    // SDL initialization replace the signal handler for SIGTERM, so Ctrl+C is    // managed by the event loop. This blocking call blocks the event loop, so    // timeout the connection not to block indefinitely in case of SIGTERM.#define SERVER_CONNECT_TIMEOUT_MS 2000    TCPsocket device_socket = server_connect_to(&server, serial, SERVER_CONNECT_TIMEOUT_MS);    if (!device_socket) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server, serial);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // kill the server before decoder_join() to wake up the decoder    server_stop(&server, serial);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
TCPsocket server_connect_to(struct server *server, const char *serial) {    SDL_assert(server->server_socket);    server->device_socket = server_socket_accept(server->server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server->server_socket);    server->server_socket = NULL;    // we don't need the adb tunnel anymore    disable_tunnel(serial); // ignore failure    server->adb_reverse_enabled = SDL_FALSE;    return server->device_socket;}
TCPsocket server_connect_to(struct server *server, const char *serial) {    SDL_assert(server->server_socket);    server->device_socket = server_socket_accept(server->server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server->server_socket);    server->server_socket = NULL;    // we don't need the adb tunnel anymore    disable_tunnel(serial); // ignore failure    server->adb_reverse_enabled = SDL_FALSE;    return server->device_socket;}
TCPsocket server_connect_to(struct server *server, const char *serial, Uint32 timeout_ms) {    SDL_assert(server->server_socket);    server->device_socket = server_socket_accept(server->server_socket, timeout_ms);    // we don't need the server socket anymore    SDLNet_TCP_Close(server->server_socket);    server->server_socket = NULL;    // we don't need the adb tunnel anymore    disable_tunnel(serial); // ignore failure    server->adb_reverse_enabled = SDL_FALSE;    return server->device_socket;}
TCPsocket server_connect_to(struct server *server, const char *serial, Uint32 timeout_ms) {    SDL_assert(server->server_socket);    server->device_socket = server_socket_accept(server->server_socket, timeout_ms);    // we don't need the server socket anymore    SDLNet_TCP_Close(server->server_socket);    server->server_socket = NULL;    // we don't need the adb tunnel anymore    disable_tunnel(serial); // ignore failure    server->adb_reverse_enabled = SDL_FALSE;    return server->device_socket;}
SDL_bool sdl_init_and_configure(void) {    if (SDL_Init(SDL_INIT_VIDEO)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return SDL_FALSE;    }    atexit(SDL_Quit);    // Use the best available scale quality    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "2")) {        LOGW("Could not enable bilinear filtering");    }#if SDL_VERSION_ATLEAST(2, 0, 5)    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif    return SDL_TRUE;}
SDL_bool sdl_init_and_configure(void) {    if (SDL_Init(SDL_INIT_VIDEO)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return SDL_FALSE;    }    atexit(SDL_Quit);    // Use the best available scale quality    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "2")) {        LOGW("Could not enable bilinear filtering");    }#if SDL_VERSION_ATLEAST(2, 0, 5)    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return SDL_TRUE;}
SDL_bool process_check_success(process_t proc, const char *name) {    if (proc == PROCESS_NONE) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not execute \"%s\"", name);        return SDL_FALSE;    }    exit_code_t exit_code;    if (!cmd_simple_wait(proc, &exit_code)) {        if (exit_code != NO_EXIT_CODE) {            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "\"%s\" returned with value %" PRIexitcode, name, exit_code);        } else {            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "\"%s\" exited unexpectedly", name);        }        return SDL_FALSE;    }    return SDL_TRUE;}
SDL_bool process_check_success(process_t proc, const char *name) {    if (proc == PROCESS_NONE) {        LOGE("Could not execute \"%s\"", name);        return SDL_FALSE;    }    exit_code_t exit_code;    if (!cmd_simple_wait(proc, &exit_code)) {        if (exit_code != NO_EXIT_CODE) {            LOGE("\"%s\" returned with value %" PRIexitcode, name, exit_code);        } else {            LOGE("\"%s\" exited unexpectedly", name);        }        return SDL_FALSE;    }    return SDL_TRUE;}
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            write32(&buf[2], event->keycode_event.keycode);            write32(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (1 byte) + date (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > TEXT_MAX_LENGTH) {                len = TEXT_MAX_LENGTH;            }            buf[1] = (Uint8) len;            memcpy(&buf[2], &event->text_event.text, len);            return 2 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            write32(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 14;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            write32(&buf[9], (Uint32) event->scroll_event.hscroll);            write32(&buf[13], (Uint32) event->scroll_event.vscroll);            return 17;        case CONTROL_EVENT_TYPE_COMMAND:            buf[1] = event->command_event.action;            return 2;        default:            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Unknown event type: %u", (unsigned) event->type);            return 0;    }}
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            write32(&buf[2], event->keycode_event.keycode);            write32(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (1 byte) + date (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > TEXT_MAX_LENGTH) {                len = TEXT_MAX_LENGTH;            }            buf[1] = (Uint8) len;            memcpy(&buf[2], &event->text_event.text, len);            return 2 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            write32(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 14;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            write32(&buf[9], (Uint32) event->scroll_event.hscroll);            write32(&buf[13], (Uint32) event->scroll_event.vscroll);            return 17;        case CONTROL_EVENT_TYPE_COMMAND:            buf[1] = event->command_event.action;            return 2;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
SDL_bool controller_start(struct controller *controller) {    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Starting controller thread");    controller->thread = SDL_CreateThread(run_controller, "controller", controller);    if (!controller->thread) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not start controller thread");        return SDL_FALSE;    }    return SDL_TRUE;}
static int run_controller(void *data) {    struct controller *controller = data;    mutex_lock(controller->mutex);    for (;;) {        while (!controller->stopped && control_event_queue_is_empty(&controller->queue)) {            cond_wait(controller->event_cond, controller->mutex);        }        if (controller->stopped) {            // stop immediately, do not process further events            break;        }        struct control_event event;        while (control_event_queue_take(&controller->queue, &event)) {            if (!process_event(controller, &event)) {                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Cannot write event to socket");                goto end;            }        }    }end:    mutex_unlock(controller->mutex);    return 0;}
SDL_bool controller_start(struct controller *controller) {    LOGD("Starting controller thread");    controller->thread = SDL_CreateThread(run_controller, "controller", controller);    if (!controller->thread) {        LOGC("Could not start controller thread");        return SDL_FALSE;    }    return SDL_TRUE;}
static int run_controller(void *data) {    struct controller *controller = data;    mutex_lock(controller->mutex);    for (;;) {        while (!controller->stopped && control_event_queue_is_empty(&controller->queue)) {            cond_wait(controller->event_cond, controller->mutex);        }        if (controller->stopped) {            // stop immediately, do not process further events            break;        }        struct control_event event;        while (control_event_queue_take(&controller->queue, &event)) {            if (!process_event(controller, &event)) {                LOGD("Cannot write event to socket");                goto end;            }        }    }end:    mutex_unlock(controller->mutex);    return 0;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    int ret = 0;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "H.264 decoder not found");        return -1;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not allocate decoder context");        return -1;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open H.264 codec");        ret = -1;        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not allocate format context");        ret = -1;        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not allocate buffer");        ret = -1;        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        ret = -1;        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    //const char *url = "tcp://127.0.0.1:1234";    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video stream");        ret = -1;        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet) && !avio_ctx->eof_reached) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57, 37, 0)        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#else        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not send video packet: %d", ret);            goto run_quit;        }        if ((ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame)) < 0) {            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not receive video frame: %d", ret);            goto run_quit;        }        push_frame(decoder);#endif    }    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    SDL_PushEvent(&(SDL_Event) {.type = EVENT_DECODER_STOPPED});    return ret;}
SDL_bool decoder_start(struct decoder *decoder) {    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Starting decoder thread");    decoder->thread = SDL_CreateThread(run_decoder, "video_decoder", decoder);    if (!decoder->thread) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not start decoder thread");        return SDL_FALSE;    }    return SDL_TRUE;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    int ret = 0;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        return -1;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        return -1;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        ret = -1;        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        ret = -1;        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        ret = -1;        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        ret = -1;        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    //const char *url = "tcp://127.0.0.1:1234";    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        ret = -1;        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet) && !avio_ctx->eof_reached) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57, 37, 0)        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#else        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        if ((ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame)) < 0) {            LOGE("Could not receive video frame: %d", ret);            goto run_quit;        }        push_frame(decoder);#endif    }    LOGD("End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    SDL_PushEvent(&(SDL_Event) {.type = EVENT_DECODER_STOPPED});    return ret;}
SDL_bool decoder_start(struct decoder *decoder) {    LOGD("Starting decoder thread");    decoder->thread = SDL_CreateThread(run_decoder, "video_decoder", decoder);    if (!decoder->thread) {        LOGC("Could not start decoder thread");        return SDL_FALSE;    }    return SDL_TRUE;}
SDL_bool device_read_info(TCPsocket device_socket, char *device_name, struct size *size) {    unsigned char buf[DEVICE_NAME_FIELD_LENGTH + 4];    if (SDLNet_TCP_Recv(device_socket, buf, sizeof(buf)) <= 0) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve device information");        return SDL_FALSE;    }    buf[DEVICE_NAME_FIELD_LENGTH - 1] = '\0'; // in case the client sends garbage    // strcpy is safe here, since name contains at least DEVICE_NAME_FIELD_LENGTH bytes    // and strlen(buf) < DEVICE_NAME_FIELD_LENGTH    strcpy(device_name, (char *) buf);    size->width = (buf[DEVICE_NAME_FIELD_LENGTH] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 1];    size->height = (buf[DEVICE_NAME_FIELD_LENGTH + 2] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 3];    return SDL_TRUE;}
SDL_bool device_read_info(TCPsocket device_socket, char *device_name, struct size *size) {    unsigned char buf[DEVICE_NAME_FIELD_LENGTH + 4];    if (SDLNet_TCP_Recv(device_socket, buf, sizeof(buf)) <= 0) {        LOGE("Could not retrieve device information");        return SDL_FALSE;    }    buf[DEVICE_NAME_FIELD_LENGTH - 1] = '\0'; // in case the client sends garbage    // strcpy is safe here, since name contains at least DEVICE_NAME_FIELD_LENGTH bytes    // and strlen(buf) < DEVICE_NAME_FIELD_LENGTH    strcpy(device_name, (char *) buf);    size->width = (buf[DEVICE_NAME_FIELD_LENGTH] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 1];    size->height = (buf[DEVICE_NAME_FIELD_LENGTH + 2] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 3];    return SDL_TRUE;}
SDL_bool frames_offer_decoded_frame(struct frames *frames) {    mutex_lock(frames->mutex);#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then the decoder must wait for the current    // frame to be consumed    while (!frames->rendering_frame_consumed && !frames->stopped) {        cond_wait(frames->rendering_frame_consumed_cond, frames->mutex);    }#else    if (!frames->rendering_frame_consumed) {        SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Skip frame");    }#endif    frames_swap(frames);    SDL_bool previous_frame_consumed = frames->rendering_frame_consumed;    frames->rendering_frame_consumed = SDL_FALSE;    mutex_unlock(frames->mutex);    return previous_frame_consumed;}
SDL_bool frames_offer_decoded_frame(struct frames *frames) {    mutex_lock(frames->mutex);#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then the decoder must wait for the current    // frame to be consumed    while (!frames->rendering_frame_consumed && !frames->stopped) {        cond_wait(frames->rendering_frame_consumed_cond, frames->mutex);    }#else    if (!frames->rendering_frame_consumed) {        LOGD("Skip frame");    }#endif    frames_swap(frames);    SDL_bool previous_frame_consumed = frames->rendering_frame_consumed;    frames->rendering_frame_consumed = SDL_FALSE;    mutex_unlock(frames->mutex);    return previous_frame_consumed;}
void mutex_lock(SDL_mutex *mutex) {    if (SDL_LockMutex(mutex)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not lock mutex");        abort();    }}
void mutex_unlock(SDL_mutex *mutex) {    if (SDL_UnlockMutex(mutex)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not unlock mutex");        abort();    }}
void cond_signal(SDL_cond *cond) {    if (SDL_CondSignal(cond)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not signal a condition");        abort();    }}
void cond_wait(SDL_cond *cond, SDL_mutex *mutex) {    if (SDL_CondWait(cond, mutex)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not wait on condition");        abort();    }}
void mutex_lock(SDL_mutex *mutex) {    if (SDL_LockMutex(mutex)) {        LOGC("Could not lock mutex");        abort();    }}
void mutex_unlock(SDL_mutex *mutex) {    if (SDL_UnlockMutex(mutex)) {        LOGC("Could not unlock mutex");        abort();    }}
void cond_signal(SDL_cond *cond) {    if (SDL_CondSignal(cond)) {        LOGC("Could not signal a condition");        abort();    }}
void cond_wait(SDL_cond *cond, SDL_mutex *mutex) {    if (SDL_CondWait(cond, mutex)) {        LOGC("Could not wait on condition");        abort();    }}
static int parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"help",     no_argument,       NULL, 'h'},        {"port",     required_argument, NULL, 'p'},        {"max-size", required_argument, NULL, 'm'},        {"bit-rate", required_argument, NULL, 'b'},        {"version",  no_argument,       NULL, 'v'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "hvp:m:b:", long_options, NULL)) != -1) {        switch (c) {            case 'h': {                args->help = SDL_TRUE;                break;            }            case 'v': {                args->version = SDL_TRUE;                break;            }            case 'p': {                char *endptr;                if (*optarg == '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                if (*endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld", value);                    return -1;                }                args->port = (Uint16) value;                break;            }            case 'm': {                char *endptr;                if (*optarg == '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Max size parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                if (*endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid max size: %s", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Max size must be between 0 and 65535: %ld", value);                    return -1;                }                args->max_size = (Uint16) value;                break;            }            case 'b': {                char *endptr;                if (*optarg == '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Bit-rate parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                int mul = 1;                if (*endptr != '\0') {                    if (optarg == endptr) {                        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid bit-rate: %s", optarg);                        return -1;                    }                    if ((*endptr == 'M' || *endptr == 'm') && endptr[1] == '\0') {                        mul = 1000000;                    } else if ((*endptr == 'K' || *endptr == 'k') && endptr[1] == '\0') {                        mul = 1000;                    } else {                        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid bit-rate unit: %s", optarg);                        return -1;                    }                }                if (value < 0 || ((Uint32) -1) / mul < value) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Bitrate must be positive and less than 2^32: %s", optarg);                    return -1;                }                args->bit_rate = (Uint32) value * mul;                break;            }            default:                // getopt prints the error message on stderr                return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s", argv[index]);        return -1;    }    return 0;}
static int parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"help",     no_argument,       NULL, 'h'},        {"port",     required_argument, NULL, 'p'},        {"max-size", required_argument, NULL, 'm'},        {"bit-rate", required_argument, NULL, 'b'},        {"version",  no_argument,       NULL, 'v'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "hvp:m:b:", long_options, NULL)) != -1) {        switch (c) {            case 'h': {                args->help = SDL_TRUE;                break;            }            case 'v': {                args->version = SDL_TRUE;                break;            }            case 'p': {                char *endptr;                if (*optarg == '\0') {                    LOGE("Invalid port parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                if (*endptr != '\0') {                    LOGE("Invalid port: %s", optarg);                    return -1;                }                if (value & ~0xffff) {                    LOGE("Port out of range: %ld", value);                    return -1;                }                args->port = (Uint16) value;                break;            }            case 'm': {                char *endptr;                if (*optarg == '\0') {                    LOGE("Max size parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                if (*endptr != '\0') {                    LOGE("Invalid max size: %s", optarg);                    return -1;                }                if (value & ~0xffff) {                    LOGE("Max size must be between 0 and 65535: %ld", value);                    return -1;                }                args->max_size = (Uint16) value;                break;            }            case 'b': {                char *endptr;                if (*optarg == '\0') {                    LOGE("Bit-rate parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                int mul = 1;                if (*endptr != '\0') {                    if (optarg == endptr) {                        LOGE("Invalid bit-rate: %s", optarg);                        return -1;                    }                    if ((*endptr == 'M' || *endptr == 'm') && endptr[1] == '\0') {                        mul = 1000000;                    } else if ((*endptr == 'K' || *endptr == 'k') && endptr[1] == '\0') {                        mul = 1000;                    } else {                        LOGE("Invalid bit-rate unit: %s", optarg);                        return -1;                    }                }                if (value < 0 || ((Uint32) -1) / mul < value) {                    LOGE("Bitrate must be positive and less than 2^32: %s", optarg);                    return -1;                }                args->bit_rate = (Uint32) value * mul;                break;            }            default:                // getopt prints the error message on stderr                return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return -1;    }    return 0;}
TCPsocket server_socket_accept(TCPsocket server_socket, Uint32 timeout_ms) {    SDLNet_SocketSet set = SDLNet_AllocSocketSet(1);    if (!set) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not allocate socket set");        return NULL;    }    if (SDLNet_TCP_AddSocket(set, server_socket) == -1) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not add socket to set");        SDLNet_FreeSocketSet(set);        return NULL;    }    if (SDLNet_CheckSockets(set, timeout_ms) != 1) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "No connection to accept");        SDLNet_FreeSocketSet(set);        return NULL;    }    SDLNet_FreeSocketSet(set);    return SDLNet_TCP_Accept(server_socket);}
TCPsocket server_socket_accept(TCPsocket server_socket, Uint32 timeout_ms) {    SDLNet_SocketSet set = SDLNet_AllocSocketSet(1);    if (!set) {        LOGC("Could not allocate socket set");        return NULL;    }    if (SDLNet_TCP_AddSocket(set, server_socket) == -1) {        LOGC("Could not add socket to set");        SDLNet_FreeSocketSet(set);        return NULL;    }    if (SDLNet_CheckSockets(set, timeout_ms) != 1) {        LOGE("No connection to accept");        SDLNet_FreeSocketSet(set);        return NULL;    }    SDLNet_FreeSocketSet(set);    return SDLNet_TCP_Accept(server_socket);}
static void count_frame(void) {    static long ts = 0;    static int nbframes = 0;    long now = timestamp_ms();    ++nbframes;    if (now - ts > 1000) {        SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "%d fps", nbframes);        ts = now;        nbframes = 0;    }}
static void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");                return;            case SDL_QUIT:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return;                }                count_frame(); // display fps for debug                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;                }                break;            case SDL_TEXTINPUT: {                screencontrol_handle_text_input(&controller, &screen, &event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                screencontrol_handle_key(&controller, &screen, &event.key);                break;            case SDL_MOUSEMOTION:                screencontrol_handle_mouse_motion(&controller, &screen, &event.motion);                break;            case SDL_MOUSEWHEEL: {                screencontrol_handle_mouse_wheel(&controller, &screen, &event.wheel);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                screencontrol_handle_mouse_button(&controller, &screen, &event.button);                break;            }        }    }}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    // SDL initialization replace the signal handler for SIGTERM, so Ctrl+C is    // managed by the event loop. This blocking call blocks the event loop, so    // timeout the connection not to block indefinitely in case of SIGTERM.#define SERVER_CONNECT_TIMEOUT_MS 2000    TCPsocket device_socket = server_connect_to(&server, serial, SERVER_CONNECT_TIMEOUT_MS);    if (!device_socket) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server, serial);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // kill the server before decoder_join() to wake up the decoder    server_stop(&server, serial);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
static void count_frame(void) {    static long ts = 0;    static int nbframes = 0;    long now = timestamp_ms();    ++nbframes;    if (now - ts > 1000) {        LOGD("%d fps", nbframes);        ts = now;        nbframes = 0;    }}
static void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return;            case SDL_QUIT:                LOGD("User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return;                }                count_frame(); // display fps for debug                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;                }                break;            case SDL_TEXTINPUT: {                screencontrol_handle_text_input(&controller, &screen, &event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                screencontrol_handle_key(&controller, &screen, &event.key);                break;            case SDL_MOUSEMOTION:                screencontrol_handle_mouse_motion(&controller, &screen, &event.motion);                break;            case SDL_MOUSEWHEEL: {                screencontrol_handle_mouse_wheel(&controller, &screen, &event.wheel);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                screencontrol_handle_mouse_button(&controller, &screen, &event.button);                break;            }        }    }}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    // SDL initialization replace the signal handler for SIGTERM, so Ctrl+C is    // managed by the event loop. This blocking call blocks the event loop, so    // timeout the connection not to block indefinitely in case of SIGTERM.#define SERVER_CONNECT_TIMEOUT_MS 2000    TCPsocket device_socket = server_connect_to(&server, serial, SERVER_CONNECT_TIMEOUT_MS);    if (!device_socket) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server, serial);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // kill the server before decoder_join() to wake up the decoder    server_stop(&server, serial);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
SDL_bool sdl_init_and_configure(void) {    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        return SDL_FALSE;    }    atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not enable bilinear filtering");    }#if SDL_VERSION_ATLEAST(2, 0, 5)    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not enable mouse focus clickthrough");    }#endif    return SDL_TRUE;}
SDL_bool screen_init_rendering(struct screen *screen, const char *device_name, struct size frame_size) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height, SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE);    if (!screen->window) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1, SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    screen->texture = SDL_CreateTexture(screen->renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                                        frame_size.width, frame_size.height);    if (!screen->texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    screen_render(screen);    return SDL_TRUE;}
static SDL_bool prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width || screen->frame_size.height != new_frame_size.height) {        if (SDL_RenderSetLogicalSize(screen->renderer, new_frame_size.width, new_frame_size.height)) {            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not set renderer logical size: %s", SDL_GetError());            return SDL_FALSE;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        struct size current_size = get_window_size(screen);        struct size target_size = {            (Uint32) current_size.width * new_frame_size.width / screen->frame_size.width,            (Uint32) current_size.height * new_frame_size.height / screen->frame_size.height,        };        target_size = get_optimal_size(target_size, new_frame_size);        set_window_size(screen, target_size);        screen->frame_size = new_frame_size;        SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = SDL_CreateTexture(screen->renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                                            new_frame_size.width, new_frame_size.height);        if (!screen->texture) {            SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not create texture: %s", SDL_GetError());            return SDL_FALSE;        }    }    return SDL_TRUE;}
void screen_resize_to_fit(struct screen *screen) {    if (!screen->fullscreen) {        struct size optimal_size = get_optimal_window_size(screen, screen->frame_size);        SDL_SetWindowSize(screen->window, optimal_size.width, optimal_size.height);        SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Resized to optimal size");    }}
void screen_resize_to_pixel_perfect(struct screen *screen) {    if (!screen->fullscreen) {        SDL_SetWindowSize(screen->window, screen->frame_size.width, screen->frame_size.height);        SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Resized to pixel-perfect");    }}
void screen_switch_fullscreen(struct screen *screen) {    if (!screen->fullscreen) {        // going to fullscreen, store the current windowed window size        screen->windowed_window_size = get_native_window_size(screen->window);    }    Uint32 new_mode = screen->fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;    if (SDL_SetWindowFullscreen(screen->window, new_mode)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());        return;    }    screen->fullscreen = !screen->fullscreen;    if (!screen->fullscreen) {        // fullscreen disabled, restore expected windowed window size        SDL_SetWindowSize(screen->window, screen->windowed_window_size.width, screen->windowed_window_size.height);    }    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Switched to %s mode", screen->fullscreen ? "fullscreen" : "windowed");    screen_render(screen);}
static SDL_bool get_preferred_display_bounds(struct size *bounds) {    SDL_Rect rect;#if SDL_VERSION_ATLEAST(2, 0, 5)# define GET_DISPLAY_BOUNDS(i, r) SDL_GetDisplayUsableBounds((i), (r))#else# define GET_DISPLAY_BOUNDS(i, r) SDL_GetDisplayBounds((i), (r))#endif    if (GET_DISPLAY_BOUNDS(0, &rect)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not get display usable bounds: %s", SDL_GetError());        return SDL_FALSE;    }    bounds->width = MAX(0, rect.w - DISPLAY_MARGINS);    bounds->height = MAX(0, rect.h - DISPLAY_MARGINS);    return SDL_TRUE;}
SDL_bool sdl_init_and_configure(void) {    if (SDL_Init(SDL_INIT_VIDEO)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return SDL_FALSE;    }    atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        LOGW("Could not enable bilinear filtering");    }#if SDL_VERSION_ATLEAST(2, 0, 5)    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif    return SDL_TRUE;}
SDL_bool screen_init_rendering(struct screen *screen, const char *device_name, struct size frame_size) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height, SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1, SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width, frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    screen->texture = SDL_CreateTexture(screen->renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                                        frame_size.width, frame_size.height);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    screen_render(screen);    return SDL_TRUE;}
static SDL_bool prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width || screen->frame_size.height != new_frame_size.height) {        if (SDL_RenderSetLogicalSize(screen->renderer, new_frame_size.width, new_frame_size.height)) {            LOGE("Could not set renderer logical size: %s", SDL_GetError());            return SDL_FALSE;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        struct size current_size = get_window_size(screen);        struct size target_size = {            (Uint32) current_size.width * new_frame_size.width / screen->frame_size.width,            (Uint32) current_size.height * new_frame_size.height / screen->frame_size.height,        };        target_size = get_optimal_size(target_size, new_frame_size);        set_window_size(screen, target_size);        screen->frame_size = new_frame_size;        LOGD("New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = SDL_CreateTexture(screen->renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                                            new_frame_size.width, new_frame_size.height);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return SDL_FALSE;        }    }    return SDL_TRUE;}
void screen_resize_to_fit(struct screen *screen) {    if (!screen->fullscreen) {        struct size optimal_size = get_optimal_window_size(screen, screen->frame_size);        SDL_SetWindowSize(screen->window, optimal_size.width, optimal_size.height);        LOGD("Resized to optimal size");    }}
void screen_resize_to_pixel_perfect(struct screen *screen) {    if (!screen->fullscreen) {        SDL_SetWindowSize(screen->window, screen->frame_size.width, screen->frame_size.height);        LOGD("Resized to pixel-perfect");    }}
void screen_switch_fullscreen(struct screen *screen) {    if (!screen->fullscreen) {        // going to fullscreen, store the current windowed window size        screen->windowed_window_size = get_native_window_size(screen->window);    }    Uint32 new_mode = screen->fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;    if (SDL_SetWindowFullscreen(screen->window, new_mode)) {        LOGW("Could not switch fullscreen mode: %s", SDL_GetError());        return;    }    screen->fullscreen = !screen->fullscreen;    if (!screen->fullscreen) {        // fullscreen disabled, restore expected windowed window size        SDL_SetWindowSize(screen->window, screen->windowed_window_size.width, screen->windowed_window_size.height);    }    LOGD("Switched to %s mode", screen->fullscreen ? "fullscreen" : "windowed");    screen_render(screen);}
static SDL_bool get_preferred_display_bounds(struct size *bounds) {    SDL_Rect rect;#if SDL_VERSION_ATLEAST(2, 0, 5)# define GET_DISPLAY_BOUNDS(i, r) SDL_GetDisplayUsableBounds((i), (r))#else# define GET_DISPLAY_BOUNDS(i, r) SDL_GetDisplayBounds((i), (r))#endif    if (GET_DISPLAY_BOUNDS(0, &rect)) {        LOGW("Could not get display usable bounds: %s", SDL_GetError());        return SDL_FALSE;    }    bounds->width = MAX(0, rect.w - DISPLAY_MARGINS);    bounds->height = MAX(0, rect.h - DISPLAY_MARGINS);    return SDL_TRUE;}
void screencontrol_handle_key(struct controller *controller,                              struct screen *screen,                              const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        switch (keycode) {            case SDLK_h:                action_home(controller);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(controller);                return;            case SDLK_m:                action_app_switch(controller);                return;            case SDLK_p:                action_power(controller);                return;            case SDLK_f:                screen_switch_fullscreen(screen);                return;            case SDLK_x:                screen_resize_to_fit(screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(screen);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
void screencontrol_handle_mouse_motion(struct controller *controller,                                       struct screen *screen,                                       const SDL_MouseMotionEvent *event) {    if (!event->state) {        // do not send motion events when no button is pressed        return;    }    struct control_event control_event;    if (mouse_motion_from_sdl_to_android(event, screen->frame_size, &control_event)) {        if (!controller_push_event(controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse motion event");        }    }}
static void turn_screen_on(struct controller *controller) {    struct control_event control_event = {        .type = CONTROL_EVENT_TYPE_COMMAND,        .command_event = {            .action = CONTROL_EVENT_COMMAND_SCREEN_ON,        },    };    if (!controller_push_event(controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot turn screen on");    }}
void screencontrol_handle_mouse_button(struct controller *controller,                                       struct screen *screen,                                       const SDL_MouseButtonEvent *event) {    if (event->button == SDL_BUTTON_RIGHT && event->type == SDL_MOUSEBUTTONDOWN) {        turn_screen_on(controller);        return;    };    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, screen->frame_size, &control_event)) {        if (!controller_push_event(controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse button event");        }    }}
void screencontrol_handle_mouse_wheel(struct controller *controller,                                      struct screen *screen,                                      const SDL_MouseWheelEvent *event) {    struct position position = {        .screen_size = screen->frame_size,        .point = get_mouse_point(),    };    struct control_event control_event;    if (mouse_wheel_from_sdl_to_android(event, position, &control_event)) {        if (!controller_push_event(controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send wheel button event");        }    }}
void screencontrol_handle_text_input(struct controller *controller,                                     struct screen *screen,                                     const SDL_TextInputEvent *event) {    if (is_ctrl_down()) {        switch (event->text[0]) {            case '+':                action_volume_up(controller);                break;            case '-':                action_volume_down(controller);                break;        }        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    strncpy(control_event.text_event.text, event->text, TEXT_MAX_LENGTH);    control_event.text_event.text[TEXT_MAX_LENGTH] = '\0';    if (!controller_push_event(controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send text event");    }}
static void send_keycode(struct controller *controller, enum android_keycode keycode, const char *name) {    // send DOWN event    struct control_event control_event = {        .type = CONTROL_EVENT_TYPE_KEYCODE,        .keycode_event = {            .action = AKEY_EVENT_ACTION_DOWN,            .keycode = keycode,            .metastate = 0,        },    };    if (!controller_push_event(controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send %s (DOWN)", name);        return;    }    // send UP event    control_event.keycode_event.action = AKEY_EVENT_ACTION_UP;    if (!controller_push_event(controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send %s (UP)", name);    }}
void screencontrol_handle_key(struct controller *controller,                              struct screen *screen,                              const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        switch (keycode) {            case SDLK_h:                action_home(controller);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(controller);                return;            case SDLK_m:                action_app_switch(controller);                return;            case SDLK_p:                action_power(controller);                return;            case SDLK_f:                screen_switch_fullscreen(screen);                return;            case SDLK_x:                screen_resize_to_fit(screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(screen);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
void screencontrol_handle_mouse_motion(struct controller *controller,                                       struct screen *screen,                                       const SDL_MouseMotionEvent *event) {    if (!event->state) {        // do not send motion events when no button is pressed        return;    }    struct control_event control_event;    if (mouse_motion_from_sdl_to_android(event, screen->frame_size, &control_event)) {        if (!controller_push_event(controller, &control_event)) {            LOGW("Cannot send mouse motion event");        }    }}
static void turn_screen_on(struct controller *controller) {    struct control_event control_event = {        .type = CONTROL_EVENT_TYPE_COMMAND,        .command_event = {            .action = CONTROL_EVENT_COMMAND_SCREEN_ON,        },    };    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot turn screen on");    }}
void screencontrol_handle_mouse_button(struct controller *controller,                                       struct screen *screen,                                       const SDL_MouseButtonEvent *event) {    if (event->button == SDL_BUTTON_RIGHT && event->type == SDL_MOUSEBUTTONDOWN) {        turn_screen_on(controller);        return;    };    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, screen->frame_size, &control_event)) {        if (!controller_push_event(controller, &control_event)) {            LOGW("Cannot send mouse button event");        }    }}
void screencontrol_handle_mouse_wheel(struct controller *controller,                                      struct screen *screen,                                      const SDL_MouseWheelEvent *event) {    struct position position = {        .screen_size = screen->frame_size,        .point = get_mouse_point(),    };    struct control_event control_event;    if (mouse_wheel_from_sdl_to_android(event, position, &control_event)) {        if (!controller_push_event(controller, &control_event)) {            LOGW("Cannot send wheel button event");        }    }}
void screencontrol_handle_text_input(struct controller *controller,                                     struct screen *screen,                                     const SDL_TextInputEvent *event) {    if (is_ctrl_down()) {        switch (event->text[0]) {            case '+':                action_volume_up(controller);                break;            case '-':                action_volume_down(controller);                break;        }        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    strncpy(control_event.text_event.text, event->text, TEXT_MAX_LENGTH);    control_event.text_event.text[TEXT_MAX_LENGTH] = '\0';    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot send text event");    }}
static void send_keycode(struct controller *controller, enum android_keycode keycode, const char *name) {    // send DOWN event    struct control_event control_event = {        .type = CONTROL_EVENT_TYPE_KEYCODE,        .keycode_event = {            .action = AKEY_EVENT_ACTION_DOWN,            .keycode = keycode,            .metastate = 0,        },    };    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot send %s (DOWN)", name);        return;    }    // send UP event    control_event.keycode_event.action = AKEY_EVENT_ACTION_UP;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot send %s (UP)", name);    }}
SDL_bool server_start(struct server *server, const char *serial, Uint16 local_port,                      Uint16 max_size, Uint32 bit_rate) {    if (!push_server(serial)) {        return SDL_FALSE;    }    if (!enable_tunnel(serial, local_port)) {        return SDL_FALSE;    }    // At the application level, the device part is "the server" because it    // serves video stream and control. However, at network level, the client    // listens and the server connects to the client. That way, the client can    // listen before starting the server app, so there is no need to try to    // connect until the server socket is listening on the device.    server->server_socket = listen_on_port(local_port);    if (!server->server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not listen on port %" PRIu16, local_port);        disable_tunnel(serial);        return SDL_FALSE;    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate);    if (server->process == PROCESS_NONE) {        SDLNet_TCP_Close(server->server_socket);        disable_tunnel(serial);        return SDL_FALSE;    }    server->adb_reverse_enabled = SDL_TRUE;    return SDL_TRUE;}
static void terminate_server(process_t server) {    if (!cmd_terminate(server)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not terminate server: %s", strerror(errno));    }}
SDL_bool server_start(struct server *server, const char *serial, Uint16 local_port,                      Uint16 max_size, Uint32 bit_rate) {    if (!push_server(serial)) {        return SDL_FALSE;    }    if (!enable_tunnel(serial, local_port)) {        return SDL_FALSE;    }    // At the application level, the device part is "the server" because it    // serves video stream and control. However, at network level, the client    // listens and the server connects to the client. That way, the client can    // listen before starting the server app, so there is no need to try to    // connect until the server socket is listening on the device.    server->server_socket = listen_on_port(local_port);    if (!server->server_socket) {        LOGE("Could not listen on port %" PRIu16, local_port);        disable_tunnel(serial);        return SDL_FALSE;    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate);    if (server->process == PROCESS_NONE) {        SDLNet_TCP_Close(server->server_socket);        disable_tunnel(serial);        return SDL_FALSE;    }    server->adb_reverse_enabled = SDL_TRUE;    return SDL_TRUE;}
static void terminate_server(process_t server) {    if (!cmd_terminate(server)) {        LOGE("Could not terminate server: %s", strerror(errno));    }}
HANDLE cmd_execute(const char *path, const char *const argv[]) {    STARTUPINFO si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    // Windows command-line parsing is WTF:    // <http://daviddeley.com/autohotkey/parameters/parameters.htm#WINPASS>    // only make it work for this very specific program    // (don't handle escaping nor quotes)    char cmd[256];    size_t ret = xstrjoin(cmd, argv, ' ', sizeof(cmd));    if (ret >= sizeof(cmd)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Command too long (%" PRIsizet " chars)", sizeof(cmd) - 1);        return NULL;    }    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {        return NULL;    }    return pi.hProcess;}
HANDLE cmd_execute(const char *path, const char *const argv[]) {    STARTUPINFO si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    // Windows command-line parsing is WTF:    // <http://daviddeley.com/autohotkey/parameters/parameters.htm#WINPASS>    // only make it work for this very specific program    // (don't handle escaping nor quotes)    char cmd[256];    size_t ret = xstrjoin(cmd, argv, ' ', sizeof(cmd));    if (ret >= sizeof(cmd)) {        LOGE("Command too long (%" PRIsizet " chars)", sizeof(cmd) - 1);        return NULL;    }    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {        return NULL;    }    return pi.hProcess;}
SDL_Surface *read_xpm(char *xpm[]) {#if SDL_ASSERT_LEVEL >= 2    // patch the XPM to change the icon color in debug mode    xpm[2] = ".	c #CC00CC";#endif    char *endptr;    // *** No error handling, assume the XPM source is valid ***    // (it's in our source repo)    // Assertions are only checked in debug    Uint32 width = strtol(xpm[0], &endptr, 10);    Uint32 height = strtol(endptr + 1, &endptr, 10);    Uint32 colors = strtol(endptr + 1, &endptr, 10);    Uint32 chars = strtol(endptr + 1, &endptr, 10);    // sanity checks    SDL_assert(width < 256);    SDL_assert(height < 256);    SDL_assert(colors < 256);    SDL_assert(chars == 1); // this implementation does not support more    // init index    struct index index[colors];    for (int i = 0; i < colors; ++i) {        const char *line = xpm[1+i];        index[i].c = line[0];        SDL_assert(line[1] == '\t');        SDL_assert(line[2] == 'c');        SDL_assert(line[3] == ' ');        if (line[4] == '#') {            index[i].color = 0xff000000 | strtol(&line[5], &endptr, 0x10);            SDL_assert(*endptr == '\0');        } else {            SDL_assert(!strcmp("None", &line[4]));            index[i].color = 0;        }    }    // parse image    Uint32 *pixels = SDL_malloc(4 * width * height);    if (!pixels) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not allocate icon memory");        return NULL;    }    for (int y = 0; y < height; ++y) {        const char *line = xpm[1 + colors + y];        for (int x = 0; x < width; ++x) {            char c = line[x];            Uint32 color;            SDL_bool color_found = find_color(index, colors, c, &color);            SDL_assert(color_found);            pixels[y * width + x] = color;        }    }#if SDL_BYTEORDER == SDL_BIG_ENDIAN    Uint32 amask = 0x000000ff;    Uint32 rmask = 0x0000ff00;    Uint32 gmask = 0x00ff0000;    Uint32 bmask = 0xff000000;#else // little endian, like x86    Uint32 amask = 0xff000000;    Uint32 rmask = 0x00ff0000;    Uint32 gmask = 0x0000ff00;    Uint32 bmask = 0x000000ff;#endif    SDL_Surface *surface = SDL_CreateRGBSurfaceFrom(pixels,                                                    width, height,                                                    32, 4 * width,                                                    rmask, gmask, bmask, amask);    // make the surface own the raw pixels    surface->flags &= ~SDL_PREALLOC;    return surface;}
SDL_Surface *read_xpm(char *xpm[]) {#if SDL_ASSERT_LEVEL >= 2    // patch the XPM to change the icon color in debug mode    xpm[2] = ".	c #CC00CC";#endif    char *endptr;    // *** No error handling, assume the XPM source is valid ***    // (it's in our source repo)    // Assertions are only checked in debug    Uint32 width = strtol(xpm[0], &endptr, 10);    Uint32 height = strtol(endptr + 1, &endptr, 10);    Uint32 colors = strtol(endptr + 1, &endptr, 10);    Uint32 chars = strtol(endptr + 1, &endptr, 10);    // sanity checks    SDL_assert(width < 256);    SDL_assert(height < 256);    SDL_assert(colors < 256);    SDL_assert(chars == 1); // this implementation does not support more    // init index    struct index index[colors];    for (int i = 0; i < colors; ++i) {        const char *line = xpm[1+i];        index[i].c = line[0];        SDL_assert(line[1] == '\t');        SDL_assert(line[2] == 'c');        SDL_assert(line[3] == ' ');        if (line[4] == '#') {            index[i].color = 0xff000000 | strtol(&line[5], &endptr, 0x10);            SDL_assert(*endptr == '\0');        } else {            SDL_assert(!strcmp("None", &line[4]));            index[i].color = 0;        }    }    // parse image    Uint32 *pixels = SDL_malloc(4 * width * height);    if (!pixels) {        LOGE("Could not allocate icon memory");        return NULL;    }    for (int y = 0; y < height; ++y) {        const char *line = xpm[1 + colors + y];        for (int x = 0; x < width; ++x) {            char c = line[x];            Uint32 color;            SDL_bool color_found = find_color(index, colors, c, &color);            SDL_assert(color_found);            pixels[y * width + x] = color;        }    }#if SDL_BYTEORDER == SDL_BIG_ENDIAN    Uint32 amask = 0x000000ff;    Uint32 rmask = 0x0000ff00;    Uint32 gmask = 0x00ff0000;    Uint32 bmask = 0xff000000;#else // little endian, like x86    Uint32 amask = 0xff000000;    Uint32 rmask = 0x00ff0000;    Uint32 gmask = 0x0000ff00;    Uint32 bmask = 0x000000ff;#endif    SDL_Surface *surface = SDL_CreateRGBSurfaceFrom(pixels,                                                    width, height,                                                    32, 4 * width,                                                    rmask, gmask, bmask, amask);    // make the surface own the raw pixels    surface->flags &= ~SDL_PREALLOC;    return surface;}
convert_mouse_wheel(const SDL_MouseWheelEvent *from, struct screen *screen,                    struct control_msg *to) {    struct position position = {        .screen_size = screen->frame_size,        .point = get_mouse_point(screen),    };    to->type = CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT;    to->inject_scroll_event.position = position;    int mul = from->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    // SDL behavior seems inconsistent between horizontal and vertical scrolling    // so reverse the horizontal    // <https://wiki.libsdl.org/SDL_MouseWheelEvent#Remarks>    to->inject_scroll_event.hscroll = -mul * from->x;    to->inject_scroll_event.vscroll = mul * from->y;    return true;}
convert_mouse_wheel(const SDL_MouseWheelEvent *from, struct screen *screen,                    struct control_msg *to) {    struct position position = {        .screen_size = screen->frame_size,        .point = get_mouse_point(screen),    };    to->type = CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT;    to->inject_scroll_event.position = position;    to->inject_scroll_event.hscroll = from->x;    to->inject_scroll_event.vscroll = from->y;    return true;}
    private void writeFrameMeta(FileDescriptor fd, MediaCodec.BufferInfo bufferInfo, int packetSize) throws IOException {        headerBuffer.clear();        long pts;        if ((bufferInfo.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {            pts = 0; // non-media data packet        } else {            if (ptsOrigin == 0) {                ptsOrigin = bufferInfo.presentationTimeUs;            }            pts = bufferInfo.presentationTimeUs - ptsOrigin;        }        headerBuffer.putLong(pts);        headerBuffer.putInt(packetSize);        headerBuffer.flip();        IO.writeFully(fd, headerBuffer);    }
    private void writeFrameMeta(FileDescriptor fd, MediaCodec.BufferInfo bufferInfo, int packetSize) throws IOException {        headerBuffer.clear();        long pts;        if ((bufferInfo.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {            pts = NO_PTS; // non-media data packet        } else {            if (ptsOrigin == 0) {                ptsOrigin = bufferInfo.presentationTimeUs;            }            pts = bufferInfo.presentationTimeUs - ptsOrigin;        }        headerBuffer.putLong(pts);        headerBuffer.putInt(packetSize);        headerBuffer.flip();        IO.writeFully(fd, headerBuffer);    }
    public Point getPhysicalPoint(Position position) {        ScreenInfo screenInfo = getScreenInfo(); // read with synchronization        Size videoSize = screenInfo.getVideoSize();        Size clientVideoSize = position.getScreenSize();        if (!videoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event            return null;        }        Size deviceSize = screenInfo.getDeviceSize();        int xPadding = screenInfo.getXPadding();        int yPadding = screenInfo.getYPadding();        int contentWidth = videoSize.getWidth() - xPadding;        int contentHeight = videoSize.getHeight() - yPadding;        Point point = position.getPoint();        int x = point.getX() - xPadding / 2;        int y = point.getY() - yPadding / 2;        if (x < 0 || x >= contentWidth || y < 0 || y >= contentHeight) {            // out of screen            return null;        }        int scaledX = x * deviceSize.getWidth() / videoSize.getWidth();        int scaledY = y * deviceSize.getHeight() / videoSize.getHeight();        return new Point(scaledX, scaledY);    }
    public Point getPhysicalPoint(Position position) {        ScreenInfo screenInfo = getScreenInfo(); // read with synchronization        Size videoSize = screenInfo.getVideoSize();        Size clientVideoSize = position.getScreenSize();        if (!videoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event            return null;        }        Size deviceSize = screenInfo.getDeviceSize();        int xPadding = screenInfo.getXPadding();        int yPadding = screenInfo.getYPadding();        int contentWidth = videoSize.getWidth() - xPadding;        int contentHeight = videoSize.getHeight() - yPadding;        Point point = position.getPoint();        int x = point.x - xPadding / 2;        int y = point.y - yPadding / 2;        if (x < 0 || x >= contentWidth || y < 0 || y >= contentHeight) {            // out of screen            return null;        }        int scaledX = x * deviceSize.getWidth() / videoSize.getWidth();        int scaledY = y * deviceSize.getHeight() / videoSize.getHeight();        return new Point(scaledX, scaledY);    }
    private void setPointerCoords(Point point) {        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.x = point.getX();        coords.y = point.getY();    }
    private void setPointerCoords(Point point) {        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.x = point.x;        coords.y = point.y;    }
static void handle_shortcut(char c) {    switch (c) {        case 'h':            send_keycode(AKEYCODE_HOME, "HOME");            break;        case 'b':            send_keycode(AKEYCODE_BACK, "BACK");            break;        case 'm':            send_keycode(AKEYCODE_APP_SWITCH, "APP_SWITCH");            break;        case 'p':            send_keycode(AKEYCODE_POWER, "POWER");            break;        case '+':            send_keycode(AKEYCODE_VOLUME_UP, "VOLUME_UP");            break;        case '-':            send_keycode(AKEYCODE_VOLUME_DOWN, "VOLUME_DOWN");            break;        case 'f':            switch_fullscreen();            break;        case 'x':            resize_to_fit();            break;        case 'g':            resize_to_pixel_perfect();            break;    }}
static void handle_shortcut(char c) {    switch (c) {        case 'h':            send_keycode(AKEYCODE_HOME, "HOME");            break;        case 'b':            send_keycode(AKEYCODE_BACK, "BACK");            break;        case 'm':            send_keycode(AKEYCODE_APP_SWITCH, "APP_SWITCH");            break;        case 'p':            send_keycode(AKEYCODE_POWER, "POWER");            break;        case '+':            send_keycode(AKEYCODE_VOLUME_UP, "VOLUME_UP");            break;        case '-':            send_keycode(AKEYCODE_VOLUME_DOWN, "VOLUME_DOWN");            break;        case 'f':            switch_fullscreen();            break;        case 'x':            resize_to_fit();            break;        case 'g':            resize_to_pixel_perfect();            break;    }}
static void handle_shortcut(char c) {    switch (c) {        case 'h':            send_keycode(AKEYCODE_HOME, "HOME");            break;        case 'b':            send_keycode(AKEYCODE_BACK, "BACK");            break;        case 'm':            send_keycode(AKEYCODE_APP_SWITCH, "APP_SWITCH");            break;        case 'p':            send_keycode(AKEYCODE_POWER, "POWER");            break;        case '+':            send_keycode(AKEYCODE_VOLUME_UP, "VOLUME_UP");            break;        case '-':            send_keycode(AKEYCODE_VOLUME_DOWN, "VOLUME_DOWN");            break;        case 'f':            switch_fullscreen();            break;        case 'x':            resize_to_fit();            break;        case 'g':            resize_to_pixel_perfect();            break;    }}
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        switch (keycode) {            case SDLK_f:                handle_shortcut('f');                return;            case SDLK_x:                handle_shortcut('x');                return;            case SDLK_g:                handle_shortcut('g');                return;            case SDLK_h:                handle_shortcut('h');                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                handle_shortcut('b');                return;            case SDLK_m:                handle_shortcut('m');                return;            case SDLK_p:                handle_shortcut('p');                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        switch (keycode) {            case SDLK_f:                handle_shortcut('f');                return;            case SDLK_x:                handle_shortcut('x');                return;            case SDLK_g:                handle_shortcut('g');                return;            case SDLK_h:                handle_shortcut('h');                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                handle_shortcut('b');                return;            case SDLK_m:                handle_shortcut('m');                return;            case SDLK_p:                handle_shortcut('p');                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
static void handle_text_input(const SDL_TextInputEvent *event) {    if (is_ctrl_down()) {        handle_shortcut(event->text[0]);        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    strncpy(control_event.text_event.text, event->text, TEXT_MAX_LENGTH);    control_event.text_event.text[TEXT_MAX_LENGTH] = '\0';    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send text event");    }}
static void handle_text_input(const SDL_TextInputEvent *event) {    if (is_ctrl_down()) {        handle_shortcut(event->text[0]);        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    strncpy(control_event.text_event.text, event->text, TEXT_MAX_LENGTH);    control_event.text_event.text[TEXT_MAX_LENGTH] = '\0';    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send text event");    }}
static void handle_text_input(const SDL_TextInputEvent *event) {    if (is_ctrl_down()) {        handle_shortcut(event->text[0]);        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    strncpy(control_event.text_event.text, event->text, TEXT_MAX_LENGTH);    control_event.text_event.text[TEXT_MAX_LENGTH] = '\0';    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send text event");    }}
static void handle_text_input(const SDL_TextInputEvent *event) {    if (is_ctrl_down()) {        handle_shortcut(event->text[0]);        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    strncpy(control_event.text_event.text, event->text, TEXT_MAX_LENGTH);    control_event.text_event.text[TEXT_MAX_LENGTH] = '\0';    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send text event");    }}
    frames.rendering_frame_consumed = SDL_TRUE;    if (!decoder.skip_frames) {        cond_signal(frames.rendering_frame_consumed_cond);    }    struct size current_frame_size = {frame->width, frame->height};    if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {        return SDL_FALSE;    }    frame_size = current_frame_size;    update_texture(frame, texture);    mutex_unlock(frames.mutex);    render(renderer, texture);    return SDL_TRUE;}static SDL_bool is_ctrl_down(void) {    const Uint8 *state = SDL_GetKeyboardState(NULL);    return state[SDL_SCANCODE_LCTRL] || state[SDL_SCANCODE_RCTRL];}static void handle_text_input(const SDL_TextInputEvent *event) {    if (is_ctrl_down()) {        switch (event->text[0]) {            case '+':                action_volume_up();                break;            case '-':                action_volume_down();
static inline void action_app_switch(void) {    send_keycode(AKEYCODE_APP_SWITCH, "APP_SWITCH");}
static inline void action_back(void) {    send_keycode(AKEYCODE_BACK, "BACK");}
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        switch (keycode) {            case SDLK_h:                action_home();                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back();                return;            case SDLK_m:                action_app_switch();                return;            case SDLK_p:                action_power();                return;            case SDLK_f:                switch_fullscreen();                return;            case SDLK_x:                resize_to_fit();                return;            case SDLK_g:                resize_to_pixel_perfect();                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
static inline void action_volume_down(void) {    send_keycode(AKEYCODE_VOLUME_DOWN, "VOLUME_DOWN");}
static void handle_text_input(const SDL_TextInputEvent *event) {    if (is_ctrl_down()) {        switch (event->text[0]) {            case '+':                action_volume_up();                break;            case '-':                action_volume_down();                break;        }        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    strncpy(control_event.text_event.text, event->text, TEXT_MAX_LENGTH);    control_event.text_event.text[TEXT_MAX_LENGTH] = '\0';    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send text event");    }}
static inline void action_power(void) {    send_keycode(AKEYCODE_POWER, "POWER");}
static inline void action_home(void) {    send_keycode(AKEYCODE_HOME, "HOME");}
static inline void action_volume_up(void) {    send_keycode(AKEYCODE_VOLUME_UP, "VOLUME_UP");}
pid_t cmd_execute(const char *path, const char *const argv[]) {    pid_t pid = fork();    if (pid == -1) {        perror("fork");        return -1;    }    if (pid == 0) {        execvp(path, (char *const *)argv);        perror("exec");        exit(1);    }    return pid;}
pid_t cmd_execute(const char *path, const char *const argv[]) {    pid_t pid = fork();    if (pid == -1) {        perror("fork");        return -1;    }    if (pid == 0) {        execvp(path, (char *const *)argv);        perror("exec");        _exit(1);    }    return pid;}
static inline void write32(Uint8 *buf, Uint32 value) {    buf[0] = value >> 24;    buf[1] = value >> 16;    buf[2] = value >> 8;    buf[3] = value;}
static inline void write16(Uint8 *buf, Uint16 value) {    buf[0] = value >> 8;    buf[1] = value;}
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            write32(&buf[2], event->keycode_event.keycode);            write32(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (1 byte) + date (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > TEXT_MAX_LENGTH) {                // injecting a text takes time, so limit the text length                len = TEXT_MAX_LENGTH;            }            write16(&buf[1], (Uint16) len);            memcpy(&buf[3], event->text_event.text, len);            return 3 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            write32(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 14;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            write32(&buf[9], (Uint32) event->scroll_event.hscroll);            write32(&buf[13], (Uint32) event->scroll_event.vscroll);            return 17;        case CONTROL_EVENT_TYPE_COMMAND:            buf[1] = event->command_event.action;            return 2;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
static void write_position(Uint8 *buf, const struct position *position) {    write16(&buf[0], position->point.x);    write16(&buf[2], position->point.y);    write16(&buf[4], position->screen_size.width);    write16(&buf[6], position->screen_size.height);}
    buffer_write16be(&buf[6], position->screen_size.height);}int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:
static void write_position(Uint8 *buf, const struct position *position) {    buffer_write16be(&buf[0], position->point.x);    buffer_write16be(&buf[2], position->point.y);    buffer_write16be(&buf[4], position->screen_size.width);
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            buffer_write32be(&buf[2], event->keycode_event.keycode);            buffer_write32be(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (1 byte) + date (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > TEXT_MAX_LENGTH) {                // injecting a text takes time, so limit the text length                len = TEXT_MAX_LENGTH;            }            buffer_write16be(&buf[1], (Uint16) len);            memcpy(&buf[3], event->text_event.text, len);            return 3 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            buffer_write32be(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 14;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            buffer_write32be(&buf[9], (Uint32) event->scroll_event.hscroll);            buffer_write32be(&buf[13], (Uint32) event->scroll_event.vscroll);            return 17;        case CONTROL_EVENT_TYPE_COMMAND:            buf[1] = event->command_event.action;            return 2;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
static void write_position(Uint8 *buf, const struct position *position) {    buffer_write16be(&buf[0], position->point.x);    buffer_write16be(&buf[2], position->point.y);    buffer_write16be(&buf[4], position->screen_size.width);    buffer_write16be(&buf[6], position->screen_size.height);}
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            write32(&buf[2], event->keycode_event.keycode);            write32(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (1 byte) + date (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > TEXT_MAX_LENGTH) {                // injecting a text takes time, so limit the text length                len = TEXT_MAX_LENGTH;            }            buf[1] = (Uint8) len;            memcpy(&buf[2], event->text_event.text, len);            return 2 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            write32(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 14;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            write32(&buf[9], (Uint32) event->scroll_event.hscroll);            write32(&buf[13], (Uint32) event->scroll_event.vscroll);            return 17;        case CONTROL_EVENT_TYPE_COMMAND:            buf[1] = event->command_event.action;            return 2;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            write32(&buf[2], event->keycode_event.keycode);            write32(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (1 byte) + date (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > TEXT_MAX_LENGTH) {                // injecting a text takes time, so limit the text length                len = TEXT_MAX_LENGTH;            }            write16(&buf[1], (Uint16) len);            memcpy(&buf[3], event->text_event.text, len);            return 3 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            write32(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 14;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            write32(&buf[9], (Uint32) event->scroll_event.hscroll);            write32(&buf[13], (Uint32) event->scroll_event.vscroll);            return 17;        case CONTROL_EVENT_TYPE_COMMAND:            buf[1] = event->command_event.action;            return 2;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
static void test_serialize_text_event() {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_TEXT,        .text_event = {            .text = "hello, world!",        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 15);    const unsigned char expected[] = {        0x01, // CONTROL_EVENT_TYPE_KEYCODE        0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}static void test_serialize_mouse_event() {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_MOUSE,        .mouse_event = {            .action = AMOTION_EVENT_ACTION_DOWN,            .buttons = AMOTION_EVENT_BUTTON_PRIMARY,            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },        },
int main() {    test_serialize_keycode_event();    test_serialize_text_event();    test_serialize_mouse_event();    test_serialize_scroll_event();    return 0;}
static void test_serialize_text_event() {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_TEXT,        .text_event = {            .text = "hello, world!",        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 15);    const unsigned char expected[] = {        0x01, // CONTROL_EVENT_TYPE_KEYCODE        0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_long_text_event() {    struct control_event event;    event.type = CONTROL_EVENT_TYPE_TEXT;    char text[TEXT_MAX_LENGTH];    memset(text, 'a', sizeof(text));    event.text_event.text = text;    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 3 + sizeof(text));    unsigned char expected[3 + TEXT_MAX_LENGTH];    expected[0] = 0x01; // CONTROL_EVENT_TYPE_KEYCODE    expected[1] = 0x01;    expected[2] = 0x2c; // text length (16 bits)    memset(&expected[3], 'a', TEXT_MAX_LENGTH);    assert(!memcmp(buf, expected, sizeof(expected)));}
int main() {    test_serialize_keycode_event();    test_serialize_text_event();    test_serialize_long_text_event();    test_serialize_mouse_event();    test_serialize_scroll_event();    return 0;}
static void test_serialize_text_event() {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_TEXT,        .text_event = {            .text = "hello, world!",        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 16);    const unsigned char expected[] = {        0x01, // CONTROL_EVENT_TYPE_KEYCODE        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
    private ControlEvent parseTextControlEvent() {        if (buffer.remaining() < 1) {            return null;        }        int len = toUnsigned(buffer.get());        if (buffer.remaining() < len) {            return null;        }        buffer.get(textBuffer, 0, len);        String text = new String(textBuffer, 0, len, StandardCharsets.UTF_8);        return ControlEvent.createTextControlEvent(text);    }
    private ControlEvent parseTextControlEvent() {        if (buffer.remaining() < 1) {            return null;        }        int len = toUnsigned(buffer.getShort());        if (buffer.remaining() < len) {            return null;        }        buffer.get(textBuffer, 0, len);        String text = new String(textBuffer, 0, len, StandardCharsets.UTF_8);        return ControlEvent.createTextControlEvent(text);    }
    public void testParseTextEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_TEXT);        byte[] text = "testé".getBytes(StandardCharsets.UTF_8);        dos.writeByte(text.length);        dos.write("testé".getBytes(StandardCharsets.UTF_8));        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_TEXT, event.getType());        Assert.assertEquals("testé", event.getText());    }
    public void testParseTextEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_TEXT);        byte[] text = "testé".getBytes(StandardCharsets.UTF_8);        dos.writeByte(text.length);        dos.write("testé".getBytes(StandardCharsets.UTF_8));        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_TEXT, event.getType());        Assert.assertEquals("testé", event.getText());    }
    public void testParseTextEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_TEXT);        byte[] text = "testé".getBytes(StandardCharsets.UTF_8);        dos.writeShort(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_TEXT, event.getType());        Assert.assertEquals("testé", event.getText());    }
    public void testParseLongTextEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_TEXT);        byte[] text = new byte[ControlEventReader.TEXT_MAX_LENGTH];        Arrays.fill(text, (byte) 'a');        dos.writeShort(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_TEXT, event.getType());        Assert.assertEquals(new String(text, StandardCharsets.US_ASCII), event.getText());    }
event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        enum event_result result = handle_event(&event);        switch (result) {            case EVENT_RESULT_STOPPED_BY_USER:                return SDL_TRUE;            case EVENT_RESULT_STOPPED_BY_EOS:                return SDL_FALSE;            case EVENT_RESULT_CONTINUE:                break;        }    }    return SDL_FALSE;}
event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        enum event_result result = handle_event(&event);        switch (result) {            case EVENT_RESULT_STOPPED_BY_USER:                return SDL_TRUE;            case EVENT_RESULT_STOPPED_BY_EOS:                return SDL_FALSE;            case EVENT_RESULT_CONTINUE:                break;        }    }    return SDL_FALSE;}
scrcpy(const struct scrcpy_options *options) {    SDL_bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    SDL_bool display = !options->no_window;    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            server_stop(&server);            ret = SDL_FALSE;            goto finally_destroy_server;        }        if (!file_handler_init(&file_handler, server.serial)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_video_buffer;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (display) {        if (!controller_init(&controller, device_socket)) {            ret = SDL_FALSE;            goto finally_stop_stream;        }        if (!controller_start(&controller)) {            ret = SDL_FALSE;            goto finally_destroy_controller;        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            ret = SDL_FALSE;            goto finally_stop_and_join_controller;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    if (display) {        controller_stop(&controller);        controller_join(&controller);    }finally_destroy_controller:    if (display) {        controller_destroy(&controller);    }finally_stop_stream:    stream_stop(&stream);    // stop the server before stream_join() to wake up the stream    server_stop(&server);    stream_join(&stream);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    if (display) {        file_handler_stop(&file_handler);        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }finally_destroy_video_buffer:    if (display) {        video_buffer_destroy(&video_buffer);    }finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial,                                                     SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
event_loop(SDL_bool display) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    if (display) {        SDL_AddEventWatch(event_watcher, NULL);    }#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        enum event_result result = handle_event(&event);        switch (result) {            case EVENT_RESULT_STOPPED_BY_USER:                return SDL_TRUE;            case EVENT_RESULT_STOPPED_BY_EOS:                return SDL_FALSE;            case EVENT_RESULT_CONTINUE:                break;        }    }    return SDL_FALSE;}
event_loop(SDL_bool display) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    if (display) {        SDL_AddEventWatch(event_watcher, NULL);    }#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        enum event_result result = handle_event(&event);        switch (result) {            case EVENT_RESULT_STOPPED_BY_USER:                return SDL_TRUE;            case EVENT_RESULT_STOPPED_BY_EOS:                return SDL_FALSE;            case EVENT_RESULT_CONTINUE:                break;        }    }    return SDL_FALSE;
scrcpy(const struct scrcpy_options *options) {    SDL_bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    SDL_bool display = !options->no_window;    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            server_stop(&server);            ret = SDL_FALSE;            goto finally_destroy_server;        }        if (!file_handler_init(&file_handler, server.serial)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_video_buffer;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (display) {        if (!controller_init(&controller, device_socket)) {            ret = SDL_FALSE;            goto finally_stop_stream;        }        if (!controller_start(&controller)) {            ret = SDL_FALSE;            goto finally_destroy_controller;        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            ret = SDL_FALSE;            goto finally_stop_and_join_controller;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    ret = event_loop(display);    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    if (display) {        controller_stop(&controller);        controller_join(&controller);    }finally_destroy_controller:    if (display) {        controller_destroy(&controller);    }finally_stop_stream:    stream_stop(&stream);    // stop the server before stream_join() to wake up the stream    server_stop(&server);    stream_join(&stream);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    if (display) {        file_handler_stop(&file_handler);        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }finally_destroy_video_buffer:    if (display) {        video_buffer_destroy(&video_buffer);    }finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial,                                                     SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet) && !avio_ctx->eof_reached) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57, 37, 0)        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#else        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        if ((ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame)) < 0) {            LOGE("Could not receive video frame: %d", ret);            goto run_quit;        }        push_frame(decoder);#endif    }    LOGD("End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet) && !avio_ctx->eof_reached) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        if ((ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame)) < 0) {            LOGE("Could not receive video frame: %d", ret);            goto run_quit;        }        push_frame(decoder);#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif    }    LOGD("End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
    public static void main(String... args) throws Exception {        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {            @Override            public void uncaughtException(Thread t, Throwable e) {                Ln.e("Exception on thread " + t, e);            }        });        Options options = createOptions(args);        scrcpy(options);    }}
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        try (DesktopConnection connection = DesktopConnection.open(device)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getBitRate());            // asynchronous            startEventController(device, connection);            try {                // synchronous                screenEncoder.streamScreen(device, connection.getOutputStream());            } catch (IOException e) {                Ln.e("Screen streaming interrupted", e);            }        }    }
    private static void startEventController(final Device device, final DesktopConnection connection) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    new EventController(device, connection).control();                } catch (IOException e) {                    Ln.e("Exception from event controller", e);                }            }        }).start();    }
    public static void main(String... args) throws Exception {        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {            @Override            public void uncaughtException(Thread t, Throwable e) {                if (e instanceof AssertionError && e.getCause() instanceof InvocationTargetException) {                    // WORKAROUND                    // When we call a method of the framework by reflection, it may throw an InvocationTargetException                    // (that we wrap into an AssertionError) if this process is being killed.                    // To avoid the stacktrace on close, do not log these errors.                    return;                }                Ln.e("Exception on thread " + t, e);            }        });        Options options = createOptions(args);        scrcpy(options);    }}
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        try (DesktopConnection connection = DesktopConnection.open(device)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getBitRate());            // asynchronous            startEventController(device, connection);            try {                // synchronous                screenEncoder.streamScreen(device, connection.getOutputStream());            } catch (IOException e) {                Ln.w("Screen streaming stopped");            }        }    }
    private static void startEventController(final Device device, final DesktopConnection connection) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    new EventController(device, connection).control();                } catch (IOException e) {                    Ln.w("Event controller stopped");                }            }        }).start();    }
static int read_packet_with_meta(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    struct receiver_state *state = &decoder->receiver_state;    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    if (!state->remaining) {        // the next PTS is now for the current frame        state->pts = state->next_pts;#define HEADER_SIZE 12        uint8_t header[HEADER_SIZE];        ssize_t ret = net_recv_all(decoder->video_socket, header, HEADER_SIZE);        if (ret <= 0) {            return ret;        }        // no partial read (net_recv_all())        SDL_assert_release(ret == HEADER_SIZE);        state->next_pts = buffer_read64be(header);        state->remaining = buffer_read32be(&header[8]);    }    SDL_assert(state->remaining);    if (buf_size > state->remaining)        buf_size = state->remaining;    ssize_t ret = net_recv(decoder->video_socket, buf, buf_size);    if (ret <= 0) {        return ret;    }    SDL_assert(state->remaining >= ret);    state->remaining -= ret;    return ret;}
static int read_packet_with_meta(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    struct receiver_state *state = &decoder->receiver_state;    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    if (!state->remaining) {        // the next PTS is now for the current frame        state->pts = state->next_pts;#define HEADER_SIZE 12        uint8_t header[HEADER_SIZE];        ssize_t ret = net_recv_all(decoder->video_socket, header, HEADER_SIZE);        if (ret <= 0) {            return ret;        }        // no partial read (net_recv_all())        SDL_assert_release(ret == HEADER_SIZE);        state->next_pts = buffer_read64be(header);        state->remaining = buffer_read32be(&header[8]);    }    SDL_assert(state->remaining);    if (buf_size > state->remaining)        buf_size = state->remaining;    ssize_t ret = net_recv(decoder->video_socket, buf, buf_size);    if (ret <= 0) {        return ret;    }    SDL_assert(state->remaining >= ret);    state->remaining -= ret;    return ret;}
static int read_packet_with_meta(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    struct receiver_state *state = &decoder->receiver_state;    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    if (!state->remaining) {        // the next PTS is now for the current frame        state->pts = state->next_pts;#define HEADER_SIZE 12        uint8_t header[HEADER_SIZE];        ssize_t ret = net_recv_all(decoder->video_socket, header, HEADER_SIZE);        if (ret <= 0) {            return ret;        }        // no partial read (net_recv_all())        SDL_assert_release(ret == HEADER_SIZE);        state->next_pts = buffer_read64be(header);        state->remaining = buffer_read32be(&header[8]);    }    SDL_assert(state->remaining);    if (buf_size > state->remaining)        buf_size = state->remaining;    ssize_t ret = net_recv(decoder->video_socket, buf, buf_size);    if (ret <= 0) {        return ret;    }    SDL_assert(state->remaining >= ret);    state->remaining -= ret;    return ret;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    // initialize the receiver state    decoder->receiver_state.remaining = 0;    // if recording is enabled, a "header" is sent between raw packets    int (*read_packet)(void *, uint8_t *, int) =            decoder->recorder ? read_packet_with_meta : read_raw_packet;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder,                                               read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        if (decoder->recorder) {            packet.pts = decoder->receiver_state.pts;            packet.dts = decoder->receiver_state.pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(decoder->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto run_quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    // initialize the receiver state    decoder->receiver_state.remaining = 0;    // if recording is enabled, a "header" is sent between raw packets    int (*read_packet)(void *, uint8_t *, int) =            decoder->recorder ? read_packet_with_meta : read_raw_packet;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder,                                               read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        if (decoder->recorder) {            packet.pts = decoder->receiver_state.pts;            packet.dts = decoder->receiver_state.pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(decoder->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto run_quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    // initialize the receiver state    decoder->receiver_state.remaining = 0;    // if recording is enabled, a "header" is sent between raw packets    int (*read_packet)(void *, uint8_t *, int) =            decoder->recorder ? read_packet_with_meta : read_raw_packet;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder,                                               read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        if (decoder->recorder) {            packet.pts = decoder->receiver_state.pts;            packet.dts = decoder->receiver_state.pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(decoder->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto run_quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static int read_packet_with_meta(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    struct receiver_state *state = &decoder->receiver_state;    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    if (!state->remaining) {#define HEADER_SIZE 12        uint8_t header[HEADER_SIZE];        ssize_t ret = net_recv_all(decoder->video_socket, header, HEADER_SIZE);        if (ret <= 0) {            return ret;        }        // no partial read (net_recv_all())        SDL_assert_release(ret == HEADER_SIZE);        uint64_t pts = buffer_read64be(header);        state->remaining = buffer_read32be(&header[8]);        if (!receiver_state_push_meta(state, pts)) {            LOGE("Could not store PTS for recording");            // we cannot save the PTS, the recording would be broken            return -1;        }    }    SDL_assert(state->remaining);    if (buf_size > state->remaining)        buf_size = state->remaining;    ssize_t ret = net_recv(decoder->video_socket, buf, buf_size);    if (ret <= 0) {        return ret;    }    SDL_assert(state->remaining >= ret);    state->remaining -= ret;    return ret;}
static SDL_bool receiver_state_push_meta(struct receiver_state *state,                                         uint64_t pts) {    struct frame_meta *frame_meta = frame_meta_new(pts);    if (!frame_meta) {        return SDL_FALSE;    }    // append to the list    // (iterate to find the last item, in practice the list should be tiny)    struct frame_meta **p = &state->frame_meta_queue;    while (*p) {        p = &(*p)->next;    }    *p = frame_meta;    return SDL_TRUE;}
static uint64_t receiver_state_take_meta(struct receiver_state *state) {    struct frame_meta *frame_meta = state->frame_meta_queue; // first item    SDL_assert(frame_meta); // must not be empty    uint64_t pts = frame_meta->pts;    state->frame_meta_queue = frame_meta->next; // remove the item    frame_meta_delete(frame_meta);    return pts;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    // initialize the receiver state    decoder->receiver_state.frame_meta_queue = NULL;    decoder->receiver_state.remaining = 0;    // if recording is enabled, a "header" is sent between raw packets    int (*read_packet)(void *, uint8_t *, int) =            decoder->recorder ? read_packet_with_meta : read_raw_packet;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder,                                               read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        if (decoder->recorder) {            // we retrieve the PTS in order they were received, so they will            // be assigned to the correct frame            uint64_t pts = receiver_state_take_meta(&decoder->receiver_state);            packet.pts = pts;            packet.dts = pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(decoder->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto run_quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static void frame_meta_delete(struct frame_meta *frame_meta) {    free(frame_meta);}
static struct frame_meta *frame_meta_new(uint64_t pts) {    struct frame_meta *meta = malloc(sizeof(*meta));    if (!meta) {        return meta;    }    meta->pts = pts;    meta->next = NULL;    return meta;}
process_t adb_push(const char *serial, const char *local, const char *remote) {    const char *const adb_cmd[] = {"push", (char *) local, (char *) remote};    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
process_t adb_push(const char *serial, const char *local, const char *remote) {    const char *const adb_cmd[] = {"push", local, remote};    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
TCPsocket blocking_accept(TCPsocket server_socket) {    SDLNet_SocketSet set = SDLNet_AllocSocketSet(1);    if (!set) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not allocate socket set");        return NULL;    }    if (SDLNet_TCP_AddSocket(set, server_socket) == -1) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not add socket to set");        SDLNet_FreeSocketSet(set);        return NULL;    }    // timeout is (2^32-1) milliseconds, this should be sufficient    if (SDLNet_CheckSockets(set, -1) != 1) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not check socket: %s", SDL_GetError());        SDLNet_FreeSocketSet(set);        return NULL;    }    SDLNet_FreeSocketSet(set);    return SDLNet_TCP_Accept(server_socket);}
TCPsocket server_socket_accept(TCPsocket server_socket) {    SDLNet_SocketSet set = SDLNet_AllocSocketSet(1);    if (!set) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not allocate socket set");        return NULL;    }    if (SDLNet_TCP_AddSocket(set, server_socket) == -1) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not add socket to set");        SDLNet_FreeSocketSet(set);        return NULL;    }    // timeout is (2^32-1) milliseconds, this should be sufficient    if (SDLNet_CheckSockets(set, -1) != 1) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not check socket");        SDLNet_FreeSocketSet(set);        return NULL;    }    SDLNet_FreeSocketSet(set);    return SDLNet_TCP_Accept(server_socket);}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    SDL_bool ret = SDL_TRUE;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, max_size, bit_rate);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto finally_destroy_controller;    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // let the server some time to print any exception trace before killing it    struct timespec timespec = {        .tv_sec = 0,        .tv_nsec = 100000000, // 100ms    };    nanosleep(&timespec, NULL); // ignore error    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
static TCPsocket listen_on_port(Uint16 port) {    IPaddress addr = {        .host = INADDR_ANY,        .port = SDL_SwapBE16(port),    };    return SDLNet_TCP_Open(&addr);}
static int wait_for_success(process_t proc, const char *name) {    if (proc == PROCESS_NONE) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not execute \"%s\"", name);        return -1;    }    exit_code_t exit_code;    if (!cmd_simple_wait(proc, &exit_code)) {        if (exit_code != NO_EXIT_CODE) {            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "\"%s\" returned with value %" PRIexitcode, name, exit_code);        } else {            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "\"%s\" exited unexpectedly", name);        }        return -1;    }    return 0;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = server_connect_to(&server);    if (!device_socket) {        server_stop(&server, serial);        return SDL_FALSE;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        server_stop(&server, serial);        return SDL_FALSE;    }    if (!frames_init(&frames)) {        server_stop(&server, serial);        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    decoder.frames = &frames;    decoder.video_socket = device_socket;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server, serial);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    // kill the server before decoder_join() to wake up the decoder    server_stop(&server, serial);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);    return ret;}
// name must be at least DEVICE_NAME_FIELD_LENGTH bytesstatic SDL_bool read_initial_device_info(TCPsocket socket, char *device_name, struct size *size) {    unsigned char buf[DEVICE_NAME_FIELD_LENGTH + 4];    if (SDLNet_TCP_Recv(socket, buf, sizeof(buf)) <= 0) {        return SDL_FALSE;    }    buf[DEVICE_NAME_FIELD_LENGTH - 1] = '\0'; // in case the client sends garbage
            .metastate = 0,        },    };    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send %s (DOWN)", name);        return;    }    // send UP event    control_event.keycode_event.action = AKEY_EVENT_ACTION_UP;    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send %s (UP)", name);    }}static inline void action_home(void) {
void stop_server(process_t server) {    if (!cmd_terminate(server)) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not terminate server: %s", strerror(errno));    }}
void stop_server(process_t server) {    if (!cmd_terminate(server)) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not terminate server: %s", strerror(errno));    }}
void stop_server(process_t server) {    if (!cmd_terminate(server)) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not terminate server: %s", strerror(errno));    }}
process_t disable_tunnel(const char *serial) {    return adb_reverse_remove(serial, SOCKET_NAME);}
process_t disable_tunnel(const char *serial) {    return adb_reverse_remove(serial, SOCKET_NAME);}
process_t disable_tunnel(const char *serial) {    return adb_reverse_remove(serial, SOCKET_NAME);}
process_t start_server(const char *serial, Uint16 max_size, Uint32 bit_rate) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.ScrCpyServer",        max_size_string,        bit_rate_string,    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
process_t start_server(const char *serial, Uint16 max_size, Uint32 bit_rate) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.ScrCpyServer",        max_size_string,        bit_rate_string,    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
process_t start_server(const char *serial, Uint16 max_size, Uint32 bit_rate) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.ScrCpyServer",        max_size_string,        bit_rate_string,    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
process_t start_server(const char *serial, Uint16 max_size, Uint32 bit_rate) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.ScrCpyServer",        max_size_string,        bit_rate_string,    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
process_t push_server(const char *serial) {    const char *server_path = getenv("SCRCPY_SERVER_JAR");    if (!server_path) {        server_path = "scrcpy-server.jar";    }    return adb_push(serial, server_path, "/data/local/tmp/scrcpy-server.jar");}
process_t enable_tunnel(const char *serial, Uint16 local_port) {    return adb_reverse(serial, SOCKET_NAME, local_port);}
        max_size_string,        bit_rate_string,    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
static TCPsocket listen_on_port(Uint16 port) {    IPaddress addr = {        .host = INADDR_ANY,        .port = SDL_SwapBE16(port),    };    return SDLNet_TCP_Open(&addr);}
SDL_bool server_start(struct server *server, const char *serial, Uint16 local_port,                      Uint16 max_size, Uint32 bit_rate) {    if (!push_server(serial)) {        return SDL_FALSE;    }    if (!enable_tunnel(serial, local_port)) {        return SDL_FALSE;    }    // At the application level, the device part is "the server" because it    // serves video stream and control. However, at network level, the client    // listens and the server connects to the client. That way, the client can    // listen before starting the server app, so there is no need to try to    // connect until the server socket is listening on the device.    server->server_socket = listen_on_port(local_port);    if (!server->server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not listen on port %" PRIu16, local_port);        disable_tunnel(serial);        return SDL_FALSE;    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate);    if (server->process == PROCESS_NONE) {        SDLNet_TCP_Close(server->server_socket);        disable_tunnel(serial);        return SDL_FALSE;    }    server->adb_reverse_enabled = SDL_TRUE;    return SDL_TRUE;}
static SDL_bool disable_tunnel(const char *serial) {    process_t process = adb_reverse_remove(serial, SOCKET_NAME);    return process_check_success(process, "adb reverse --remove");}
void server_stop(struct server *server, const char *serial) {    SDL_assert(server->process != PROCESS_NONE);    if (server->server_socket) {        SDLNet_TCP_Close(server->server_socket);    }    if (server->device_socket) {        SDLNet_TCP_Close(server->device_socket);    }    // let the server some time to print any exception trace before killing it    struct timespec timespec = {        .tv_sec = 0,        .tv_nsec = 100000000, // 100ms    };    nanosleep(&timespec, NULL); // ignore error    terminate_server(server->process);    if (server->adb_reverse_enabled) {        // ignore failure        disable_tunnel(serial);    }}
TCPsocket server_connect_to(struct server *server) {    SDL_assert(server->server_socket);    server->device_socket = server_socket_accept(server->server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server->server_socket);    server->server_socket = NULL;    return server->device_socket;}
static SDL_bool disable_tunnel(const char *serial) {    process_t process = adb_reverse_remove(serial, SOCKET_NAME);    return process_check_success(process, "adb reverse --remove");}static process_t execute_server(const char *serial, Uint16 max_size, Uint32 bit_rate) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.ScrCpyServer",
static process_t execute_server(const char *serial, Uint16 max_size, Uint32 bit_rate) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.ScrCpyServer",        max_size_string,        bit_rate_string,    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
static void terminate_server(process_t server) {    if (!cmd_terminate(server)) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not terminate server: %s", strerror(errno));    }}
void server_init(struct server *server) {    *server = (struct server) SERVER_INITIALIZER;}
static SDL_bool push_server(const char *serial) {    const char *server_path = getenv("SCRCPY_SERVER_JAR");    if (!server_path) {        server_path = "scrcpy-server.jar";    }    process_t process = adb_push(serial, server_path, "/data/local/tmp/scrcpy-server.jar");    return process_check_success(process, "adb push");}
static SDL_bool enable_tunnel(const char *serial, Uint16 local_port) {    process_t process = adb_reverse(serial, SOCKET_NAME, local_port);    return process_check_success(process, "adb reverse");}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
SDL_bool cmd_terminate(pid_t pid) {    return kill(pid, SIGTERM) != -1;}
SDL_bool cmd_terminate(pid_t pid) {    if (pid <= 0) {        LOGC("Requested to kill %d, this is an error. Please report the bug.\n", (int) pid);        abort();    }    return kill(pid, SIGTERM) != -1;}
run_controller(void *data) {    struct controller *controller = data;    for (;;) {        mutex_lock(controller->mutex);        while (!controller->stopped && cbuf_is_empty(&controller->queue)) {            cond_wait(controller->msg_cond, controller->mutex);        }        if (controller->stopped) {            // stop immediately, do not process further msgs            mutex_unlock(controller->mutex);            break;        }        struct control_msg msg;        bool non_empty = cbuf_take(&controller->queue, &msg);        SDL_assert(non_empty);        mutex_unlock(controller->mutex);        bool ok = process_msg(controller, &msg);        control_msg_destroy(&msg);        if (!ok) {            LOGD("Cannot write msg to socket");            break;        }    }    return 0;}
run_controller(void *data) {    struct controller *controller = data;    for (;;) {        mutex_lock(controller->mutex);        while (!controller->stopped && cbuf_is_empty(&controller->queue)) {            cond_wait(controller->msg_cond, controller->mutex);        }        if (controller->stopped) {            // stop immediately, do not process further msgs            mutex_unlock(controller->mutex);            break;        }        struct control_msg msg;        bool non_empty = cbuf_take(&controller->queue, &msg);        SDL_assert(non_empty);        mutex_unlock(controller->mutex);        bool ok = process_msg(controller, &msg);        control_msg_destroy(&msg);        if (!ok) {            LOGD("Could not write msg to socket");            break;        }    }    return 0;}
file_handler_stop(struct file_handler *file_handler) {    mutex_lock(file_handler->mutex);    file_handler->stopped = true;    cond_signal(file_handler->event_cond);    if (file_handler->current_process != PROCESS_NONE) {        if (!cmd_terminate(file_handler->current_process)) {            LOGW("Cannot terminate install process");        }        cmd_simple_wait(file_handler->current_process, NULL);        file_handler->current_process = PROCESS_NONE;    }    mutex_unlock(file_handler->mutex);}
file_handler_init(struct file_handler *file_handler, const char *serial) {    cbuf_init(&file_handler->queue);    if (!(file_handler->mutex = SDL_CreateMutex())) {        return false;    }    if (!(file_handler->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(file_handler->mutex);        return false;    }    if (serial) {        file_handler->serial = SDL_strdup(serial);        if (!file_handler->serial) {            LOGW("Cannot strdup serial");            SDL_DestroyCond(file_handler->event_cond);            SDL_DestroyMutex(file_handler->mutex);            return false;        }    } else {        file_handler->serial = NULL;    }    // lazy initialization    file_handler->initialized = false;    file_handler->stopped = false;    file_handler->current_process = PROCESS_NONE;    return true;}
file_handler_stop(struct file_handler *file_handler) {    mutex_lock(file_handler->mutex);    file_handler->stopped = true;    cond_signal(file_handler->event_cond);    if (file_handler->current_process != PROCESS_NONE) {        if (!cmd_terminate(file_handler->current_process)) {            LOGW("Could not terminate install process");        }        cmd_simple_wait(file_handler->current_process, NULL);        file_handler->current_process = PROCESS_NONE;    }    mutex_unlock(file_handler->mutex);}
file_handler_init(struct file_handler *file_handler, const char *serial) {    cbuf_init(&file_handler->queue);    if (!(file_handler->mutex = SDL_CreateMutex())) {        return false;    }    if (!(file_handler->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(file_handler->mutex);        return false;    }    if (serial) {        file_handler->serial = SDL_strdup(serial);        if (!file_handler->serial) {            LOGW("Could not strdup serial");            SDL_DestroyCond(file_handler->event_cond);            SDL_DestroyMutex(file_handler->mutex);            return false;        }    } else {        file_handler->serial = NULL;    }    // lazy initialization    file_handler->initialized = false;    file_handler->stopped = false;    file_handler->current_process = PROCESS_NONE;    return true;}
expand_notification_panel(struct controller *controller) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL;    if (!controller_push_msg(controller, &msg)) {        LOGW("Cannot request 'expand notification panel'");    }}
press_back_or_turn_screen_on(struct controller *controller) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON;    if (!controller_push_msg(controller, &msg)) {        LOGW("Cannot request 'turn screen on'");    }}
send_keycode(struct controller *controller, enum android_keycode keycode,             int actions, const char *name) {    // send DOWN event    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_KEYCODE;    msg.inject_keycode.keycode = keycode;    msg.inject_keycode.metastate = 0;    if (actions & ACTION_DOWN) {        msg.inject_keycode.action = AKEY_EVENT_ACTION_DOWN;        if (!controller_push_msg(controller, &msg)) {            LOGW("Cannot request 'inject %s (DOWN)'", name);            return;        }    }    if (actions & ACTION_UP) {        msg.inject_keycode.action = AKEY_EVENT_ACTION_UP;        if (!controller_push_msg(controller, &msg)) {            LOGW("Cannot request 'inject %s (UP)'", name);        }    }}
clipboard_paste(struct controller *controller) {    char *text = SDL_GetClipboardText();    if (!text) {        LOGW("Cannot get clipboard text: %s", SDL_GetError());        return;    }    if (!*text) {        // empty text        SDL_free(text);        return;    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    msg.inject_text.text = text;    if (!controller_push_msg(controller, &msg)) {        SDL_free(text);        LOGW("Cannot request 'paste clipboard'");    }}
request_device_clipboard(struct controller *controller) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_GET_CLIPBOARD;    if (!controller_push_msg(controller, &msg)) {        LOGW("Cannot request device clipboard");    }}
collapse_notification_panel(struct controller *controller) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL;    if (!controller_push_msg(controller, &msg)) {        LOGW("Cannot request 'collapse notification panel'");    }}
set_screen_power_mode(struct controller *controller,                      enum screen_power_mode mode) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;    msg.set_screen_power_mode.mode = mode;    if (!controller_push_msg(controller, &msg)) {        LOGW("Cannot request 'set screen power mode'");    }}
input_manager_process_text_input(struct input_manager *input_manager,                                 const SDL_TextInputEvent *event) {    char c = event->text[0];    if (isalpha(c) || c == ' ') {        SDL_assert(event->text[1] == '\0');        // letters and space are handled as raw key event        return;    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    msg.inject_text.text = SDL_strdup(event->text);    if (!msg.inject_text.text) {        LOGW("Cannot strdup input text");        return;    }    if (!controller_push_msg(input_manager->controller, &msg)) {        SDL_free(msg.inject_text.text);        LOGW("Cannot request 'inject text'");    }}
set_device_clipboard(struct controller *controller) {    char *text = SDL_GetClipboardText();    if (!text) {        LOGW("Cannot get clipboard text: %s", SDL_GetError());        return;    }    if (!*text) {        // empty text        SDL_free(text);        return;    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_SET_CLIPBOARD;    msg.set_clipboard.text = text;    if (!controller_push_msg(controller, &msg)) {        SDL_free(text);        LOGW("Cannot request 'set device clipboard'");    }}
expand_notification_panel(struct controller *controller) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL;    if (!controller_push_msg(controller, &msg)) {        LOGW("Could not request 'expand notification panel'");    }}
press_back_or_turn_screen_on(struct controller *controller) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON;    if (!controller_push_msg(controller, &msg)) {        LOGW("Could not request 'turn screen on'");    }}
send_keycode(struct controller *controller, enum android_keycode keycode,             int actions, const char *name) {    // send DOWN event    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_KEYCODE;    msg.inject_keycode.keycode = keycode;    msg.inject_keycode.metastate = 0;    if (actions & ACTION_DOWN) {        msg.inject_keycode.action = AKEY_EVENT_ACTION_DOWN;        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject %s (DOWN)'", name);            return;        }    }    if (actions & ACTION_UP) {        msg.inject_keycode.action = AKEY_EVENT_ACTION_UP;        if (!controller_push_msg(controller, &msg)) {            LOGW("Could not request 'inject %s (UP)'", name);        }    }}
clipboard_paste(struct controller *controller) {    char *text = SDL_GetClipboardText();    if (!text) {        LOGW("Could not get clipboard text: %s", SDL_GetError());        return;    }    if (!*text) {        // empty text        SDL_free(text);        return;    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    msg.inject_text.text = text;    if (!controller_push_msg(controller, &msg)) {        SDL_free(text);        LOGW("Could not request 'paste clipboard'");    }}
request_device_clipboard(struct controller *controller) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_GET_CLIPBOARD;    if (!controller_push_msg(controller, &msg)) {        LOGW("Could not request device clipboard");    }}
collapse_notification_panel(struct controller *controller) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL;    if (!controller_push_msg(controller, &msg)) {        LOGW("Could not request 'collapse notification panel'");    }}
set_screen_power_mode(struct controller *controller,                      enum screen_power_mode mode) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;    msg.set_screen_power_mode.mode = mode;    if (!controller_push_msg(controller, &msg)) {        LOGW("Could not request 'set screen power mode'");    }}
input_manager_process_text_input(struct input_manager *input_manager,                                 const SDL_TextInputEvent *event) {    char c = event->text[0];    if (isalpha(c) || c == ' ') {        SDL_assert(event->text[1] == '\0');        // letters and space are handled as raw key event        return;    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    msg.inject_text.text = SDL_strdup(event->text);    if (!msg.inject_text.text) {        LOGW("Could not strdup input text");        return;    }    if (!controller_push_msg(input_manager->controller, &msg)) {        SDL_free(msg.inject_text.text);        LOGW("Could not request 'inject text'");    }}
set_device_clipboard(struct controller *controller) {    char *text = SDL_GetClipboardText();    if (!text) {        LOGW("Could not get clipboard text: %s", SDL_GetError());        return;    }    if (!*text) {        // empty text        SDL_free(text);        return;    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_SET_CLIPBOARD;    msg.set_clipboard.text = text;    if (!controller_push_msg(controller, &msg)) {        SDL_free(text);        LOGW("Could not request 'set device clipboard'");    }}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, 'T'},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, 'c'},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, 'f'},        {"render-expired-frames", no_argument,       NULL,                                                 OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"version",               no_argument,       NULL, 'v'},        {NULL,                    0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return false;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = true;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return false;                }                break;            case 'n':                args->no_control = true;                break;            case 'N':                args->no_display = true;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return false;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 'S':                args->turn_screen_off = true;                break;            case 't':                args->show_touches = true;                break;            case 'T':                args->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                args->render_expired_frames = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (args->no_display && !args->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (args->no_display && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return false;        }    }    if (args->no_control && args->turn_screen_off) {        LOGE("Cannot request to turn screen off if control is disabled");        return false;    }    return true;}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, 'T'},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, 'c'},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, 'f'},        {"render-expired-frames", no_argument,       NULL,                                                 OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"version",               no_argument,       NULL, 'v'},        {NULL,                    0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return false;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = true;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return false;                }                break;            case 'n':                args->no_control = true;                break;            case 'N':                args->no_display = true;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return false;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 'S':                args->turn_screen_off = true;                break;            case 't':                args->show_touches = true;                break;            case 'T':                args->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                args->render_expired_frames = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (args->no_display && !args->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (args->no_display && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return false;        }    }    if (args->no_control && args->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
recorder_init(struct recorder *recorder,              const char *filename,              enum recorder_format format,              struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Cannot strdup filename");        return false;    }    recorder->format = format;    recorder->declared_frame_size = declared_frame_size;    recorder->header_written = false;    return true;}
recorder_write_header(struct recorder *recorder, const AVPacket *packet) {    AVStream *ostream = recorder->ctx->streams[0];    uint8_t *extradata = av_malloc(packet->size * sizeof(uint8_t));    if (!extradata) {        LOGC("Cannot allocate extradata");        return false;    }    // copy the first packet to the extra data    memcpy(extradata, packet->data, packet->size);#ifdef SCRCPY_LAVF_HAS_NEW_CODEC_PARAMS_API    ostream->codecpar->extradata = extradata;    ostream->codecpar->extradata_size = packet->size;#else    ostream->codec->extradata = extradata;    ostream->codec->extradata_size = packet->size;#endif    int ret = avformat_write_header(recorder->ctx, NULL);    if (ret < 0) {        LOGE("Failed to write header to %s", recorder->filename);        SDL_free(extradata);        avio_closep(&recorder->ctx->pb);        avformat_free_context(recorder->ctx);        return false;    }    return true;}
recorder_init(struct recorder *recorder,              const char *filename,              enum recorder_format format,              struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Could not strdup filename");        return false;    }    recorder->format = format;    recorder->declared_frame_size = declared_frame_size;    recorder->header_written = false;    return true;}
recorder_write_header(struct recorder *recorder, const AVPacket *packet) {    AVStream *ostream = recorder->ctx->streams[0];    uint8_t *extradata = av_malloc(packet->size * sizeof(uint8_t));    if (!extradata) {        LOGC("Could not allocate extradata");        return false;    }    // copy the first packet to the extra data    memcpy(extradata, packet->data, packet->size);#ifdef SCRCPY_LAVF_HAS_NEW_CODEC_PARAMS_API    ostream->codecpar->extradata = extradata;    ostream->codecpar->extradata_size = packet->size;#else    ostream->codec->extradata = extradata;    ostream->codec->extradata_size = packet->size;#endif    int ret = avformat_write_header(recorder->ctx, NULL);    if (ret < 0) {        LOGE("Failed to write header to %s", recorder->filename);        SDL_free(extradata);        avio_closep(&recorder->ctx->pb);        avformat_free_context(recorder->ctx);        return false;    }    return true;}
av_log_callback(void *avcl, int level, const char *fmt, va_list vl) {    SDL_LogPriority priority = sdl_priority_from_av_level(level);    if (priority == 0) {        return;    }    char *local_fmt = SDL_malloc(strlen(fmt) + 10);    if (!local_fmt) {        LOGC("Cannot allocate string");        return;    }    // strcpy is safe here, the destination is large enough    strcpy(local_fmt, "[FFmpeg] ");    strcpy(local_fmt + 9, fmt);    SDL_LogMessageV(SDL_LOG_CATEGORY_VIDEO, priority, local_fmt, vl);    SDL_free(local_fmt);}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .send_frame_meta = record,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Cannot request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
av_log_callback(void *avcl, int level, const char *fmt, va_list vl) {    SDL_LogPriority priority = sdl_priority_from_av_level(level);    if (priority == 0) {        return;    }    char *local_fmt = SDL_malloc(strlen(fmt) + 10);    if (!local_fmt) {        LOGC("Could not allocate string");        return;    }    // strcpy is safe here, the destination is large enough    strcpy(local_fmt, "[FFmpeg] ");    strcpy(local_fmt + 9, fmt);    SDL_LogMessageV(SDL_LOG_CATEGORY_VIDEO, priority, local_fmt, vl);    SDL_free(local_fmt);}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .send_frame_meta = record,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
get_optimal_size(struct size current_size, struct size frame_size) {    if (frame_size.width == 0 || frame_size.height == 0) {        // avoid division by 0        return current_size;    }    struct size display_size;    // 32 bits because we need to multiply two 16 bits values    uint32_t w;    uint32_t h;    if (!get_preferred_display_bounds(&display_size)) {        // cannot get display bounds, do not constraint the size        w = current_size.width;        h = current_size.height;    } else {        w = MIN(current_size.width, display_size.width);        h = MIN(current_size.height, display_size.height);    }    bool keep_width = frame_size.width * h > frame_size.height * w;    if (keep_width) {        // remove black borders on top and bottom        h = frame_size.height * w / frame_size.width;    } else {        // remove black borders on left and right (or none at all if it already        // fits)        w = frame_size.width * h / frame_size.height;    }    // w and h must fit into 16 bits    SDL_assert_release(w < 0x10000 && h < 0x10000);    return (struct size) {w, h};}
get_optimal_size(struct size current_size, struct size frame_size) {    if (frame_size.width == 0 || frame_size.height == 0) {        // avoid division by 0        return current_size;    }    struct size display_size;    // 32 bits because we need to multiply two 16 bits values    uint32_t w;    uint32_t h;    if (!get_preferred_display_bounds(&display_size)) {        // could not get display bounds, do not constraint the size        w = current_size.width;        h = current_size.height;    } else {        w = MIN(current_size.width, display_size.width);        h = MIN(current_size.height, display_size.height);    }    bool keep_width = frame_size.width * h > frame_size.height * w;    if (keep_width) {        // remove black borders on top and bottom        h = frame_size.height * w / frame_size.width;    } else {        // remove black borders on left and right (or none at all if it already        // fits)        w = frame_size.width * h / frame_size.height;    }    // w and h must fit into 16 bits    SDL_assert_release(w < 0x10000 && h < 0x10000);    return (struct size) {w, h};}
close_socket(socket_t *socket) {    SDL_assert(*socket != INVALID_SOCKET);    net_shutdown(*socket, SHUT_RDWR);    if (!net_close(*socket)) {        LOGW("Cannot close socket");        return;    }    *socket = INVALID_SOCKET;}
get_server_path(void) {    const char *server_path_env = getenv("SCRCPY_SERVER_PATH");    if (server_path_env) {        LOGD("Using SCRCPY_SERVER_PATH: %s", server_path_env);        // if the envvar is set, use it        return server_path_env;    }#ifndef PORTABLE    LOGD("Using server: " DEFAULT_SERVER_PATH);    // the absolute path is hardcoded    return DEFAULT_SERVER_PATH;#else    // use scrcpy-server.jar in the same directory as the executable    char *executable_path = get_executable_path();    if (!executable_path) {        LOGE("Cannot get executable path, "             "using " SERVER_FILENAME " from current directory");        // not found, use current directory        return SERVER_FILENAME;    }    char *dir = dirname(executable_path);    size_t dirlen = strlen(dir);    // sizeof(SERVER_FILENAME) gives statically the size including the null byte    size_t len = dirlen + 1 + sizeof(SERVER_FILENAME);    char *server_path = SDL_malloc(len);    if (!server_path) {        LOGE("Cannot alloc server path string, "             "using " SERVER_FILENAME " from current directory");        SDL_free(executable_path);        return SERVER_FILENAME;    }    memcpy(server_path, dir, dirlen);    server_path[dirlen] = PATH_SEPARATOR;    memcpy(&server_path[dirlen + 1], SERVER_FILENAME, sizeof(SERVER_FILENAME));    // the final null byte has been copied with SERVER_FILENAME    SDL_free(executable_path);    LOGD("Using server (portable): %s", server_path);    return server_path;#endif}
server_stop(struct server *server) {    if (server->server_socket != INVALID_SOCKET) {        close_socket(&server->server_socket);    }    if (server->video_socket != INVALID_SOCKET) {        close_socket(&server->video_socket);    }    if (server->control_socket != INVALID_SOCKET) {        close_socket(&server->control_socket);    }    SDL_assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Cannot terminate server");    }    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->tunnel_enabled) {        // ignore failure        disable_tunnel(server);    }}
close_socket(socket_t *socket) {    SDL_assert(*socket != INVALID_SOCKET);    net_shutdown(*socket, SHUT_RDWR);    if (!net_close(*socket)) {        LOGW("Could not close socket");        return;    }    *socket = INVALID_SOCKET;}
get_server_path(void) {    const char *server_path_env = getenv("SCRCPY_SERVER_PATH");    if (server_path_env) {        LOGD("Using SCRCPY_SERVER_PATH: %s", server_path_env);        // if the envvar is set, use it        return server_path_env;    }#ifndef PORTABLE    LOGD("Using server: " DEFAULT_SERVER_PATH);    // the absolute path is hardcoded    return DEFAULT_SERVER_PATH;#else    // use scrcpy-server.jar in the same directory as the executable    char *executable_path = get_executable_path();    if (!executable_path) {        LOGE("Could not get executable path, "             "using " SERVER_FILENAME " from current directory");        // not found, use current directory        return SERVER_FILENAME;    }    char *dir = dirname(executable_path);    size_t dirlen = strlen(dir);    // sizeof(SERVER_FILENAME) gives statically the size including the null byte    size_t len = dirlen + 1 + sizeof(SERVER_FILENAME);    char *server_path = SDL_malloc(len);    if (!server_path) {        LOGE("Could not alloc server path string, "             "using " SERVER_FILENAME " from current directory");        SDL_free(executable_path);        return SERVER_FILENAME;    }    memcpy(server_path, dir, dirlen);    server_path[dirlen] = PATH_SEPARATOR;    memcpy(&server_path[dirlen + 1], SERVER_FILENAME, sizeof(SERVER_FILENAME));    // the final null byte has been copied with SERVER_FILENAME    SDL_free(executable_path);    LOGD("Using server (portable): %s", server_path);    return server_path;#endif}
server_stop(struct server *server) {    if (server->server_socket != INVALID_SOCKET) {        close_socket(&server->server_socket);    }    if (server->video_socket != INVALID_SOCKET) {        close_socket(&server->video_socket);    }    if (server->control_socket != INVALID_SOCKET) {        close_socket(&server->control_socket);    }    SDL_assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Could not terminate server");    }    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->tunnel_enabled) {        // ignore failure        disable_tunnel(server);    }}
read_packet_with_meta(void *opaque, uint8_t *buf, int buf_size) {    struct stream *stream = opaque;    struct receiver_state *state = &stream->receiver_state;    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    if (!state->remaining) {#define HEADER_SIZE 12        uint8_t header[HEADER_SIZE];        ssize_t r = net_recv_all(stream->socket, header, HEADER_SIZE);        if (r == -1) {            return AVERROR(errno);        }        if (r == 0) {            return AVERROR_EOF;        }        // no partial read (net_recv_all())        SDL_assert_release(r == HEADER_SIZE);        uint64_t pts = buffer_read64be(header);        state->remaining = buffer_read32be(&header[8]);        if (pts != NO_PTS && !receiver_state_push_meta(state, pts)) {            LOGE("Could not store PTS for recording");            // we cannot save the PTS, the recording would be broken            return AVERROR(ENOMEM);        }    }    SDL_assert(state->remaining);    if (buf_size > state->remaining) {        buf_size = state->remaining;    }    ssize_t r = net_recv(stream->socket, buf, buf_size);    if (r == -1) {        return errno ? AVERROR(errno) : AVERROR_EOF;    }    if (r == 0) {        return AVERROR_EOF;    }    SDL_assert(state->remaining >= r);    state->remaining -= r;    return r;}
read_packet_with_meta(void *opaque, uint8_t *buf, int buf_size) {    struct stream *stream = opaque;    struct receiver_state *state = &stream->receiver_state;    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    if (!state->remaining) {#define HEADER_SIZE 12        uint8_t header[HEADER_SIZE];        ssize_t r = net_recv_all(stream->socket, header, HEADER_SIZE);        if (r == -1) {            return AVERROR(errno);        }        if (r == 0) {            return AVERROR_EOF;        }        // no partial read (net_recv_all())        SDL_assert_release(r == HEADER_SIZE);        uint64_t pts = buffer_read64be(header);        state->remaining = buffer_read32be(&header[8]);        if (pts != NO_PTS && !receiver_state_push_meta(state, pts)) {            LOGE("Could not store PTS for recording");            // we could not save the PTS, the recording would be broken            return AVERROR(ENOMEM);        }    }    SDL_assert(state->remaining);    if (buf_size > state->remaining) {        buf_size = state->remaining;    }    ssize_t r = net_recv(stream->socket, buf, buf_size);    if (r == -1) {        return errno ? AVERROR(errno) : AVERROR_EOF;    }    if (r == 0) {        return AVERROR_EOF;    }    SDL_assert(state->remaining >= r);    state->remaining -= r;    return r;}
cmd_simple_wait(pid_t pid, int *exit_code) {    int status;    int code;    if (waitpid(pid, &status, 0) == -1 || !WIFEXITED(status)) {        // cannot wait, or exited unexpectedly, probably by a signal        code = -1;    } else {        code = WEXITSTATUS(status);    }    if (exit_code) {        *exit_code = code;    }    return !code;}
cmd_simple_wait(pid_t pid, int *exit_code) {    int status;    int code;    if (waitpid(pid, &status, 0) == -1 || !WIFEXITED(status)) {        // could not wait, or exited unexpectedly, probably by a signal        code = -1;    } else {        code = WEXITSTATUS(status);    }    if (exit_code) {        *exit_code = code;    }    return !code;}
cmd_simple_wait(HANDLE handle, DWORD *exit_code) {    DWORD code;    if (WaitForSingleObject(handle, INFINITE) != WAIT_OBJECT_0            || !GetExitCodeProcess(handle, &code)) {        // cannot wait or retrieve the exit code        code = -1; // max value, it's unsigned    }    if (exit_code) {        *exit_code = code;    }    return !code;}
cmd_execute(const char *path, const char *const argv[], HANDLE *handle) {    STARTUPINFOW si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    char cmd[256];    if (build_cmd(cmd, sizeof(cmd), argv)) {        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }    wchar_t *wide = utf8_to_wide_char(cmd);    if (!wide) {        LOGC("Cannot allocate wide char string");        return PROCESS_ERROR_GENERIC;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcessW(NULL, wide, NULL, NULL, FALSE, flags, NULL, NULL, &si,                        &pi)) {        SDL_free(wide);        *handle = NULL;        if (GetLastError() == ERROR_FILE_NOT_FOUND) {            return PROCESS_ERROR_MISSING_BINARY;        }        return PROCESS_ERROR_GENERIC;    }    SDL_free(wide);    *handle = pi.hProcess;    return PROCESS_SUCCESS;}
cmd_simple_wait(HANDLE handle, DWORD *exit_code) {    DWORD code;    if (WaitForSingleObject(handle, INFINITE) != WAIT_OBJECT_0            || !GetExitCodeProcess(handle, &code)) {        // could not wait or retrieve the exit code        code = -1; // max value, it's unsigned    }    if (exit_code) {        *exit_code = code;    }    return !code;}
cmd_execute(const char *path, const char *const argv[], HANDLE *handle) {    STARTUPINFOW si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    char cmd[256];    if (build_cmd(cmd, sizeof(cmd), argv)) {        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }    wchar_t *wide = utf8_to_wide_char(cmd);    if (!wide) {        LOGC("Could not allocate wide char string");        return PROCESS_ERROR_GENERIC;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcessW(NULL, wide, NULL, NULL, FALSE, flags, NULL, NULL, &si,                        &pi)) {        SDL_free(wide);        *handle = NULL;        if (GetLastError() == ERROR_FILE_NOT_FOUND) {            return PROCESS_ERROR_MISSING_BINARY;        }        return PROCESS_ERROR_GENERIC;    }    SDL_free(wide);    *handle = pi.hProcess;    return PROCESS_SUCCESS;}
    private static void unlinkSelf() {        try {            new File(SERVER_PATH).delete();        } catch (Exception e) {            Ln.e("Cannot unlink server", e);        }    }
    private static void unlinkSelf() {        try {            new File(SERVER_PATH).delete();        } catch (Exception e) {            Ln.e("Could not unlink server", e);        }    }
    public void expandNotificationsPanel() {        if (expandNotificationsPanelMethod == null) {            try {                expandNotificationsPanelMethod = manager.getClass().getMethod("expandNotificationsPanel");            } catch (NoSuchMethodException e) {                Ln.e("ServiceBarManager.expandNotificationsPanel() is not available on this device");                return;            }        }        try {            expandNotificationsPanelMethod.invoke(manager);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Cannot invoke ServiceBarManager.expandNotificationsPanel()", e);        }    }
    public void collapsePanels() {        if (collapsePanelsMethod == null) {            try {                collapsePanelsMethod = manager.getClass().getMethod("collapsePanels");            } catch (NoSuchMethodException e) {                Ln.e("ServiceBarManager.collapsePanels() is not available on this device");                return;            }        }        try {            collapsePanelsMethod.invoke(manager);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Cannot invoke ServiceBarManager.collapsePanels()", e);        }    }}
    public void expandNotificationsPanel() {        if (expandNotificationsPanelMethod == null) {            try {                expandNotificationsPanelMethod = manager.getClass().getMethod("expandNotificationsPanel");            } catch (NoSuchMethodException e) {                Ln.e("ServiceBarManager.expandNotificationsPanel() is not available on this device");                return;            }        }        try {            expandNotificationsPanelMethod.invoke(manager);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke ServiceBarManager.expandNotificationsPanel()", e);        }    }
    public void collapsePanels() {        if (collapsePanelsMethod == null) {            try {                collapsePanelsMethod = manager.getClass().getMethod("collapsePanels");            } catch (NoSuchMethodException e) {                Ln.e("ServiceBarManager.collapsePanels() is not available on this device");                return;            }        }        try {            collapsePanelsMethod.invoke(manager);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke ServiceBarManager.collapsePanels()", e);        }    }}
SDL_bool mouse_wheel_from_sdl_to_android(const SDL_MouseWheelEvent *from,                                         struct position position,                                         struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_SCROLL;    to->scroll_event.position = position;    int mul = from->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    to->scroll_event.hscroll = mul * from->x;    to->scroll_event.vscroll = mul * from->y;    return SDL_TRUE;}
SDL_bool mouse_wheel_from_sdl_to_android(const SDL_MouseWheelEvent *from,                                         struct position position,                                         struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_SCROLL;    to->scroll_event.position = position;    int mul = from->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    // SDL behavior seems inconsistent between horizontal and vertical scrolling    // so reverse the horizontal    // <https://wiki.libsdl.org/SDL_MouseWheelEvent#Remarks>    to->scroll_event.hscroll = -mul * from->x;    to->scroll_event.vscroll = mul * from->y;    return SDL_TRUE;}
static void push_frame(struct decoder *decoder) {    SDL_bool previous_frame_consumed = frames_offer_decoded_frame(decoder->frames);    if (!previous_frame_consumed) {        // the previous EVENT_NEW_FRAME will consume this frame        return;    }    static SDL_Event new_frame_event = {        .type = EVENT_NEW_FRAME,    };    SDL_PushEvent(&new_frame_event);}
void decoder_init(struct decoder *decoder, struct frames *frames,                  socket_t video_socket, struct recorder *recorder) {    decoder->frames = frames;    decoder->video_socket = video_socket;    decoder->recorder = recorder;}
void decoder_init(struct decoder *decoder, struct frames *frames,                  socket_t video_socket, struct recorder *recorder) {    decoder->frames = frames;    decoder->video_socket = video_socket;    decoder->recorder = recorder;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    // initialize the receiver state    decoder->receiver_state.frame_meta_queue = NULL;    decoder->receiver_state.remaining = 0;    // if recording is enabled, a "header" is sent between raw packets    int (*read_packet)(void *, uint8_t *, int) =            decoder->recorder ? read_packet_with_meta : read_raw_packet;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder,                                               read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#ifdef SCRCPY_LAVF_HAS_NEW_ENCODING_DECODING_API        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        if (decoder->recorder) {            // we retrieve the PTS in order they were received, so they will            // be assigned to the correct frame            uint64_t pts = receiver_state_take_meta(&decoder->receiver_state);            packet.pts = pts;            packet.dts = pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(decoder->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto run_quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_free(avio_ctx->buffer);    av_free(avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
void decoder_stop(struct decoder *decoder) {    frames_stop(decoder->frames);}
static void push_frame(struct decoder *decoder) {    SDL_bool previous_frame_consumed = video_buffer_offer_decoded_frame(decoder->video_buffer);    if (!previous_frame_consumed) {        // the previous EVENT_NEW_FRAME will consume this frame        return;    }    static SDL_Event new_frame_event = {        .type = EVENT_NEW_FRAME,    };    SDL_PushEvent(&new_frame_event);}
void decoder_init(struct decoder *decoder, struct video_buffer *vb,                  socket_t video_socket, struct recorder *recorder) {    decoder->video_buffer = vb;    decoder->video_socket = video_socket;    decoder->recorder = recorder;}
void decoder_init(struct decoder *decoder, struct video_buffer *vb,                  socket_t video_socket, struct recorder *recorder) {    decoder->video_buffer = vb;    decoder->video_socket = video_socket;    decoder->recorder = recorder;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    // initialize the receiver state    decoder->receiver_state.frame_meta_queue = NULL;    decoder->receiver_state.remaining = 0;    // if recording is enabled, a "header" is sent between raw packets    int (*read_packet)(void *, uint8_t *, int) =            decoder->recorder ? read_packet_with_meta : read_raw_packet;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder,                                               read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#ifdef SCRCPY_LAVF_HAS_NEW_ENCODING_DECODING_API        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->video_buffer->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->video_buffer->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        if (decoder->recorder) {            // we retrieve the PTS in order they were received, so they will            // be assigned to the correct frame            uint64_t pts = receiver_state_take_meta(&decoder->receiver_state);            packet.pts = pts;            packet.dts = pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(decoder->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto run_quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_free(avio_ctx->buffer);    av_free(avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
void decoder_stop(struct decoder *decoder) {    video_buffer_stop(decoder->video_buffer);}
static void switch_fps_counter_state(struct frames *frames) {    mutex_lock(frames->mutex);    if (frames->fps_counter.started) {        LOGI("FPS counter stopped");        fps_counter_stop(&frames->fps_counter);    } else {        LOGI("FPS counter started");        fps_counter_start(&frames->fps_counter);    }    mutex_unlock(frames->mutex);}
static void switch_fps_counter_state(struct frames *frames) {    mutex_lock(frames->mutex);    if (frames->fps_counter.started) {        LOGI("FPS counter stopped");        fps_counter_stop(&frames->fps_counter);    } else {        LOGI("FPS counter started");        fps_counter_start(&frames->fps_counter);    }    mutex_unlock(frames->mutex);}
static void switch_fps_counter_state(struct video_buffer *vb) {    mutex_lock(vb->mutex);    if (vb->fps_counter.started) {        LOGI("FPS counter stopped");        fps_counter_stop(&vb->fps_counter);    } else {        LOGI("FPS counter started");        fps_counter_start(&vb->fps_counter);    }    mutex_unlock(vb->mutex);}
static void switch_fps_counter_state(struct video_buffer *vb) {    mutex_lock(vb->mutex);    if (vb->fps_counter.started) {        LOGI("FPS counter stopped");        fps_counter_stop(&vb->fps_counter);    } else {        LOGI("FPS counter started");        fps_counter_start(&vb->fps_counter);    }    mutex_unlock(vb->mutex);}
static SDL_bool event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return SDL_FALSE;            case SDL_QUIT:                LOGD("User requested to quit");                return SDL_TRUE;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return SDL_FALSE;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                    case SDL_WINDOWEVENT_EXPOSED:                    case SDL_WINDOWEVENT_SIZE_CHANGED:                        screen_render(&screen);                        break;                }                break;            case SDL_TEXTINPUT:                input_manager_process_text_input(&input_manager, &event.text);                break;            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL:                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP:                input_manager_process_mouse_button(&input_manager, &event.button);                break;            case SDL_DROPFILE: {                file_handler_action_t action;                if (is_apk(event.drop.file)) {                    action = ACTION_INSTALL_APK;                } else {                    action = ACTION_PUSH_FILE;                }                file_handler_request(&file_handler, action, event.drop.file);                break;            }        }    }    return SDL_FALSE;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    SDL_bool send_frame_meta = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      send_frame_meta)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    struct recorder *rec = NULL;    if (options->record_filename) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    decoder_init(&decoder, &frames, device_socket, rec);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size, options->always_on_top)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_recorder:    if (options->record_filename) {        recorder_destroy(&recorder);    }finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
static SDL_bool event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return SDL_FALSE;            case SDL_QUIT:                LOGD("User requested to quit");                return SDL_TRUE;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &video_buffer)) {                    return SDL_FALSE;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                    case SDL_WINDOWEVENT_EXPOSED:                    case SDL_WINDOWEVENT_SIZE_CHANGED:                        screen_render(&screen);                        break;                }                break;            case SDL_TEXTINPUT:                input_manager_process_text_input(&input_manager, &event.text);                break;            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL:                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP:                input_manager_process_mouse_button(&input_manager, &event.button);                break;            case SDL_DROPFILE: {                file_handler_action_t action;                if (is_apk(event.drop.file)) {                    action = ACTION_INSTALL_APK;                } else {                    action = ACTION_PUSH_FILE;                }                file_handler_request(&file_handler, action, event.drop.file);                break;            }        }    }    return SDL_FALSE;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    SDL_bool send_frame_meta = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      send_frame_meta)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!video_buffer_init(&video_buffer)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_video_buffer;    }    struct recorder *rec = NULL;    if (options->record_filename) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    decoder_init(&decoder, &video_buffer, device_socket, rec);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size, options->always_on_top)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_recorder:    if (options->record_filename) {        recorder_destroy(&recorder);    }finally_destroy_video_buffer:    video_buffer_destroy(&video_buffer);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
SDL_bool screen_update_frame(struct screen *screen, struct frames *frames) {    mutex_lock(frames->mutex);    const AVFrame *frame = frames_consume_rendered_frame(frames);    struct size new_frame_size = {frame->width, frame->height};    if (!prepare_for_frame(screen, new_frame_size)) {        mutex_unlock(frames->mutex);        return SDL_FALSE;    }    update_texture(screen, frame);    mutex_unlock(frames->mutex);    screen_render(screen);    return SDL_TRUE;}
SDL_bool screen_update_frame(struct screen *screen, struct frames *frames) {    mutex_lock(frames->mutex);    const AVFrame *frame = frames_consume_rendered_frame(frames);    struct size new_frame_size = {frame->width, frame->height};    if (!prepare_for_frame(screen, new_frame_size)) {        mutex_unlock(frames->mutex);        return SDL_FALSE;    }    update_texture(screen, frame);    mutex_unlock(frames->mutex);    screen_render(screen);    return SDL_TRUE;}
SDL_bool screen_update_frame(struct screen *screen, struct video_buffer *vb) {    mutex_lock(vb->mutex);    const AVFrame *frame = video_buffer_consume_rendered_frame(vb);    struct size new_frame_size = {frame->width, frame->height};    if (!prepare_for_frame(screen, new_frame_size)) {        mutex_unlock(vb->mutex);        return SDL_FALSE;    }    update_texture(screen, frame);    mutex_unlock(vb->mutex);    screen_render(screen);    return SDL_TRUE;}
SDL_bool screen_update_frame(struct screen *screen, struct video_buffer *vb) {    mutex_lock(vb->mutex);    const AVFrame *frame = video_buffer_consume_rendered_frame(vb);    struct size new_frame_size = {frame->width, frame->height};    if (!prepare_for_frame(screen, new_frame_size)) {        mutex_unlock(vb->mutex);        return SDL_FALSE;    }    update_texture(screen, frame);    mutex_unlock(vb->mutex);    screen_render(screen);    return SDL_TRUE;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .record_format = 0,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = SDL_FALSE,        .no_window = SDL_FALSE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,        .no_window = args.no_window,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-window\n"        "        Do not show window (only when screen recording is enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top", no_argument,       NULL, 'T'},        {"bit-rate",      required_argument, NULL, 'b'},        {"crop",          required_argument, NULL, 'c'},        {"fullscreen",    no_argument,       NULL, 'f'},        {"help",          no_argument,       NULL, 'h'},        {"max-size",      required_argument, NULL, 'm'},        {"no-window",     no_argument,       NULL, 'n'},        {"port",          required_argument, NULL, 'p'},        {"record",        required_argument, NULL, 'r'},        {"record-format", required_argument, NULL, 'f'},        {"serial",        required_argument, NULL, 's'},        {"show-touches",  no_argument,       NULL, 't'},        {"version",       no_argument,       NULL, 'v'},        {NULL,            0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:np:r:s:tTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = SDL_TRUE;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return SDL_FALSE;                }                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'n':                args->no_window = SDL_TRUE;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = SDL_TRUE;                break;            case 'T':                args->always_on_top = SDL_TRUE;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    if (args->no_window && !args->record_filename) {        LOGE("-n/--no-window requires screen recording (-r/--record)");        return SDL_FALSE;    }    if (args->no_window && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -n/--no-window");        return SDL_FALSE;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return SDL_FALSE;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return SDL_FALSE;        }    }    return SDL_TRUE;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .record_format = 0,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = SDL_FALSE,        .no_display = SDL_FALSE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,        .no_display = args.no_display,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top", no_argument,       NULL, 'T'},        {"bit-rate",      required_argument, NULL, 'b'},        {"crop",          required_argument, NULL, 'c'},        {"fullscreen",    no_argument,       NULL, 'f'},        {"help",          no_argument,       NULL, 'h'},        {"max-size",      required_argument, NULL, 'm'},        {"no-display",    no_argument,       NULL, 'N'},        {"port",          required_argument, NULL, 'p'},        {"record",        required_argument, NULL, 'r'},        {"record-format", required_argument, NULL, 'f'},        {"serial",        required_argument, NULL, 's'},        {"show-touches",  no_argument,       NULL, 't'},        {"version",       no_argument,       NULL, 'v'},        {NULL,            0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:Np:r:s:tTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = SDL_TRUE;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return SDL_FALSE;                }                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'N':                args->no_display = SDL_TRUE;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = SDL_TRUE;                break;            case 'T':                args->always_on_top = SDL_TRUE;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    if (args->no_display && !args->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return SDL_FALSE;    }    if (args->no_display && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return SDL_FALSE;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return SDL_FALSE;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return SDL_FALSE;        }    }    return SDL_TRUE;}
scrcpy(const struct scrcpy_options *options) {    SDL_bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    SDL_bool display = !options->no_window;    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            server_stop(&server);            ret = SDL_FALSE;            goto finally_destroy_server;        }        if (!file_handler_init(&file_handler, server.serial)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_video_buffer;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (display) {        if (!controller_init(&controller, device_socket)) {            ret = SDL_FALSE;            goto finally_stop_stream;        }        if (!controller_start(&controller)) {            ret = SDL_FALSE;            goto finally_destroy_controller;        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            ret = SDL_FALSE;            goto finally_stop_and_join_controller;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    ret = event_loop(display);    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    if (display) {        controller_stop(&controller);        controller_join(&controller);    }finally_destroy_controller:    if (display) {        controller_destroy(&controller);    }finally_stop_stream:    stream_stop(&stream);    // stop the server before stream_join() to wake up the stream    server_stop(&server);    stream_join(&stream);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    if (display) {        file_handler_stop(&file_handler);        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }finally_destroy_video_buffer:    if (display) {        video_buffer_destroy(&video_buffer);    }finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial,                                                     SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    SDL_bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    SDL_bool display = !options->no_display;    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            server_stop(&server);            ret = SDL_FALSE;            goto finally_destroy_server;        }        if (!file_handler_init(&file_handler, server.serial)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_video_buffer;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (display) {        if (!controller_init(&controller, device_socket)) {            ret = SDL_FALSE;            goto finally_stop_stream;        }        if (!controller_start(&controller)) {            ret = SDL_FALSE;            goto finally_destroy_controller;        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            ret = SDL_FALSE;            goto finally_stop_and_join_controller;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    ret = event_loop(display);    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    if (display) {        controller_stop(&controller);        controller_join(&controller);    }finally_destroy_controller:    if (display) {        controller_destroy(&controller);    }finally_stop_stream:    stream_stop(&stream);    // stop the server before stream_join() to wake up the stream    server_stop(&server);    stream_join(&stream);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    if (display) {        file_handler_stop(&file_handler);        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }finally_destroy_video_buffer:    if (display) {        video_buffer_destroy(&video_buffer);    }finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial,                                                     SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
    private void send(String deviceName, int width, int height) throws IOException {        byte[] buffer = new byte[DEVICE_NAME_FIELD_LENGTH + 4];        byte[] deviceNameBytes = deviceName.getBytes(StandardCharsets.UTF_8);        int len = Math.min(DEVICE_NAME_FIELD_LENGTH - 1, deviceNameBytes.length);        System.arraycopy(deviceNameBytes, 0, buffer, 0, len);        // byte[] are always 0-initialized in java, no need to set '\0' explicitly        buffer[DEVICE_NAME_FIELD_LENGTH] = (byte) (width >> 8);        buffer[DEVICE_NAME_FIELD_LENGTH + 1] = (byte) width;        buffer[DEVICE_NAME_FIELD_LENGTH + 2] = (byte) (height >> 8);        buffer[DEVICE_NAME_FIELD_LENGTH + 3] = (byte) height;        IO.writeFully(videoFd, buffer, 0, buffer.length);    }
    private void send(String deviceName, int width, int height) throws IOException {        byte[] buffer = new byte[DEVICE_NAME_FIELD_LENGTH + 4];        byte[] deviceNameBytes = deviceName.getBytes(StandardCharsets.UTF_8);        int len = StringUtils.getUtf8TruncationIndex(deviceNameBytes, DEVICE_NAME_FIELD_LENGTH - 1);        System.arraycopy(deviceNameBytes, 0, buffer, 0, len);        // byte[] are always 0-initialized in java, no need to set '\0' explicitly        buffer[DEVICE_NAME_FIELD_LENGTH] = (byte) (width >> 8);        buffer[DEVICE_NAME_FIELD_LENGTH + 1] = (byte) width;        buffer[DEVICE_NAME_FIELD_LENGTH + 2] = (byte) (height >> 8);        buffer[DEVICE_NAME_FIELD_LENGTH + 3] = (byte) height;        IO.writeFully(videoFd, buffer, 0, buffer.length);    }
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {        if (avio_ctx->eof_reached) {            av_packet_unref(&packet);            goto run_quit;        }// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        av_packet_unref(&packet);    }    LOGD("End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    SDL_bool ret = SDL_TRUE;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, max_size, bit_rate);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }#if SDL_VERSION_ATLEAST(2, 0, 5)    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable mouse focus clickthrough");    }#endif    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_Surface *icon = IMG_ReadXPMFromArray(icon_xpm);    if (!icon) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not load icon: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_SetWindowIcon(window, icon);    SDL_FreeSurface(icon);    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    SDL_bool ret = SDL_TRUE;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, max_size, bit_rate);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }#if SDL_VERSION_ATLEAST(2, 0, 5)    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable mouse focus clickthrough");    }#endif    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not load icon: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_SetWindowIcon(window, icon);    SDL_FreeSurface(icon);    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
server_stop(struct server *server) {    SDL_assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Cannot terminate server");    }    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->tunnel_enabled) {        // ignore failure        disable_tunnel(server);    }}
server_destroy(struct server *server) {    if (server->server_socket != INVALID_SOCKET) {        close_socket(&server->server_socket);    }    if (server->device_socket != INVALID_SOCKET) {        close_socket(&server->device_socket);    }    SDL_free(server->serial);}
server_stop(struct server *server) {    if (server->server_socket != INVALID_SOCKET) {        close_socket(&server->server_socket);    }    if (server->device_socket != INVALID_SOCKET) {        close_socket(&server->device_socket);    }    SDL_assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Cannot terminate server");    }    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->tunnel_enabled) {        // ignore failure        disable_tunnel(server);    }}
    if (server->tunnel_enabled) {        // ignore failure        disable_tunnel(server);    }}voidserver_destroy(struct server *server) {    SDL_free(server->serial);}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options] [serial]\n"        "\n"        "    serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "        resize window to optimal size (remove black borders)\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "        click on BACK\n"        "\n"        "    Ctrl+m\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+'+'\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+'-'\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click\n"        "        turn screen on\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static int parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"help",     no_argument,       NULL, 'h'},        {"port",     required_argument, NULL, 'p'},        {"max-size", required_argument, NULL, 'm'},        {"bit-rate", required_argument, NULL, 'b'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "hp:m:b:", long_options, NULL)) != -1) {        switch (c) {            case 'h': {                args->help = SDL_TRUE;                break;            }            case 'p': {                char *endptr;                if (*optarg == '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                if (*endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld", value);                    return -1;                }                args->port = (Uint16) value;                break;            }            case 'm': {                char *endptr;                if (*optarg == '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Max size parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                if (*endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid max size: %s", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Max size must be between 0 and 65535: %ld", value);                    return -1;                }                args->max_size = (Uint16) value;                break;            }            case 'b': {                char *endptr;                if (*optarg == '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Bit-rate parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                int mul = 1;                if (*endptr != '\0') {                    if (optarg == endptr) {                        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid bit-rate: %s", optarg);                        return -1;                    }                    if ((*endptr == 'M' || *endptr == 'm') && endptr[1] == '\0') {                        mul = 1000000;                    } else if ((*endptr == 'K' || *endptr == 'k') && endptr[1] == '\0') {                        mul = 1000;                    } else {                        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid bit-rate unit: %s", optarg);                        return -1;                    }                }                if (value < 0 || ((Uint32) -1) / mul < value) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Bitrate must be positive and less than 2^32: %s", optarg);                    return -1;                }                args->bit_rate = (Uint32) value * mul;                break;            }            default:                // getopt prints the error message on stderr                return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s", argv[index]);        return -1;    }    return 0;}
int main(int argc, char *argv[]) {    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (parse_args(&args, argc, argv)) {        usage(argv[0]);        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    int res = scrcpy(args.serial, args.port, args.max_size, args.bit_rate) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options] [serial]\n"        "\n"        "    serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "        resize window to optimal size (remove black borders)\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "        click on BACK\n"        "\n"        "    Ctrl+m\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+'+'\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+'-'\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click\n"        "        turn screen on\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static int parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"help",     no_argument,       NULL, 'h'},        {"port",     required_argument, NULL, 'p'},        {"max-size", required_argument, NULL, 'm'},        {"bit-rate", required_argument, NULL, 'b'},        {"version",  no_argument,       NULL, 'v'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "hvp:m:b:", long_options, NULL)) != -1) {        switch (c) {            case 'h': {                args->help = SDL_TRUE;                break;            }            case 'v': {                args->version = SDL_TRUE;                break;            }            case 'p': {                char *endptr;                if (*optarg == '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                if (*endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld", value);                    return -1;                }                args->port = (Uint16) value;                break;            }            case 'm': {                char *endptr;                if (*optarg == '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Max size parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                if (*endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid max size: %s", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Max size must be between 0 and 65535: %ld", value);                    return -1;                }                args->max_size = (Uint16) value;                break;            }            case 'b': {                char *endptr;                if (*optarg == '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Bit-rate parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                int mul = 1;                if (*endptr != '\0') {                    if (optarg == endptr) {                        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid bit-rate: %s", optarg);                        return -1;                    }                    if ((*endptr == 'M' || *endptr == 'm') && endptr[1] == '\0') {                        mul = 1000000;                    } else if ((*endptr == 'K' || *endptr == 'k') && endptr[1] == '\0') {                        mul = 1000;                    } else {                        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid bit-rate unit: %s", optarg);                        return -1;                    }                }                if (value < 0 || ((Uint32) -1) / mul < value) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Bitrate must be positive and less than 2^32: %s", optarg);                    return -1;                }                args->bit_rate = (Uint32) value * mul;                break;            }            default:                // getopt prints the error message on stderr                return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s", argv[index]);        return -1;    }    return 0;}
int main(int argc, char *argv[]) {    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (parse_args(&args, argc, argv)) {        usage(argv[0]);        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        fprintf(stderr, "scrcpy v%s\n", SCRCPY_VERSION);        return 0;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    int res = scrcpy(args.serial, args.port, args.max_size, args.bit_rate) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
HANDLE cmd_execute(const char *path, const char *const argv[]) {    STARTUPINFO si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    // Windows command-line parsing is WTF:    // <http://daviddeley.com/autohotkey/parameters/parameters.htm#WINPASS>    // only make it work for this very specific program    // (don't handle escaping nor quotes)    char cmd[256];    size_t ret = xstrjoin(cmd, argv, ' ', sizeof(cmd));    if (ret >= sizeof(cmd)) {        LOGE("Command too long (%" PRIsizet " chars)", sizeof(cmd) - 1);        return NULL;    }    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi)) {        return NULL;    }    return pi.hProcess;}
HANDLE cmd_execute(const char *path, const char *const argv[]) {    STARTUPINFO si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    // Windows command-line parsing is WTF:    // <http://daviddeley.com/autohotkey/parameters/parameters.htm#WINPASS>    // only make it work for this very specific program    // (don't handle escaping nor quotes)    char cmd[256];    size_t ret = xstrjoin(cmd, argv, ' ', sizeof(cmd));    if (ret >= sizeof(cmd)) {        LOGE("Command too long (%" PRIsizet " chars)", sizeof(cmd) - 1);        return NULL;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, flags, NULL, NULL, &si, &pi)) {        return NULL;    }    return pi.hProcess;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {        if (decoder->recorder) {            // do not record configuration packets            // (they contain no media data and have no PTS/DTS)            // FIXME do not use MediaCodec specific flags            if (!(decoder->buffer_info_flags & MEDIA_CODEC_FLAG_CONFIG)) {                packet.pts = decoder->pts;                packet.dts = decoder->pts;                // no need to rescale with av_packet_rescale_ts(), the timestamps                // are in microseconds both in input and output                if (!recorder_write(decoder->recorder, &packet)) {                    LOGE("Could not write frame to output file");                    av_packet_unref(&packet);                    goto run_quit;                }            }        }// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        if (decoder->recorder) {            // do not record configuration packets            // (they contain no media data and have no PTS/DTS)            // FIXME do not use MediaCodec specific flags            if (!(decoder->buffer_info_flags & MEDIA_CODEC_FLAG_CONFIG)) {                packet.pts = decoder->pts;                packet.dts = decoder->pts;                // no need to rescale with av_packet_rescale_ts(), the timestamps                // are in microseconds both in input and output                if (!recorder_write(decoder->recorder, &packet)) {                    LOGE("Could not write frame to output file");                    av_packet_unref(&packet);                    goto run_quit;                }            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static void usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        // Some devices internally create a Handler when creating an input Surface, causing an exception:        //   "Can't create handler inside thread that has not called Looper.prepare()"        // <https://github.com/Genymobile/scrcpy/issues/240>        //        // Use Looper.prepareMainLooper() instead of Looper.prepare() to avoid a NullPointerException:        //   "Attempt to read from field 'android.os.MessageQueue android.os.Looper.mQueue'        //    on a null object reference"        // <https://github.com/Genymobile/scrcpy/issues/921>        Looper.prepareMainLooper();        MediaFormat format = createFormat(bitRate, frameRate, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                Rect contentRect = device.getScreenInfo().getContentRect();                Rect videoRect = device.getScreenInfo().getVideoSize().toRect();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, contentRect, videoRect);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate) {        this(sendFrameMeta, bitRate, DEFAULT_FRAME_RATE, DEFAULT_I_FRAME_INTERVAL);    }
    private static MediaFormat createFormat(int bitRate, int frameRate, int iFrameInterval) throws IOException {        MediaFormat format = new MediaFormat();        format.setString(MediaFormat.KEY_MIME, "video/avc");        format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);        format.setInteger(MediaFormat.KEY_FRAME_RATE, frameRate);        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iFrameInterval);        // display the very first frame, and recover from bad quality when no new frames        format.setLong(MediaFormat.KEY_REPEAT_PREVIOUS_FRAME_AFTER, MICROSECONDS_IN_ONE_SECOND * REPEAT_FRAME_DELAY / frameRate); // µs        return format;    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate) {        this(sendFrameMeta, bitRate, DEFAULT_FRAME_RATE, DEFAULT_I_FRAME_INTERVAL);    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int frameRate, int iFrameInterval) {        this.sendFrameMeta = sendFrameMeta;        this.bitRate = bitRate;        this.frameRate = frameRate;        this.iFrameInterval = iFrameInterval;    }
    private static MediaFormat createFormat(int bitRate, int frameRate, int iFrameInterval) throws IOException {        MediaFormat format = new MediaFormat();        format.setString(MediaFormat.KEY_MIME, "video/avc");        format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);        format.setInteger(MediaFormat.KEY_FRAME_RATE, frameRate);        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iFrameInterval);        // display the very first frame, and recover from bad quality when no new frames        format.setLong(MediaFormat.KEY_REPEAT_PREVIOUS_FRAME_AFTER, MICROSECONDS_IN_ONE_SECOND * REPEAT_FRAME_DELAY / frameRate); // µs        return format;    }
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        // Some devices internally create a Handler when creating an input Surface, causing an exception:        //   "Can't create handler inside thread that has not called Looper.prepare()"        // <https://github.com/Genymobile/scrcpy/issues/240>        //        // Use Looper.prepareMainLooper() instead of Looper.prepare() to avoid a NullPointerException:        //   "Attempt to read from field 'android.os.MessageQueue android.os.Looper.mQueue'        //    on a null object reference"        // <https://github.com/Genymobile/scrcpy/issues/921>        Looper.prepareMainLooper();        MediaFormat format = createFormat(bitRate, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                Rect contentRect = device.getScreenInfo().getContentRect();                Rect videoRect = device.getScreenInfo().getVideoSize().toRect();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, contentRect, videoRect);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int iFrameInterval) {        this.sendFrameMeta = sendFrameMeta;        this.bitRate = bitRate;        this.iFrameInterval = iFrameInterval;    }
    private static MediaFormat createFormat(int bitRate, int iFrameInterval) throws IOException {        MediaFormat format = new MediaFormat();        format.setString(MediaFormat.KEY_MIME, "video/avc");        format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);        // must be present to configure the encoder, but does not impact the actual frame rate, which is variable        format.setInteger(MediaFormat.KEY_FRAME_RATE, 60);        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iFrameInterval);        // display the very first frame, and recover from bad quality when no new frames        format.setLong(MediaFormat.KEY_REPEAT_PREVIOUS_FRAME_AFTER, REPEAT_FRAME_DELAY_US); // µs        return format;    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate) {        this(sendFrameMeta, bitRate, DEFAULT_I_FRAME_INTERVAL);    }
    }    public ScreenEncoder(boolean sendFrameMeta, int bitRate) {        this(sendFrameMeta, bitRate, DEFAULT_I_FRAME_INTERVAL);    }    @Override
        format.setInteger(MediaFormat.KEY_FRAME_RATE, 60);        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iFrameInterval);        // display the very first frame, and recover from bad quality when no new frames        format.setLong(MediaFormat.KEY_REPEAT_PREVIOUS_FRAME_AFTER, REPEAT_FRAME_DELAY_US); // µs        return format;    }    private static IBinder createDisplay() {        return SurfaceControl.createDisplay("scrcpy", true);    }
static void send_keycode(struct controller *controller, enum android_keycode keycode, const char *name) {    // send DOWN event    struct control_event control_event = {        .type = CONTROL_EVENT_TYPE_KEYCODE,        .keycode_event = {            .action = AKEY_EVENT_ACTION_DOWN,            .keycode = keycode,            .metastate = 0,        },    };    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot send %s (DOWN)", name);        return;    }    // send UP event    control_event.keycode_event.action = AKEY_EVENT_ACTION_UP;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot send %s (UP)", name);    }}
static void turn_screen_on(struct controller *controller) {    struct control_event control_event = {        .type = CONTROL_EVENT_TYPE_COMMAND,        .command_event = {            .action = CONTROL_EVENT_COMMAND_SCREEN_ON,        },    };    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot turn screen on");    }}
static void send_keycode(struct controller *controller, enum android_keycode keycode, const char *name) {    // send DOWN event    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_KEYCODE;    control_event.keycode_event.action = AKEY_EVENT_ACTION_DOWN;    control_event.keycode_event.keycode = keycode;    control_event.keycode_event.metastate = 0;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot send %s (DOWN)", name);        return;    }    // send UP event    control_event.keycode_event.action = AKEY_EVENT_ACTION_UP;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot send %s (UP)", name);    }}
static void turn_screen_on(struct controller *controller) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_COMMAND;    control_event.command_event.action = CONTROL_EVENT_COMMAND_SCREEN_ON;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot turn screen on");    }}
int main(void) {    test_xstrncpy_simple();    test_xstrncpy_just_fit();    test_xstrncpy_truncated();    test_xstrjoin_simple();    test_xstrjoin_just_fit();    test_xstrjoin_truncated_in_token();    test_xstrjoin_truncated_before_sep();    test_xstrjoin_truncated_after_sep();    test_utf8_truncate();    return 0;}
int main(void) {    test_xstrncpy_simple();    test_xstrncpy_just_fit();    test_xstrncpy_truncated();    test_xstrjoin_simple();    test_xstrjoin_just_fit();    test_xstrjoin_truncated_in_token();    test_xstrjoin_truncated_before_sep();    test_xstrjoin_truncated_after_sep();    test_strquote();    test_utf8_truncate();    return 0;}
    return w == length;}static intrun_controller(void *data) {    struct controller *controller = data;    for (;;) {        mutex_lock(controller->mutex);        while (!controller->stopped && cbuf_is_empty(&controller->queue)) {            cond_wait(controller->event_cond, controller->mutex);        }        if (controller->stopped) {            // stop immediately, do not process further events
controller_stop(struct controller *controller) {    mutex_lock(controller->mutex);    controller->stopped = true;    cond_signal(controller->event_cond);    mutex_unlock(controller->mutex);}
controller_destroy(struct controller *controller) {    SDL_DestroyCond(controller->event_cond);    SDL_DestroyMutex(controller->mutex);    struct control_event event;    while (cbuf_take(&controller->queue, &event)) {        control_event_destroy(&event);    }    receiver_destroy(&controller->receiver);}
controller_init(struct controller *controller, socket_t control_socket) {    cbuf_init(&controller->queue);    if (!receiver_init(&controller->receiver, control_socket)) {        return false;    }    if (!(controller->mutex = SDL_CreateMutex())) {        receiver_destroy(&controller->receiver);        return false;    }    if (!(controller->event_cond = SDL_CreateCond())) {        receiver_destroy(&controller->receiver);        SDL_DestroyMutex(controller->mutex);        return false;    }    controller->control_socket = control_socket;    controller->stopped = false;    return true;}
controller_push_event(struct controller *controller,                      const struct control_event *event) {    mutex_lock(controller->mutex);    bool was_empty = cbuf_is_empty(&controller->queue);    bool res = cbuf_push(&controller->queue, *event);    if (was_empty) {        cond_signal(controller->event_cond);    }    mutex_unlock(controller->mutex);    return res;}
run_controller(void *data) {    struct controller *controller = data;    for (;;) {        mutex_lock(controller->mutex);        while (!controller->stopped && cbuf_is_empty(&controller->queue)) {            cond_wait(controller->event_cond, controller->mutex);        }        if (controller->stopped) {            // stop immediately, do not process further events            mutex_unlock(controller->mutex);            break;        }        struct control_event event;        bool non_empty = cbuf_take(&controller->queue, &event);        SDL_assert(non_empty);        mutex_unlock(controller->mutex);        bool ok = process_event(controller, &event);        control_event_destroy(&event);        if (!ok) {            LOGD("Cannot write event to socket");            break;        }    }    return 0;}
run_controller(void *data) {    struct controller *controller = data;    for (;;) {        mutex_lock(controller->mutex);        while (!controller->stopped && cbuf_is_empty(&controller->queue)) {            cond_wait(controller->event_cond, controller->mutex);        }        if (controller->stopped) {            // stop immediately, do not process further events            mutex_unlock(controller->mutex);            break;        }        struct control_event event;        bool non_empty = cbuf_take(&controller->queue, &event);        SDL_assert(non_empty);        mutex_unlock(controller->mutex);        bool ok = process_event(controller, &event);        control_event_destroy(&event);        if (!ok) {            LOGD("Cannot write event to socket");            break;        }    }    return 0;}
process_event(struct controller *controller,              const struct control_event *event) {    unsigned char serialized_event[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int length = control_event_serialize(event, serialized_event);    if (!length) {        return false;    }    int w = net_send_all(controller->control_socket, serialized_event, length);    return w == length;}
process_msg(struct controller *controller,              const struct control_msg *msg) {    unsigned char serialized_msg[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int length = control_msg_serialize(msg, serialized_msg);    if (!length) {        return false;    }    int w = net_send_all(controller->control_socket, serialized_msg, length);    return w == length;}
controller_stop(struct controller *controller) {    mutex_lock(controller->mutex);    controller->stopped = true;    cond_signal(controller->msg_cond);    mutex_unlock(controller->mutex);}
controller_destroy(struct controller *controller) {    SDL_DestroyCond(controller->msg_cond);    SDL_DestroyMutex(controller->mutex);    struct control_msg msg;    while (cbuf_take(&controller->queue, &msg)) {        control_msg_destroy(&msg);    }    receiver_destroy(&controller->receiver);}
controller_init(struct controller *controller, socket_t control_socket) {    cbuf_init(&controller->queue);    if (!receiver_init(&controller->receiver, control_socket)) {        return false;    }    if (!(controller->mutex = SDL_CreateMutex())) {        receiver_destroy(&controller->receiver);        return false;    }    if (!(controller->msg_cond = SDL_CreateCond())) {        receiver_destroy(&controller->receiver);        SDL_DestroyMutex(controller->mutex);        return false;    }    controller->control_socket = control_socket;    controller->stopped = false;    return true;}
controller_push_msg(struct controller *controller,                      const struct control_msg *msg) {    mutex_lock(controller->mutex);    bool was_empty = cbuf_is_empty(&controller->queue);    bool res = cbuf_push(&controller->queue, *msg);    if (was_empty) {        cond_signal(controller->msg_cond);    }    mutex_unlock(controller->mutex);    return res;}
run_controller(void *data) {    struct controller *controller = data;    for (;;) {        mutex_lock(controller->mutex);        while (!controller->stopped && cbuf_is_empty(&controller->queue)) {            cond_wait(controller->msg_cond, controller->mutex);        }        if (controller->stopped) {            // stop immediately, do not process further msgs            mutex_unlock(controller->mutex);            break;        }        struct control_msg msg;        bool non_empty = cbuf_take(&controller->queue, &msg);        SDL_assert(non_empty);        mutex_unlock(controller->mutex);        bool ok = process_msg(controller, &msg);        control_msg_destroy(&msg);        if (!ok) {            LOGD("Cannot write msg to socket");            break;        }    }    return 0;}
controller_push_msg(struct controller *controller,                      const struct control_msg *msg) {    mutex_lock(controller->mutex);    bool was_empty = cbuf_is_empty(&controller->queue);    bool res = cbuf_push(&controller->queue, *msg);    if (was_empty) {        cond_signal(controller->msg_cond);    }    mutex_unlock(controller->mutex);    return res;}
process_msg(struct controller *controller,              const struct control_msg *msg) {    unsigned char serialized_msg[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int length = control_msg_serialize(msg, serialized_msg);    if (!length) {        return false;    }    int w = net_send_all(controller->control_socket, serialized_msg, length);    return w == length;}
mouse_button_from_sdl_to_android(const SDL_MouseButtonEvent *from,                                 struct size screen_size,                                 struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    if (!convert_mouse_action(from->type, &to->mouse_event.action)) {        return false;    }    to->mouse_event.buttons = convert_mouse_buttons(SDL_BUTTON(from->button));    to->mouse_event.position.screen_size = screen_size;    to->mouse_event.position.point.x = from->x;    to->mouse_event.position.point.y = from->y;    return true;}
mouse_button_from_sdl_to_android(const SDL_MouseButtonEvent *from,                                 struct size screen_size,                                 struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    if (!convert_mouse_action(from->type, &to->mouse_event.action)) {        return false;    }    to->mouse_event.buttons = convert_mouse_buttons(SDL_BUTTON(from->button));    to->mouse_event.position.screen_size = screen_size;    to->mouse_event.position.point.x = from->x;    to->mouse_event.position.point.y = from->y;    return true;}
input_key_from_sdl_to_android(const SDL_KeyboardEvent *from,                              struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_KEYCODE;    if (!convert_keycode_action(from->type, &to->keycode_event.action)) {        return false;    }    uint16_t mod = from->keysym.mod;    if (!convert_keycode(from->keysym.sym, &to->keycode_event.keycode, mod)) {        return false;    }    to->keycode_event.metastate = convert_meta_state(mod);    return true;}
input_key_from_sdl_to_android(const SDL_KeyboardEvent *from,                              struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_KEYCODE;    if (!convert_keycode_action(from->type, &to->keycode_event.action)) {        return false;    }    uint16_t mod = from->keysym.mod;    if (!convert_keycode(from->keysym.sym, &to->keycode_event.keycode, mod)) {        return false;    }    to->keycode_event.metastate = convert_meta_state(mod);    return true;}
mouse_motion_from_sdl_to_android(const SDL_MouseMotionEvent *from,                                 struct size screen_size,                                 struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    to->mouse_event.action = AMOTION_EVENT_ACTION_MOVE;    to->mouse_event.buttons = convert_mouse_buttons(from->state);    to->mouse_event.position.screen_size = screen_size;    to->mouse_event.position.point.x = from->x;    to->mouse_event.position.point.y = from->y;    return true;}
mouse_wheel_from_sdl_to_android(const SDL_MouseWheelEvent *from,                                struct position position,                                struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_SCROLL;    to->scroll_event.position = position;    int mul = from->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    // SDL behavior seems inconsistent between horizontal and vertical scrolling    // so reverse the horizontal    // <https://wiki.libsdl.org/SDL_MouseWheelEvent#Remarks>    to->scroll_event.hscroll = -mul * from->x;    to->scroll_event.vscroll = mul * from->y;    return true;}
mouse_motion_from_sdl_to_android(const SDL_MouseMotionEvent *from,                                 struct size screen_size,                                 struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    to->mouse_event.action = AMOTION_EVENT_ACTION_MOVE;    to->mouse_event.buttons = convert_mouse_buttons(from->state);    to->mouse_event.position.screen_size = screen_size;    to->mouse_event.position.point.x = from->x;    to->mouse_event.position.point.y = from->y;    return true;}
mouse_wheel_from_sdl_to_android(const SDL_MouseWheelEvent *from,                                struct position position,                                struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_SCROLL;    to->scroll_event.position = position;    int mul = from->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    // SDL behavior seems inconsistent between horizontal and vertical scrolling    // so reverse the horizontal    // <https://wiki.libsdl.org/SDL_MouseWheelEvent#Remarks>    to->scroll_event.hscroll = -mul * from->x;    to->scroll_event.vscroll = mul * from->y;    return true;}
mouse_button_from_sdl_to_android(const SDL_MouseButtonEvent *from,                                 struct size screen_size,                                 struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_MOUSE_EVENT;    if (!convert_mouse_action(from->type, &to->inject_mouse_event.action)) {        return false;    }    to->inject_mouse_event.buttons =        convert_mouse_buttons(SDL_BUTTON(from->button));    to->inject_mouse_event.position.screen_size = screen_size;    to->inject_mouse_event.position.point.x = from->x;    to->inject_mouse_event.position.point.y = from->y;    return true;}
mouse_button_from_sdl_to_android(const SDL_MouseButtonEvent *from,                                 struct size screen_size,                                 struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_MOUSE_EVENT;    if (!convert_mouse_action(from->type, &to->inject_mouse_event.action)) {        return false;    }    to->inject_mouse_event.buttons =        convert_mouse_buttons(SDL_BUTTON(from->button));    to->inject_mouse_event.position.screen_size = screen_size;    to->inject_mouse_event.position.point.x = from->x;    to->inject_mouse_event.position.point.y = from->y;    return true;}
input_key_from_sdl_to_android(const SDL_KeyboardEvent *from,                              struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_KEYCODE;    if (!convert_keycode_action(from->type, &to->inject_keycode.action)) {        return false;    }    uint16_t mod = from->keysym.mod;    if (!convert_keycode(from->keysym.sym, &to->inject_keycode.keycode, mod)) {        return false;    }    to->inject_keycode.metastate = convert_meta_state(mod);    return true;}
input_key_from_sdl_to_android(const SDL_KeyboardEvent *from,                              struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_KEYCODE;    if (!convert_keycode_action(from->type, &to->inject_keycode.action)) {        return false;    }    uint16_t mod = from->keysym.mod;    if (!convert_keycode(from->keysym.sym, &to->inject_keycode.keycode, mod)) {        return false;    }    to->inject_keycode.metastate = convert_meta_state(mod);    return true;}
boolmouse_motion_from_sdl_to_android(const SDL_MouseMotionEvent *from,                                 struct size screen_size,                                 struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_MOUSE_EVENT;    to->inject_mouse_event.action = AMOTION_EVENT_ACTION_MOVE;    to->inject_mouse_event.buttons = convert_mouse_buttons(from->state);    to->inject_mouse_event.position.screen_size = screen_size;    to->inject_mouse_event.position.point.x = from->x;    to->inject_mouse_event.position.point.y = from->y;    return true;}
boolmouse_wheel_from_sdl_to_android(const SDL_MouseWheelEvent *from,                                struct position position,                                struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT;    to->inject_scroll_event.position = position;    int mul = from->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    // SDL behavior seems inconsistent between horizontal and vertical scrolling    // so reverse the horizontal    // <https://wiki.libsdl.org/SDL_MouseWheelEvent#Remarks>    to->inject_scroll_event.hscroll = -mul * from->x;    to->inject_scroll_event.vscroll = mul * from->y;    return true;}
mouse_motion_from_sdl_to_android(const SDL_MouseMotionEvent *from,                                 struct size screen_size,                                 struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_MOUSE_EVENT;    to->inject_mouse_event.action = AMOTION_EVENT_ACTION_MOVE;    to->inject_mouse_event.buttons = convert_mouse_buttons(from->state);    to->inject_mouse_event.position.screen_size = screen_size;    to->inject_mouse_event.position.point.x = from->x;    to->inject_mouse_event.position.point.y = from->y;    return true;}
mouse_wheel_from_sdl_to_android(const SDL_MouseWheelEvent *from,                                struct position position,                                struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT;    to->inject_scroll_event.position = position;    int mul = from->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    // SDL behavior seems inconsistent between horizontal and vertical scrolling    // so reverse the horizontal    // <https://wiki.libsdl.org/SDL_MouseWheelEvent#Remarks>    to->inject_scroll_event.hscroll = -mul * from->x;    to->inject_scroll_event.vscroll = mul * from->y;    return true;}
device_event_deserialize(const unsigned char *buf, size_t len,                         struct device_event *event) {    if (len < 3) {        // at least type + empty string length        return 0; // not available    }    event->type = buf[0];    switch (event->type) {        case DEVICE_EVENT_TYPE_GET_CLIPBOARD: {            uint16_t clipboard_len = buffer_read16be(&buf[1]);            if (clipboard_len > len - 3) {                return 0; // not available            }            char *text = SDL_malloc(clipboard_len + 1);            if (!text) {                LOGW("Could not allocate text for clipboard");                return -1;            }            if (clipboard_len) {                memcpy(text, &buf[3], clipboard_len);            }            text[clipboard_len] = '\0';            event->clipboard_event.text = text;            return 3 + clipboard_len;        }        default:            LOGW("Unsupported device event type: %d", (int) event->type);            return -1; // error, we cannot recover    }}
device_event_deserialize(const unsigned char *buf, size_t len,                         struct device_event *event) {    if (len < 3) {        // at least type + empty string length        return 0; // not available    }    event->type = buf[0];    switch (event->type) {        case DEVICE_EVENT_TYPE_GET_CLIPBOARD: {            uint16_t clipboard_len = buffer_read16be(&buf[1]);            if (clipboard_len > len - 3) {                return 0; // not available            }            char *text = SDL_malloc(clipboard_len + 1);            if (!text) {                LOGW("Could not allocate text for clipboard");                return -1;            }            if (clipboard_len) {                memcpy(text, &buf[3], clipboard_len);            }            text[clipboard_len] = '\0';            event->clipboard_event.text = text;            return 3 + clipboard_len;        }        default:            LOGW("Unsupported device event type: %d", (int) event->type);            return -1; // error, we cannot recover    }}
device_event_destroy(struct device_event *event) {    if (event->type == DEVICE_EVENT_TYPE_GET_CLIPBOARD) {        SDL_free(event->clipboard_event.text);    }}
device_msg_deserialize(const unsigned char *buf, size_t len,                       struct device_msg *msg) {    if (len < 3) {        // at least type + empty string length        return 0; // not available    }    msg->type = buf[0];    switch (msg->type) {        case DEVICE_MSG_TYPE_CLIPBOARD: {            uint16_t clipboard_len = buffer_read16be(&buf[1]);            if (clipboard_len > len - 3) {                return 0; // not available            }            char *text = SDL_malloc(clipboard_len + 1);            if (!text) {                LOGW("Could not allocate text for clipboard");                return -1;            }            if (clipboard_len) {                memcpy(text, &buf[3], clipboard_len);            }            text[clipboard_len] = '\0';            msg->clipboard.text = text;            return 3 + clipboard_len;        }        default:            LOGW("Unknown device message type: %d", (int) msg->type);            return -1; // error, we cannot recover    }}
device_msg_deserialize(const unsigned char *buf, size_t len,                       struct device_msg *msg) {    if (len < 3) {        // at least type + empty string length        return 0; // not available    }    msg->type = buf[0];    switch (msg->type) {        case DEVICE_MSG_TYPE_CLIPBOARD: {            uint16_t clipboard_len = buffer_read16be(&buf[1]);            if (clipboard_len > len - 3) {                return 0; // not available            }            char *text = SDL_malloc(clipboard_len + 1);            if (!text) {                LOGW("Could not allocate text for clipboard");                return -1;            }            if (clipboard_len) {                memcpy(text, &buf[3], clipboard_len);            }            text[clipboard_len] = '\0';            msg->clipboard.text = text;            return 3 + clipboard_len;        }        default:            LOGW("Unknown device message type: %d", (int) msg->type);            return -1; // error, we cannot recover    }}
device_msg_destroy(struct device_msg *msg) {    if (msg->type == DEVICE_MSG_TYPE_CLIPBOARD) {        SDL_free(msg->clipboard.text);    }}
collapse_notification_panel(struct controller *controller) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_COLLAPSE_NOTIFICATION_PANEL;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot collapse notification panel");    }}
expand_notification_panel(struct controller *controller) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_EXPAND_NOTIFICATION_PANEL;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot expand notification panel");    }}
press_back_or_turn_screen_on(struct controller *controller) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_BACK_OR_SCREEN_ON;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot turn screen on");    }}
clipboard_paste(struct controller *controller) {    char *text = SDL_GetClipboardText();    if (!text) {        LOGW("Cannot get clipboard text: %s", SDL_GetError());        return;    }    if (!*text) {        // empty text        SDL_free(text);        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    control_event.text_event.text = text;    if (!controller_push_event(controller, &control_event)) {        SDL_free(text);        LOGW("Cannot send clipboard paste event");    }}
input_manager_process_text_input(struct input_manager *input_manager,                                 const SDL_TextInputEvent *event) {    char c = event->text[0];    if (isalpha(c) || c == ' ') {        SDL_assert(event->text[1] == '\0');        // letters and space are handled as raw key event        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    control_event.text_event.text = SDL_strdup(event->text);    if (!control_event.text_event.text) {        LOGW("Cannot strdup input text");        return;    }    if (!controller_push_event(input_manager->controller, &control_event)) {        SDL_free(control_event.text_event.text);        LOGW("Cannot send text event");    }}
set_device_clipboard(struct controller *controller) {    char *text = SDL_GetClipboardText();    if (!text) {        LOGW("Cannot get clipboard text: %s", SDL_GetError());        return;    }    if (!*text) {        // empty text        SDL_free(text);        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_SET_CLIPBOARD;    control_event.set_clipboard_event.text = text;    if (!controller_push_event(controller, &control_event)) {        SDL_free(text);        LOGW("Cannot send clipboard paste event");    }}
send_keycode(struct controller *controller, enum android_keycode keycode,             int actions, const char *name) {    // send DOWN event    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_KEYCODE;    control_event.keycode_event.keycode = keycode;    control_event.keycode_event.metastate = 0;    if (actions & ACTION_DOWN) {        control_event.keycode_event.action = AKEY_EVENT_ACTION_DOWN;        if (!controller_push_event(controller, &control_event)) {            LOGW("Cannot send %s (DOWN)", name);            return;        }    }    if (actions & ACTION_UP) {        control_event.keycode_event.action = AKEY_EVENT_ACTION_UP;        if (!controller_push_event(controller, &control_event)) {            LOGW("Cannot send %s (UP)", name);        }    }}
request_device_clipboard(struct controller *controller) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_GET_CLIPBOARD;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot get device clipboard");    }}
collapse_notification_panel(struct controller *controller) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL;    if (!controller_push_msg(controller, &msg)) {        LOGW("Cannot request 'collapse notification panel'");    }}
expand_notification_panel(struct controller *controller) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL;    if (!controller_push_msg(controller, &msg)) {        LOGW("Cannot request 'expand notification panel'");    }}
press_back_or_turn_screen_on(struct controller *controller) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON;    if (!controller_push_msg(controller, &msg)) {        LOGW("Cannot request 'turn screen on'");    }}
clipboard_paste(struct controller *controller) {    char *text = SDL_GetClipboardText();    if (!text) {        LOGW("Cannot get clipboard text: %s", SDL_GetError());        return;    }    if (!*text) {        // empty text        SDL_free(text);        return;    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    msg.inject_text.text = text;    if (!controller_push_msg(controller, &msg)) {        SDL_free(text);        LOGW("Cannot request 'paste clipboard'");    }}
input_manager_process_text_input(struct input_manager *input_manager,                                 const SDL_TextInputEvent *event) {    char c = event->text[0];    if (isalpha(c) || c == ' ') {        SDL_assert(event->text[1] == '\0');        // letters and space are handled as raw key event        return;    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_TEXT;    msg.inject_text.text = SDL_strdup(event->text);    if (!msg.inject_text.text) {        LOGW("Cannot strdup input text");        return;    }    if (!controller_push_msg(input_manager->controller, &msg)) {        SDL_free(msg.inject_text.text);        LOGW("Cannot request 'inject text'");    }}
set_device_clipboard(struct controller *controller) {    char *text = SDL_GetClipboardText();    if (!text) {        LOGW("Cannot get clipboard text: %s", SDL_GetError());        return;    }    if (!*text) {        // empty text        SDL_free(text);        return;    }    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_SET_CLIPBOARD;    msg.set_clipboard.text = text;    if (!controller_push_msg(controller, &msg)) {        SDL_free(text);        LOGW("Cannot request 'set device clipboard'");    }}
send_keycode(struct controller *controller, enum android_keycode keycode,             int actions, const char *name) {    // send DOWN event    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_INJECT_KEYCODE;    msg.inject_keycode.keycode = keycode;    msg.inject_keycode.metastate = 0;    if (actions & ACTION_DOWN) {        msg.inject_keycode.action = AKEY_EVENT_ACTION_DOWN;        if (!controller_push_msg(controller, &msg)) {            LOGW("Cannot request 'inject %s (DOWN)'", name);            return;        }    }    if (actions & ACTION_UP) {        msg.inject_keycode.action = AKEY_EVENT_ACTION_UP;        if (!controller_push_msg(controller, &msg)) {            LOGW("Cannot request 'inject %s (UP)'", name);        }    }}
request_device_clipboard(struct controller *controller) {    struct control_msg msg;    msg.type = CONTROL_MSG_TYPE_GET_CLIPBOARD;    if (!controller_push_msg(controller, &msg)) {        LOGW("Cannot request device clipboard");    }}
run_receiver(void *data) {    struct receiver *receiver = data;    unsigned char buf[DEVICE_EVENT_SERIALIZED_MAX_SIZE];    size_t head = 0;    for (;;) {        SDL_assert(head < DEVICE_EVENT_SERIALIZED_MAX_SIZE);        ssize_t r = net_recv(receiver->control_socket, buf,                             DEVICE_EVENT_SERIALIZED_MAX_SIZE - head);        if (r <= 0) {            LOGD("Receiver stopped");            break;        }        ssize_t consumed = process_events(receiver, buf, r);        if (consumed == -1) {            // an error occurred            break;        }        if (consumed) {            // shift the remaining data in the buffer            memmove(buf, &buf[consumed], r - consumed);            head = r - consumed;        }    }    return 0;}
run_receiver(void *data) {    struct receiver *receiver = data;    unsigned char buf[DEVICE_EVENT_SERIALIZED_MAX_SIZE];    size_t head = 0;    for (;;) {        SDL_assert(head < DEVICE_EVENT_SERIALIZED_MAX_SIZE);        ssize_t r = net_recv(receiver->control_socket, buf,                             DEVICE_EVENT_SERIALIZED_MAX_SIZE - head);        if (r <= 0) {            LOGD("Receiver stopped");            break;        }        ssize_t consumed = process_events(receiver, buf, r);        if (consumed == -1) {            // an error occurred            break;        }        if (consumed) {            // shift the remaining data in the buffer            memmove(buf, &buf[consumed], r - consumed);            head = r - consumed;        }    }    return 0;}
process_event(struct receiver *receiver, struct device_event *event) {    switch (event->type) {        case DEVICE_EVENT_TYPE_GET_CLIPBOARD:            SDL_SetClipboardText(event->clipboard_event.text);            break;    }}
process_events(struct receiver *receiver, const unsigned char *buf,               size_t len) {    size_t head = 0;    for (;;) {        struct device_event event;        ssize_t r = device_event_deserialize(&buf[head], len - head, &event);        if (r == -1) {            return -1;        }        if (r == 0) {            return head;        }        process_event(receiver, &event);        device_event_destroy(&event);        head += r;        SDL_assert(head <= len);        if (head == len) {            return head;        }    }}
process_events(struct receiver *receiver, const unsigned char *buf,               size_t len) {    size_t head = 0;    for (;;) {        struct device_event event;        ssize_t r = device_event_deserialize(&buf[head], len - head, &event);        if (r == -1) {            return -1;        }        if (r == 0) {            return head;        }        process_event(receiver, &event);        device_event_destroy(&event);        head += r;        SDL_assert(head <= len);        if (head == len) {            return head;        }    }}
run_receiver(void *data) {    struct receiver *receiver = data;    unsigned char buf[DEVICE_MSG_SERIALIZED_MAX_SIZE];    size_t head = 0;    for (;;) {        SDL_assert(head < DEVICE_MSG_SERIALIZED_MAX_SIZE);        ssize_t r = net_recv(receiver->control_socket, buf,                             DEVICE_MSG_SERIALIZED_MAX_SIZE - head);        if (r <= 0) {            LOGD("Receiver stopped");            break;        }        ssize_t consumed = process_msgs(receiver, buf, r);        if (consumed == -1) {            // an error occurred            break;        }        if (consumed) {            // shift the remaining data in the buffer            memmove(buf, &buf[consumed], r - consumed);            head = r - consumed;        }    }    return 0;}
process_msg(struct receiver *receiver, struct device_msg *msg) {    switch (msg->type) {        case DEVICE_MSG_TYPE_CLIPBOARD:            SDL_SetClipboardText(msg->clipboard.text);            break;    }}
    switch (msg->type) {        case DEVICE_MSG_TYPE_CLIPBOARD:            SDL_SetClipboardText(msg->clipboard.text);            break;    }}static ssize_t
    size_t head = 0;    for (;;) {        struct device_msg msg;        ssize_t r = device_msg_deserialize(&buf[head], len - head, &msg);        if (r == -1) {            return -1;        }        if (r == 0) {            return head;        }        process_msg(receiver, &msg);        device_msg_destroy(&msg);        head += r;        SDL_assert(head <= len);        if (head == len) {            return head;        }    }}static intrun_receiver(void *data) {
process_msgs(struct receiver *receiver, const unsigned char *buf, size_t len) {    size_t head = 0;    for (;;) {        struct device_msg msg;        ssize_t r = device_msg_deserialize(&buf[head], len - head, &msg);        if (r == -1) {            return -1;        }        if (r == 0) {            return head;        }        process_msg(receiver, &msg);        device_msg_destroy(&msg);        head += r;        SDL_assert(head <= len);        if (head == len) {            return head;        }    }}
    public static ControlEvent createSimpleControlEvent(int type) {        ControlEvent event = new ControlEvent();        event.type = type;        return event;    }
    public static ControlEvent createTextControlEvent(String text) {        ControlEvent event = new ControlEvent();        event.type = TYPE_TEXT;        event.text = text;        return event;    }
    public static ControlEvent createTextControlEvent(String text) {        ControlEvent event = new ControlEvent();        event.type = TYPE_TEXT;        event.text = text;        return event;    }
    private ControlEvent() {    }
    private ControlEvent() {    }
    public static ControlEvent createScrollControlEvent(Position position, int hScroll, int vScroll) {        ControlEvent event = new ControlEvent();        event.type = TYPE_SCROLL;        event.position = position;        event.hScroll = hScroll;        event.vScroll = vScroll;        return event;    }
    public static ControlEvent createSetClipboardControlEvent(String text) {        ControlEvent event = new ControlEvent();        event.type = TYPE_SET_CLIPBOARD;        event.text = text;        return event;    }
    public static ControlEvent createSetClipboardControlEvent(String text) {        ControlEvent event = new ControlEvent();        event.type = TYPE_SET_CLIPBOARD;        event.text = text;        return event;    }
    public static ControlEvent createSetClipboardControlEvent(String text) {        ControlEvent event = new ControlEvent();        event.type = TYPE_SET_CLIPBOARD;        event.text = text;        return event;    }
    public static ControlEvent createMotionControlEvent(int action, int buttons, Position position) {        ControlEvent event = new ControlEvent();        event.type = TYPE_MOUSE;        event.action = action;        event.buttons = buttons;        event.position = position;        return event;    }
    public static ControlEvent createMotionControlEvent(int action, int buttons, Position position) {        ControlEvent event = new ControlEvent();        event.type = TYPE_MOUSE;        event.action = action;        event.buttons = buttons;        event.position = position;        return event;    }
    public static ControlEvent createMotionControlEvent(int action, int buttons, Position position) {        ControlEvent event = new ControlEvent();        event.type = TYPE_MOUSE;        event.action = action;        event.buttons = buttons;        event.position = position;        return event;    }
    public static ControlEvent createMotionControlEvent(int action, int buttons, Position position) {        ControlEvent event = new ControlEvent();        event.type = TYPE_MOUSE;        event.action = action;        event.buttons = buttons;        event.position = position;        return event;    }
    public static ControlEvent createKeycodeControlEvent(int action, int keycode, int metaState) {        ControlEvent event = new ControlEvent();        event.type = TYPE_KEYCODE;        event.action = action;        event.keycode = keycode;        event.metaState = metaState;        return event;    }
    public static ControlMessage createEmpty(int type) {        ControlMessage event = new ControlMessage();        event.type = type;        return event;    }
    public static ControlMessage createInjectText(String text) {        ControlMessage event = new ControlMessage();        event.type = TYPE_INJECT_TEXT;        event.text = text;        return event;    }
    public static ControlMessage createSetClipboard(String text) {        ControlMessage event = new ControlMessage();        event.type = TYPE_SET_CLIPBOARD;        event.text = text;        return event;    }
    private ControlMessage() {    }
    public static ControlMessage createEmpty(int type) {        ControlMessage event = new ControlMessage();        event.type = type;        return event;    }
    public static ControlMessage createInjectScrollEvent(Position position, int hScroll, int vScroll) {        ControlMessage event = new ControlMessage();        event.type = TYPE_INJECT_SCROLL_EVENT;        event.position = position;        event.hScroll = hScroll;        event.vScroll = vScroll;        return event;    }
    public static ControlMessage createSetClipboard(String text) {        ControlMessage event = new ControlMessage();        event.type = TYPE_SET_CLIPBOARD;        event.text = text;        return event;    }
    private ControlMessage() {    }
    public static ControlMessage createInjectText(String text) {        ControlMessage event = new ControlMessage();        event.type = TYPE_INJECT_TEXT;        event.text = text;        return event;    }
    public static ControlMessage createInjectMouseEvent(int action, int buttons, Position position) {        ControlMessage event = new ControlMessage();        event.type = TYPE_INJECT_MOUSE_EVENT;        event.action = action;        event.buttons = buttons;        event.position = position;        return event;    }
    public static ControlMessage createInjectScrollEvent(Position position, int hScroll, int vScroll) {        ControlMessage event = new ControlMessage();        event.type = TYPE_INJECT_SCROLL_EVENT;        event.position = position;        event.hScroll = hScroll;        event.vScroll = vScroll;        return event;    }
    public static ControlMessage createInjectMouseEvent(int action, int buttons, Position position) {        ControlMessage event = new ControlMessage();        event.type = TYPE_INJECT_MOUSE_EVENT;        event.action = action;        event.buttons = buttons;        event.position = position;        return event;    }
    public static ControlMessage createInjectKeycode(int action, int keycode, int metaState) {        ControlMessage event = new ControlMessage();        event.type = TYPE_INJECT_KEYCODE;        event.action = action;        event.keycode = keycode;        event.metaState = metaState;        return event;    }
    public static ControlMessage createInjectKeycode(int action, int keycode, int metaState) {        ControlMessage event = new ControlMessage();        event.type = TYPE_INJECT_KEYCODE;        event.action = action;        event.keycode = keycode;        event.metaState = metaState;        return event;    }
    private ControlEvent parseTextControlEvent() {        String text = parseString();        if (text == null) {            return null;        }        return ControlEvent.createTextControlEvent(text);    }
    private ControlEvent parseScrollControlEvent() {        if (buffer.remaining() < SCROLL_PAYLOAD_LENGTH) {            return null;        }        Position position = readPosition(buffer);        int hScroll = buffer.getInt();        int vScroll = buffer.getInt();        return ControlEvent.createScrollControlEvent(position, hScroll, vScroll);    }
    private ControlEvent parseScrollControlEvent() {        if (buffer.remaining() < SCROLL_PAYLOAD_LENGTH) {            return null;        }        Position position = readPosition(buffer);        int hScroll = buffer.getInt();        int vScroll = buffer.getInt();        return ControlEvent.createScrollControlEvent(position, hScroll, vScroll);    }
    private ControlEvent parseMouseControlEvent() {        if (buffer.remaining() < MOUSE_PAYLOAD_LENGTH) {            return null;        }        int action = toUnsigned(buffer.get());        int buttons = buffer.getInt();        Position position = readPosition(buffer);        return ControlEvent.createMotionControlEvent(action, buttons, position);    }
    public void readFrom(InputStream input) throws IOException {        if (isFull()) {            throw new IllegalStateException("Buffer full, call next() to consume");        }        buffer.compact();        int head = buffer.position();        int r = input.read(rawBuffer, head, rawBuffer.length - head);        if (r == -1) {            throw new EOFException("Event controller socket closed");        }        buffer.position(head + r);        buffer.flip();    }
    public void readFrom(InputStream input) throws IOException {        if (isFull()) {            throw new IllegalStateException("Buffer full, call next() to consume");        }        buffer.compact();        int head = buffer.position();        int r = input.read(rawBuffer, head, rawBuffer.length - head);        if (r == -1) {            throw new EOFException("Event controller socket closed");        }        buffer.position(head + r);        buffer.flip();    }
    public void readFrom(InputStream input) throws IOException {        if (isFull()) {            throw new IllegalStateException("Buffer full, call next() to consume");        }        buffer.compact();        int head = buffer.position();        int r = input.read(rawBuffer, head, rawBuffer.length - head);        if (r == -1) {            throw new EOFException("Event controller socket closed");        }        buffer.position(head + r);        buffer.flip();    }
    public ControlEvent next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        ControlEvent controlEvent;        switch (type) {            case ControlEvent.TYPE_KEYCODE:                controlEvent = parseKeycodeControlEvent();                break;            case ControlEvent.TYPE_TEXT:                controlEvent = parseTextControlEvent();                break;            case ControlEvent.TYPE_MOUSE:                controlEvent = parseMouseControlEvent();                break;            case ControlEvent.TYPE_SCROLL:                controlEvent = parseScrollControlEvent();                break;            case ControlEvent.TYPE_SET_CLIPBOARD:                controlEvent = parseSetClipboardEvent();                break;            case ControlEvent.TYPE_BACK_OR_SCREEN_ON:            case ControlEvent.TYPE_EXPAND_NOTIFICATION_PANEL:            case ControlEvent.TYPE_COLLAPSE_NOTIFICATION_PANEL:            case ControlEvent.TYPE_GET_CLIPBOARD:                controlEvent = ControlEvent.createSimpleControlEvent(type);                break;            default:                Ln.w("Unknown event type: " + type);                controlEvent = null;                break;        }        if (controlEvent == null) {            // failure, reset savedPosition            buffer.position(savedPosition);        }        return controlEvent;    }
    public ControlEvent next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        ControlEvent controlEvent;        switch (type) {            case ControlEvent.TYPE_KEYCODE:                controlEvent = parseKeycodeControlEvent();                break;            case ControlEvent.TYPE_TEXT:                controlEvent = parseTextControlEvent();                break;            case ControlEvent.TYPE_MOUSE:                controlEvent = parseMouseControlEvent();                break;            case ControlEvent.TYPE_SCROLL:                controlEvent = parseScrollControlEvent();                break;            case ControlEvent.TYPE_SET_CLIPBOARD:                controlEvent = parseSetClipboardEvent();                break;            case ControlEvent.TYPE_BACK_OR_SCREEN_ON:            case ControlEvent.TYPE_EXPAND_NOTIFICATION_PANEL:            case ControlEvent.TYPE_COLLAPSE_NOTIFICATION_PANEL:            case ControlEvent.TYPE_GET_CLIPBOARD:                controlEvent = ControlEvent.createSimpleControlEvent(type);                break;            default:                Ln.w("Unknown event type: " + type);                controlEvent = null;                break;        }        if (controlEvent == null) {            // failure, reset savedPosition            buffer.position(savedPosition);        }        return controlEvent;    }
    public ControlEvent next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        ControlEvent controlEvent;        switch (type) {            case ControlEvent.TYPE_KEYCODE:                controlEvent = parseKeycodeControlEvent();                break;            case ControlEvent.TYPE_TEXT:                controlEvent = parseTextControlEvent();                break;            case ControlEvent.TYPE_MOUSE:                controlEvent = parseMouseControlEvent();                break;            case ControlEvent.TYPE_SCROLL:                controlEvent = parseScrollControlEvent();                break;            case ControlEvent.TYPE_SET_CLIPBOARD:                controlEvent = parseSetClipboardEvent();                break;            case ControlEvent.TYPE_BACK_OR_SCREEN_ON:            case ControlEvent.TYPE_EXPAND_NOTIFICATION_PANEL:            case ControlEvent.TYPE_COLLAPSE_NOTIFICATION_PANEL:            case ControlEvent.TYPE_GET_CLIPBOARD:                controlEvent = ControlEvent.createSimpleControlEvent(type);                break;            default:                Ln.w("Unknown event type: " + type);                controlEvent = null;                break;        }        if (controlEvent == null) {            // failure, reset savedPosition            buffer.position(savedPosition);        }        return controlEvent;    }
    private ControlEvent parseSetClipboardEvent() {        String text = parseString();        if (text == null) {            return null;        }        return ControlEvent.createSetClipboardControlEvent(text);    }
    private ControlEvent parseSetClipboardEvent() {        String text = parseString();        if (text == null) {            return null;        }        return ControlEvent.createSetClipboardControlEvent(text);    }
    private ControlEvent parseKeycodeControlEvent() {        if (buffer.remaining() < KEYCODE_PAYLOAD_LENGTH) {            return null;        }        int action = toUnsigned(buffer.get());        int keycode = buffer.getInt();        int metaState = buffer.getInt();        return ControlEvent.createKeycodeControlEvent(action, keycode, metaState);    }
    public ControlEventReader() {        // invariant: the buffer is always in "get" mode        buffer.limit(0);    }
    public ControlEventReader() {        // invariant: the buffer is always in "get" mode        buffer.limit(0);    }
    public ControlEventReader() {        // invariant: the buffer is always in "get" mode        buffer.limit(0);    }
    private ControlMessage parseInjectText() {        String text = parseString();        if (text == null) {            return null;        }        return ControlMessage.createInjectText(text);    }
    private ControlMessage parseInjectScrollEvent() {        if (buffer.remaining() < INJECT_SCROLL_EVENT_PAYLOAD_LENGTH) {            return null;        }        Position position = readPosition(buffer);        int hScroll = buffer.getInt();        int vScroll = buffer.getInt();        return ControlMessage.createInjectScrollEvent(position, hScroll, vScroll);    }
    private ControlMessage parseInjectScrollEvent() {        if (buffer.remaining() < INJECT_SCROLL_EVENT_PAYLOAD_LENGTH) {            return null;        }        Position position = readPosition(buffer);        int hScroll = buffer.getInt();        int vScroll = buffer.getInt();        return ControlMessage.createInjectScrollEvent(position, hScroll, vScroll);    }
    private ControlMessage parseInjectMouseEvent() {        if (buffer.remaining() < INJECT_MOUSE_EVENT_PAYLOAD_LENGTH) {            return null;        }        int action = toUnsigned(buffer.get());        int buttons = buffer.getInt();        Position position = readPosition(buffer);        return ControlMessage.createInjectMouseEvent(action, buttons, position);    }
    public void readFrom(InputStream input) throws IOException {        if (isFull()) {            throw new IllegalStateException("Buffer full, call next() to consume");        }        buffer.compact();        int head = buffer.position();        int r = input.read(rawBuffer, head, rawBuffer.length - head);        if (r == -1) {            throw new EOFException("Controller socket closed");        }        buffer.position(head + r);        buffer.flip();    }
    public ControlMessage next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        ControlMessage msg;        switch (type) {            case ControlMessage.TYPE_INJECT_KEYCODE:                msg = parseInjectKeycode();                break;            case ControlMessage.TYPE_INJECT_TEXT:                msg = parseInjectText();                break;            case ControlMessage.TYPE_INJECT_MOUSE_EVENT:                msg = parseInjectMouseEvent();                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                msg = parseInjectScrollEvent();                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                msg = parseSetClipboard();                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:            case ControlMessage.TYPE_GET_CLIPBOARD:                msg = ControlMessage.createEmpty(type);                break;            default:                Ln.w("Unknown event type: " + type);                msg = null;                break;        }        if (msg == null) {            // failure, reset savedPosition            buffer.position(savedPosition);        }        return msg;    }
    private ControlMessage parseSetClipboard() {        String text = parseString();        if (text == null) {            return null;        }        return ControlMessage.createSetClipboard(text);    }
    public ControlMessage next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        ControlMessage msg;        switch (type) {            case ControlMessage.TYPE_INJECT_KEYCODE:                msg = parseInjectKeycode();                break;            case ControlMessage.TYPE_INJECT_TEXT:                msg = parseInjectText();                break;            case ControlMessage.TYPE_INJECT_MOUSE_EVENT:                msg = parseInjectMouseEvent();                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                msg = parseInjectScrollEvent();                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                msg = parseSetClipboard();                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:            case ControlMessage.TYPE_GET_CLIPBOARD:                msg = ControlMessage.createEmpty(type);                break;            default:                Ln.w("Unknown event type: " + type);                msg = null;                break;        }        if (msg == null) {            // failure, reset savedPosition            buffer.position(savedPosition);        }        return msg;    }
    private ControlMessage parseInjectText() {        String text = parseString();        if (text == null) {            return null;        }        return ControlMessage.createInjectText(text);    }
    private ControlMessage parseInjectKeycode() {        if (buffer.remaining() < INJECT_KEYCODE_PAYLOAD_LENGTH) {            return null;        }        int action = toUnsigned(buffer.get());        int keycode = buffer.getInt();        int metaState = buffer.getInt();        return ControlMessage.createInjectKeycode(action, keycode, metaState);    }
    private ControlMessage parseSetClipboard() {        String text = parseString();        if (text == null) {            return null;        }        return ControlMessage.createSetClipboard(text);    }
    private ControlMessage parseInjectMouseEvent() {        if (buffer.remaining() < INJECT_MOUSE_EVENT_PAYLOAD_LENGTH) {            return null;        }        int action = toUnsigned(buffer.get());        int buttons = buffer.getInt();        Position position = readPosition(buffer);        return ControlMessage.createInjectMouseEvent(action, buttons, position);    }
    private ControlMessage parseInjectKeycode() {        if (buffer.remaining() < INJECT_KEYCODE_PAYLOAD_LENGTH) {            return null;        }        int action = toUnsigned(buffer.get());        int keycode = buffer.getInt();        int metaState = buffer.getInt();        return ControlMessage.createInjectKeycode(action, keycode, metaState);    }
    public ControlMessageReader() {        // invariant: the buffer is always in "get" mode        buffer.limit(0);    }
    public void readFrom(InputStream input) throws IOException {        if (isFull()) {            throw new IllegalStateException("Buffer full, call next() to consume");        }        buffer.compact();        int head = buffer.position();        int r = input.read(rawBuffer, head, rawBuffer.length - head);        if (r == -1) {            throw new EOFException("Controller socket closed");        }        buffer.position(head + r);        buffer.flip();    }
    public ControlMessageReader() {        // invariant: the buffer is always in "get" mode        buffer.limit(0);    }
    public EventController(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;        initPointer();        sender = new EventSender(connection);    }
    public EventController(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;        initPointer();        sender = new EventSender(connection);    }
    private void handleEvent() throws IOException {        ControlEvent controlEvent = connection.receiveControlEvent();        switch (controlEvent.getType()) {            case ControlEvent.TYPE_KEYCODE:                injectKeycode(controlEvent.getAction(), controlEvent.getKeycode(), controlEvent.getMetaState());                break;            case ControlEvent.TYPE_TEXT:                injectText(controlEvent.getText());                break;            case ControlEvent.TYPE_MOUSE:                injectMouse(controlEvent.getAction(), controlEvent.getButtons(), controlEvent.getPosition());                break;            case ControlEvent.TYPE_SCROLL:                injectScroll(controlEvent.getPosition(), controlEvent.getHScroll(), controlEvent.getVScroll());                break;            case ControlEvent.TYPE_BACK_OR_SCREEN_ON:                pressBackOrTurnScreenOn();                break;            case ControlEvent.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlEvent.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlEvent.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlEvent.TYPE_SET_CLIPBOARD:                device.setClipboardText(controlEvent.getText());                break;            default:                // do nothing        }    }
    public EventSender getSender() {        return sender;    }
    public EventSender getSender() {        return sender;    }
    public EventSender getSender() {        return sender;    }
    public Controller(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;        initPointer();        sender = new DeviceMessageSender(connection);    }
    public DeviceMessageSender getSender() {        return sender;    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                break;            case ControlMessage.TYPE_INJECT_TEXT:                injectText(msg.getText());                break;            case ControlMessage.TYPE_INJECT_MOUSE_EVENT:                injectMouse(msg.getAction(), msg.getButtons(), msg.getPosition());                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                pressBackOrTurnScreenOn();                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                device.setClipboardText(msg.getText());                break;            default:                // do nothing        }    }
    public DeviceMessageSender getSender() {        return sender;    }
    public Controller(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;        initPointer();        sender = new DeviceMessageSender(connection);    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                break;            case ControlMessage.TYPE_INJECT_TEXT:                injectText(msg.getText());                break;            case ControlMessage.TYPE_INJECT_MOUSE_EVENT:                injectMouse(msg.getAction(), msg.getButtons(), msg.getPosition());                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                pressBackOrTurnScreenOn();                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                device.setClipboardText(msg.getText());                break;            default:                // do nothing        }    }
                controlSocket = connect(SOCKET_NAME);            } catch (IOException | RuntimeException e) {                videoSocket.close();                throw e;
    public void sendDeviceEvent(DeviceEvent event) throws IOException {        writer.writeTo(event, controlOutputStream);    }}
    public void sendDeviceEvent(DeviceEvent event) throws IOException {        writer.writeTo(event, controlOutputStream);    }}
    public ControlEvent receiveControlEvent() throws IOException {        ControlEvent event = reader.next();        while (event == null) {            reader.readFrom(controlInputStream);            event = reader.next();        }        return event;    }
    public void sendDeviceMessage(DeviceMessage msg) throws IOException {        writer.writeTo(msg, controlOutputStream);    }}
    public void sendDeviceMessage(DeviceMessage msg) throws IOException {        writer.writeTo(msg, controlOutputStream);    }}
    public ControlMessage receiveControlMessage() throws IOException {        ControlMessage msg = reader.next();        while (msg == null) {            reader.readFrom(controlInputStream);            msg = reader.next();        }        return msg;    }
    public ControlMessage receiveControlMessage() throws IOException {        ControlMessage msg = reader.next();        while (msg == null) {            reader.readFrom(controlInputStream);            msg = reader.next();        }        return msg;    }
                while (clipboardText == null) {                    wait();                }                text = clipboardText;
                while (clipboardText == null) {                    wait();                }                text = clipboardText;
    public EventSender(DesktopConnection connection) {        this.connection = connection;    }
    public void loop() throws IOException, InterruptedException {        while (true) {            String text;            synchronized (this) {                while (clipboardText == null) {                    wait();                }                text = clipboardText;                clipboardText = null;            }            DeviceEvent event = DeviceEvent.createGetClipboardEvent(text);            connection.sendDeviceEvent(event);        }    }}
    public void loop() throws IOException, InterruptedException {        while (true) {            String text;            synchronized (this) {                while (clipboardText == null) {                    wait();                }                text = clipboardText;                clipboardText = null;            }            DeviceMessage event = DeviceMessage.createClipboard(text);            connection.sendDeviceMessage(event);        }    }}
    public DeviceMessageSender(DesktopConnection connection) {        this.connection = connection;    }
    public DeviceMessageSender(DesktopConnection connection) {        this.connection = connection;    }
    public void loop() throws IOException, InterruptedException {        while (true) {            String text;            synchronized (this) {                while (clipboardText == null) {                    wait();                }                text = clipboardText;                clipboardText = null;            }            DeviceMessage event = DeviceMessage.createClipboard(text);            connection.sendDeviceMessage(event);        }    }}
        switch (event.getType()) {            case DeviceEvent.TYPE_GET_CLIPBOARD:                String text = event.getText();                byte[] raw = text.getBytes(StandardCharsets.UTF_8);                int len = StringUtils.getUtf8TruncationIndex(raw, CLIPBOARD_TEXT_MAX_LENGTH);                buffer.putShort((short) len);                buffer.put(raw, 0, len);                output.write(rawBuffer, 0, buffer.position());                break;            default:                Ln.w("Unknown device event: " + event.getType());                break;        }    }}
    public void writeTo(DeviceEvent event, OutputStream output) throws IOException {        buffer.clear();        buffer.put((byte) DeviceEvent.TYPE_GET_CLIPBOARD);        switch (event.getType()) {            case DeviceEvent.TYPE_GET_CLIPBOARD:                String text = event.getText();                byte[] raw = text.getBytes(StandardCharsets.UTF_8);                int len = StringUtils.getUtf8TruncationIndex(raw, CLIPBOARD_TEXT_MAX_LENGTH);                buffer.putShort((short) len);                buffer.put(raw, 0, len);                output.write(rawBuffer, 0, buffer.position());                break;            default:                Ln.w("Unknown device event: " + event.getType());                break;        }    }}
    public void writeTo(DeviceMessage msg, OutputStream output) throws IOException {        buffer.clear();        buffer.put((byte) DeviceMessage.TYPE_CLIPBOARD);        switch (msg.getType()) {            case DeviceMessage.TYPE_CLIPBOARD:                String text = msg.getText();                byte[] raw = text.getBytes(StandardCharsets.UTF_8);                int len = StringUtils.getUtf8TruncationIndex(raw, CLIPBOARD_TEXT_MAX_LENGTH);                buffer.putShort((short) len);                buffer.put(raw, 0, len);                output.write(rawBuffer, 0, buffer.position());                break;            default:                Ln.w("Unknown device message: " + msg.getType());                break;        }    }}
    public void writeTo(DeviceMessage msg, OutputStream output) throws IOException {        buffer.clear();        buffer.put((byte) DeviceMessage.TYPE_CLIPBOARD);        switch (msg.getType()) {            case DeviceMessage.TYPE_CLIPBOARD:                String text = msg.getText();                byte[] raw = text.getBytes(StandardCharsets.UTF_8);                int len = StringUtils.getUtf8TruncationIndex(raw, CLIPBOARD_TEXT_MAX_LENGTH);                buffer.putShort((short) len);                buffer.put(raw, 0, len);                output.write(rawBuffer, 0, buffer.position());                break;            default:                Ln.w("Unknown device message: " + msg.getType());                break;        }    }}
    private static void startEventController(final EventController controller) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    controller.control();                } catch (IOException e) {                    // this is expected on close                    Ln.d("Event controller stopped");                }            }        }).start();    }
    private static void startEventSender(final EventSender sender) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    sender.loop();                } catch (IOException | InterruptedException e) {                    // this is expected on close                    Ln.d("Event sender stopped");                }            }        }).start();    }
    private static void startEventSender(final EventSender sender) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    sender.loop();                } catch (IOException | InterruptedException e) {                    // this is expected on close                    Ln.d("Event sender stopped");                }            }        }).start();    }
    private static void startEventSender(final EventSender sender) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    sender.loop();                } catch (IOException | InterruptedException e) {                    // this is expected on close                    Ln.d("Event sender stopped");                }            }        }).start();    }
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate());            EventController controller = new EventController(device, connection);            // asynchronous            startEventController(controller);            startEventSender(controller.getSender());            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    private static void startController(final Controller controller) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    controller.control();                } catch (IOException e) {                    // this is expected on close                    Ln.d("Controller stopped");                }            }        }).start();    }
    private static void startDeviceMessageSender(final DeviceMessageSender sender) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    sender.loop();                } catch (IOException | InterruptedException e) {                    // this is expected on close                    Ln.d("Device message sender stopped");                }            }        }).start();    }
    private static void startDeviceMessageSender(final DeviceMessageSender sender) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    sender.loop();                } catch (IOException | InterruptedException e) {                    // this is expected on close                    Ln.d("Device message sender stopped");                }            }        }).start();    }
    private static void startController(final Controller controller) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    controller.control();                } catch (IOException e) {                    // this is expected on close                    Ln.d("Controller stopped");                }            }        }).start();    }
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate());            Controller controller = new Controller(device, connection);            // asynchronous            startController(controller);            startDeviceMessageSender(controller.getSender());            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    public void testParseGetClipboardEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_GET_CLIPBOARD);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_GET_CLIPBOARD, event.getType());    }
    public void testMultiEvents() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(KeyEvent.META_CTRL_ON);        dos.writeByte(ControlEvent.TYPE_KEYCODE);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_KEYCODE, event.getType());        Assert.assertEquals(KeyEvent.ACTION_UP, event.getAction());        Assert.assertEquals(KeyEvent.KEYCODE_ENTER, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());        event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_KEYCODE, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }
    public void testMultiEvents() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(KeyEvent.META_CTRL_ON);        dos.writeByte(ControlEvent.TYPE_KEYCODE);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_KEYCODE, event.getType());        Assert.assertEquals(KeyEvent.ACTION_UP, event.getAction());        Assert.assertEquals(KeyEvent.KEYCODE_ENTER, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());        event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_KEYCODE, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }
    public void testMultiEvents() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(KeyEvent.META_CTRL_ON);        dos.writeByte(ControlEvent.TYPE_KEYCODE);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_KEYCODE, event.getType());        Assert.assertEquals(KeyEvent.ACTION_UP, event.getAction());        Assert.assertEquals(KeyEvent.KEYCODE_ENTER, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());        event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_KEYCODE, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }
    public void testParseLongTextEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_TEXT);        byte[] text = new byte[ControlEventReader.TEXT_MAX_LENGTH];        Arrays.fill(text, (byte) 'a');        dos.writeShort(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_TEXT, event.getType());        Assert.assertEquals(new String(text, StandardCharsets.US_ASCII), event.getText());    }
    public void testParseKeycodeEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_KEYCODE, event.getType());        Assert.assertEquals(KeyEvent.ACTION_UP, event.getAction());        Assert.assertEquals(KeyEvent.KEYCODE_ENTER, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }
    public void testParseExpandNotificationPanelEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_EXPAND_NOTIFICATION_PANEL);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_EXPAND_NOTIFICATION_PANEL, event.getType());    }
    public void testParseCollapseNotificationPanelEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_COLLAPSE_NOTIFICATION_PANEL);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_COLLAPSE_NOTIFICATION_PANEL, event.getType());    }
    public void testParseMouseEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_KEYCODE);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_KEYCODE, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }
    public void testParseMouseEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_KEYCODE);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_KEYCODE, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }
    public void testParseMouseEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_KEYCODE);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_KEYCODE, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }
    public void testParseMouseEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_KEYCODE);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_KEYCODE, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }
    public void testParseMouseEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_KEYCODE);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_KEYCODE, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }
    public void testParseMouseEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_KEYCODE);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_KEYCODE, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }
    public void testParseSetClipboardEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_SET_CLIPBOARD);        byte[] text = "testé".getBytes(StandardCharsets.UTF_8);        dos.writeShort(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_SET_CLIPBOARD, event.getType());        Assert.assertEquals("testé", event.getText());    }
    public void testParseTextEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_TEXT);        byte[] text = "testé".getBytes(StandardCharsets.UTF_8);        dos.writeShort(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_TEXT, event.getType());        Assert.assertEquals("testé", event.getText());    }
    public void testParseTextEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_TEXT);        byte[] text = "testé".getBytes(StandardCharsets.UTF_8);        dos.writeShort(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_TEXT, event.getType());        Assert.assertEquals("testé", event.getText());    }
    public void testPartialEvents() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(KeyEvent.META_CTRL_ON);        dos.writeByte(ControlEvent.TYPE_KEYCODE);        dos.writeByte(MotionEvent.ACTION_DOWN);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_KEYCODE, event.getType());        Assert.assertEquals(KeyEvent.ACTION_UP, event.getAction());        Assert.assertEquals(KeyEvent.KEYCODE_ENTER, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());        event = reader.next();        Assert.assertNull(event); // the event is not complete        bos.reset();        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(KeyEvent.META_CTRL_ON);        packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        // the event is now complete        event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_KEYCODE, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }}
    public void testPartialEvents() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(KeyEvent.META_CTRL_ON);        dos.writeByte(ControlEvent.TYPE_KEYCODE);        dos.writeByte(MotionEvent.ACTION_DOWN);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_KEYCODE, event.getType());        Assert.assertEquals(KeyEvent.ACTION_UP, event.getAction());        Assert.assertEquals(KeyEvent.KEYCODE_ENTER, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());        event = reader.next();        Assert.assertNull(event); // the event is not complete        bos.reset();        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(KeyEvent.META_CTRL_ON);        packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        // the event is now complete        event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_KEYCODE, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }}
    public void testParseScrollEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_SCROLL);        dos.writeInt(260);        dos.writeInt(1026);        dos.writeShort(1080);        dos.writeShort(1920);        dos.writeInt(1);        dos.writeInt(-1);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_SCROLL, event.getType());        Assert.assertEquals(260, event.getPosition().getPoint().getX());        Assert.assertEquals(1026, event.getPosition().getPoint().getY());        Assert.assertEquals(1080, event.getPosition().getScreenSize().getWidth());        Assert.assertEquals(1920, event.getPosition().getScreenSize().getHeight());        Assert.assertEquals(1, event.getHScroll());        Assert.assertEquals(-1, event.getVScroll());    }
    public void testParseBackOrScreenOnEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_BACK_OR_SCREEN_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_BACK_OR_SCREEN_ON, event.getType());    }
    public void testParseBackOrScreenOnEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_BACK_OR_SCREEN_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_BACK_OR_SCREEN_ON, event.getType());    }
    public void testParseBackOrScreenOnEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_BACK_OR_SCREEN_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_BACK_OR_SCREEN_ON, event.getType());    }
    public void testParseBackOrScreenOnEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_BACK_OR_SCREEN_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_BACK_OR_SCREEN_ON, event.getType());    }
    public void testParseGetClipboardEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_GET_CLIPBOARD);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_GET_CLIPBOARD, event.getType());    }
    public void testMultiEvents() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(KeyEvent.META_CTRL_ON);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(KeyEvent.ACTION_UP, event.getAction());        Assert.assertEquals(KeyEvent.KEYCODE_ENTER, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());        event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }
    public void testParseGetClipboardEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_GET_CLIPBOARD);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_GET_CLIPBOARD, event.getType());    }
    public void testMultiEvents() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(KeyEvent.META_CTRL_ON);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(KeyEvent.ACTION_UP, event.getAction());        Assert.assertEquals(KeyEvent.KEYCODE_ENTER, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());        event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }
    public void testParseLongTextEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_TEXT);        byte[] text = new byte[ControlMessageReader.TEXT_MAX_LENGTH];        Arrays.fill(text, (byte) 'a');        dos.writeShort(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_TEXT, event.getType());        Assert.assertEquals(new String(text, StandardCharsets.US_ASCII), event.getText());    }
    public void testParseKeycodeEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(KeyEvent.ACTION_UP, event.getAction());        Assert.assertEquals(KeyEvent.KEYCODE_ENTER, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }
    public void testParseExpandNotificationPanelEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL, event.getType());    }
    public void testParseCollapseNotificationPanelEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL, event.getType());    }
    public void testParseMouseEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }
    public void testParseKeycodeEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(KeyEvent.ACTION_UP, event.getAction());        Assert.assertEquals(KeyEvent.KEYCODE_ENTER, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }
    public void testPartialEvents() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(KeyEvent.META_CTRL_ON);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(MotionEvent.ACTION_DOWN);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(KeyEvent.ACTION_UP, event.getAction());        Assert.assertEquals(KeyEvent.KEYCODE_ENTER, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());        event = reader.next();        Assert.assertNull(event); // the event is not complete        bos.reset();        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(KeyEvent.META_CTRL_ON);        packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        // the event is now complete        event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }}
    public void testParseTextEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_TEXT);        byte[] text = "testé".getBytes(StandardCharsets.UTF_8);        dos.writeShort(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_TEXT, event.getType());        Assert.assertEquals("testé", event.getText());    }
    public void testParseExpandNotificationPanelEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL, event.getType());    }
    public void testParseSetClipboardEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_SET_CLIPBOARD);        byte[] text = "testé".getBytes(StandardCharsets.UTF_8);        dos.writeShort(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_SET_CLIPBOARD, event.getType());        Assert.assertEquals("testé", event.getText());    }
    public void testParseSetClipboardEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_SET_CLIPBOARD);        byte[] text = "testé".getBytes(StandardCharsets.UTF_8);        dos.writeShort(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_SET_CLIPBOARD, event.getType());        Assert.assertEquals("testé", event.getText());    }
    public void testParseTextEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_TEXT);        byte[] text = "testé".getBytes(StandardCharsets.UTF_8);        dos.writeShort(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_TEXT, event.getType());        Assert.assertEquals("testé", event.getText());    }
    public void testParseBackOrScreenOnEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_BACK_OR_SCREEN_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_BACK_OR_SCREEN_ON, event.getType());    }
    public void testPartialEvents() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(KeyEvent.META_CTRL_ON);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(MotionEvent.ACTION_DOWN);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(KeyEvent.ACTION_UP, event.getAction());        Assert.assertEquals(KeyEvent.KEYCODE_ENTER, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());        event = reader.next();        Assert.assertNull(event); // the event is not complete        bos.reset();        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(KeyEvent.META_CTRL_ON);        packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        // the event is now complete        event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }}
    public void testParseScrollEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_SCROLL_EVENT);        dos.writeInt(260);        dos.writeInt(1026);        dos.writeShort(1080);        dos.writeShort(1920);        dos.writeInt(1);        dos.writeInt(-1);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_SCROLL_EVENT, event.getType());        Assert.assertEquals(260, event.getPosition().getPoint().getX());        Assert.assertEquals(1026, event.getPosition().getPoint().getY());        Assert.assertEquals(1080, event.getPosition().getScreenSize().getWidth());        Assert.assertEquals(1920, event.getPosition().getScreenSize().getHeight());        Assert.assertEquals(1, event.getHScroll());        Assert.assertEquals(-1, event.getVScroll());    }
    public void testParseScrollEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_SCROLL_EVENT);        dos.writeInt(260);        dos.writeInt(1026);        dos.writeShort(1080);        dos.writeShort(1920);        dos.writeInt(1);        dos.writeInt(-1);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_SCROLL_EVENT, event.getType());        Assert.assertEquals(260, event.getPosition().getPoint().getX());        Assert.assertEquals(1026, event.getPosition().getPoint().getY());        Assert.assertEquals(1080, event.getPosition().getScreenSize().getWidth());        Assert.assertEquals(1920, event.getPosition().getScreenSize().getHeight());        Assert.assertEquals(1, event.getHScroll());        Assert.assertEquals(-1, event.getVScroll());    }
    public void testParseBackOrScreenOnEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_BACK_OR_SCREEN_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_BACK_OR_SCREEN_ON, event.getType());    }
    public void testParseLongTextEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_TEXT);        byte[] text = new byte[ControlMessageReader.TEXT_MAX_LENGTH];        Arrays.fill(text, (byte) 'a');        dos.writeShort(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_TEXT, event.getType());        Assert.assertEquals(new String(text, StandardCharsets.US_ASCII), event.getText());    }
    public void testParseMouseEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }
    public void testParseCollapseNotificationPanelEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL, event.getType());    }
static struct size get_optimal_size(struct size current_size, struct size frame_size) {    struct size display_size;    // 32 bits because we need to multiply two 16 bits values    Uint32 w;    Uint32 h;    if (!get_preferred_display_bounds(&display_size)) {        // cannot get display bounds, do not constraint the size        w = current_size.width;        h = current_size.height;    } else {        w = MIN(current_size.width, display_size.width);        h = MIN(current_size.height, display_size.height);    }    SDL_bool keep_width = frame_size.width * h > frame_size.height * w;    if (keep_width) {        // remove black borders on top and bottom        h = frame_size.height * w / frame_size.width;    } else {        // remove black borders on left and right (or none at all if it already fits)        w = frame_size.width * h / frame_size.height;    }    // w and h must fit into 16 bits    SDL_assert_release(w < 0x10000 && h < 0x10000);    return (struct size) {w, h};}
static struct size get_optimal_size(struct size current_size, struct size frame_size) {    if (frame_size.width == 0 || frame_size.height == 0) {        // avoid division by 0        return current_size;    }    struct size display_size;    // 32 bits because we need to multiply two 16 bits values    Uint32 w;    Uint32 h;    if (!get_preferred_display_bounds(&display_size)) {        // cannot get display bounds, do not constraint the size        w = current_size.width;        h = current_size.height;    } else {        w = MIN(current_size.width, display_size.width);        h = MIN(current_size.height, display_size.height);    }    SDL_bool keep_width = frame_size.width * h > frame_size.height * w;    if (keep_width) {        // remove black borders on top and bottom        h = frame_size.height * w / frame_size.width;    } else {        // remove black borders on left and right (or none at all if it already fits)        w = frame_size.width * h / frame_size.height;    }    // w and h must fit into 16 bits    SDL_assert_release(w < 0x10000 && h < 0x10000);    return (struct size) {w, h};}
void frames_destroy(struct frames *frames) {    SDL_DestroyMutex(frames->mutex);    SDL_DestroyCond(frames->rendering_frame_consumed_cond);    av_frame_free(&frames->rendering_frame);    av_frame_free(&frames->decoding_frame);}
void frames_destroy(struct frames *frames) {    SDL_DestroyCond(frames->rendering_frame_consumed_cond);    SDL_DestroyMutex(frames->mutex);    av_frame_free(&frames->rendering_frame);    av_frame_free(&frames->decoding_frame);}
void control_event_queue_destroy(struct control_event_queue *queue) {    // nothing to do in the current implementation}
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            write32(&buf[2], event->keycode_event.keycode);            write32(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (1 byte) + date (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > TEXT_MAX_LENGTH) {                len = TEXT_MAX_LENGTH;            }            buf[1] = (Uint8) len;            memcpy(&buf[2], &event->text_event.text, len);            return 2 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            write32(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 14;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            write32(&buf[9], (Uint32) event->scroll_event.hscroll);            write32(&buf[13], (Uint32) event->scroll_event.vscroll);            return 17;        case CONTROL_EVENT_TYPE_COMMAND:            buf[1] = event->command_event.action;            return 2;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            write32(&buf[2], event->keycode_event.keycode);            write32(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (1 byte) + date (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > TEXT_MAX_LENGTH) {                len = TEXT_MAX_LENGTH;            }            buf[1] = (Uint8) len;            memcpy(&buf[2], &event->text_event.text, len);            return 2 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            write32(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 14;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            write32(&buf[9], (Uint32) event->scroll_event.hscroll);            write32(&buf[13], (Uint32) event->scroll_event.vscroll);            return 17;        case CONTROL_EVENT_TYPE_COMMAND:            buf[1] = event->command_event.action;            return 2;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
void control_event_queue_destroy(struct control_event_queue *queue) {    int i = queue->tail;    while (i != queue->head) {        control_event_destroy(&queue->data[i]);        i = (i + 1) % CONTROL_EVENT_QUEUE_SIZE;    }}
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            write32(&buf[2], event->keycode_event.keycode);            write32(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (1 byte) + date (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > TEXT_MAX_LENGTH) {                // injecting a text takes time, so limit the text length                len = TEXT_MAX_LENGTH;            }            buf[1] = (Uint8) len;            memcpy(&buf[2], event->text_event.text, len);            return 2 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            write32(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 14;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            write32(&buf[9], (Uint32) event->scroll_event.hscroll);            write32(&buf[13], (Uint32) event->scroll_event.vscroll);            return 17;        case CONTROL_EVENT_TYPE_COMMAND:            buf[1] = event->command_event.action;            return 2;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
void control_event_destroy(struct control_event *event) {    if (event->type == CONTROL_EVENT_TYPE_TEXT) {        SDL_free(event->text_event.text);    }}
static int run_controller(void *data) {    struct controller *controller = data;    mutex_lock(controller->mutex);    for (;;) {        while (!controller->stopped && control_event_queue_is_empty(&controller->queue)) {            cond_wait(controller->event_cond, controller->mutex);        }        if (controller->stopped) {            // stop immediately, do not process further events            break;        }        struct control_event event;        while (control_event_queue_take(&controller->queue, &event)) {            if (!process_event(controller, &event)) {                LOGD("Cannot write event to socket");                goto end;            }        }    }end:    mutex_unlock(controller->mutex);    return 0;}
static int run_controller(void *data) {    struct controller *controller = data;    mutex_lock(controller->mutex);    for (;;) {        while (!controller->stopped && control_event_queue_is_empty(&controller->queue)) {            cond_wait(controller->event_cond, controller->mutex);        }        if (controller->stopped) {            // stop immediately, do not process further events            break;        }        struct control_event event;        while (control_event_queue_take(&controller->queue, &event)) {            SDL_bool ok = process_event(controller, &event);            control_event_destroy(&event);            if (!ok) {                LOGD("Cannot write event to socket");                goto end;            }        }    }end:    mutex_unlock(controller->mutex);    return 0;}
void input_manager_process_text_input(struct input_manager *input_manager,                                      const SDL_TextInputEvent *event) {    if (is_ctrl_down()) {        switch (event->text[0]) {            case '+':                action_volume_up(input_manager->controller);                break;            case '-':                action_volume_down(input_manager->controller);                break;        }        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    strncpy(control_event.text_event.text, event->text, TEXT_MAX_LENGTH);    control_event.text_event.text[TEXT_MAX_LENGTH] = '\0';    if (!controller_push_event(input_manager->controller, &control_event)) {        LOGW("Cannot send text event");    }}
void input_manager_process_text_input(struct input_manager *input_manager,                                      const SDL_TextInputEvent *event) {    if (is_ctrl_down()) {        switch (event->text[0]) {            case '+':                action_volume_up(input_manager->controller);                break;            case '-':                action_volume_down(input_manager->controller);                break;        }        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    strncpy(control_event.text_event.text, event->text, TEXT_MAX_LENGTH);    control_event.text_event.text[TEXT_MAX_LENGTH] = '\0';    if (!controller_push_event(input_manager->controller, &control_event)) {        LOGW("Cannot send text event");    }}
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    // capture all Ctrl events    if (ctrl) {        SDL_bool repeat = event->repeat;        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        SDL_Keycode keycode = event->keysym.sym;        switch (keycode) {            case SDLK_h:                action_home(input_manager->controller);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(input_manager->controller);                return;            case SDLK_m:                action_app_switch(input_manager->controller);                return;            case SDLK_p:                action_power(input_manager->controller);                return;            case SDLK_f:                screen_switch_fullscreen(input_manager->screen);                return;            case SDLK_x:                screen_resize_to_fit(input_manager->screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(input_manager->screen);                return;            case SDLK_i:                switch_fps_counter_state(input_manager->frames);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
void input_manager_process_text_input(struct input_manager *input_manager,                                      const SDL_TextInputEvent *event) {    if (is_ctrl_down()) {        switch (event->text[0]) {            case '+':                action_volume_up(input_manager->controller);                break;            case '-':                action_volume_down(input_manager->controller);                break;        }        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    control_event.text_event.text = SDL_strdup(event->text);    if (!control_event.text_event.text) {        LOGW("Cannot strdup input text");        return;    }    if (!controller_push_event(input_manager->controller, &control_event)) {        LOGW("Cannot send text event");    }}
static void clipboard_paste(struct controller *controller) {    char *text = SDL_GetClipboardText();    if (!text) {        LOGW("Cannot get clipboard text: %s", SDL_GetError());        return;    }    if (!*text) {        // empty text        SDL_free(text);        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    control_event.text_event.text = text;    if (!controller_push_event(controller, &control_event)) {        SDL_free(text);        LOGW("Cannot send clipboard paste event");    }}
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    // capture all Ctrl events    if (ctrl) {        SDL_bool repeat = event->repeat;        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        SDL_Keycode keycode = event->keysym.sym;        switch (keycode) {            case SDLK_h:                action_home(input_manager->controller);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(input_manager->controller);                return;            case SDLK_m:                action_app_switch(input_manager->controller);                return;            case SDLK_p:                action_power(input_manager->controller);                return;            case SDLK_v:                clipboard_paste(input_manager->controller);                return;            case SDLK_f:                screen_switch_fullscreen(input_manager->screen);                return;            case SDLK_x:                screen_resize_to_fit(input_manager->screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(input_manager->screen);                return;            case SDLK_i:                switch_fps_counter_state(input_manager->frames);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "        click on BACK\n"        "\n"        "    Ctrl+m\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+'+'\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+'-'\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click\n"        "        turn screen on\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "        click on BACK\n"        "\n"        "    Ctrl+m\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+'+'\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+'-'\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
    private boolean injectText(String text) {        return injectText(text, true);    }
    private boolean injectText(String text, boolean decomposeOnFailure) {        KeyEvent[] events = charMap.getEvents(text.toCharArray());        if (events == null) {            return decomposeOnFailure ? injectDecomposition(text) : false;        }        for (KeyEvent event : events) {            if (!injectEvent(event)) {                return false;            }        }        return true;    }
    private boolean injectDecomposition(String text) {        for (char c : text.toCharArray()) {            String composedText = KeyComposition.decompose(c);            if (composedText == null || !injectText(composedText, false)) {                return false;            }        }        return true;    }
    private boolean injectDecomposition(String text) {        for (char c : text.toCharArray()) {            String composedText = KeyComposition.decompose(c);            if (composedText == null || !injectText(composedText, false)) {                return false;            }        }        return true;    }
    private boolean injectText(String text) {        for (char c : text.toCharArray()) {            if (!injectChar(c)) {                return false;            }        }        return true;    }
        if (events == null) {            return false;        }        for (KeyEvent event : events) {            if (!injectEvent(event)) {                return false;            }        }        return true;    }    private boolean injectText(String text) {        for (char c : text.toCharArray()) {
            if (!injectChar(c)) {                return false;            }        }        return true;    }    private boolean injectMouse(int action, int buttons, Position position) {        long now = SystemClock.uptimeMillis();        if (action == MotionEvent.ACTION_DOWN) {
    private boolean injectChar(char c) {        String decomposed = KeyComposition.decompose(c);        char[] chars = decomposed != null ? decomposed.toCharArray() : new char[] {c};        KeyEvent[] events = charMap.getEvents(chars);        if (events == null) {            return false;        }        for (KeyEvent event : events) {            if (!injectEvent(event)) {                return false;            }        }        return true;    }
SDL_bool frames_init(struct frames *frames) {    if (!(frames->decoding_frame = av_frame_alloc())) {        goto error_0;    }    if (!(frames->rendering_frame = av_frame_alloc())) {        goto error_1;    }    if (!(frames->mutex = SDL_CreateMutex())) {        goto error_2;    }#ifndef SKIP_FRAMES    if (!(frames->rendering_frame_consumed_cond = SDL_CreateCond())) {        SDL_DestroyMutex(frames->mutex);        goto error_2;    }    frames->stopped = SDL_FALSE;#endif    // there is initially no rendering frame, so consider it has already been    // consumed    frames->rendering_frame_consumed = SDL_TRUE;    return SDL_TRUE;error_2:    av_frame_free(&frames->rendering_frame);error_1:    av_frame_free(&frames->decoding_frame);error_0:    return SDL_FALSE;}
const AVFrame *frames_consume_rendered_frame(struct frames *frames) {    SDL_assert(!frames->rendering_frame_consumed);    frames->rendering_frame_consumed = SDL_TRUE;#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then notify the decoder the current frame is    // consumed, so that it may push a new one    cond_signal(frames->rendering_frame_consumed_cond);#endif    return frames->rendering_frame;}
SDL_bool frames_offer_decoded_frame(struct frames *frames) {    mutex_lock(frames->mutex);#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then the decoder must wait for the current    // frame to be consumed    while (!frames->rendering_frame_consumed && !frames->stopped) {        cond_wait(frames->rendering_frame_consumed_cond, frames->mutex);    }#else    if (!frames->rendering_frame_consumed) {        LOGD("Skip frame");    }#endif    frames_swap(frames);    SDL_bool previous_frame_consumed = frames->rendering_frame_consumed;    frames->rendering_frame_consumed = SDL_FALSE;    mutex_unlock(frames->mutex);    return previous_frame_consumed;}
SDL_bool frames_init(struct frames *frames) {    if (!(frames->decoding_frame = av_frame_alloc())) {        goto error_0;    }    if (!(frames->rendering_frame = av_frame_alloc())) {        goto error_1;    }    if (!(frames->mutex = SDL_CreateMutex())) {        goto error_2;    }#ifndef SKIP_FRAMES    if (!(frames->rendering_frame_consumed_cond = SDL_CreateCond())) {        SDL_DestroyMutex(frames->mutex);        goto error_2;    }    frames->stopped = SDL_FALSE;#endif    // there is initially no rendering frame, so consider it has already been    // consumed    frames->rendering_frame_consumed = SDL_TRUE;    fps_counter_init(&frames->fps_counter);    return SDL_TRUE;error_2:    av_frame_free(&frames->rendering_frame);error_1:    av_frame_free(&frames->decoding_frame);error_0:    return SDL_FALSE;}
const AVFrame *frames_consume_rendered_frame(struct frames *frames) {    SDL_assert(!frames->rendering_frame_consumed);    frames->rendering_frame_consumed = SDL_TRUE;    if (frames->fps_counter.started) {        fps_counter_add_rendered_frame(&frames->fps_counter);    }#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then notify the decoder the current frame is    // consumed, so that it may push a new one    cond_signal(frames->rendering_frame_consumed_cond);#endif    return frames->rendering_frame;}
SDL_bool frames_offer_decoded_frame(struct frames *frames) {    mutex_lock(frames->mutex);#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then the decoder must wait for the current    // frame to be consumed    while (!frames->rendering_frame_consumed && !frames->stopped) {        cond_wait(frames->rendering_frame_consumed_cond, frames->mutex);    }#else    if (frames->fps_counter.started && !frames->rendering_frame_consumed) {        fps_counter_add_skipped_frame(&frames->fps_counter);    }#endif    frames_swap(frames);    SDL_bool previous_frame_consumed = frames->rendering_frame_consumed;    frames->rendering_frame_consumed = SDL_FALSE;    mutex_unlock(frames->mutex);    return previous_frame_consumed;}
static void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return;            case SDL_QUIT:                LOGD("User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return;                }                count_frame(); // display fps for debug                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;                }                break;            case SDL_TEXTINPUT: {                screencontrol_handle_text_input(&controller, &screen, &event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                screencontrol_handle_key(&controller, &screen, &event.key);                break;            case SDL_MOUSEMOTION:                screencontrol_handle_mouse_motion(&controller, &screen, &event.motion);                break;            case SDL_MOUSEWHEEL: {                screencontrol_handle_mouse_wheel(&controller, &screen, &event.wheel);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                screencontrol_handle_mouse_button(&controller, &screen, &event.button);                break;            }        }    }}
static long timestamp_ms(void) {    struct timeval tv;    gettimeofday(&tv, NULL);    return tv.tv_sec * 1000 + tv.tv_usec / 1000;}
static void count_frame(void) {    static long ts = 0;    static int nbframes = 0;    long now = timestamp_ms();    ++nbframes;    if (now - ts > 1000) {        LOGD("%d fps", nbframes);        ts = now;        nbframes = 0;    }}
static void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return;            case SDL_QUIT:                LOGD("User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                    fps_counter_start(&frames.fps_counter);                }                if (!screen_update_frame(&screen, &frames)) {                    return;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;                }                break;            case SDL_TEXTINPUT: {                screencontrol_handle_text_input(&controller, &screen, &event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                screencontrol_handle_key(&controller, &screen, &event.key);                break;            case SDL_MOUSEMOTION:                screencontrol_handle_mouse_motion(&controller, &screen, &event.motion);                break;            case SDL_MOUSEWHEEL: {                screencontrol_handle_mouse_wheel(&controller, &screen, &event.wheel);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                screencontrol_handle_mouse_button(&controller, &screen, &event.button);                break;            }        }    }}
static void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:
                LOGD("Video decoder stopped");                return;            case SDL_QUIT:                LOGD("User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                    fps_counter_start(&frames.fps_counter);                }
static void push_frame(struct decoder *decoder) {    struct frames *frames = decoder->frames;    mutex_lock(frames->mutex);    if (!decoder->skip_frames) {        while (!frames->rendering_frame_consumed) {            SDL_CondWait(frames->rendering_frame_consumed_cond, frames->mutex);        }    } else if (!frames->rendering_frame_consumed) {        SDL_LogInfo(SDL_LOG_CATEGORY_RENDER, "Skip frame");    }    frames_swap(frames);    frames->rendering_frame_consumed = SDL_FALSE;    mutex_unlock(frames->mutex);    static SDL_Event new_frame_event = {        .type = EVENT_NEW_FRAME,    };    SDL_PushEvent(&new_frame_event);}
static void push_frame(struct decoder *decoder) {    struct frames *frames = decoder->frames;    mutex_lock(frames->mutex);    if (!decoder->skip_frames) {        while (!frames->rendering_frame_consumed) {            cond_wait(frames->rendering_frame_consumed_cond, frames->mutex);        }    } else if (!frames->rendering_frame_consumed) {        SDL_LogInfo(SDL_LOG_CATEGORY_RENDER, "Skip frame");    }    frames_swap(frames);    frames->rendering_frame_consumed = SDL_FALSE;    mutex_unlock(frames->mutex);    static SDL_Event new_frame_event = {        .type = EVENT_NEW_FRAME,    };    SDL_PushEvent(&new_frame_event);}
#endif
#endif
static inline void cond_signal(SDL_cond *cond) {    if (SDL_CondSignal(cond)) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not signal a condition");        exit(1);    }}
static inline void cond_wait(SDL_cond *cond, SDL_mutex *mutex) {    if (SDL_CondWait(cond, mutex)) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not wait on condition");        exit(1);    }}
SDL_bool show_screen(const char *serial, Uint16 local_port) {    SDL_bool ret = 0;    const char *server_jar_path = getenv("SCRCPY_SERVER_JAR");    if (!server_jar_path) {        server_jar_path = "scrcpy-server.jar";    }    process_t push_proc = adb_push(serial, server_jar_path, "/data/local/tmp/");    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = adb_reverse(serial, SOCKET_NAME, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    struct size frame_size;    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the width and height values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    SDL_Window *window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    SDL_Texture *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    long ts = timestamp_ms();    int nbframes = 0;    SDL_bool texture_empty = SDL_TRUE;    SDL_bool fullscreen = SDL_FALSE;    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            goto screen_quit;        case EVENT_NEW_FRAME:            mutex_lock(frames.mutex);            AVFrame *frame = frames.rendering_frame;            frames.rendering_frame_consumed = SDL_TRUE;            if (!decoder.skip_frames) {                SDL_CondSignal(frames.rendering_frame_consumed_cond);            }            struct size current_frame_size = {frame->width, frame->height};            if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {                goto screen_quit;            }            frame_size = current_frame_size;            update_texture(frame, texture);            mutex_unlock(frames.mutex);            texture_empty = SDL_FALSE;            long now = timestamp_ms();            ++nbframes;            if (now - ts > 1000) {                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "%d fps", nbframes);                ts = now;                nbframes = 0;            }            render(renderer, texture);            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_KEYDOWN: {            SDL_bool ctrl = SDL_GetModState() & (KMOD_LCTRL | KMOD_RCTRL);            SDL_bool shift = SDL_GetModState() & (KMOD_LSHIFT | KMOD_RSHIFT);            SDL_bool repeat = event.key.repeat;            switch (event.key.keysym.sym) {            case SDLK_x:                if (!repeat && ctrl && !shift) {                    // Ctrl+x                    struct size optimal_size = get_optimal_window_size(window, frame_size);                    SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                }                break;            case SDLK_f:                if (!repeat && ctrl && !shift) {                    // Ctrl+f                    Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;                    if (!SDL_SetWindowFullscreen(window, new_mode)) {                        fullscreen = !fullscreen;                        render(renderer, texture_empty ? NULL : texture);                    } else {                        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());                    }                }                break;            }            break;        }        }    }screen_quit:    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = adb_reverse_remove(serial, SOCKET_NAME);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool show_screen(const char *serial, Uint16 local_port) {    SDL_bool ret = 0;    const char *server_jar_path = getenv("SCRCPY_SERVER_JAR");    if (!server_jar_path) {        server_jar_path = "scrcpy-server.jar";    }    process_t push_proc = adb_push(serial, server_jar_path, "/data/local/tmp/");    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = adb_reverse(serial, SOCKET_NAME, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    struct size frame_size;    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the width and height values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    SDL_Window *window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    SDL_Texture *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    long ts = timestamp_ms();    int nbframes = 0;    SDL_bool texture_empty = SDL_TRUE;    SDL_bool fullscreen = SDL_FALSE;    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            goto screen_quit;        case EVENT_NEW_FRAME:            mutex_lock(frames.mutex);            AVFrame *frame = frames.rendering_frame;            frames.rendering_frame_consumed = SDL_TRUE;            if (!decoder.skip_frames) {                cond_signal(frames.rendering_frame_consumed_cond);            }            struct size current_frame_size = {frame->width, frame->height};            if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {                goto screen_quit;            }            frame_size = current_frame_size;            update_texture(frame, texture);            mutex_unlock(frames.mutex);            texture_empty = SDL_FALSE;            long now = timestamp_ms();            ++nbframes;            if (now - ts > 1000) {                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "%d fps", nbframes);                ts = now;                nbframes = 0;            }            render(renderer, texture);            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_KEYDOWN: {            SDL_bool ctrl = SDL_GetModState() & (KMOD_LCTRL | KMOD_RCTRL);            SDL_bool shift = SDL_GetModState() & (KMOD_LSHIFT | KMOD_RSHIFT);            SDL_bool repeat = event.key.repeat;            switch (event.key.keysym.sym) {            case SDLK_x:                if (!repeat && ctrl && !shift) {                    // Ctrl+x                    struct size optimal_size = get_optimal_window_size(window, frame_size);                    SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                }                break;            case SDLK_f:                if (!repeat && ctrl && !shift) {                    // Ctrl+f                    Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;                    if (!SDL_SetWindowFullscreen(window, new_mode)) {                        fullscreen = !fullscreen;                        render(renderer, texture_empty ? NULL : texture);                    } else {                        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());                    }                }                break;            }            break;        }        }    }screen_quit:    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = adb_reverse_remove(serial, SOCKET_NAME);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
    public void control() throws IOException {        while (handleEvent());    }
    private boolean injectKeyEvent(int action, int keyCode, int repeat, int metaState) {        long now = SystemClock.uptimeMillis();        KeyEvent event = new KeyEvent(now, now, action, keyCode, repeat, metaState, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, 0, InputDevice.SOURCE_KEYBOARD);        return injectEvent(event);    }
    private boolean injectMouse(int action, int buttons, Position position) {        long now = SystemClock.uptimeMillis();        if (action == MotionEvent.ACTION_DOWN) {            lastMouseDown = now;        }        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        setPointerCoords(point);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, action, 1, pointerProperties, pointerCoords, 0, buttons, 1f, 1f, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
    private boolean injectScroll(Position position, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        setPointerCoords(point);        setScroll(hScroll, vScroll);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, MotionEvent.ACTION_SCROLL, 1, pointerProperties, pointerCoords, 0, 0, 1f, 1f, 0, 0, InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
    public void control() throws IOException {        while (handleEvent()) ;    }
    private boolean injectKeyEvent(int action, int keyCode, int repeat, int metaState) {        long now = SystemClock.uptimeMillis();        KeyEvent event = new KeyEvent(now, now, action, keyCode, repeat, metaState, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, 0,                InputDevice.SOURCE_KEYBOARD);        return injectEvent(event);    }
    private boolean injectMouse(int action, int buttons, Position position) {        long now = SystemClock.uptimeMillis();        if (action == MotionEvent.ACTION_DOWN) {            lastMouseDown = now;        }        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        setPointerCoords(point);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, action, 1, pointerProperties, pointerCoords, 0, buttons, 1f, 1f, 0, 0,                InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
    private boolean injectScroll(Position position, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        setPointerCoords(point);        setScroll(hScroll, vScroll);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, MotionEvent.ACTION_SCROLL, 1, pointerProperties, pointerCoords, 0, 0, 1f, 1f, 0,                0, InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
        localSocket.connect(new LocalSocketAddress(abstractName));        return localSocket;    }    public static DesktopConnection open(Device device) throws IOException {        LocalSocket socket = connect(SOCKET_NAME);        DesktopConnection connection = new DesktopConnection(socket);        Size videoSize = device.getScreenInfo().getVideoSize();        connection.send(Device.getDeviceName(), videoSize.getWidth(), videoSize.getHeight());        return connection;    }
    public void sendVideoStream(byte[] videoStreamBuffer, int len) throws IOException {        outputStream.write(videoStreamBuffer, 0, len);    }
    public OutputStream getOutputStream() {        return outputStream;    }
    public OutputStream getOutputStream() {        return outputStream;    }
    private ScreenInfo computeScreenInfo(int maximumSize) {        // Compute the video size and the padding of the content inside this video.        // Principle:        // - scale down the great side of the screen to maximumSize (if necessary);        // - scale down the other side so that the aspect ratio is preserved;        // - ceil this value to the next multiple of 8 (H.264 only accepts multiples of 8)        // - this may introduce black bands, so store the padding (typically a few pixels)        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        int w = deviceSize.getWidth();        int h = deviceSize.getHeight();        int padding = 0;        if (maximumSize > 0) {            assert maximumSize % 8 == 0;            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;            if (major > maximumSize) {                int minorExact = minor * maximumSize / major;                // +7 to ceil the value on rounding to the next multiple of 8,                // so that any necessary black bands to keep the aspect ratio are added to the smallest dimension                minor = (minorExact + 7) & ~7;                major = maximumSize;                padding = minor - minorExact;            }            w = portrait ? minor : major;            h = portrait ? major : minor;        }        return new ScreenInfo(deviceSize, new Size(w, h), padding, rotated);    }
    public Point getPhysicalPoint(Position position) {        ScreenInfo screenInfo = getScreenInfo(); // read with synchronization        Size videoSize = screenInfo.getVideoSize();        Size clientVideoSize = position.getScreenSize();        if (!videoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event            return null;        }        Size deviceSize = screenInfo.getDeviceSize();        int xPadding = screenInfo.getXPadding();        int yPadding = screenInfo.getYPadding();        int contentWidth = videoSize.getWidth() - xPadding;        int contentHeight = videoSize.getHeight() - yPadding;        Point point = position.getPoint();        int x = point.x - xPadding / 2;        int y = point.y - yPadding / 2;        if (x < 0 || x >= contentWidth || y < 0 || y >= contentHeight) {            // out of screen            return null;        }        int scaledX = x * deviceSize.getWidth() / videoSize.getWidth();        int scaledY = y * deviceSize.getHeight() / videoSize.getHeight();        return new Point(scaledX, scaledY);    }
    private ScreenInfo computeScreenInfo(int maximumSize) {        // Compute the video size and the padding of the content inside this video.        // Principle:        // - scale down the great side of the screen to maximumSize (if necessary);        // - scale down the other side so that the aspect ratio is preserved;        // - round this value to the nearest multiple of 8 (H.264 only accepts multiples of 8)        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        int w = deviceSize.getWidth();        int h = deviceSize.getHeight();        if (maximumSize > 0) {            assert maximumSize % 8 == 0;            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;            if (major > maximumSize) {                int minorExact = minor * maximumSize / major;                // +4 to round the value to the nearest multiple of 8                minor = (minorExact + 4) & ~7;                major = maximumSize;            }            w = portrait ? minor : major;            h = portrait ? major : minor;        }        Size videoSize = new Size(w, h);        return new ScreenInfo(deviceSize, videoSize, rotated);    }
    public Point getPhysicalPoint(Position position) {        ScreenInfo screenInfo = getScreenInfo(); // read with synchronization        Size videoSize = screenInfo.getVideoSize();        Size clientVideoSize = position.getScreenSize();        if (!videoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event            return null;        }        Size deviceSize = screenInfo.getDeviceSize();        Point point = position.getPoint();        int scaledX = point.x * deviceSize.getWidth() / videoSize.getWidth();        int scaledY = point.y * deviceSize.getHeight() / videoSize.getHeight();        return new Point(scaledX, scaledY);    }
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        try (DesktopConnection connection = DesktopConnection.open(device)) {            final ScreenStreamer streamer = new ScreenStreamer(device, connection);            device.setRotationListener(new Device.RotationListener() {                @Override                public void onRotationChanged(int rotation) {                    streamer.reset();                }            });            // asynchronous            startEventController(device, connection);            try {                // synchronous                streamer.streamScreen();            } catch (IOException e) {                Ln.e("Screen streaming interrupted", e);            }        }    }
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        try (DesktopConnection connection = DesktopConnection.open(device)) {            ScreenEncoder screenEncoder = new ScreenEncoder();            // asynchronous            startEventController(device, connection);            try {                // synchronous                screenEncoder.streamScreen(device, connection.getOutputStream());            } catch (IOException e) {                Ln.e("Screen streaming interrupted", e);            }        }    }
    public int getXPadding() {        return videoSize.getWidth() < videoSize.getHeight() ? padding : 0;    }
    public ScreenInfo withRotation(int rotation) {        boolean newRotated = (rotation & 1) != 0;        if (rotated == newRotated) {            return this;        }        return new ScreenInfo(deviceSize.rotate(), videoSize.rotate(), padding, newRotated);    }}
    public ScreenInfo(Size deviceSize, Size videoSize, int padding, boolean rotated) {        this.deviceSize = deviceSize;        this.videoSize = videoSize;        this.padding = padding;        this.rotated = rotated;    }
    public int getYPadding() {        return videoSize.getHeight() < videoSize.getWidth() ? padding : 0;    }
    public ScreenInfo(Size deviceSize, Size videoSize, int padding, boolean rotated) {        this.deviceSize = deviceSize;        this.videoSize = videoSize;        this.padding = padding;        this.rotated = rotated;    }
        if (rotated == newRotated) {            return this;        }        return new ScreenInfo(deviceSize.rotate(), videoSize.rotate(), newRotated);
    public ScreenInfo withRotation(int rotation) {        boolean newRotated = (rotation & 1) != 0;        if (rotated == newRotated) {            return this;        }        return new ScreenInfo(deviceSize.rotate(), videoSize.rotate(), newRotated);    }}
        this.deviceSize = deviceSize;        this.videoSize = videoSize;        this.rotated = rotated;    }    public Size getDeviceSize() {        return deviceSize;
    }}
    public ScreenInfo(Size deviceSize, Size videoSize, boolean rotated) {        this.deviceSize = deviceSize;        this.videoSize = videoSize;        this.rotated = rotated;    }
SDL_bool scrcpy(const struct scrcpy_options *options) {    SDL_bool send_frame_meta = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      send_frame_meta)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!video_buffer_init(&video_buffer)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_video_buffer;    }    struct recorder *rec = NULL;    if (options->record_filename) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    decoder_init(&decoder, &video_buffer, device_socket, rec);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size, options->always_on_top)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_recorder:    if (options->record_filename) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_video_buffer:    video_buffer_destroy(&video_buffer);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    SDL_bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!video_buffer_init(&video_buffer)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_video_buffer;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    decoder_init(&decoder, &video_buffer, device_socket, rec);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size, options->always_on_top)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_video_buffer:    video_buffer_destroy(&video_buffer);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    SDL_bool send_frame_meta = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      send_frame_meta)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!video_buffer_init(&video_buffer)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_video_buffer;    }    struct recorder *rec = NULL;    if (options->record_filename) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    decoder_init(&decoder, &video_buffer, device_socket, rec);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size, options->always_on_top)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_recorder:    if (options->record_filename) {        recorder_destroy(&recorder);    }finally_destroy_video_buffer:    video_buffer_destroy(&video_buffer);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    SDL_bool send_frame_meta = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      send_frame_meta)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!video_buffer_init(&video_buffer)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_video_buffer;    }    struct recorder *rec = NULL;    if (options->record_filename) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    decoder_init(&decoder, &video_buffer, device_socket, rec);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size, options->always_on_top)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_recorder:    if (options->record_filename) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_video_buffer:    video_buffer_destroy(&video_buffer);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    Ctrl+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    Ctrl+Shift+o\n"        "        turn device screen on\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+c\n"        "        copy device clipboard to computer\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    Ctrl+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+c\n"        "        copy device clipboard to computer\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}static voidprint_version(void) {    fprintf(stderr, "scrcpy %s\n\n", SCRCPY_VERSION);
static void test_serialize_long_text_event(void) {    struct control_event event;    event.type = CONTROL_EVENT_TYPE_TEXT;    char text[TEXT_MAX_LENGTH];    memset(text, 'a', sizeof(text));    event.text_event.text = text;    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 3 + sizeof(text));    unsigned char expected[3 + TEXT_MAX_LENGTH];    expected[0] = 0x01; // CONTROL_EVENT_TYPE_KEYCODE    expected[1] = 0x01;    expected[2] = 0x2c; // text length (16 bits)    memset(&expected[3], 'a', TEXT_MAX_LENGTH);    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_long_text_event(void) {    struct control_event event;    event.type = CONTROL_EVENT_TYPE_TEXT;    char text[TEXT_MAX_LENGTH + 1];    memset(text, 'a', sizeof(text));    text[TEXT_MAX_LENGTH] = '\0';    event.text_event.text = text;    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 3 + TEXT_MAX_LENGTH);    unsigned char expected[3 + TEXT_MAX_LENGTH];    expected[0] = 0x01; // CONTROL_EVENT_TYPE_KEYCODE    expected[1] = 0x01;    expected[2] = 0x2c; // text length (16 bits)    memset(&expected[3], 'a', TEXT_MAX_LENGTH);    assert(!memcmp(buf, expected, sizeof(expected)));}
connect_and_read_byte(uint16_t port) {    socket_t socket = net_connect(IPV4_LOCALHOST, port);    if (socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    char byte;    // the connection may succeed even if the server behind the "adb tunnel"    // is not listening, so read one byte to detect a working connection    if (net_recv_all(socket, &byte, 1) != 1) {        // the server is not listening yet behind the adb tunnel        return INVALID_SOCKET;    }    return socket;}
connect_and_read_byte(uint16_t port) {    socket_t socket = net_connect(IPV4_LOCALHOST, port);    if (socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    char byte;    // the connection may succeed even if the server behind the "adb tunnel"    // is not listening, so read one byte to detect a working connection    if (net_recv(socket, &byte, 1) != 1) {        // the server is not listening yet behind the adb tunnel        return INVALID_SOCKET;    }    return socket;}
    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot send %s (DOWN)", name);        return;    }    // send UP event    control_event.keycode_event.action = AKEY_EVENT_ACTION_UP;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot send %s (UP)", name);    }}static inline void action_home(struct controller *controller) {    send_keycode(controller, AKEYCODE_HOME, "HOME");}static inline void action_back(struct controller *controller) {    send_keycode(controller, AKEYCODE_BACK, "BACK");}static inline void action_app_switch(struct controller *controller) {    send_keycode(controller, AKEYCODE_APP_SWITCH, "APP_SWITCH");}static inline void action_power(struct controller *controller) {    send_keycode(controller, AKEYCODE_POWER, "POWER");}static inline void action_volume_up(struct controller *controller) {    send_keycode(controller, AKEYCODE_VOLUME_UP, "VOLUME_UP");}static inline void action_volume_down(struct controller *controller) {    send_keycode(controller, AKEYCODE_VOLUME_DOWN, "VOLUME_DOWN");}static void turn_screen_on(struct controller *controller) {    struct control_event control_event = {        .type = CONTROL_EVENT_TYPE_COMMAND,        .command_event = {            .action = CONTROL_EVENT_COMMAND_SCREEN_ON,        },    };    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot turn screen on");    }}void input_manager_process_text_input(struct input_manager *input_manager,                                      const SDL_TextInputEvent *event) {    if (is_ctrl_down()) {        switch (event->text[0]) {            case '+':
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        switch (keycode) {            case SDLK_h:                action_home(input_manager->controller);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(input_manager->controller);                return;            case SDLK_m:                action_app_switch(input_manager->controller);                return;            case SDLK_p:                action_power(input_manager->controller);                return;            case SDLK_f:                screen_switch_fullscreen(input_manager->screen);                return;            case SDLK_x:                screen_resize_to_fit(input_manager->screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(input_manager->screen);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
static void switch_fps_counter_state(struct frames *frames) {    mutex_lock(frames->mutex);    if (frames->fps_counter.started) {        LOGI("FPS counter stopped");        fps_counter_stop(&frames->fps_counter);    } else {        LOGI("FPS counter started");        fps_counter_start(&frames->fps_counter);    }    mutex_unlock(frames->mutex);}
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        switch (keycode) {            case SDLK_h:                action_home(input_manager->controller);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(input_manager->controller);                return;            case SDLK_m:                action_app_switch(input_manager->controller);                return;            case SDLK_p:                action_power(input_manager->controller);                return;            case SDLK_f:                screen_switch_fullscreen(input_manager->screen);                return;            case SDLK_x:                screen_resize_to_fit(input_manager->screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(input_manager->screen);                return;            case SDLK_i:                switch_fps_counter_state(input_manager->frames);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "        resize window to optimal size (remove black borders)\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "        click on BACK\n"        "\n"        "    Ctrl+m\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+'+'\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+'-'\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click\n"        "        turn screen on\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "        resize window to optimal size (remove black borders)\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "        click on BACK\n"        "\n"        "    Ctrl+m\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+'+'\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+'-'\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click\n"        "        turn screen on\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return;            case SDL_QUIT:                LOGD("User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                    fps_counter_start(&frames.fps_counter);                }                if (!screen_update_frame(&screen, &frames)) {                    return;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;                }                break;            case SDL_TEXTINPUT: {                input_manager_process_text_input(&input_manager, &event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL: {                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                input_manager_process_mouse_button(&input_manager, &event.button);                break;            }        }    }}
static void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return;            case SDL_QUIT:                LOGD("User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;                }                break;            case SDL_TEXTINPUT: {                input_manager_process_text_input(&input_manager, &event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL: {                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                input_manager_process_mouse_button(&input_manager, &event.button);                break;            }        }    }}
event_loop(bool display, bool control) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    if (display) {        SDL_AddEventWatch(event_watcher, NULL);    }#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        enum event_result result = handle_event(&event, control);        switch (result) {            case EVENT_RESULT_STOPPED_BY_USER:                return true;            case EVENT_RESULT_STOPPED_BY_EOS:                return false;            case EVENT_RESULT_CONTINUE:                break;        }    }    return false;}
event_loop(bool display, bool control) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    if (display) {        SDL_AddEventWatch(event_watcher, NULL);    }#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        enum event_result result = handle_event(&event, control);        switch (result) {            case EVENT_RESULT_STOPPED_BY_USER:                return true;            case EVENT_RESULT_STOPPED_BY_EOS:                LOGW("Device disconnected");                return false;            case EVENT_RESULT_CONTINUE:                break;        }    }    return false;}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        params->send_frame_meta ? "true" : "false",        params->control ? "true" : "false",    };    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/" SERVER_FILENAME,        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        params->send_frame_meta ? "true" : "false",        params->control ? "true" : "false",    };    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"bit-rate",     required_argument, NULL, 'b'},        {"crop",         required_argument, NULL, 'c'},        {"help",         no_argument,       NULL, 'h'},        {"max-size",     required_argument, NULL, 'm'},        {"port",         required_argument, NULL, 'p'},        {"serial",       required_argument, NULL, 's'},        {"show-touches", no_argument,       NULL, 't'},        {"version",      no_argument,       NULL, 'v'},        {NULL,           0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:hm:p:s:tv", long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'c':                args->crop = optarg;                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = SDL_TRUE;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    return SDL_TRUE;}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"bit-rate",     required_argument, NULL, 'b'},        {"crop",         required_argument, NULL, 'c'},        {"fullscreen",   no_argument,       NULL, 'f'},        {"help",         no_argument,       NULL, 'h'},        {"max-size",     required_argument, NULL, 'm'},        {"port",         required_argument, NULL, 'p'},        {"serial",       required_argument, NULL, 's'},        {"show-touches", no_argument,       NULL, 't'},        {"version",      no_argument,       NULL, 'v'},        {NULL,           0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fhm:p:s:tv", long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = SDL_TRUE;                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = SDL_TRUE;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    return SDL_TRUE;}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_file_handler;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_file_handler;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
static int run_controller(void *data) {    struct controller *controller = data;    mutex_lock(controller->mutex);    for (;;) {        while (!controller->stopped && control_event_queue_is_empty(&controller->queue)) {            cond_wait(controller->event_cond, controller->mutex);        }        if (controller->stopped) {            // stop immediately, do not process further events            break;        }        struct control_event event;        while (control_event_queue_take(&controller->queue, &event)) {            SDL_bool ok = process_event(controller, &event);            control_event_destroy(&event);            if (!ok) {                LOGD("Cannot write event to socket");                goto end;            }        }    }end:    mutex_unlock(controller->mutex);    return 0;}
static int run_controller(void *data) {    struct controller *controller = data;    for (;;) {        mutex_lock(controller->mutex);        while (!controller->stopped && control_event_queue_is_empty(&controller->queue)) {            cond_wait(controller->event_cond, controller->mutex);        }        if (controller->stopped) {            // stop immediately, do not process further events            mutex_unlock(controller->mutex);            break;        }        struct control_event event;#ifdef BUILD_DEBUG        bool non_empty = control_event_queue_take(&controller->queue, &event);        SDL_assert(non_empty);#else        control_event_queue_take(&controller->queue, &event);#endif        mutex_unlock(controller->mutex);        SDL_bool ok = process_event(controller, &event);        control_event_destroy(&event);        if (!ok) {            LOGD("Cannot write event to socket");            break;        }    }    return 0;}
read_xpm(char *xpm[]) {#if SDL_ASSERT_LEVEL >= 2    // patch the XPM to change the icon color in debug mode    xpm[2] = ".	c #CC00CC";#endif    char *endptr;    // *** No error handling, assume the XPM source is valid ***    // (it's in our source repo)    // Assertions are only checked in debug    int width = strtol(xpm[0], &endptr, 10);    int height = strtol(endptr + 1, &endptr, 10);    int colors = strtol(endptr + 1, &endptr, 10);    int chars = strtol(endptr + 1, &endptr, 10);    // sanity checks    SDL_assert(0 <= width && width < 256);    SDL_assert(0 <= height && height < 256);    SDL_assert(0 <= colors && colors < 256);    SDL_assert(chars == 1); // this implementation does not support more    // init index    struct index index[colors];    for (int i = 0; i < colors; ++i) {        const char *line = xpm[1+i];        index[i].c = line[0];        SDL_assert(line[1] == '\t');        SDL_assert(line[2] == 'c');        SDL_assert(line[3] == ' ');        if (line[4] == '#') {            index[i].color = 0xff000000 | strtol(&line[5], &endptr, 0x10);            SDL_assert(*endptr == '\0');        } else {            SDL_assert(!strcmp("None", &line[4]));            index[i].color = 0;        }    }    // parse image    uint32_t *pixels = SDL_malloc(4 * width * height);    if (!pixels) {        LOGE("Could not allocate icon memory");        return NULL;    }    for (int y = 0; y < height; ++y) {        const char *line = xpm[1 + colors + y];        for (int x = 0; x < width; ++x) {            char c = line[x];            uint32_t color;            bool color_found = find_color(index, colors, c, &color);            SDL_assert(color_found);            pixels[y * width + x] = color;        }    }#if SDL_BYTEORDER == SDL_BIG_ENDIAN    uint32_t amask = 0x000000ff;    uint32_t rmask = 0x0000ff00;    uint32_t gmask = 0x00ff0000;    uint32_t bmask = 0xff000000;#else // little endian, like x86    uint32_t amask = 0xff000000;    uint32_t rmask = 0x00ff0000;    uint32_t gmask = 0x0000ff00;    uint32_t bmask = 0x000000ff;#endif    SDL_Surface *surface = SDL_CreateRGBSurfaceFrom(pixels,                                                    width, height,                                                    32, 4 * width,                                                    rmask, gmask, bmask, amask);    // make the surface own the raw pixels    surface->flags &= ~SDL_PREALLOC;    return surface;}
read_xpm(char *xpm[]) {#if SDL_ASSERT_LEVEL >= 2    // patch the XPM to change the icon color in debug mode    xpm[2] = ".	c #CC00CC";#endif    char *endptr;    // *** No error handling, assume the XPM source is valid ***    // (it's in our source repo)    // Assertions are only checked in debug    int width = strtol(xpm[0], &endptr, 10);    int height = strtol(endptr + 1, &endptr, 10);    int colors = strtol(endptr + 1, &endptr, 10);    int chars = strtol(endptr + 1, &endptr, 10);    // sanity checks    SDL_assert(0 <= width && width < 256);    SDL_assert(0 <= height && height < 256);    SDL_assert(0 <= colors && colors < 256);    SDL_assert(chars == 1); // this implementation does not support more    // init index    struct index index[colors];    for (int i = 0; i < colors; ++i) {        const char *line = xpm[1+i];        index[i].c = line[0];        SDL_assert(line[1] == '\t');        SDL_assert(line[2] == 'c');        SDL_assert(line[3] == ' ');        if (line[4] == '#') {            index[i].color = 0xff000000 | strtol(&line[5], &endptr, 0x10);            SDL_assert(*endptr == '\0');        } else {            SDL_assert(!strcmp("None", &line[4]));            index[i].color = 0;        }    }    // parse image    uint32_t *pixels = SDL_malloc(4 * width * height);    if (!pixels) {        LOGE("Could not allocate icon memory");        return NULL;    }    for (int y = 0; y < height; ++y) {        const char *line = xpm[1 + colors + y];        for (int x = 0; x < width; ++x) {            char c = line[x];            uint32_t color;            bool color_found = find_color(index, colors, c, &color);            SDL_assert(color_found);            pixels[y * width + x] = color;        }    }#if SDL_BYTEORDER == SDL_BIG_ENDIAN    uint32_t amask = 0x000000ff;    uint32_t rmask = 0x0000ff00;    uint32_t gmask = 0x00ff0000;    uint32_t bmask = 0xff000000;#else // little endian, like x86    uint32_t amask = 0xff000000;    uint32_t rmask = 0x00ff0000;    uint32_t gmask = 0x0000ff00;    uint32_t bmask = 0x000000ff;#endif    SDL_Surface *surface = SDL_CreateRGBSurfaceFrom(pixels,                                                    width, height,                                                    32, 4 * width,                                                    rmask, gmask, bmask, amask);    if (!surface) {        LOGE("Could not create icon surface");        return NULL;    }    // make the surface own the raw pixels    surface->flags &= ~SDL_PREALLOC;    return surface;}
        return screenInfo;    }    private ScreenInfo computeScreenInfo(int maxSize) {
        return screenInfo;    }    private ScreenInfo computeScreenInfo(int maxSize) {
    public InputManager getInputManager() {        return serviceManager.getInputManager();    }
    public PowerManager getPowerManager() {        return serviceManager.getPowerManager();    }
    public boolean injectInputEvent(InputEvent inputEvent, int mode) {        return serviceManager.getInputManager().injectInputEvent(inputEvent, mode);    }
    public boolean isScreenOn() {        return serviceManager.getPowerManager().isScreenOn();    }
        return serviceManager.getInputManager().injectInputEvent(inputEvent, mode);    }    public boolean isScreenOn() {
        return serviceManager.getPowerManager().isScreenOn();    }    public void registerRotationWatcher(IRotationWatcher rotationWatcher) {
    private boolean injectEvent(InputEvent event) {        return inputManager.injectInputEvent(event, InputManager.INJECT_INPUT_EVENT_MODE_ASYNC);    }
    public EventController(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;        inputManager = device.getInputManager();        powerManager = device.getPowerManager();        initPointer();        // on start, turn screen on        turnScreenOn();    }
    private boolean turnScreenOn() {        return powerManager.isScreenOn() || injectKeycode(KeyEvent.KEYCODE_POWER);    }
    private boolean injectEvent(InputEvent event) {        return device.injectInputEvent(event, InputManager.INJECT_INPUT_EVENT_MODE_ASYNC);    }
        initPointer();        // on start, turn screen on        turnScreenOn();    }    private void initPointer() {        MotionEvent.PointerProperties props = pointerProperties[0];        props.id = 0;        props.toolType = MotionEvent.TOOL_TYPE_FINGER;
    private boolean turnScreenOn() {        return device.isScreenOn() || injectKeycode(KeyEvent.KEYCODE_POWER);    }
socket_t server_connect_to(struct server *server) {    if (!server->tunnel_forward) {        server->device_socket = net_accept(server->server_socket);    } else {        Uint32 attempts = 50;        Uint32 delay = 100; // ms        server->device_socket = connect_to_server(server->local_port, attempts, delay);    }    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    if (!server->tunnel_forward) {        // we don't need the server socket anymore        close_socket(&server->server_socket);    }    // the server is started, we can clean up the jar from the temporary folder    remove_server(server->serial); // ignore failure    server->server_copied_to_device = SDL_FALSE;    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = SDL_FALSE;    return server->device_socket;}
socket_t server_connect_to(struct server *server) {    if (!server->tunnel_forward) {        server->device_socket = net_accept(server->server_socket);    } else {        Uint32 attempts = 100;        Uint32 delay = 100; // ms        server->device_socket = connect_to_server(server->local_port, attempts, delay);    }    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    if (!server->tunnel_forward) {        // we don't need the server socket anymore        close_socket(&server->server_socket);    }    // the server is started, we can clean up the jar from the temporary folder    remove_server(server->serial); // ignore failure    server->server_copied_to_device = SDL_FALSE;    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = SDL_FALSE;    return server->device_socket;}
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        MediaFormat format = createFormat(bitRate, frameRate, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                Rect contentRect = device.getScreenInfo().getContentRect();                Rect videoRect = device.getScreenInfo().getVideoSize().toRect();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, contentRect, videoRect);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        // Some devices internally create a Handler when creating an input Surface, causing an exception:        //   "Can't create handler inside thread that has not called Looper.prepare()"        // <https://github.com/Genymobile/scrcpy/issues/240>        //        // Use Looper.prepareMainLooper() instead of Looper.prepare() to avoid a NullPointerException:        //   "Attempt to read from field 'android.os.MessageQueue android.os.Looper.mQueue'        //    on a null object reference"        // <https://github.com/Genymobile/scrcpy/issues/921>        Looper.prepareMainLooper();        MediaFormat format = createFormat(bitRate, frameRate, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                Rect contentRect = device.getScreenInfo().getContentRect();                Rect videoRect = device.getScreenInfo().getVideoSize().toRect();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, contentRect, videoRect);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
void input_manager_process_mouse_button(struct input_manager *input_manager,                                        const SDL_MouseButtonEvent *event) {    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(input_manager->controller);            return;        }        if (event->button == SDL_BUTTON_MIDDLE) {            action_home(input_manager->controller);            return;        }    };    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, input_manager->screen->frame_size, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send mouse button event");        }    }}
void input_manager_process_mouse_button(struct input_manager *input_manager,                                        const SDL_MouseButtonEvent *event) {    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(input_manager->controller);            return;        }        if (event->button == SDL_BUTTON_MIDDLE) {            action_home(input_manager->controller);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            SDL_bool outside_device_screen =                    event->x < 0 || event->x >= input_manager->screen->frame_size.width ||                    event->y < 0 || event->y >= input_manager->screen->frame_size.height;                if (outside_device_screen) {                    screen_resize_to_fit(input_manager->screen);                }            return;        }    };    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, input_manager->screen->frame_size, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send mouse button event");        }    }}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+m\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+'+'\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+'-'\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+m\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+'+'\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+'-'\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
    public CharSequence getText() {        Method method = getGetPrimaryClipMethod();        if (method == null) {            return null;        }        try {            ClipData clipData = getPrimaryClip(method, manager);            if (clipData == null || clipData.getItemCount() == 0) {                return null;            }            return clipData.getItemAt(0).getText();        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);            return null;        }    }
    private Method getSetPrimaryClipMethod() {        if (setPrimaryClipMethod == null) {            try {                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                    setPrimaryClipMethod = manager.getClass().getMethod("setPrimaryClip", ClipData.class, String.class);                } else {                    setPrimaryClipMethod = manager.getClass().getMethod("setPrimaryClip", ClipData.class, String.class, int.class);                }            } catch (NoSuchMethodException e) {                Ln.e("Could not find method", e);            }        }        return setPrimaryClipMethod;    }
    private Method getGetPrimaryClipMethod() {        if (getPrimaryClipMethod == null) {            try {                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                    getPrimaryClipMethod = manager.getClass().getMethod("getPrimaryClip", String.class);                } else {                    getPrimaryClipMethod = manager.getClass().getMethod("getPrimaryClip", String.class, int.class);                }            } catch (NoSuchMethodException e) {                Ln.e("Could not find method", e);            }        }        return getPrimaryClipMethod;    }
    public void setText(CharSequence text) {        Method method = getSetPrimaryClipMethod();        if (method == null) {            return;        }        ClipData clipData = ClipData.newPlainText(null, text);        try {            setPrimaryClip(method, manager, clipData);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);        }    }}
    public CharSequence getText() {        try {            Method method = getGetPrimaryClipMethod();            ClipData clipData = getPrimaryClip(method, manager);            if (clipData == null || clipData.getItemCount() == 0) {                return null;            }            return clipData.getItemAt(0).getText();        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            Ln.e("Could not invoke method", e);            return null;        }    }
    private Method getSetPrimaryClipMethod() throws NoSuchMethodException {        if (setPrimaryClipMethod == null) {            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                setPrimaryClipMethod = manager.getClass().getMethod("setPrimaryClip", ClipData.class, String.class);            } else {                setPrimaryClipMethod = manager.getClass().getMethod("setPrimaryClip", ClipData.class, String.class, int.class);            }        }        return setPrimaryClipMethod;    }
    private Method getGetPrimaryClipMethod() throws NoSuchMethodException {        if (getPrimaryClipMethod == null) {            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                getPrimaryClipMethod = manager.getClass().getMethod("getPrimaryClip", String.class);            } else {                getPrimaryClipMethod = manager.getClass().getMethod("getPrimaryClip", String.class, int.class);            }        }        return getPrimaryClipMethod;    }
    public void setText(CharSequence text) {        try {            Method method = getSetPrimaryClipMethod();            ClipData clipData = ClipData.newPlainText(null, text);            setPrimaryClip(method, manager, clipData);        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            Ln.e("Could not invoke method", e);        }    }}
    private Method getInjectInputEventMethod() {        if (injectInputEventMethod == null) {            try {                injectInputEventMethod = manager.getClass().getMethod("injectInputEvent", InputEvent.class, int.class);            } catch (NoSuchMethodException e) {                Ln.e("Could not find method", e);            }        }        return injectInputEventMethod;    }
    public boolean injectInputEvent(InputEvent inputEvent, int mode) {        Method method = getInjectInputEventMethod();        if (method == null) {            return false;        }        try {            return (Boolean) method.invoke(manager, inputEvent, mode);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);            return false;        }    }}
    private Method getInjectInputEventMethod() throws NoSuchMethodException {        if (injectInputEventMethod == null) {            injectInputEventMethod = manager.getClass().getMethod("injectInputEvent", InputEvent.class, int.class);        }        return injectInputEventMethod;    }
    public boolean injectInputEvent(InputEvent inputEvent, int mode) {        try {            Method method = getInjectInputEventMethod();            return (boolean) method.invoke(manager, inputEvent, mode);        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            Ln.e("Could not invoke method", e);            return false;        }    }}
    public boolean isScreenOn() {        Method method = getIsScreenOnMethod();        if (method == null) {            return false;        }        try {            return (Boolean) method.invoke(manager);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);            return false;        }    }}
    private Method getIsScreenOnMethod() {        if (isScreenOnMethod == null) {            try {                @SuppressLint("ObsoleteSdkInt") // we may lower minSdkVersion in the future                        String methodName = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT_WATCH ? "isInteractive" : "isScreenOn";                isScreenOnMethod = manager.getClass().getMethod(methodName);            } catch (NoSuchMethodException e) {                Ln.e("Could not find method", e);            }        }        return isScreenOnMethod;    }
    public boolean isScreenOn() {        try {            Method method = getIsScreenOnMethod();            return (boolean) method.invoke(manager);        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            Ln.e("Could not invoke method", e);            return false;        }    }}
    private Method getIsScreenOnMethod() throws NoSuchMethodException {        if (isScreenOnMethod == null) {            @SuppressLint("ObsoleteSdkInt") // we may lower minSdkVersion in the future                    String methodName = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT_WATCH ? "isInteractive" : "isScreenOn";            isScreenOnMethod = manager.getClass().getMethod(methodName);        }        return isScreenOnMethod;    }
    public void expandNotificationsPanel() {        Method method = getExpandNotificationsPanelMethod();        if (method == null) {            return;        }        try {            method.invoke(manager);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);        }    }
    private Method getCollapsePanelsMethod() {        if (collapsePanelsMethod == null) {            try {                collapsePanelsMethod = manager.getClass().getMethod("collapsePanels");            } catch (NoSuchMethodException e) {                Ln.e("Could not find method", e);            }        }        return collapsePanelsMethod;    }
    public void collapsePanels() {        Method method = getCollapsePanelsMethod();        if (method == null) {            return;        }        try {            method.invoke(manager);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);        }    }}
    private Method getExpandNotificationsPanelMethod() {        if (expandNotificationsPanelMethod == null) {            try {                expandNotificationsPanelMethod = manager.getClass().getMethod("expandNotificationsPanel");            } catch (NoSuchMethodException e) {                Ln.e("Could not find method", e);            }        }        return expandNotificationsPanelMethod;    }
    public void expandNotificationsPanel() {        try {            Method method = getExpandNotificationsPanelMethod();            method.invoke(manager);        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            Ln.e("Could not invoke method", e);        }    }
    private Method getCollapsePanelsMethod() throws NoSuchMethodException {        if (collapsePanelsMethod == null) {            collapsePanelsMethod = manager.getClass().getMethod("collapsePanels");        }        return collapsePanelsMethod;    }
    public void collapsePanels() {        try {            Method method = getCollapsePanelsMethod();            method.invoke(manager);        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            Ln.e("Could not invoke method", e);        }    }}
    private Method getExpandNotificationsPanelMethod() throws NoSuchMethodException {        if (expandNotificationsPanelMethod == null) {            expandNotificationsPanelMethod = manager.getClass().getMethod("expandNotificationsPanel");        }        return expandNotificationsPanelMethod;    }
    public static IBinder getBuiltInDisplay() {        Method method = getGetBuiltInDisplayMethod();        if (method == null) {            return null;        }        try {            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                // call getBuiltInDisplay(0)                return (IBinder) method.invoke(null, 0);            }            // call getInternalDisplayToken()            return (IBinder) method.invoke(null);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);            return null;        }    }
    private static Method getGetBuiltInDisplayMethod() {        if (getBuiltInDisplayMethod == null) {            try {                // the method signature has changed in Android Q                // <https://github.com/Genymobile/scrcpy/issues/586>                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                    getBuiltInDisplayMethod = CLASS.getMethod("getBuiltInDisplay", int.class);                } else {                    getBuiltInDisplayMethod = CLASS.getMethod("getInternalDisplayToken");                }            } catch (NoSuchMethodException e) {                Ln.e("Could not find method", e);            }        }        return getBuiltInDisplayMethod;    }
    public static void setDisplayPowerMode(IBinder displayToken, int mode) {        Method method = getSetDisplayPowerModeMethod();        if (method == null) {            return;        }        try {            method.invoke(null, displayToken, mode);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);        }    }
    private static Method getSetDisplayPowerModeMethod() {        if (setDisplayPowerModeMethod == null) {            try {                setDisplayPowerModeMethod = CLASS.getMethod("setDisplayPowerMode", IBinder.class, int.class);            } catch (NoSuchMethodException e) {                Ln.e("Could not find method", e);            }        }        return setDisplayPowerModeMethod;    }
    public static IBinder getBuiltInDisplay() {        try {            Method method = getGetBuiltInDisplayMethod();            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                // call getBuiltInDisplay(0)                return (IBinder) method.invoke(null, 0);            }            // call getInternalDisplayToken()            return (IBinder) method.invoke(null);        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            Ln.e("Could not invoke method", e);            return null;        }    }
    private static Method getGetBuiltInDisplayMethod() throws NoSuchMethodException {        if (getBuiltInDisplayMethod == null) {            // the method signature has changed in Android Q            // <https://github.com/Genymobile/scrcpy/issues/586>            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                getBuiltInDisplayMethod = CLASS.getMethod("getBuiltInDisplay", int.class);            } else {                getBuiltInDisplayMethod = CLASS.getMethod("getInternalDisplayToken");            }        }        return getBuiltInDisplayMethod;    }
    public static void setDisplayPowerMode(IBinder displayToken, int mode) {        try {            Method method = getSetDisplayPowerModeMethod();            method.invoke(null, displayToken, mode);        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            Ln.e("Could not invoke method", e);        }    }
    private static Method getSetDisplayPowerModeMethod() throws NoSuchMethodException {        if (setDisplayPowerModeMethod == null) {            setDisplayPowerModeMethod = CLASS.getMethod("setDisplayPowerMode", IBinder.class, int.class);        }        return setDisplayPowerModeMethod;    }
    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Could not open H.264 codec");        ret = -1;        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        SDL_LogCritical(SDL_LOG_CATEGORY_VIDEO, "Could not allocate format context");        ret = -1;        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        SDL_LogCritical(SDL_LOG_CATEGORY_VIDEO, "Could not allocate buffer");        ret = -1;        goto run_finally_free_format_ctx;
void decoder_stop(struct decoder *decoder) {    frames_stop(decoder->frames);}
#endif    SDL_DestroyMutex(frames->mutex);    av_frame_free(&frames->rendering_frame);    av_frame_free(&frames->decoding_frame);}static void frames_swap(struct frames *frames) {    AVFrame *tmp = frames->decoding_frame;    frames->decoding_frame = frames->rendering_frame;    frames->rendering_frame = tmp;}SDL_bool frames_offer_decoded_frame(struct frames *frames) {    mutex_lock(frames->mutex);    SDL_bool previous_frame_consumed;#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then the decoder must wait for the current    // frame to be consumed    while (!frames->rendering_frame_consumed) {        cond_wait(frames->rendering_frame_consumed_cond, frames->mutex);
SDL_bool frames_offer_decoded_frame(struct frames *frames) {    mutex_lock(frames->mutex);    SDL_bool previous_frame_consumed;#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then the decoder must wait for the current    // frame to be consumed    while (!frames->rendering_frame_consumed) {        cond_wait(frames->rendering_frame_consumed_cond, frames->mutex);    }    // by definition, we are not skipping the frames    previous_frame_consumed = SDL_TRUE;#else    previous_frame_consumed = frames->rendering_frame_consumed;    if (!previous_frame_consumed) {        SDL_LogDebug(SDL_LOG_CATEGORY_RENDER, "Skip frame");    }#endif    frames_swap(frames);    frames->rendering_frame_consumed = SDL_FALSE;    mutex_unlock(frames->mutex);    return previous_frame_consumed;}
SDL_bool frames_init(struct frames *frames) {    if (!(frames->decoding_frame = av_frame_alloc())) {        goto error_0;    }    if (!(frames->rendering_frame = av_frame_alloc())) {        goto error_1;    }    if (!(frames->mutex = SDL_CreateMutex())) {        goto error_2;    }#ifndef SKIP_FRAMES    if (!(frames->rendering_frame_consumed_cond = SDL_CreateCond())) {        SDL_DestroyMutex(frames->mutex);        goto error_2;    }#endif    // there is initially no rendering frame, so consider it has already been    // consumed    frames->rendering_frame_consumed = SDL_TRUE;    return SDL_TRUE;error_2:    av_frame_free(&frames->rendering_frame);error_1:    av_frame_free(&frames->decoding_frame);error_0:    return SDL_FALSE;}
void frames_stop(struct frames *frames) {#ifdef SKIP_FRAMES    (void) frames; // unused#else    mutex_lock(frames->mutex);    frames->stopped = SDL_TRUE;    mutex_unlock(frames->mutex);    // wake up blocking wait    cond_signal(frames->rendering_frame_consumed_cond);#endif}
SDL_bool frames_offer_decoded_frame(struct frames *frames) {    mutex_lock(frames->mutex);#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then the decoder must wait for the current    // frame to be consumed    while (!frames->rendering_frame_consumed && !frames->stopped) {        cond_wait(frames->rendering_frame_consumed_cond, frames->mutex);    }#else    if (!frames->rendering_frame_consumed) {        SDL_LogDebug(SDL_LOG_CATEGORY_RENDER, "Skip frame");    }#endif    frames_swap(frames);    SDL_bool previous_frame_consumed = frames->rendering_frame_consumed;    frames->rendering_frame_consumed = SDL_FALSE;    mutex_unlock(frames->mutex);    return previous_frame_consumed;}
SDL_bool frames_init(struct frames *frames) {    if (!(frames->decoding_frame = av_frame_alloc())) {        goto error_0;    }    if (!(frames->rendering_frame = av_frame_alloc())) {        goto error_1;    }    if (!(frames->mutex = SDL_CreateMutex())) {        goto error_2;    }#ifndef SKIP_FRAMES    if (!(frames->rendering_frame_consumed_cond = SDL_CreateCond())) {        SDL_DestroyMutex(frames->mutex);        goto error_2;    }    frames->stopped = SDL_FALSE;#endif    // there is initially no rendering frame, so consider it has already been    // consumed    frames->rendering_frame_consumed = SDL_TRUE;    return SDL_TRUE;error_2:    av_frame_free(&frames->rendering_frame);error_1:    av_frame_free(&frames->decoding_frame);error_0:    return SDL_FALSE;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = server_connect_to(&server, serial);    if (!device_socket) {        server_stop(&server, serial);        return SDL_FALSE;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server, serial);        return SDL_FALSE;    }    if (!frames_init(&frames)) {        server_stop(&server, serial);        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    decoder.frames = &frames;    decoder.video_socket = device_socket;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server, serial);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    // kill the server before decoder_join() to wake up the decoder    server_stop(&server, serial);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = server_connect_to(&server, serial);    if (!device_socket) {        server_stop(&server, serial);        return SDL_FALSE;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server, serial);        return SDL_FALSE;    }    if (!frames_init(&frames)) {        server_stop(&server, serial);        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    decoder.frames = &frames;    decoder.video_socket = device_socket;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server, serial);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // kill the server before decoder_join() to wake up the decoder    server_stop(&server, serial);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);    return ret;}
static void test_options(void) {    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    char *argv[] = {        "scrcpy",        "--always-on-top",        "--bit-rate", "5M",        "--crop", "100:200:300:400",        "--fullscreen",        "--max-fps", "30",        "--max-size", "1024",        // "--no-control" is not compatible with "--turn-screen-off"        // "--no-display" is not compatible with "--fulscreen"        "--port", "1234",        "--push-target", "/sdcard/Movies",        "--record", "file",        "--record-format", "mkv",        "--render-expired-frames",        "--serial", "0123456789abcdef",        "--show-touches",        "--turn-screen-off",        "--prefer-text",        "--window-title", "my device",        "--window-x", "100",        "--window-y", "-1",        "--window-width", "600",        "--window-height", "0",        "--window-borderless",    };    bool ok = scrcpy_parse_args(&args, sizeof(argv) / sizeof(*argv), argv);    assert(ok);    const struct scrcpy_options *opts = &args.opts;    assert(opts->always_on_top);    fprintf(stderr, "%d\n", (int) opts->bit_rate);    assert(opts->bit_rate == 5000000);    assert(!strcmp(opts->crop, "100:200:300:400"));    assert(opts->fullscreen);    assert(opts->max_fps == 30);    assert(opts->max_size == 1024);    assert(opts->port == 1234);    assert(!strcmp(opts->push_target, "/sdcard/Movies"));    assert(!strcmp(opts->record_filename, "file"));    assert(opts->record_format == RECORDER_FORMAT_MKV);    assert(opts->render_expired_frames);    assert(!strcmp(opts->serial, "0123456789abcdef"));    assert(opts->show_touches);    assert(opts->turn_screen_off);    assert(opts->prefer_text);    assert(!strcmp(opts->window_title, "my device"));    assert(opts->window_x == 100);    assert(opts->window_y == -1);    assert(opts->window_width == 600);    assert(opts->window_height == 0);    assert(opts->window_borderless);}
static void test_options2(void) {    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    char *argv[] = {        "scrcpy",        "--no-control",        "--no-display",        "--record", "file.mp4", // cannot enable --no-display without recording    };    bool ok = scrcpy_parse_args(&args, sizeof(argv) / sizeof(*argv), argv);    assert(ok);    const struct scrcpy_options *opts = &args.opts;    assert(!opts->control);    assert(!opts->display);    assert(!strcmp(opts->record_filename, "file.mp4"));    assert(opts->record_format == RECORDER_FORMAT_MP4);}
static void test_options(void) {    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    char *argv[] = {        "scrcpy",        "--always-on-top",        "--bit-rate", "5M",        "--crop", "100:200:300:400",        "--fullscreen",        "--max-fps", "30",        "--max-size", "1024",        // "--no-control" is not compatible with "--turn-screen-off"        // "--no-display" is not compatible with "--fulscreen"        "--port", "1234",        "--push-target", "/sdcard/Movies",        "--record", "file",        "--record-format", "mkv",        "--render-expired-frames",        "--serial", "0123456789abcdef",        "--show-touches",        "--turn-screen-off",        "--prefer-text",        "--window-title", "my device",        "--window-x", "100",        "--window-y", "-1",        "--window-width", "600",        "--window-height", "0",        "--window-borderless",    };    bool ok = scrcpy_parse_args(&args, ARRAY_LEN(argv), argv);    assert(ok);    const struct scrcpy_options *opts = &args.opts;    assert(opts->always_on_top);    fprintf(stderr, "%d\n", (int) opts->bit_rate);    assert(opts->bit_rate == 5000000);    assert(!strcmp(opts->crop, "100:200:300:400"));    assert(opts->fullscreen);    assert(opts->max_fps == 30);    assert(opts->max_size == 1024);    assert(opts->port == 1234);    assert(!strcmp(opts->push_target, "/sdcard/Movies"));    assert(!strcmp(opts->record_filename, "file"));    assert(opts->record_format == RECORDER_FORMAT_MKV);    assert(opts->render_expired_frames);    assert(!strcmp(opts->serial, "0123456789abcdef"));    assert(opts->show_touches);    assert(opts->turn_screen_off);    assert(opts->prefer_text);    assert(!strcmp(opts->window_title, "my device"));    assert(opts->window_x == 100);    assert(opts->window_y == -1);    assert(opts->window_width == 600);    assert(opts->window_height == 0);    assert(opts->window_borderless);}
static void test_options2(void) {    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    char *argv[] = {        "scrcpy",        "--no-control",        "--no-display",        "--record", "file.mp4", // cannot enable --no-display without recording    };    bool ok = scrcpy_parse_args(&args, ARRAY_LEN(argv), argv);    assert(ok);    const struct scrcpy_options *opts = &args.opts;    assert(!opts->control);    assert(!opts->display);    assert(!strcmp(opts->record_filename, "file.mp4"));    assert(opts->record_format == RECORDER_FORMAT_MP4);}
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    // capture all Ctrl events    if (ctrl) {        SDL_bool repeat = event->repeat;        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        SDL_Keycode keycode = event->keysym.sym;        switch (keycode) {            case SDLK_h:                action_home(input_manager->controller);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(input_manager->controller);                return;            case SDLK_s:                action_app_switch(input_manager->controller);                return;            case SDLK_m:                action_menu(input_manager->controller);                return;            case SDLK_p:                action_power(input_manager->controller);                return;            case SDLK_DOWN:                action_volume_down(input_manager->controller);                return;            case SDLK_UP:                action_volume_up(input_manager->controller);                return;            case SDLK_v:                clipboard_paste(input_manager->controller);                return;            case SDLK_f:                screen_switch_fullscreen(input_manager->screen);                return;            case SDLK_x:                screen_resize_to_fit(input_manager->screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(input_manager->screen);                return;            case SDLK_i:                switch_fps_counter_state(input_manager->frames);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    // capture all Ctrl events    if (ctrl) {        SDL_bool repeat = event->repeat;        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        if (shift) {            // currently, there is no shortcut involving SHIFT            return;        }        SDL_Keycode keycode = event->keysym.sym;        switch (keycode) {            case SDLK_h:                action_home(input_manager->controller);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(input_manager->controller);                return;            case SDLK_s:                action_app_switch(input_manager->controller);                return;            case SDLK_m:                action_menu(input_manager->controller);                return;            case SDLK_p:                action_power(input_manager->controller);                return;            case SDLK_DOWN:                action_volume_down(input_manager->controller);                return;            case SDLK_UP:                action_volume_up(input_manager->controller);                return;            case SDLK_v:                clipboard_paste(input_manager->controller);                return;            case SDLK_f:                screen_switch_fullscreen(input_manager->screen);                return;            case SDLK_x:                screen_resize_to_fit(input_manager->screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(input_manager->screen);                return;            case SDLK_i:                switch_fps_counter_state(input_manager->frames);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
SDL_bool show_screen(const char *serial, Uint16 local_port) {    SDL_bool ret = 0;    const char *server_jar_path = getenv("SCRCPY_SERVER_JAR");    if (!server_jar_path) {        server_jar_path = "scrcpy-server.jar";    }    process_t push_proc = adb_push(serial, server_jar_path, "/data/local/tmp/");    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = adb_reverse(serial, SOCKET_NAME, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    struct size frame_size;    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the width and height values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    SDL_Window *window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    SDL_Texture *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    long ts = timestamp_ms();    int nbframes = 0;    SDL_bool texture_empty = SDL_TRUE;    SDL_bool fullscreen = SDL_FALSE;    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            goto screen_quit;        case EVENT_NEW_FRAME:            mutex_lock(frames.mutex);            AVFrame *frame = frames.rendering_frame;            frames.rendering_frame_consumed = SDL_TRUE;            if (!decoder.skip_frames) {                cond_signal(frames.rendering_frame_consumed_cond);            }            struct size current_frame_size = {frame->width, frame->height};            if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {                goto screen_quit;            }            frame_size = current_frame_size;            update_texture(frame, texture);            mutex_unlock(frames.mutex);            texture_empty = SDL_FALSE;            long now = timestamp_ms();            ++nbframes;            if (now - ts > 1000) {                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "%d fps", nbframes);                ts = now;                nbframes = 0;            }            render(renderer, texture);            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_KEYDOWN: {            SDL_bool ctrl = SDL_GetModState() & (KMOD_LCTRL | KMOD_RCTRL);            SDL_bool shift = SDL_GetModState() & (KMOD_LSHIFT | KMOD_RSHIFT);            SDL_bool repeat = event.key.repeat;            switch (event.key.keysym.sym) {            case SDLK_x:                if (!repeat && ctrl && !shift) {                    // Ctrl+x                    struct size optimal_size = get_optimal_window_size(window, frame_size);                    SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                }                break;            case SDLK_f:                if (!repeat && ctrl && !shift) {                    // Ctrl+f                    Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;                    if (!SDL_SetWindowFullscreen(window, new_mode)) {                        fullscreen = !fullscreen;                        render(renderer, texture_empty ? NULL : texture);                    } else {                        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());                    }                }                break;            }            break;        }        }    }screen_quit:    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = adb_reverse_remove(serial, SOCKET_NAME);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool show_screen(const char *serial, Uint16 local_port) {    SDL_bool ret = 0;    const char *server_jar_path = getenv("SCRCPY_SERVER_JAR");    if (!server_jar_path) {        server_jar_path = "scrcpy-server.jar";    }    process_t push_proc = adb_push(serial, server_jar_path, "/data/local/tmp/");    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = adb_reverse(serial, SOCKET_NAME, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    struct size frame_size;    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    SDL_Window *window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    SDL_Texture *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    long ts = timestamp_ms();    int nbframes = 0;    SDL_bool texture_empty = SDL_TRUE;    SDL_bool fullscreen = SDL_FALSE;    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            goto screen_quit;        case EVENT_NEW_FRAME:            mutex_lock(frames.mutex);            AVFrame *frame = frames.rendering_frame;            frames.rendering_frame_consumed = SDL_TRUE;            if (!decoder.skip_frames) {                cond_signal(frames.rendering_frame_consumed_cond);            }            struct size current_frame_size = {frame->width, frame->height};            if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {                goto screen_quit;            }            frame_size = current_frame_size;            update_texture(frame, texture);            mutex_unlock(frames.mutex);            texture_empty = SDL_FALSE;            long now = timestamp_ms();            ++nbframes;            if (now - ts > 1000) {                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "%d fps", nbframes);                ts = now;                nbframes = 0;            }            render(renderer, texture);            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_KEYDOWN: {            SDL_bool ctrl = SDL_GetModState() & (KMOD_LCTRL | KMOD_RCTRL);            SDL_bool shift = SDL_GetModState() & (KMOD_LSHIFT | KMOD_RSHIFT);            SDL_bool repeat = event.key.repeat;            switch (event.key.keysym.sym) {            case SDLK_x:                if (!repeat && ctrl && !shift) {                    // Ctrl+x                    struct size optimal_size = get_optimal_window_size(window, frame_size);                    SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                }                break;            case SDLK_f:                if (!repeat && ctrl && !shift) {                    // Ctrl+f                    Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;                    if (!SDL_SetWindowFullscreen(window, new_mode)) {                        fullscreen = !fullscreen;                        render(renderer, texture_empty ? NULL : texture);                    } else {                        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());                    }                }                break;            }            break;        }        }    }screen_quit:    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = adb_reverse_remove(serial, SOCKET_NAME);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
handle_event(SDL_Event *event, bool control) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = true;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return false;            }            break;        case SDL_WINDOWEVENT:            switch (event->window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;            }            break;        case SDL_TEXTINPUT:            if (!control) {                break;            }            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            // some key events do not interact with the device, so process the            // event even if control is disabled            input_manager_process_key(&input_manager, &event->key, control);            break;        case SDL_MOUSEMOTION:            if (!control) {                break;            }            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            if (!control) {                break;            }            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            // some mouse events do not interact with the device, so process            // the event even if control is disabled            input_manager_process_mouse_button(&input_manager, &event->button,                                               control);            break;        case SDL_DROPFILE: {            if (!control) {                break;            }            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
handle_event(SDL_Event *event, bool control) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = true;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return EVENT_RESULT_CONTINUE;            }            break;        case SDL_WINDOWEVENT:            switch (event->window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;            }            break;        case SDL_TEXTINPUT:            if (!control) {                break;            }            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            // some key events do not interact with the device, so process the            // event even if control is disabled            input_manager_process_key(&input_manager, &event->key, control);            break;        case SDL_MOUSEMOTION:            if (!control) {                break;            }            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            if (!control) {                break;            }            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            // some mouse events do not interact with the device, so process            // the event even if control is disabled            input_manager_process_mouse_button(&input_manager, &event->button,                                               control);            break;        case SDL_DROPFILE: {            if (!control) {                break;            }            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
adb_execute(const char *serial, const char *const adb_cmd[], size_t len) {    const char *cmd[len + 4];    int i;    process_t process;    cmd[0] = get_adb_command();    if (serial) {        cmd[1] = "-s";        cmd[2] = serial;        i = 3;    } else {        i = 1;    }    memcpy(&cmd[i], adb_cmd, len * sizeof(const char *));    cmd[len + i] = NULL;    enum process_result r = cmd_execute(cmd[0], cmd, &process);    if (r != PROCESS_SUCCESS) {        show_adb_err_msg(r, cmd);        return PROCESS_NONE;    }    return process;}
adb_execute(const char *serial, const char *const adb_cmd[], size_t len) {    const char *cmd[len + 4];    int i;    process_t process;    cmd[0] = get_adb_command();    if (serial) {        cmd[1] = "-s";        cmd[2] = serial;        i = 3;    } else {        i = 1;    }    memcpy(&cmd[i], adb_cmd, len * sizeof(const char *));    cmd[len + i] = NULL;    enum process_result r = cmd_execute(cmd, &process);    if (r != PROCESS_SUCCESS) {        show_adb_err_msg(r, cmd);        return PROCESS_NONE;    }    return process;}
cmd_execute(const char *path, const char *const argv[], pid_t *pid) {    int fd[2];    if (pipe(fd) == -1) {        perror("pipe");        return PROCESS_ERROR_GENERIC;    }    enum process_result ret = PROCESS_SUCCESS;    *pid = fork();    if (*pid == -1) {        perror("fork");        ret = PROCESS_ERROR_GENERIC;        goto end;    }    if (*pid > 0) {        // parent close write side        close(fd[1]);        fd[1] = -1;        // wait for EOF or receive errno from child        if (read(fd[0], &ret, sizeof(ret)) == -1) {            perror("read");            ret = PROCESS_ERROR_GENERIC;            goto end;        }    } else if (*pid == 0) {        // child close read side        close(fd[0]);        if (fcntl(fd[1], F_SETFD, FD_CLOEXEC) == 0) {            execvp(path, (char *const *)argv);            if (errno == ENOENT) {                ret = PROCESS_ERROR_MISSING_BINARY;            } else {                ret = PROCESS_ERROR_GENERIC;            }            perror("exec");        } else {            perror("fcntl");            ret = PROCESS_ERROR_GENERIC;        }        // send ret to the parent        if (write(fd[1], &ret, sizeof(ret)) == -1) {            perror("write");        }        // close write side before exiting        close(fd[1]);        _exit(1);    }end:    if (fd[0] != -1) {        close(fd[0]);    }    if (fd[1] != -1) {        close(fd[1]);    }    return ret;}
cmd_execute(const char *path, const char *const argv[], pid_t *pid) {    int fd[2];    if (pipe(fd) == -1) {        perror("pipe");        return PROCESS_ERROR_GENERIC;    }    enum process_result ret = PROCESS_SUCCESS;    *pid = fork();    if (*pid == -1) {        perror("fork");        ret = PROCESS_ERROR_GENERIC;        goto end;    }    if (*pid > 0) {        // parent close write side        close(fd[1]);        fd[1] = -1;        // wait for EOF or receive errno from child        if (read(fd[0], &ret, sizeof(ret)) == -1) {            perror("read");            ret = PROCESS_ERROR_GENERIC;            goto end;        }    } else if (*pid == 0) {        // child close read side        close(fd[0]);        if (fcntl(fd[1], F_SETFD, FD_CLOEXEC) == 0) {            execvp(path, (char *const *)argv);            if (errno == ENOENT) {                ret = PROCESS_ERROR_MISSING_BINARY;            } else {                ret = PROCESS_ERROR_GENERIC;            }            perror("exec");        } else {            perror("fcntl");            ret = PROCESS_ERROR_GENERIC;        }        // send ret to the parent        if (write(fd[1], &ret, sizeof(ret)) == -1) {            perror("write");        }        // close write side before exiting        close(fd[1]);        _exit(1);    }end:    if (fd[0] != -1) {        close(fd[0]);    }    if (fd[1] != -1) {        close(fd[1]);    }    return ret;}
cmd_execute(const char *const argv[], pid_t *pid) {    int fd[2];    if (pipe(fd) == -1) {        perror("pipe");        return PROCESS_ERROR_GENERIC;    }    enum process_result ret = PROCESS_SUCCESS;    *pid = fork();    if (*pid == -1) {        perror("fork");        ret = PROCESS_ERROR_GENERIC;        goto end;    }    if (*pid > 0) {        // parent close write side        close(fd[1]);        fd[1] = -1;        // wait for EOF or receive errno from child        if (read(fd[0], &ret, sizeof(ret)) == -1) {            perror("read");            ret = PROCESS_ERROR_GENERIC;            goto end;        }    } else if (*pid == 0) {        // child close read side        close(fd[0]);        if (fcntl(fd[1], F_SETFD, FD_CLOEXEC) == 0) {            execvp(argv[0], (char *const *)argv);            if (errno == ENOENT) {                ret = PROCESS_ERROR_MISSING_BINARY;            } else {                ret = PROCESS_ERROR_GENERIC;            }            perror("exec");        } else {            perror("fcntl");            ret = PROCESS_ERROR_GENERIC;        }        // send ret to the parent        if (write(fd[1], &ret, sizeof(ret)) == -1) {            perror("write");        }        // close write side before exiting        close(fd[1]);        _exit(1);    }end:    if (fd[0] != -1) {        close(fd[0]);    }    if (fd[1] != -1) {        close(fd[1]);    }    return ret;}
cmd_execute(const char *const argv[], pid_t *pid) {    int fd[2];    if (pipe(fd) == -1) {        perror("pipe");        return PROCESS_ERROR_GENERIC;    }    enum process_result ret = PROCESS_SUCCESS;    *pid = fork();    if (*pid == -1) {        perror("fork");        ret = PROCESS_ERROR_GENERIC;        goto end;    }    if (*pid > 0) {        // parent close write side        close(fd[1]);        fd[1] = -1;        // wait for EOF or receive errno from child        if (read(fd[0], &ret, sizeof(ret)) == -1) {            perror("read");            ret = PROCESS_ERROR_GENERIC;            goto end;        }    } else if (*pid == 0) {        // child close read side        close(fd[0]);        if (fcntl(fd[1], F_SETFD, FD_CLOEXEC) == 0) {            execvp(argv[0], (char *const *)argv);            if (errno == ENOENT) {                ret = PROCESS_ERROR_MISSING_BINARY;            } else {                ret = PROCESS_ERROR_GENERIC;            }            perror("exec");        } else {            perror("fcntl");            ret = PROCESS_ERROR_GENERIC;        }        // send ret to the parent        if (write(fd[1], &ret, sizeof(ret)) == -1) {            perror("write");        }        // close write side before exiting        close(fd[1]);        _exit(1);    }end:    if (fd[0] != -1) {        close(fd[0]);    }    if (fd[1] != -1) {        close(fd[1]);    }    return ret;}
cmd_execute(const char *path, const char *const argv[], HANDLE *handle) {    (void) path;    STARTUPINFOW si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    char cmd[256];    if (build_cmd(cmd, sizeof(cmd), argv)) {        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }    wchar_t *wide = utf8_to_wide_char(cmd);    if (!wide) {        LOGC("Could not allocate wide char string");        return PROCESS_ERROR_GENERIC;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcessW(NULL, wide, NULL, NULL, FALSE, flags, NULL, NULL, &si,                        &pi)) {        SDL_free(wide);        *handle = NULL;        if (GetLastError() == ERROR_FILE_NOT_FOUND) {            return PROCESS_ERROR_MISSING_BINARY;        }        return PROCESS_ERROR_GENERIC;    }    SDL_free(wide);    *handle = pi.hProcess;    return PROCESS_SUCCESS;}
cmd_execute(const char *path, const char *const argv[], HANDLE *handle) {    (void) path;    STARTUPINFOW si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    char cmd[256];    if (build_cmd(cmd, sizeof(cmd), argv)) {        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }    wchar_t *wide = utf8_to_wide_char(cmd);    if (!wide) {        LOGC("Could not allocate wide char string");        return PROCESS_ERROR_GENERIC;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcessW(NULL, wide, NULL, NULL, FALSE, flags, NULL, NULL, &si,                        &pi)) {        SDL_free(wide);        *handle = NULL;        if (GetLastError() == ERROR_FILE_NOT_FOUND) {            return PROCESS_ERROR_MISSING_BINARY;        }        return PROCESS_ERROR_GENERIC;    }    SDL_free(wide);    *handle = pi.hProcess;    return PROCESS_SUCCESS;}
cmd_execute(const char *const argv[], HANDLE *handle) {    STARTUPINFOW si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    char cmd[256];    if (build_cmd(cmd, sizeof(cmd), argv)) {        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }    wchar_t *wide = utf8_to_wide_char(cmd);    if (!wide) {        LOGC("Could not allocate wide char string");        return PROCESS_ERROR_GENERIC;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcessW(NULL, wide, NULL, NULL, FALSE, flags, NULL, NULL, &si,                        &pi)) {        SDL_free(wide);        *handle = NULL;        if (GetLastError() == ERROR_FILE_NOT_FOUND) {            return PROCESS_ERROR_MISSING_BINARY;        }        return PROCESS_ERROR_GENERIC;    }    SDL_free(wide);    *handle = pi.hProcess;    return PROCESS_SUCCESS;}
cmd_execute(const char *const argv[], HANDLE *handle) {    STARTUPINFOW si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    char cmd[256];    if (build_cmd(cmd, sizeof(cmd), argv)) {        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }    wchar_t *wide = utf8_to_wide_char(cmd);    if (!wide) {        LOGC("Could not allocate wide char string");        return PROCESS_ERROR_GENERIC;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcessW(NULL, wide, NULL, NULL, FALSE, flags, NULL, NULL, &si,                        &pi)) {        SDL_free(wide);        *handle = NULL;        if (GetLastError() == ERROR_FILE_NOT_FOUND) {            return PROCESS_ERROR_MISSING_BINARY;        }        return PROCESS_ERROR_GENERIC;    }    SDL_free(wide);    *handle = pi.hProcess;    return PROCESS_SUCCESS;}bool
enum process_result cmd_execute(const char *path, const char *const argv[], HANDLE *handle) {    STARTUPINFO si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    // Windows command-line parsing is WTF:    // <http://daviddeley.com/autohotkey/parameters/parameters.htm#WINPASS>    // only make it work for this very specific program    // (don't handle escaping nor quotes)    char cmd[256];    size_t ret = xstrjoin(cmd, argv, ' ', sizeof(cmd));    if (ret >= sizeof(cmd)) {        LOGE("Command too long (%" PRIsizet " chars)", sizeof(cmd) - 1);        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, flags, NULL, NULL, &si, &pi)) {        *handle = NULL;        if (GetLastError() == ERROR_FILE_NOT_FOUND) {            return PROCESS_ERROR_MISSING_BINARY;        }        return PROCESS_ERROR_GENERIC;    }    *handle = pi.hProcess;    return PROCESS_SUCCESS;}
enum process_result cmd_execute(const char *path, const char *const argv[], HANDLE *handle) {    STARTUPINFO si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    // Windows command-line parsing is WTF:    // <http://daviddeley.com/autohotkey/parameters/parameters.htm#WINPASS>    // only make it work for this very specific program    // (don't handle escaping nor quotes)    char cmd[256];    size_t ret = xstrjoin(cmd, argv, ' ', sizeof(cmd));    if (ret >= sizeof(cmd)) {        LOGE("Command too long (%" PRIsizet " chars)", sizeof(cmd) - 1);        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, flags, NULL, NULL, &si, &pi)) {        *handle = NULL;        if (GetLastError() == ERROR_FILE_NOT_FOUND) {            return PROCESS_ERROR_MISSING_BINARY;        }        return PROCESS_ERROR_GENERIC;    }    *handle = pi.hProcess;    return PROCESS_SUCCESS;}
enum process_result cmd_execute(const char *path, const char *const argv[], HANDLE *handle) {    STARTUPINFO si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    char cmd[256];    if (build_cmd(cmd, sizeof(cmd), argv)) {        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, flags, NULL, NULL, &si, &pi)) {        *handle = NULL;        if (GetLastError() == ERROR_FILE_NOT_FOUND) {            return PROCESS_ERROR_MISSING_BINARY;        }        return PROCESS_ERROR_GENERIC;    }    *handle = pi.hProcess;    return PROCESS_SUCCESS;}
static int build_cmd(char *cmd, size_t len, const char *const argv[]) {    // Windows command-line parsing is WTF:    // <http://daviddeley.com/autohotkey/parameters/parameters.htm#WINPASS>    // only make it work for this very specific program    // (don't handle escaping nor quotes)    size_t ret = xstrjoin(cmd, argv, ' ', len);    if (ret >= len) {        LOGE("Command too long (%" PRIsizet " chars)", len - 1);        return -1;    }    return 0;}
    private void initPointer() {        MotionEvent.PointerProperties props = pointerProperties[0];        props.id = 0;        props.toolType = MotionEvent.TOOL_TYPE_MOUSE;        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.orientation = 0;        coords.pressure = 1;        coords.size = 1;        coords.toolMajor = 1;        coords.toolMinor = 1;        coords.touchMajor = 1;        coords.touchMinor = 1;    }
    private boolean injectMouse(int action, int buttons, Point point) {        long now = SystemClock.uptimeMillis();        if (action == MotionEvent.ACTION_DOWN) {            lastMouseDown = now;        }        RawPoint rawPoint = Device.getInstance().getPhysicalPoint(point);        if (rawPoint == null) {            // ignore event            return false;        }        setPointerCoords(rawPoint);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, action, 1, pointerProperties, pointerCoords, 0, buttons, 1f, 1f, 0, 0, InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
    private void initPointer() {        MotionEvent.PointerProperties props = pointerProperties[0];        props.id = 0;        props.toolType = MotionEvent.TOOL_TYPE_FINGER;        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.orientation = 0;        coords.pressure = 1;        coords.size = 1;        coords.toolMajor = 1;        coords.toolMinor = 1;        coords.touchMajor = 1;        coords.touchMinor = 1;    }
    private boolean injectMouse(int action, int buttons, Point point) {        long now = SystemClock.uptimeMillis();        if (action == MotionEvent.ACTION_DOWN) {            lastMouseDown = now;        }        RawPoint rawPoint = Device.getInstance().getPhysicalPoint(point);        if (rawPoint == null) {            // ignore event            return false;        }        setPointerCoords(rawPoint);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, action, 1, pointerProperties, pointerCoords, 0, buttons, 1f, 1f, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
    private void setScroll(int hScroll, int vScroll) {        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.setAxisValue(MotionEvent.AXIS_SCROLL, hScroll);        coords.setAxisValue(MotionEvent.AXIS_VSCROLL, vScroll);    }
    private void setScroll(int hScroll, int vScroll) {        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.setAxisValue(MotionEvent.AXIS_HSCROLL, hScroll);        coords.setAxisValue(MotionEvent.AXIS_VSCROLL, vScroll);    }
recorder_queue_push(struct recorder_queue *queue, const AVPacket *packet) {    struct record_packet *rec = record_packet_new(packet);    if (!rec) {        LOGC("Could not allocate record packet");        return false;    }    rec->next = NULL;    if (recorder_queue_is_empty(queue)) {        queue->first = queue->last = rec;    } else {        // chain rec after the (current) last packet        queue->last->next = rec;        // the last packet is now rec        queue->last = rec;    }    return true;}
recorder_queue_init(struct recorder_queue *queue) {    queue->first = NULL;    // queue->last is undefined if queue->first == NULL}
recorder_queue_is_empty(struct recorder_queue *queue) {    return !queue->first;}
recorder_queue_clear(struct recorder_queue *queue) {    struct record_packet *rec = queue->first;    while (rec) {        struct record_packet *current = rec;        rec = rec->next;        record_packet_delete(current);    }    queue->first = NULL;}
run_recorder(void *data) {    struct recorder *recorder = data;    for (;;) {        mutex_lock(recorder->mutex);        while (!recorder->stopped &&                recorder_queue_is_empty(&recorder->queue)) {            cond_wait(recorder->queue_cond, recorder->mutex);        }        // if stopped is set, continue to process the remaining events (to        // finish the recording) before actually stopping        if (recorder->stopped && recorder_queue_is_empty(&recorder->queue)) {            mutex_unlock(recorder->mutex);            break;        }        struct record_packet *rec = recorder_queue_take(&recorder->queue);        mutex_unlock(recorder->mutex);        bool ok = recorder_write(recorder, &rec->packet);        record_packet_delete(rec);        if (!ok) {            LOGE("Could not record packet");            mutex_lock(recorder->mutex);            recorder->failed = true;            // discard pending packets            recorder_queue_clear(&recorder->queue);            mutex_unlock(recorder->mutex);            break;        }    }    LOGD("Recorder thread ended");    return 0;}
recorder_init(struct recorder *recorder,              const char *filename,              enum recorder_format format,              struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Could not strdup filename");        return false;    }    recorder->mutex = SDL_CreateMutex();    if (!recorder->mutex) {        LOGC("Could not create mutex");        SDL_free(recorder->filename);        return false;    }    recorder->queue_cond = SDL_CreateCond();    if (!recorder->queue_cond) {        LOGC("Could not create cond");        SDL_DestroyMutex(recorder->mutex);        SDL_free(recorder->filename);        return false;    }    recorder_queue_init(&recorder->queue);    recorder->stopped = false;    recorder->failed = false;    recorder->format = format;    recorder->declared_frame_size = declared_frame_size;    recorder->header_written = false;    return true;}
recorder_queue_take(struct recorder_queue *queue) {    SDL_assert(!recorder_queue_is_empty(queue));    struct record_packet *rec = queue->first;    SDL_assert(rec);    queue->first = rec->next;    // no need to update queue->last if the queue is left empty:    // queue->last is undefined if queue->first == NULL    return rec;}
record_packet_new(const AVPacket *packet) {    struct record_packet *rec = SDL_malloc(sizeof(*rec));    if (!rec) {        return NULL;    }    if (av_packet_ref(&rec->packet, packet)) {        SDL_free(rec);        return NULL;    }    rec->next = NULL;    return rec;}
recorder_push(struct recorder *recorder, const AVPacket *packet) {    mutex_lock(recorder->mutex);    SDL_assert(!recorder->stopped);    if (recorder->failed) {        // reject any new packet (this will stop the stream)        return false;    }    bool ok = recorder_queue_push(&recorder->queue, packet);    cond_signal(recorder->queue_cond);    mutex_unlock(recorder->mutex);    return ok;}
              struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Could not strdup filename");        return false;    }    recorder->mutex = SDL_CreateMutex();    if (!recorder->mutex) {        LOGC("Could not create mutex");        SDL_free(recorder->filename);        return false;    }    recorder->queue_cond = SDL_CreateCond();    if (!recorder->queue_cond) {        LOGC("Could not create cond");        SDL_DestroyMutex(recorder->mutex);        SDL_free(recorder->filename);
    while (!queue_is_empty(queue)) {        struct record_packet *rec;        queue_take(queue, next, &rec);        record_packet_delete(rec);    }
boolrecorder_init(struct recorder *recorder,              const char *filename,
recorder_queue_clear(struct recorder_queue *queue) {    while (!queue_is_empty(queue)) {        struct record_packet *rec;        queue_take(queue, next, &rec);        record_packet_delete(rec);    }}
run_recorder(void *data) {    struct recorder *recorder = data;    for (;;) {        mutex_lock(recorder->mutex);        while (!recorder->stopped && queue_is_empty(&recorder->queue)) {            cond_wait(recorder->queue_cond, recorder->mutex);        }        // if stopped is set, continue to process the remaining events (to        // finish the recording) before actually stopping        if (recorder->stopped && queue_is_empty(&recorder->queue)) {            mutex_unlock(recorder->mutex);            break;        }        struct record_packet *rec;        queue_take(&recorder->queue, next, &rec);        mutex_unlock(recorder->mutex);        bool ok = recorder_write(recorder, &rec->packet);        record_packet_delete(rec);        if (!ok) {            LOGE("Could not record packet");            mutex_lock(recorder->mutex);            recorder->failed = true;            // discard pending packets            recorder_queue_clear(&recorder->queue);            mutex_unlock(recorder->mutex);            break;        }    }    LOGD("Recorder thread ended");    return 0;}
recorder_init(struct recorder *recorder,              const char *filename,              enum recorder_format format,              struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Could not strdup filename");        return false;    }    recorder->mutex = SDL_CreateMutex();    if (!recorder->mutex) {        LOGC("Could not create mutex");        SDL_free(recorder->filename);        return false;    }    recorder->queue_cond = SDL_CreateCond();    if (!recorder->queue_cond) {        LOGC("Could not create cond");        SDL_DestroyMutex(recorder->mutex);        SDL_free(recorder->filename);        return false;    }    queue_init(&recorder->queue);    recorder->stopped = false;    recorder->failed = false;    recorder->format = format;    recorder->declared_frame_size = declared_frame_size;    recorder->header_written = false;    return true;}
    }    queue_init(&recorder->queue);    recorder->stopped = false;    recorder->failed = false;    recorder->format = format;    recorder->declared_frame_size = declared_frame_size;    recorder->header_written = false;    return true;}void
record_packet_new(const AVPacket *packet) {    struct record_packet *rec = SDL_malloc(sizeof(*rec));    if (!rec) {        return NULL;    }    if (av_packet_ref(&rec->packet, packet)) {        SDL_free(rec);        return NULL;    }    return rec;}static void
recorder_push(struct recorder *recorder, const AVPacket *packet) {    mutex_lock(recorder->mutex);    SDL_assert(!recorder->stopped);    if (recorder->failed) {        // reject any new packet (this will stop the stream)        return false;    }    struct record_packet *rec = record_packet_new(packet);    if (!rec) {        LOGC("Could not allocate record packet");        return false;    }    queue_push(&recorder->queue, next, rec);    cond_signal(recorder->queue_cond);    mutex_unlock(recorder->mutex);    return true;}
void screencontrol_handle_mouse_button(struct controller *controller,                                       struct screen *screen,                                       const SDL_MouseButtonEvent *event) {    if (event->button == SDL_BUTTON_RIGHT) {        turn_screen_on(controller);        return;    };    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, screen->frame_size, &control_event)) {        if (!controller_push_event(controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse button event");        }    }}
void screencontrol_handle_mouse_button(struct controller *controller,                                       struct screen *screen,                                       const SDL_MouseButtonEvent *event) {    if (event->button == SDL_BUTTON_RIGHT && event->type == SDL_MOUSEBUTTONDOWN) {        turn_screen_on(controller);        return;    };    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, screen->frame_size, &control_event)) {        if (!controller_push_event(controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse button event");        }    }}
    public void setScreenPowerMode(int mode) {        IBinder d = SurfaceControl.getBuiltInDisplay(0);        if (d == null) {            Ln.e("Could not get built-in display");            return;        }        SurfaceControl.setDisplayPowerMode(d, mode);        Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));    }
    public void setScreenPowerMode(int mode) {        IBinder d = SurfaceControl.getBuiltInDisplay();        if (d == null) {            Ln.e("Could not get built-in display");            return;        }        SurfaceControl.setDisplayPowerMode(d, mode);        Ln.i("Device screen turned " + (mode == Device.POWER_MODE_OFF ? "off" : "on"));    }
    private static Method getGetBuiltInDisplayMethod() {        if (getBuiltInDisplayMethod == null) {            try {                // the method signature has changed in Android Q                // <https://github.com/Genymobile/scrcpy/issues/586>                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                    getBuiltInDisplayMethod = CLASS.getMethod("getBuiltInDisplay", int.class);                } else {                    getBuiltInDisplayMethod = CLASS.getMethod("getPhysicalDisplayToken", long.class);                }            } catch (NoSuchMethodException e) {                Ln.e("Could not find method", e);            }        }        return getBuiltInDisplayMethod;    }
    public static IBinder getBuiltInDisplay(int builtInDisplayId) {        Method method = getGetBuiltInDisplayMethod();        if (method == null) {            return null;        }        try {            return (IBinder) method.invoke(null, builtInDisplayId);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);            return null;        }    }
    public static IBinder getBuiltInDisplay(int builtInDisplayId) {        Method method = getGetBuiltInDisplayMethod();        if (method == null) {            return null;        }        try {            return (IBinder) method.invoke(null, builtInDisplayId);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);            return null;        }    }
    private static Method getGetBuiltInDisplayMethod() {        if (getBuiltInDisplayMethod == null) {            try {                // the method signature has changed in Android Q                // <https://github.com/Genymobile/scrcpy/issues/586>                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                    getBuiltInDisplayMethod = CLASS.getMethod("getBuiltInDisplay", int.class);                } else {                    getBuiltInDisplayMethod = CLASS.getMethod("getInternalDisplayToken");                }            } catch (NoSuchMethodException e) {                Ln.e("Could not find method", e);            }        }        return getBuiltInDisplayMethod;    }
    public static IBinder getBuiltInDisplay() {        Method method = getGetBuiltInDisplayMethod();        if (method == null) {            return null;        }        try {            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                // call getBuiltInDisplay(0)                return (IBinder) method.invoke(null, 0);            }            // call getInternalDisplayToken()            return (IBinder) method.invoke(null);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);            return null;        }    }
    public static IBinder getBuiltInDisplay() {        Method method = getGetBuiltInDisplayMethod();        if (method == null) {            return null;        }        try {            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                // call getBuiltInDisplay(0)                return (IBinder) method.invoke(null, 0);            }            // call getInternalDisplayToken()            return (IBinder) method.invoke(null);
    private static Options createOptions(String... args) {        if (args.length != 6) {            throw new IllegalArgumentException("Expecting 6 parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[0]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[1]);        options.setBitRate(bitRate);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[2]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[3]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[4]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[5]);        options.setControl(control);        return options;    }
    private static Options createOptions(String... args) {        if (args.length < 1) {            throw new IllegalArgumentException("Missing client version");        }        String clientVersion = args[0];        if (!clientVersion.equals(BuildConfig.VERSION_NAME)) {            throw new IllegalArgumentException("The server version (" + clientVersion + ") does not match the client "                    + "(" + BuildConfig.VERSION_NAME + ")");        }        if (args.length != 7) {            throw new IllegalArgumentException("Expecting 7 parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[1]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[2]);        options.setBitRate(bitRate);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[3]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[4]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[5]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[6]);        options.setControl(control);        return options;    }
void frames_destroy(struct frames *frames) {    SDL_DestroyMutex(frames->mutex);    av_frame_free(&frames->rendering_frame);    av_frame_free(&frames->decoding_frame);}
void frames_destroy(struct frames *frames) {    SDL_DestroyMutex(frames->mutex);    SDL_DestroyCond(frames->rendering_frame_consumed_cond);    av_frame_free(&frames->rendering_frame);    av_frame_free(&frames->decoding_frame);}
    private void initMousePointer() {        MotionEvent.PointerProperties props = mousePointerProperties[0];        props.id = 0;        props.toolType = MotionEvent.TOOL_TYPE_FINGER;        MotionEvent.PointerCoords coords = mousePointerCoords[0];        coords.orientation = 0;        coords.pressure = 1;        coords.size = 1;    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                break;            case ControlMessage.TYPE_INJECT_TEXT:                injectText(msg.getText());                break;            case ControlMessage.TYPE_INJECT_MOUSE_EVENT:                injectMouse(msg.getAction(), msg.getButtons(), msg.getPosition());                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure());                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                pressBackOrTurnScreenOn();                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                device.setClipboardText(msg.getText());                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                device.setScreenPowerMode(msg.getAction());                break;            default:                // do nothing        }    }
    private boolean injectMouse(int action, int buttons, Position position) {        long now = SystemClock.uptimeMillis();        if (action == MotionEvent.ACTION_DOWN) {            lastMouseDown = now;        }        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        setMousePointerCoords(point);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, action, 1, mousePointerProperties,                mousePointerCoords, 0, buttons, 1f, 1f, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
    private boolean injectTouch(int action, long pointerId, Position position, float pressure) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        int pointerIndex = pointersState.getPointerIndex(pointerId);        if (pointerIndex == -1) {            Ln.w("Too many pointers for touch event");            return false;        }        Pointer pointer = pointersState.get(pointerIndex);        pointer.setPoint(point);        pointer.setPressure(pressure);        pointer.setUp(action == MotionEvent.ACTION_UP);        int pointerCount = pointersState.update(touchPointerProperties, touchPointerCoords);        if (pointerCount == 1) {            if (action == MotionEvent.ACTION_DOWN) {                lastTouchDown = now;            }        } else {            // secondary pointers must use ACTION_POINTER_* ORed with the pointerIndex            if (action == MotionEvent.ACTION_UP) {                action = MotionEvent.ACTION_POINTER_UP | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            } else if (action == MotionEvent.ACTION_DOWN) {                action = MotionEvent.ACTION_POINTER_DOWN | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            }        }        MotionEvent event = MotionEvent.obtain(lastTouchDown, now, action, pointerCount, touchPointerProperties,                touchPointerCoords, 0, 0, 1f, 1f, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
    private void setMousePointerCoords(Point point) {        MotionEvent.PointerCoords coords = mousePointerCoords[0];        coords.x = point.getX();        coords.y = point.getY();    }
    private boolean injectTouch(int action, long pointerId, Position position, float pressure) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        int pointerIndex = pointersState.getPointerIndex(pointerId);        if (pointerIndex == -1) {            Ln.w("Too many pointers for touch event");            return false;        }        Pointer pointer = pointersState.get(pointerIndex);        pointer.setPoint(point);        pointer.setPressure(pressure);        pointer.setUp(action == MotionEvent.ACTION_UP);        int pointerCount = pointersState.update(touchPointerProperties, touchPointerCoords);        if (pointerCount == 1) {            if (action == MotionEvent.ACTION_DOWN) {                lastTouchDown = now;            }        } else {            // secondary pointers must use ACTION_POINTER_* ORed with the pointerIndex            if (action == MotionEvent.ACTION_UP) {                action = MotionEvent.ACTION_POINTER_UP | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            } else if (action == MotionEvent.ACTION_DOWN) {                action = MotionEvent.ACTION_POINTER_DOWN | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            }        }        MotionEvent event = MotionEvent.obtain(lastTouchDown, now, action, pointerCount, touchPointerProperties,                touchPointerCoords, 0, 0, 1f, 1f, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
    public Controller(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;        initMousePointer();        initTouchPointers();        sender = new DeviceMessageSender(connection);    }
    private boolean injectScroll(Position position, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        setMousePointerCoords(point);        setScroll(hScroll, vScroll);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, MotionEvent.ACTION_SCROLL, 1,                mousePointerProperties, mousePointerCoords, 0, 0, 1f, 1f, 0, 0, InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
    private void setScroll(int hScroll, int vScroll) {        MotionEvent.PointerCoords coords = mousePointerCoords[0];        coords.setAxisValue(MotionEvent.AXIS_HSCROLL, hScroll);        coords.setAxisValue(MotionEvent.AXIS_VSCROLL, vScroll);    }
            MotionEvent.PointerCoords coords = new MotionEvent.PointerCoords();            coords.orientation = 0;            coords.size = 1;            touchPointerProperties[i] = props;            touchPointerCoords[i] = coords;        }    }    @SuppressWarnings("checkstyle:MagicNumber")    public void control() throws IOException {
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                break;            case ControlMessage.TYPE_INJECT_TEXT:                injectText(msg.getText());                break;            case ControlMessage.TYPE_INJECT_MOUSE_EVENT:                injectTouch(msg.getAction(), PointersState.POINTER_ID_MOUSE, msg.getPosition(), 1, msg.getButtons());                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), 0);                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                pressBackOrTurnScreenOn();                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                device.setClipboardText(msg.getText());                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                device.setScreenPowerMode(msg.getAction());                break;            default:                // do nothing        }    }
                action = MotionEvent.ACTION_POINTER_UP | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            } else if (action == MotionEvent.ACTION_DOWN) {                action = MotionEvent.ACTION_POINTER_DOWN | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            }        }        MotionEvent event = MotionEvent.obtain(lastTouchDown, now, action, pointerCount, touchPointerProperties,                touchPointerCoords, 0, 0, 1f, 1f, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }    private boolean injectScroll(Position position, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event
    private boolean injectTouch(int action, long pointerId, Position position, float pressure, int buttons) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        int pointerIndex = pointersState.getPointerIndex(pointerId);        if (pointerIndex == -1) {            Ln.w("Too many pointers for touch event");            return false;        }        Pointer pointer = pointersState.get(pointerIndex);        pointer.setPoint(point);        pointer.setPressure(pressure);        pointer.setUp(action == MotionEvent.ACTION_UP);        int pointerCount = pointersState.update(touchPointerProperties, touchPointerCoords);        if (pointerCount == 1) {            if (action == MotionEvent.ACTION_DOWN) {                lastTouchDown = now;            }        } else {            // secondary pointers must use ACTION_POINTER_* ORed with the pointerIndex            if (action == MotionEvent.ACTION_UP) {                action = MotionEvent.ACTION_POINTER_UP | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            } else if (action == MotionEvent.ACTION_DOWN) {                action = MotionEvent.ACTION_POINTER_DOWN | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            }        }        MotionEvent event = MotionEvent.obtain(lastTouchDown, now, action, pointerCount, touchPointerProperties,                touchPointerCoords, 0, 0, 1f, 1f, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
        while (true) {            handleEvent();        }    }    public DeviceMessageSender getSender() {
            return false;        }        MotionEvent.PointerProperties props = touchPointerProperties[0];        props.id = 0;        MotionEvent.PointerCoords coords = touchPointerCoords[0];        coords.x = point.getX();        coords.y = point.getY();        coords.setAxisValue(MotionEvent.AXIS_HSCROLL, hScroll);        coords.setAxisValue(MotionEvent.AXIS_VSCROLL, vScroll);        MotionEvent event = MotionEvent.obtain(lastTouchDown, now, MotionEvent.ACTION_SCROLL, 1,                touchPointerProperties, touchPointerCoords, 0, 0, 1f, 1f, 0, 0, InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }    private boolean injectKeyEvent(int action, int keyCode, int repeat, int metaState) {        long now = SystemClock.uptimeMillis();        KeyEvent event = new KeyEvent(now, now, action, keyCode, repeat, metaState, KeyCharacterMap.VIRTUAL_KEYBOARD,                0, 0, InputDevice.SOURCE_KEYBOARD);        return injectEvent(event);    }    private boolean injectKeycode(int keyCode) {        return injectKeyEvent(KeyEvent.ACTION_DOWN, keyCode, 0, 0) && injectKeyEvent(KeyEvent.ACTION_UP, keyCode, 0, 0);    }    private boolean injectEvent(InputEvent event) {        return device.injectInputEvent(event, InputManager.INJECT_INPUT_EVENT_MODE_ASYNC);    }    private boolean pressBackOrTurnScreenOn() {        int keycode = device.isScreenOn() ? KeyEvent.KEYCODE_BACK : KeyEvent.KEYCODE_POWER;        return injectKeycode(keycode);    }}
        sender = new DeviceMessageSender(connection);    }    private void initTouchPointers() {        for (int i = 0; i < PointersState.MAX_POINTERS; ++i) {            MotionEvent.PointerProperties props = new MotionEvent.PointerProperties();            props.toolType = MotionEvent.TOOL_TYPE_FINGER;
    private boolean injectScroll(Position position, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        MotionEvent.PointerProperties props = touchPointerProperties[0];        props.id = 0;        MotionEvent.PointerCoords coords = touchPointerCoords[0];        coords.x = point.getX();        coords.y = point.getY();        coords.setAxisValue(MotionEvent.AXIS_HSCROLL, hScroll);        coords.setAxisValue(MotionEvent.AXIS_VSCROLL, vScroll);        MotionEvent event = MotionEvent.obtain(lastTouchDown, now, MotionEvent.ACTION_SCROLL, 1,                touchPointerProperties, touchPointerCoords, 0, 0, 1f, 1f, 0, 0, InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
        return sender;    }    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {
    public static IBinder getBuiltInDisplay(int builtInDisplayId) {        try {            return (IBinder) CLASS.getMethod("getBuiltInDisplay", int.class).invoke(null, builtInDisplayId);        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public static IBinder getBuiltInDisplay(int builtInDisplayId) {        try {            // Android Q does not have this method anymore but has a            // replacement.            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                return (IBinder) CLASS.getMethod("getBuiltInDisplay", int.class).invoke(null, builtInDisplayId);            } else {                return (IBinder) CLASS.getMethod("getPhysicalDisplayToken", long.class).invoke(null, builtInDisplayId);            }        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        Workarounds.prepareMainLooper();        MediaFormat format = createFormat(bitRate, maxFps, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                Rect contentRect = device.getScreenInfo().getContentRect();                Rect videoRect = device.getScreenInfo().getVideoSize().toRect();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, contentRect, videoRect);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        Workarounds.prepareMainLooper();        Workarounds.fillAppInfo();        MediaFormat format = createFormat(bitRate, maxFps, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                Rect contentRect = device.getScreenInfo().getContentRect();                Rect videoRect = device.getScreenInfo().getVideoSize().toRect();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, contentRect, videoRect);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
fps_counter_start(struct fps_counter *counter) {    counter->started = true;    counter->slice_start = SDL_GetTicks();    counter->nr_rendered = 0;#ifdef SKIP_FRAMES    counter->nr_skipped = 0;#endif}
display_fps(struct fps_counter *counter) {#ifdef SKIP_FRAMES    if (counter->nr_skipped) {        LOGI("%d fps (+%d frames skipped)", counter->nr_rendered,                                            counter->nr_skipped);    } else {#endif    LOGI("%d fps", counter->nr_rendered);#ifdef SKIP_FRAMES    }#endif}
check_expired(struct fps_counter *counter) {    uint32_t now = SDL_GetTicks();    if (now - counter->slice_start >= 1000) {        display_fps(counter);        // add a multiple of one second        uint32_t elapsed_slices = (now - counter->slice_start) / 1000;        counter->slice_start += 1000 * elapsed_slices;        counter->nr_rendered = 0;#ifdef SKIP_FRAMES        counter->nr_skipped = 0;#endif    }}
fps_counter_start(struct fps_counter *counter) {    counter->started = true;    counter->slice_start = SDL_GetTicks();    counter->nr_rendered = 0;    counter->nr_skipped = 0;}voidfps_counter_stop(struct fps_counter *counter) {
display_fps(struct fps_counter *counter) {    if (counter->nr_skipped) {        LOGI("%d fps (+%d frames skipped)", counter->nr_rendered,                                            counter->nr_skipped);    } else {        LOGI("%d fps", counter->nr_rendered);    }}
        counter->slice_start += 1000 * elapsed_slices;        counter->nr_rendered = 0;        counter->nr_skipped = 0;    }}voidfps_counter_add_rendered_frame(struct fps_counter *counter) {    check_expired(counter);    ++counter->nr_rendered;}voidfps_counter_add_skipped_frame(struct fps_counter *counter) {
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    Ctrl+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+c\n"        "        copy device clipboard to computer\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, 'T'},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, 'c'},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, 'f'},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"version",               no_argument,       NULL, 'v'},        {NULL,                    0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return false;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = true;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return false;                }                break;            case 'n':                args->no_control = true;                break;            case 'N':                args->no_display = true;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return false;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 'S':                args->turn_screen_off = true;                break;            case 't':                args->show_touches = true;                break;            case 'T':                args->always_on_top = true;                break;            case 'v':                args->version = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (args->no_display && !args->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (args->no_display && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return false;        }    }    return true;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .record_format = 0,        .help = false,        .version = false,        .show_touches = false,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = false,        .no_control = false,        .no_display = false,        .turn_screen_off = false,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,        .control = !args.no_control,        .display = !args.no_display,        .turn_screen_off = args.turn_screen_off,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    Ctrl+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+c\n"        "        copy device clipboard to computer\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, 'T'},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, 'c'},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, 'f'},        {"render-expired-frames", no_argument,       NULL,                                                 OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"version",               no_argument,       NULL, 'v'},        {NULL,                    0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return false;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = true;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return false;                }                break;            case 'n':                args->no_control = true;                break;            case 'N':                args->no_display = true;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return false;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 'S':                args->turn_screen_off = true;                break;            case 't':                args->show_touches = true;                break;            case 'T':                args->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                args->render_expired_frames = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (args->no_display && !args->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (args->no_display && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return false;        }    }    return true;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .record_format = 0,        .help = false,        .version = false,        .show_touches = false,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = false,        .no_control = false,        .no_display = false,        .turn_screen_off = false,        .render_expired_frames = false,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,        .control = !args.no_control,        .display = !args.no_display,        .turn_screen_off = args.turn_screen_off,        .render_expired_frames = args.render_expired_frames,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .send_frame_meta = record,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!video_buffer_init(&video_buffer)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            if (!controller_start(&controller)) {                goto end;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Cannot request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .send_frame_meta = record,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!video_buffer_init(&video_buffer, options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            if (!controller_start(&controller)) {                goto end;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Cannot request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
video_buffer_init(struct video_buffer *vb) {    if (!(vb->decoding_frame = av_frame_alloc())) {        goto error_0;    }    if (!(vb->rendering_frame = av_frame_alloc())) {        goto error_1;    }    if (!(vb->mutex = SDL_CreateMutex())) {        goto error_2;    }#ifndef SKIP_FRAMES    if (!(vb->rendering_frame_consumed_cond = SDL_CreateCond())) {        SDL_DestroyMutex(vb->mutex);        goto error_2;    }    vb->interrupted = false;#endif    // there is initially no rendering frame, so consider it has already been    // consumed    vb->rendering_frame_consumed = true;    fps_counter_init(&vb->fps_counter);    return true;error_2:    av_frame_free(&vb->rendering_frame);error_1:    av_frame_free(&vb->decoding_frame);error_0:    return false;}
video_buffer_interrupt(struct video_buffer *vb) {#ifdef SKIP_FRAMES    (void) vb; // unused#else    mutex_lock(vb->mutex);    vb->interrupted = true;    mutex_unlock(vb->mutex);    // wake up blocking wait    cond_signal(vb->rendering_frame_consumed_cond);#endif}
video_buffer_destroy(struct video_buffer *vb) {#ifndef SKIP_FRAMES    SDL_DestroyCond(vb->rendering_frame_consumed_cond);#endif    SDL_DestroyMutex(vb->mutex);    av_frame_free(&vb->rendering_frame);    av_frame_free(&vb->decoding_frame);}
video_buffer_init(struct video_buffer *vb) {    if (!(vb->decoding_frame = av_frame_alloc())) {        goto error_0;    }    if (!(vb->rendering_frame = av_frame_alloc())) {        goto error_1;    }    if (!(vb->mutex = SDL_CreateMutex())) {        goto error_2;    }#ifndef SKIP_FRAMES    if (!(vb->rendering_frame_consumed_cond = SDL_CreateCond())) {        SDL_DestroyMutex(vb->mutex);        goto error_2;    }    vb->interrupted = false;#endif    // there is initially no rendering frame, so consider it has already been    // consumed    vb->rendering_frame_consumed = true;    fps_counter_init(&vb->fps_counter);    return true;error_2:    av_frame_free(&vb->rendering_frame);error_1:    av_frame_free(&vb->decoding_frame);error_0:    return false;}
video_buffer_offer_decoded_frame(struct video_buffer *vb,                                 bool *previous_frame_skipped) {    mutex_lock(vb->mutex);#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then the decoder must wait for the current    // frame to be consumed    while (!vb->rendering_frame_consumed && !vb->interrupted) {        cond_wait(vb->rendering_frame_consumed_cond, vb->mutex);    }#else    if (vb->fps_counter.started && !vb->rendering_frame_consumed) {        fps_counter_add_skipped_frame(&vb->fps_counter);    }#endif    video_buffer_swap_frames(vb);    *previous_frame_skipped = !vb->rendering_frame_consumed;    vb->rendering_frame_consumed = false;    mutex_unlock(vb->mutex);}
video_buffer_consume_rendered_frame(struct video_buffer *vb) {    SDL_assert(!vb->rendering_frame_consumed);    vb->rendering_frame_consumed = true;    if (vb->fps_counter.started) {        fps_counter_add_rendered_frame(&vb->fps_counter);    }#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then notify the decoder the current frame is    // consumed, so that it may push a new one    cond_signal(vb->rendering_frame_consumed_cond);#endif    return vb->rendering_frame;}
video_buffer_init(struct video_buffer *vb, bool render_expired_frames) {    if (!(vb->decoding_frame = av_frame_alloc())) {        goto error_0;    }    if (!(vb->rendering_frame = av_frame_alloc())) {        goto error_1;    }    if (!(vb->mutex = SDL_CreateMutex())) {        goto error_2;    }    vb->render_expired_frames = render_expired_frames;    if (render_expired_frames) {        if (!(vb->rendering_frame_consumed_cond = SDL_CreateCond())) {            SDL_DestroyMutex(vb->mutex);            goto error_2;        }        // interrupted is not used if expired frames are not rendered        // since offering a frame will never block        vb->interrupted = false;    }    // there is initially no rendering frame, so consider it has already been    // consumed    vb->rendering_frame_consumed = true;    fps_counter_init(&vb->fps_counter);    return true;error_2:    av_frame_free(&vb->rendering_frame);error_1:    av_frame_free(&vb->decoding_frame);error_0:    return false;}
video_buffer_interrupt(struct video_buffer *vb) {    if (vb->render_expired_frames) {        mutex_lock(vb->mutex);        vb->interrupted = true;        mutex_unlock(vb->mutex);        // wake up blocking wait        cond_signal(vb->rendering_frame_consumed_cond);    }}
video_buffer_destroy(struct video_buffer *vb) {    if (vb->render_expired_frames) {        SDL_DestroyCond(vb->rendering_frame_consumed_cond);    }    SDL_DestroyMutex(vb->mutex);    av_frame_free(&vb->rendering_frame);    av_frame_free(&vb->decoding_frame);}
video_buffer_init(struct video_buffer *vb, bool render_expired_frames) {    if (!(vb->decoding_frame = av_frame_alloc())) {        goto error_0;    }    if (!(vb->rendering_frame = av_frame_alloc())) {        goto error_1;    }    if (!(vb->mutex = SDL_CreateMutex())) {        goto error_2;    }    vb->render_expired_frames = render_expired_frames;    if (render_expired_frames) {        if (!(vb->rendering_frame_consumed_cond = SDL_CreateCond())) {            SDL_DestroyMutex(vb->mutex);            goto error_2;        }        // interrupted is not used if expired frames are not rendered        // since offering a frame will never block        vb->interrupted = false;    }    // there is initially no rendering frame, so consider it has already been    // consumed    vb->rendering_frame_consumed = true;    fps_counter_init(&vb->fps_counter);    return true;error_2:    av_frame_free(&vb->rendering_frame);error_1:    av_frame_free(&vb->decoding_frame);error_0:
video_buffer_offer_decoded_frame(struct video_buffer *vb,                                 bool *previous_frame_skipped) {    mutex_lock(vb->mutex);    if (vb->render_expired_frames) {        // wait for the current (expired) frame to be consumed        while (!vb->rendering_frame_consumed && !vb->interrupted) {            cond_wait(vb->rendering_frame_consumed_cond, vb->mutex);        }    } else {        if (vb->fps_counter.started && !vb->rendering_frame_consumed) {            fps_counter_add_skipped_frame(&vb->fps_counter);        }    }    video_buffer_swap_frames(vb);    *previous_frame_skipped = !vb->rendering_frame_consumed;    vb->rendering_frame_consumed = false;    mutex_unlock(vb->mutex);}
video_buffer_consume_rendered_frame(struct video_buffer *vb) {    SDL_assert(!vb->rendering_frame_consumed);    vb->rendering_frame_consumed = true;    if (vb->fps_counter.started) {        fps_counter_add_rendered_frame(&vb->fps_counter);    }    if (vb->render_expired_frames) {        // unblock video_buffer_offer_decoded_frame()        cond_signal(vb->rendering_frame_consumed_cond);    }    return vb->rendering_frame;}
static void usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is -1 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is -1 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, OPT_CROP},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"push-target",           required_argument, NULL, OPT_PUSH_TARGET},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, OPT_RECORD_FORMAT},        {"render-expired-frames", no_argument,       NULL,                                                     OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"prefer-text",           no_argument,       NULL, OPT_PREFER_TEXT},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",              required_argument, NULL, OPT_WINDOW_X},        {"window-y",              required_argument, NULL, OPT_WINDOW_Y},        {"window-width",          required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",         required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",     no_argument,       NULL,                                                     OPT_WINDOW_BORDERLESS},        {NULL,                    0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port(optarg, &opts->port)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
static void usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (only supported on\n"        "        devices with Android >= 10).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is -1 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
parse_max_fps(const char *optarg, uint16_t *max_fps) {    char *endptr;    if (*optarg == '\0') {        LOGE("Max FPS parameter is empty");        return false;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid max FPS: %s", optarg);        return false;    }    if (value & ~0xffff) {        // in practice, it should not be higher than 60        LOGE("Max FPS value is invalid: %ld", value);        return false;    }    *max_fps = (uint16_t) value;    return true;}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, OPT_ALWAYS_ON_TOP},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, OPT_CROP},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-fps",               required_argument, NULL, OPT_MAX_FPS},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"push-target",           required_argument, NULL, OPT_PUSH_TARGET},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, OPT_RECORD_FORMAT},        {"render-expired-frames", no_argument,       NULL,                                                     OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"prefer-text",           no_argument,       NULL, OPT_PREFER_TEXT},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL, OPT_WINDOW_TITLE},        {"window-x",              required_argument, NULL, OPT_WINDOW_X},        {"window-y",              required_argument, NULL, OPT_WINDOW_Y},        {"window-width",          required_argument, NULL, OPT_WINDOW_WIDTH},        {"window-height",         required_argument, NULL, OPT_WINDOW_HEIGHT},        {"window-borderless",     no_argument,       NULL,                                                     OPT_WINDOW_BORDERLESS},        {NULL,                    0,                 NULL, 0  },    };    struct scrcpy_options *opts = &args->opts;    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &opts->bit_rate)) {                    return false;                }                break;            case 'c':                LOGW("Deprecated option -c. Use --crop instead.");                // fall through            case OPT_CROP:                opts->crop = optarg;                break;            case 'f':                opts->fullscreen = true;                break;            case 'F':                LOGW("Deprecated option -F. Use --record-format instead.");                // fall through            case OPT_RECORD_FORMAT:                if (!parse_record_format(optarg, &opts->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case OPT_MAX_FPS:                if (!parse_max_fps(optarg, &opts->max_fps)) {                    return false;                }                break;            case 'm':                if (!parse_max_size(optarg, &opts->max_size)) {                    return false;                }                break;            case 'n':                opts->control = false;                break;            case 'N':                opts->display = false;                break;            case 'p':                if (!parse_port(optarg, &opts->port)) {                    return false;                }                break;            case 'r':                opts->record_filename = optarg;                break;            case 's':                opts->serial = optarg;                break;            case 'S':                opts->turn_screen_off = true;                break;            case 't':                opts->show_touches = true;                break;            case 'T':                LOGW("Deprecated option -T. Use --always-on-top instead.");                // fall through            case OPT_ALWAYS_ON_TOP:                opts->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                opts->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                opts->window_title = optarg;                break;            case OPT_WINDOW_X:                if (!parse_window_position(optarg, &opts->window_x)) {                    return false;                }                break;            case OPT_WINDOW_Y:                if (!parse_window_position(optarg, &opts->window_y)) {                    return false;                }                break;            case OPT_WINDOW_WIDTH:                if (!parse_window_dimension(optarg, &opts->window_width)) {                    return false;                }                break;            case OPT_WINDOW_HEIGHT:                if (!parse_window_dimension(optarg, &opts->window_height)) {                    return false;                }                break;            case OPT_WINDOW_BORDERLESS:                opts->window_borderless = true;                break;            case OPT_PUSH_TARGET:                opts->push_target = optarg;                break;            case OPT_PREFER_TEXT:                opts->prefer_text = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (!opts->display && !opts->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (!opts->display && opts->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (opts->record_format && !opts->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (opts->record_filename && !opts->record_format) {        opts->record_format = guess_record_format(opts->record_filename);        if (!opts->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 opts->record_filename);            return false;        }    }    if (!opts->control && opts->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .max_fps = options->max_fps,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top, options->window_x,                                   options->window_y, options->window_width,                                   options->window_height,                                   options->window_borderless)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    input_manager.prefer_text = options->prefer_text;    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/" SERVER_FILENAME,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,        max_size_string,        bit_rate_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    char max_fps_string[6];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    sprintf(max_fps_string, "%"PRIu16, params->max_fps);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/" SERVER_FILENAME,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,        max_size_string,        bit_rate_string,        max_fps_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        // Some devices internally create a Handler when creating an input Surface, causing an exception:        //   "Can't create handler inside thread that has not called Looper.prepare()"        // <https://github.com/Genymobile/scrcpy/issues/240>        //        // Use Looper.prepareMainLooper() instead of Looper.prepare() to avoid a NullPointerException:        //   "Attempt to read from field 'android.os.MessageQueue android.os.Looper.mQueue'        //    on a null object reference"        // <https://github.com/Genymobile/scrcpy/issues/921>        Looper.prepareMainLooper();        MediaFormat format = createFormat(bitRate, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                Rect contentRect = device.getScreenInfo().getContentRect();                Rect videoRect = device.getScreenInfo().getVideoSize().toRect();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, contentRect, videoRect);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int iFrameInterval) {        this.sendFrameMeta = sendFrameMeta;        this.bitRate = bitRate;        this.iFrameInterval = iFrameInterval;    }
    private static MediaFormat createFormat(int bitRate, int iFrameInterval) throws IOException {        MediaFormat format = new MediaFormat();        format.setString(MediaFormat.KEY_MIME, "video/avc");        format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);        // must be present to configure the encoder, but does not impact the actual frame rate, which is variable        format.setInteger(MediaFormat.KEY_FRAME_RATE, 60);        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iFrameInterval);        // display the very first frame, and recover from bad quality when no new frames        format.setLong(MediaFormat.KEY_REPEAT_PREVIOUS_FRAME_AFTER, REPEAT_FRAME_DELAY_US); // µs        return format;    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate) {        this(sendFrameMeta, bitRate, DEFAULT_I_FRAME_INTERVAL);    }
    private static MediaFormat createFormat(int bitRate, int iFrameInterval) throws IOException {        MediaFormat format = new MediaFormat();        format.setString(MediaFormat.KEY_MIME, "video/avc");        format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);        // must be present to configure the encoder, but does not impact the actual frame rate, which is variable        format.setInteger(MediaFormat.KEY_FRAME_RATE, 60);        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iFrameInterval);        // display the very first frame, and recover from bad quality when no new frames        format.setLong(MediaFormat.KEY_REPEAT_PREVIOUS_FRAME_AFTER, REPEAT_FRAME_DELAY_US); // µs        return format;    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate) {        this(sendFrameMeta, bitRate, DEFAULT_I_FRAME_INTERVAL);    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate) {        this(sendFrameMeta, bitRate, DEFAULT_I_FRAME_INTERVAL);    }
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        // Some devices internally create a Handler when creating an input Surface, causing an exception:        //   "Can't create handler inside thread that has not called Looper.prepare()"        // <https://github.com/Genymobile/scrcpy/issues/240>        //        // Use Looper.prepareMainLooper() instead of Looper.prepare() to avoid a NullPointerException:        //   "Attempt to read from field 'android.os.MessageQueue android.os.Looper.mQueue'        //    on a null object reference"        // <https://github.com/Genymobile/scrcpy/issues/921>        Looper.prepareMainLooper();        MediaFormat format = createFormat(bitRate, maxFps, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                Rect contentRect = device.getScreenInfo().getContentRect();                Rect videoRect = device.getScreenInfo().getVideoSize().toRect();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, contentRect, videoRect);                codec.start();                try {                    alive = encode(codec, fd);                    // do not call stop() on exception, it would trigger an IllegalStateException                    codec.stop();                } finally {                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    private long ptsOrigin;    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps, int iFrameInterval) {        this.sendFrameMeta = sendFrameMeta;        this.bitRate = bitRate;        this.maxFps = maxFps;
        return MediaCodec.createEncoderByType("video/avc");    }    @SuppressWarnings("checkstyle:MagicNumber")    private static MediaFormat createFormat(int bitRate, int maxFps, int iFrameInterval) {        MediaFormat format = new MediaFormat();        format.setString(MediaFormat.KEY_MIME, "video/avc");        format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);        // must be present to configure the encoder, but does not impact the actual frame rate, which is variable        format.setInteger(MediaFormat.KEY_FRAME_RATE, 60);        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iFrameInterval);        // display the very first frame, and recover from bad quality when no new frames
        this.iFrameInterval = iFrameInterval;    }    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps) {
    private static MediaFormat createFormat(int bitRate, int maxFps, int iFrameInterval) {        MediaFormat format = new MediaFormat();        format.setString(MediaFormat.KEY_MIME, "video/avc");        format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);        // must be present to configure the encoder, but does not impact the actual frame rate, which is variable        format.setInteger(MediaFormat.KEY_FRAME_RATE, 60);        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iFrameInterval);        // display the very first frame, and recover from bad quality when no new frames        format.setLong(MediaFormat.KEY_REPEAT_PREVIOUS_FRAME_AFTER, REPEAT_FRAME_DELAY_US); // µs        if (maxFps > 0) {            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {                format.setFloat(MediaFormat.KEY_MAX_FPS_TO_ENCODER, maxFps);            } else {                Ln.w("Max FPS is only supported since Android 10, the option has been ignored");            }        }        return format;    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps, int iFrameInterval) {        this.sendFrameMeta = sendFrameMeta;        this.bitRate = bitRate;        this.maxFps = maxFps;        this.iFrameInterval = iFrameInterval;    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int maxFps) {        this(sendFrameMeta, bitRate, maxFps, DEFAULT_I_FRAME_INTERVAL);    }
    private static Options createOptions(String... args) {        if (args.length < 1) {            throw new IllegalArgumentException("Missing client version");        }        String clientVersion = args[0];        if (!clientVersion.equals(BuildConfig.VERSION_NAME)) {            throw new IllegalArgumentException("The server version (" + clientVersion + ") does not match the client "                    + "(" + BuildConfig.VERSION_NAME + ")");        }        if (args.length != 7) {            throw new IllegalArgumentException("Expecting 7 parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[1]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[2]);        options.setBitRate(bitRate);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[3]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[4]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[5]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[6]);        options.setControl(control);        return options;    }
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate());            if (options.getControl()) {                Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    private static Options createOptions(String... args) {        if (args.length < 1) {            throw new IllegalArgumentException("Missing client version");        }        String clientVersion = args[0];        if (!clientVersion.equals(BuildConfig.VERSION_NAME)) {            throw new IllegalArgumentException("The server version (" + clientVersion + ") does not match the client "                    + "(" + BuildConfig.VERSION_NAME + ")");        }        if (args.length != 8) {            throw new IllegalArgumentException("Expecting 8 parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[1]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[2]);        options.setBitRate(bitRate);        int maxFps = Integer.parseInt(args[3]);        options.setMaxFps(maxFps);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[4]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[5]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[6]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[7]);        options.setControl(control);        return options;    }
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate(), options.getMaxFps());            if (options.getControl()) {                Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        // Ctrl+x: optimal size (remove black borders)        if (keycode == SDLK_x && !shift) {            resize_to_fit();            return;        }        // Ctrl+g: pixel-perfect (ratio 1:1)        if (keycode == SDLK_g && !shift) {            resize_to_pixel_perfect();            return;        }        // Ctrl+f: switch fullscreen        if (keycode == SDLK_f && !shift) {            switch_fullscreen();            return;        }        // Ctrl+h: HOME (the HOME key also works natively)        if (keycode == SDLK_h && !shift) {             send_keycode(AKEYCODE_HOME, "HOME");             return;        }        // Ctrl+b or Ctrl+BACKSPACE: BACK (the ESCAPE key also works natively)        if ((keycode == SDLK_b && !shift) || keycode == SDLK_BACKSPACE) {            send_keycode(AKEYCODE_BACK, "BACK");            return;        }        // Ctrl+m: APP_SWITCH        if (keycode == SDLK_m && !shift) {            send_keycode(AKEYCODE_APP_SWITCH, "APP_SWITCH");            return;        }        // Ctrl+p: POWER        if (keycode == SDLK_p && !shift) {            send_keycode(AKEYCODE_POWER, "POWER");            return;        }        // volume shortcuts are handled in handle_text_input()        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        // Ctrl+x: optimal size (remove black borders)        if (keycode == SDLK_x && !shift) {            resize_to_fit();            return;        }        // Ctrl+g: pixel-perfect (ratio 1:1)        if (keycode == SDLK_g && !shift) {            resize_to_pixel_perfect();            return;        }        // Ctrl+f: switch fullscreen        if (keycode == SDLK_f && !shift) {            switch_fullscreen();            return;        }        // Ctrl+h: HOME (the HOME key also works natively)        if (keycode == SDLK_h && !shift) {             send_keycode(AKEYCODE_HOME, "HOME");             return;        }        // Ctrl+b or Ctrl+BACKSPACE: BACK (the ESCAPE key also works natively)        if ((keycode == SDLK_b && !shift) || keycode == SDLK_BACKSPACE) {            send_keycode(AKEYCODE_BACK, "BACK");            return;        }        // Ctrl+m: APP_SWITCH        if (keycode == SDLK_m && !shift) {            send_keycode(AKEYCODE_APP_SWITCH, "APP_SWITCH");            return;        }        // Ctrl+p: POWER        if (keycode == SDLK_p && !shift) {            send_keycode(AKEYCODE_POWER, "POWER");            return;        }        // volume shortcuts are handled in handle_text_input()        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
static void handle_text_input(const SDL_TextInputEvent *event) {    if (is_ctrl_down()) {        char c = event->text[0];        switch (c) {            case '+':                send_keycode(AKEYCODE_VOLUME_UP, "VOLUME_UP");                break;            case '-':                send_keycode(AKEYCODE_VOLUME_DOWN, "VOLUME_DOWN");                break;        }        // ignore        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    strncpy(control_event.text_event.text, event->text, TEXT_MAX_LENGTH);    control_event.text_event.text[TEXT_MAX_LENGTH] = '\0';    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send text event");    }}
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        switch (keycode) {            case SDLK_f:                handle_shortcut('f');                return;            case SDLK_x:                handle_shortcut('x');                return;            case SDLK_g:                handle_shortcut('g');                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                handle_shortcut('b');                return;            case SDLK_m:                handle_shortcut('m');                return;            case SDLK_p:                handle_shortcut('p');                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
static void handle_shortcut(char c) {    switch (c) {        case 'h':            send_keycode(AKEYCODE_HOME, "HOME");            break;        case 'b':            send_keycode(AKEYCODE_BACK, "BACK");            break;        case 'm':            send_keycode(AKEYCODE_APP_SWITCH, "APP_SWITCH");            break;        case 'p':            send_keycode(AKEYCODE_POWER, "POWER");            break;        case '+':            send_keycode(AKEYCODE_VOLUME_UP, "VOLUME_UP");            break;        case '-':            send_keycode(AKEYCODE_VOLUME_DOWN, "VOLUME_DOWN");            break;        case 'f':            switch_fullscreen();            break;        case 'x':            resize_to_fit();            break;        case 'g':            resize_to_pixel_perfect();            break;    }}
static void handle_text_input(const SDL_TextInputEvent *event) {    if (is_ctrl_down()) {        handle_shortcut(event->text[0]);        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    strncpy(control_event.text_event.text, event->text, TEXT_MAX_LENGTH);    control_event.text_event.text[TEXT_MAX_LENGTH] = '\0';    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send text event");    }}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options] [serial]\n"        "\n"        "    serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f: switch fullscreen mode\n"        "    Ctrl+g: resize window to 1:1 (pixel-perfect)\n"        "    Ctrl+x: resize window to optimal size (remove black borders)\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options] [serial]\n"        "\n"        "    serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "        resize window to optimal size (remove black borders)\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "        click on BACK\n"        "\n"        "    Ctrl+m\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+'+'\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+'-'\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click\n"        "        turn screen on\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    // initialize the receiver state    decoder->receiver_state.frame_meta_queue = NULL;    decoder->receiver_state.remaining = 0;    // if recording is enabled, a "header" is sent between raw packets    int (*read_packet)(void *, uint8_t *, int) =            decoder->recorder ? read_packet_with_meta : read_raw_packet;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder,                                               read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#ifdef SCRCPY_LAVF_HAS_NEW_ENCODING_DECODING_API        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->video_buffer->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        int got_picture;        int len = avcodec_decode_video2(codec_ctx, decoder->video_buffer->decoding_frame, &got_picture, &packet);        if (len < 0) {            LOGE("Could not decode video packet: %d", len);            av_packet_unref(&packet);            goto run_quit;        }        if (got_picture) {            push_frame(decoder);        }#endif        if (decoder->recorder) {            // we retrieve the PTS in order they were received, so they will            // be assigned to the correct frame            uint64_t pts = receiver_state_take_meta(&decoder->receiver_state);            packet.pts = pts;            packet.dts = pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(decoder->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto run_quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_free(avio_ctx->buffer);    av_free(avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}void decoder_init(struct decoder *decoder, struct video_buffer *vb,                  socket_t video_socket, struct recorder *recorder) {    decoder->video_buffer = vb;    decoder->video_socket = video_socket;    decoder->recorder = recorder;}SDL_bool decoder_start(struct decoder *decoder) {    LOGD("Starting decoder thread");    decoder->thread = SDL_CreateThread(run_decoder, "video_decoder", decoder);    if (!decoder->thread) {        LOGC("Could not start decoder thread");        return SDL_FALSE;    }    return SDL_TRUE;}void decoder_stop(struct decoder *decoder) {    video_buffer_interrupt(decoder->video_buffer);}void decoder_join(struct decoder *decoder) {
static uint64_t receiver_state_take_meta(struct receiver_state *state) {    struct frame_meta *frame_meta = state->frame_meta_queue; // first item    SDL_assert(frame_meta); // must not be empty    uint64_t pts = frame_meta->pts;    state->frame_meta_queue = frame_meta->next; // remove the item    frame_meta_delete(frame_meta);    return pts;}
static void frame_meta_delete(struct frame_meta *frame_meta) {    free(frame_meta);}
void decoder_init(struct decoder *decoder, struct video_buffer *vb,                  socket_t video_socket, struct recorder *recorder) {    decoder->video_buffer = vb;    decoder->video_socket = video_socket;    decoder->recorder = recorder;}
void decoder_init(struct decoder *decoder, struct video_buffer *vb,                  socket_t video_socket, struct recorder *recorder) {    decoder->video_buffer = vb;    decoder->video_socket = video_socket;    decoder->recorder = recorder;}
static struct frame_meta *frame_meta_new(uint64_t pts) {    struct frame_meta *meta = malloc(sizeof(*meta));    if (!meta) {        return meta;    }    meta->pts = pts;    meta->next = NULL;    return meta;}
static int read_packet_with_meta(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    struct receiver_state *state = &decoder->receiver_state;    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    if (!state->remaining) {#define HEADER_SIZE 12        uint8_t header[HEADER_SIZE];        ssize_t r = net_recv_all(decoder->video_socket, header, HEADER_SIZE);        if (r == -1) {            return AVERROR(errno);        }        if (r == 0) {            return AVERROR_EOF;        }        // no partial read (net_recv_all())        SDL_assert_release(r == HEADER_SIZE);        uint64_t pts = buffer_read64be(header);        state->remaining = buffer_read32be(&header[8]);        if (pts != NO_PTS && !receiver_state_push_meta(state, pts)) {            LOGE("Could not store PTS for recording");            // we cannot save the PTS, the recording would be broken            return AVERROR(ENOMEM);        }    }    SDL_assert(state->remaining);    if (buf_size > state->remaining)        buf_size = state->remaining;    ssize_t r = net_recv(decoder->video_socket, buf, buf_size);    if (r == -1) {        return AVERROR(errno);    }    if (r == 0) {        return AVERROR_EOF;    }    SDL_assert(state->remaining >= r);    state->remaining -= r;    return r;}
static SDL_bool receiver_state_push_meta(struct receiver_state *state,                                         uint64_t pts) {    struct frame_meta *frame_meta = frame_meta_new(pts);    if (!frame_meta) {        return SDL_FALSE;    }    // append to the list    // (iterate to find the last item, in practice the list should be tiny)    struct frame_meta **p = &state->frame_meta_queue;    while (*p) {        p = &(*p)->next;    }    *p = frame_meta;    return SDL_TRUE;}
void decoder_init(struct decoder *decoder, struct video_buffer *vb,                  socket_t video_socket, struct recorder *recorder) {    decoder->video_buffer = vb;    decoder->video_socket = video_socket;    decoder->recorder = recorder;}
void decoder_init(struct decoder *decoder, struct video_buffer *vb,                  socket_t video_socket, struct recorder *recorder) {    decoder->video_buffer = vb;    decoder->video_socket = video_socket;    decoder->recorder = recorder;}
void decoder_close(struct decoder *decoder) {    avcodec_close(decoder->codec_ctx);    avcodec_free_context(&decoder->codec_ctx);}
}SDL_bool decoder_push(struct decoder *decoder, AVPacket *packet) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#ifdef SCRCPY_LAVF_HAS_NEW_ENCODING_DECODING_API    int ret;    if ((ret = avcodec_send_packet(decoder->codec_ctx, packet)) < 0) {        LOGE("Could not send video packet: %d", ret);
}SDL_bool decoder_open(struct decoder *decoder, AVCodec *codec) {    decoder->codec_ctx = avcodec_alloc_context3(codec);
SDL_bool decoder_open(struct decoder *decoder, AVCodec *codec) {    decoder->codec_ctx = avcodec_alloc_context3(codec);    if (!decoder->codec_ctx) {        LOGC("Could not allocate decoder context");        return SDL_FALSE;    }    if (avcodec_open2(decoder->codec_ctx, codec, NULL) < 0) {        LOGE("Could not open codec");        avcodec_free_context(&decoder->codec_ctx);        return SDL_FALSE;    }    return SDL_TRUE;}
SDL_bool decoder_push(struct decoder *decoder, AVPacket *packet) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#ifdef SCRCPY_LAVF_HAS_NEW_ENCODING_DECODING_API    int ret;    if ((ret = avcodec_send_packet(decoder->codec_ctx, packet)) < 0) {        LOGE("Could not send video packet: %d", ret);        return SDL_FALSE;    }    ret = avcodec_receive_frame(decoder->codec_ctx,                                decoder->video_buffer->decoding_frame);    if (!ret) {        // a frame was received        push_frame(decoder);    } else if (ret != AVERROR(EAGAIN)) {        LOGE("Could not receive video frame: %d", ret);        return SDL_FALSE;    }#else    int got_picture;    int len = avcodec_decode_video2(decoder->codec_ctx,                                    decoder->video_buffer->decoding_frame,                                    &got_picture,                                    packet);    if (len < 0) {        LOGE("Could not decode video packet: %d", len);        return SDL_FALSE;    }    if (got_picture) {        push_frame(decoder);    }#endif    return SDL_TRUE;}
        return;    }    static SDL_Event new_frame_event = {        .type = EVENT_NEW_FRAME,    };    SDL_PushEvent(&new_frame_event);}void decoder_init(struct decoder *decoder, struct video_buffer *vb) {    decoder->video_buffer = vb;
        return SDL_FALSE;    }    ret = avcodec_receive_frame(decoder->codec_ctx,                                decoder->video_buffer->decoding_frame);    if (!ret) {        // a frame was received        push_frame(decoder);    } else if (ret != AVERROR(EAGAIN)) {        LOGE("Could not receive video frame: %d", ret);        return SDL_FALSE;    }#else    int got_picture;    int len = avcodec_decode_video2(decoder->codec_ctx,                                    decoder->video_buffer->decoding_frame,                                    &got_picture,                                    packet);    if (len < 0) {        LOGE("Could not decode video packet: %d", len);        return SDL_FALSE;    }    if (got_picture) {        push_frame(decoder);    }#endif    return SDL_TRUE;}void decoder_interrupt(struct decoder *decoder) {    video_buffer_interrupt(decoder->video_buffer);}
    if (!decoder->codec_ctx) {        LOGC("Could not allocate decoder context");        return SDL_FALSE;    }    if (avcodec_open2(decoder->codec_ctx, codec, NULL) < 0) {        LOGE("Could not open codec");        avcodec_free_context(&decoder->codec_ctx);        return SDL_FALSE;    }    return SDL_TRUE;}void decoder_close(struct decoder *decoder) {    avcodec_close(decoder->codec_ctx);    avcodec_free_context(&decoder->codec_ctx);
void decoder_init(struct decoder *decoder, struct video_buffer *vb) {    decoder->video_buffer = vb;}
void decoder_interrupt(struct decoder *decoder) {    video_buffer_interrupt(decoder->video_buffer);}
static SDL_bool event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return SDL_FALSE;            case SDL_QUIT:                LOGD("User requested to quit");                return SDL_TRUE;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &video_buffer)) {                    return SDL_FALSE;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                    case SDL_WINDOWEVENT_EXPOSED:                    case SDL_WINDOWEVENT_SIZE_CHANGED:                        screen_render(&screen);                        break;                }                break;            case SDL_TEXTINPUT:                input_manager_process_text_input(&input_manager, &event.text);                break;            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL:                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP:                input_manager_process_mouse_button(&input_manager, &event.button);                break;            case SDL_DROPFILE: {                file_handler_action_t action;                if (is_apk(event.drop.file)) {                    action = ACTION_INSTALL_APK;                } else {                    action = ACTION_PUSH_FILE;                }                file_handler_request(&file_handler, action, event.drop.file);                break;            }        }    }    return SDL_FALSE;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    SDL_bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!video_buffer_init(&video_buffer)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_video_buffer;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    decoder_init(&decoder, &video_buffer, device_socket, rec);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size, options->always_on_top)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_video_buffer:    video_buffer_destroy(&video_buffer);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
static SDL_bool event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_STREAM_STOPPED:                LOGD("Video stream stopped");                return SDL_FALSE;            case SDL_QUIT:                LOGD("User requested to quit");                return SDL_TRUE;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &video_buffer)) {                    return SDL_FALSE;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                    case SDL_WINDOWEVENT_EXPOSED:                    case SDL_WINDOWEVENT_SIZE_CHANGED:                        screen_render(&screen);                        break;                }                break;            case SDL_TEXTINPUT:                input_manager_process_text_input(&input_manager, &event.text);                break;            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL:                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP:                input_manager_process_mouse_button(&input_manager, &event.button);                break;            case SDL_DROPFILE: {                file_handler_action_t action;                if (is_apk(event.drop.file)) {                    action = ACTION_INSTALL_APK;                } else {                    action = ACTION_PUSH_FILE;                }                file_handler_request(&file_handler, action, event.drop.file);                break;            }        }    }    return SDL_FALSE;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    SDL_bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!video_buffer_init(&video_buffer)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_video_buffer;    }    decoder_init(&decoder, &video_buffer);    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, &decoder, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_stream;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size, options->always_on_top)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_stream:    stream_stop(&stream);    // stop the server before stream_join() to wake up the stream    server_stop(&server);    stream_join(&stream);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_video_buffer:    video_buffer_destroy(&video_buffer);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
    private boolean encode(MediaCodec codec, OutputStream outputStream) throws IOException {        @SuppressWarnings("checkstyle:MagicNumber")        byte[] buf = new byte[bitRate / 8]; // may contain up to 1 second of video        boolean eof = false;        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();        while (!checkRotationChanged() && !eof) {            int outputBufferId = codec.dequeueOutputBuffer(bufferInfo, -1);            eof = (bufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;            try {                if (checkRotationChanged()) {                    // must restart encoding with new size                    break;                }                if (outputBufferId >= 0) {                    ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);                    while (outputBuffer.hasRemaining()) {                        int remaining = outputBuffer.remaining();                        int len = Math.min(buf.length, remaining);                        // the outputBuffer is probably direct (it has no underlying array), and LocalSocket does not expose channels,                        // so we must copy the data locally to write them manually to the output stream                        outputBuffer.get(buf, 0, len);                        outputStream.write(buf, 0, len);                    }                }            } finally {                if (outputBufferId >= 0) {                    codec.releaseOutputBuffer(outputBufferId, false);                }            }        }        return !eof;    }
    private boolean encode(MediaCodec codec, OutputStream outputStream) throws IOException {        @SuppressWarnings("checkstyle:MagicNumber")        byte[] buf = new byte[bitRate / 8]; // may contain up to 1 second of video        boolean eof = false;        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();        while (!checkRotationChanged() && !eof) {            int outputBufferId = codec.dequeueOutputBuffer(bufferInfo, -1);            eof = (bufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;            try {                if (checkRotationChanged()) {                    // must restart encoding with new size                    break;                }                if (outputBufferId >= 0) {                    ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);                    while (outputBuffer.hasRemaining()) {                        int remaining = outputBuffer.remaining();                        int len = Math.min(buf.length, remaining);                        // the outputBuffer is probably direct (it has no underlying array), and LocalSocket does not expose channels,                        // so we must copy the data locally to write them manually to the output stream                        outputBuffer.get(buf, 0, len);                        outputStream.write(buf, 0, len);                    }                }            } finally {                if (outputBufferId >= 0) {                    codec.releaseOutputBuffer(outputBufferId, false);                }            }        }        return !eof;    }
    public boolean checkRotationChanged() {        return rotationChanged.getAndSet(false);    }
    private boolean encode(MediaCodec codec, OutputStream outputStream) throws IOException {        @SuppressWarnings("checkstyle:MagicNumber")        byte[] buf = new byte[bitRate / 8]; // may contain up to 1 second of video        boolean eof = false;        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();        while (!consumeRotationChange() && !eof) {            int outputBufferId = codec.dequeueOutputBuffer(bufferInfo, -1);            eof = (bufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;            try {                if (consumeRotationChange()) {                    // must restart encoding with new size                    break;                }                if (outputBufferId >= 0) {                    ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);                    while (outputBuffer.hasRemaining()) {                        int remaining = outputBuffer.remaining();                        int len = Math.min(buf.length, remaining);                        // the outputBuffer is probably direct (it has no underlying array), and LocalSocket does not expose channels,                        // so we must copy the data locally to write them manually to the output stream                        outputBuffer.get(buf, 0, len);                        outputStream.write(buf, 0, len);                    }                }            } finally {                if (outputBufferId >= 0) {                    codec.releaseOutputBuffer(outputBufferId, false);                }            }        }        return !eof;    }
    public boolean consumeRotationChange() {        return rotationChanged.getAndSet(false);    }
    public boolean consumeRotationChange() {        return rotationChanged.getAndSet(false);    }
static int parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"port",     required_argument, NULL, 'p'},        {"max-size", required_argument, NULL, 'm'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "p:m:", long_options, NULL)) != -1) {        switch (c) {            case 'p': {                char *endptr;                long value = strtol(optarg, &endptr, 0);                if (*optarg == '\0' || *endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s\n", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld\n", value);                    return -1;                }                args->port = (Uint16) value;                break;            }            case 'm': {                char *endptr;                long value = strtol(optarg, &endptr, 0);                if (*optarg == '\0' || *endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid maximum size: %s\n", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Maximum size must be between 0 and 65535: %ld\n", value);                    return -1;                }                args->maximum_size = (Uint16) value;                break;            }            default:                // getopt prints the error message on stderr                return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s\n", argv[index]);        return -1;    }    return 0;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = scrcpy(args.serial, args.port, args.maximum_size) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
static int parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"port",     required_argument, NULL, 'p'},        {"max-size", required_argument, NULL, 'm'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "p:m:", long_options, NULL)) != -1) {        switch (c) {            case 'p': {                char *endptr;                long value = strtol(optarg, &endptr, 0);                if (*optarg == '\0' || *endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s\n", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld\n", value);                    return -1;                }                args->port = (Uint16) value;                break;            }            case 'm': {                char *endptr;                long value = strtol(optarg, &endptr, 0);                if (*optarg == '\0' || *endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid max size: %s\n", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Max size must be between 0 and 65535: %ld\n", value);                    return -1;                }                args->max_size = (Uint16) value;                break;            }            default:                // getopt prints the error message on stderr                return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s\n", argv[index]);        return -1;    }    return 0;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .max_size = DEFAULT_MAX_SIZE,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = scrcpy(args.serial, args.port, args.max_size) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 maximum_size) {    SDL_bool ret = 0;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, maximum_size);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 maximum_size) {    SDL_bool ret = 0;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, maximum_size);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size) {    SDL_bool ret = 0;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, max_size);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size) {    SDL_bool ret = 0;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, max_size);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
process_t start_server(const char *serial, Uint16 maximum_size) {    char maximum_size_string[6];    sprintf(maximum_size_string, "%d", maximum_size);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy.apk",        "app_process",        "/", // unused        "com.genymobile.scrcpy.ScrCpyServer",        maximum_size_string,    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
process_t start_server(const char *serial, Uint16 maximum_size) {    char maximum_size_string[6];    sprintf(maximum_size_string, "%d", maximum_size);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy.apk",        "app_process",        "/", // unused        "com.genymobile.scrcpy.ScrCpyServer",        maximum_size_string,    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
process_t start_server(const char *serial, Uint16 max_size) {    char max_size_string[6];    sprintf(max_size_string, "%d", max_size);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy.apk",        "app_process",        "/", // unused        "com.genymobile.scrcpy.ScrCpyServer",        max_size_string,    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
process_t start_server(const char *serial, Uint16 max_size) {    char max_size_string[6];    sprintf(max_size_string, "%d", max_size);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy.apk",        "app_process",        "/", // unused        "com.genymobile.scrcpy.ScrCpyServer",        max_size_string,    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
    public Device(Options options) {        screenInfo = computeScreenInfo(options.getMaximumSize());        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    screenInfo = screenInfo.withRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        });    }
    private ScreenInfo computeScreenInfo(int maximumSize) {        // Compute the video size and the padding of the content inside this video.        // Principle:        // - scale down the great side of the screen to maximumSize (if necessary);        // - scale down the other side so that the aspect ratio is preserved;        // - round this value to the nearest multiple of 8 (H.264 only accepts multiples of 8)        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        int w = deviceSize.getWidth();        int h = deviceSize.getHeight();        if (maximumSize > 0) {            assert maximumSize % 8 == 0;            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;            if (major > maximumSize) {                int minorExact = minor * maximumSize / major;                // +4 to round the value to the nearest multiple of 8                minor = (minorExact + 4) & ~7;                major = maximumSize;            }            w = portrait ? minor : major;            h = portrait ? major : minor;        }        Size videoSize = new Size(w, h);        return new ScreenInfo(deviceSize, videoSize, rotated);    }
    private ScreenInfo computeScreenInfo(int maximumSize) {        // Compute the video size and the padding of the content inside this video.        // Principle:        // - scale down the great side of the screen to maximumSize (if necessary);        // - scale down the other side so that the aspect ratio is preserved;        // - round this value to the nearest multiple of 8 (H.264 only accepts multiples of 8)        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        int w = deviceSize.getWidth();        int h = deviceSize.getHeight();        if (maximumSize > 0) {            assert maximumSize % 8 == 0;            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;            if (major > maximumSize) {                int minorExact = minor * maximumSize / major;                // +4 to round the value to the nearest multiple of 8                minor = (minorExact + 4) & ~7;                major = maximumSize;            }            w = portrait ? minor : major;            h = portrait ? major : minor;        }        Size videoSize = new Size(w, h);        return new ScreenInfo(deviceSize, videoSize, rotated);    }
    public Device(Options options) {        screenInfo = computeScreenInfo(options.getMaxSize());        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    screenInfo = screenInfo.withRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        });    }
    private ScreenInfo computeScreenInfo(int maxSize) {        // Compute the video size and the padding of the content inside this video.        // Principle:        // - scale down the great side of the screen to maxSize (if necessary);        // - scale down the other side so that the aspect ratio is preserved;        // - round this value to the nearest multiple of 8 (H.264 only accepts multiples of 8)        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        int w = deviceSize.getWidth();        int h = deviceSize.getHeight();        if (maxSize > 0) {            assert maxSize % 8 == 0;            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;            if (major > maxSize) {                int minorExact = minor * maxSize / major;                // +4 to round the value to the nearest multiple of 8                minor = (minorExact + 4) & ~7;                major = maxSize;            }            w = portrait ? minor : major;            h = portrait ? major : minor;        }        Size videoSize = new Size(w, h);        return new ScreenInfo(deviceSize, videoSize, rotated);    }
    private ScreenInfo computeScreenInfo(int maxSize) {        // Compute the video size and the padding of the content inside this video.        // Principle:        // - scale down the great side of the screen to maxSize (if necessary);        // - scale down the other side so that the aspect ratio is preserved;        // - round this value to the nearest multiple of 8 (H.264 only accepts multiples of 8)        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        int w = deviceSize.getWidth();        int h = deviceSize.getHeight();        if (maxSize > 0) {            assert maxSize % 8 == 0;            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;            if (major > maxSize) {                int minorExact = minor * maxSize / major;                // +4 to round the value to the nearest multiple of 8                minor = (minorExact + 4) & ~7;                major = maxSize;            }            w = portrait ? minor : major;            h = portrait ? major : minor;        }        Size videoSize = new Size(w, h);        return new ScreenInfo(deviceSize, videoSize, rotated);    }
    public void setMaximumSize(int maximumSize) {        this.maximumSize = maximumSize;    }}
    public int getMaximumSize() {        return maximumSize;    }
    public void setMaxSize(int maxSize) {        this.maxSize = maxSize;    }}
    public int getMaxSize() {        return maxSize;    }
    private static Options createOptions(String... args) {        Options options = new Options();        if (args.length > 0) {            int maximumSize = Integer.parseInt(args[0]) & ~7; // multiple of 8            options.setMaximumSize(maximumSize);        }        return options;    }
    private static Options createOptions(String... args) {        Options options = new Options();        if (args.length > 0) {            int maxSize = Integer.parseInt(args[0]) & ~7; // multiple of 8            options.setMaxSize(maxSize);        }        return options;    }
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/" SERVER_FILENAME,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/" SERVER_FILENAME,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,        max_size_string,        bit_rate_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
    private static Options createOptions(String... args) {        if (args.length != 6) {            throw new IllegalArgumentException("Expecting 6 parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[0]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[1]);        options.setBitRate(bitRate);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[2]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[3]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[4]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[5]);        options.setControl(control);        return options;    }
    private static Options createOptions(String... args) {        if (args.length < 1) {            throw new IllegalArgumentException("Missing client version");        }        String clientVersion = args[0];        if (!clientVersion.equals(BuildConfig.VERSION_NAME)) {            throw new IllegalArgumentException("The server version (" + clientVersion + ") does not match the client "                    + "(" + BuildConfig.VERSION_NAME + ")");        }        if (args.length != 7) {            throw new IllegalArgumentException("Expecting 7 parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[1]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[2]);        options.setBitRate(bitRate);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[3]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[4]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[5]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[6]);        options.setControl(control);        return options;    }
    private boolean injectScroll(Position position, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        MotionEvent.PointerProperties props = pointerProperties[0];        props.id = 0;        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.x = point.getX();        coords.y = point.getY();        coords.setAxisValue(MotionEvent.AXIS_HSCROLL, hScroll);        coords.setAxisValue(MotionEvent.AXIS_VSCROLL, vScroll);        MotionEvent event = MotionEvent.obtain(lastTouchDown, now, MotionEvent.ACTION_SCROLL, 1, pointerProperties, pointerCoords, 0, 0, 1f, 1f, 0, 0,                InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
    private boolean injectTouch(int action, long pointerId, Position position, float pressure, int buttons) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        int pointerIndex = pointersState.getPointerIndex(pointerId);        if (pointerIndex == -1) {            Ln.w("Too many pointers for touch event");            return false;        }        Pointer pointer = pointersState.get(pointerIndex);        pointer.setPoint(point);        pointer.setPressure(pressure);        pointer.setUp(action == MotionEvent.ACTION_UP);        int pointerCount = pointersState.update(pointerProperties, pointerCoords);        if (pointerCount == 1) {            if (action == MotionEvent.ACTION_DOWN) {                lastTouchDown = now;            }        } else {            // secondary pointers must use ACTION_POINTER_* ORed with the pointerIndex            if (action == MotionEvent.ACTION_UP) {                action = MotionEvent.ACTION_POINTER_UP | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            } else if (action == MotionEvent.ACTION_DOWN) {                action = MotionEvent.ACTION_POINTER_DOWN | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            }        }        MotionEvent event = MotionEvent.obtain(lastTouchDown, now, action, pointerCount, pointerProperties, pointerCoords, 0, buttons, 1f, 1f, 0, 0,                InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
    private boolean injectScroll(Position position, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        MotionEvent.PointerProperties props = pointerProperties[0];        props.id = 0;        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.x = point.getX();        coords.y = point.getY();        coords.setAxisValue(MotionEvent.AXIS_HSCROLL, hScroll);        coords.setAxisValue(MotionEvent.AXIS_VSCROLL, vScroll);        MotionEvent event = MotionEvent                .obtain(lastTouchDown, now, MotionEvent.ACTION_SCROLL, 1, pointerProperties, pointerCoords, 0, 0, 1f, 1f, DEVICE_ID_VIRTUAL, 0,                        InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
    private boolean injectTouch(int action, long pointerId, Position position, float pressure, int buttons) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        int pointerIndex = pointersState.getPointerIndex(pointerId);        if (pointerIndex == -1) {            Ln.w("Too many pointers for touch event");            return false;        }        Pointer pointer = pointersState.get(pointerIndex);        pointer.setPoint(point);        pointer.setPressure(pressure);        pointer.setUp(action == MotionEvent.ACTION_UP);        int pointerCount = pointersState.update(pointerProperties, pointerCoords);        if (pointerCount == 1) {            if (action == MotionEvent.ACTION_DOWN) {                lastTouchDown = now;            }        } else {            // secondary pointers must use ACTION_POINTER_* ORed with the pointerIndex            if (action == MotionEvent.ACTION_UP) {                action = MotionEvent.ACTION_POINTER_UP | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            } else if (action == MotionEvent.ACTION_DOWN) {                action = MotionEvent.ACTION_POINTER_DOWN | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            }        }        MotionEvent event = MotionEvent                .obtain(lastTouchDown, now, action, pointerCount, pointerProperties, pointerCoords, 0, buttons, 1f, 1f, DEVICE_ID_VIRTUAL, 0,                        InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");            case SDL_QUIT:                return;            case EVENT_NEW_FRAME:                if (!handle_new_frame()) {                    return;                }                texture_empty = SDL_FALSE;                count_frame(); // display fps for debug                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    render(renderer, texture_empty ? NULL : texture);                    break;                }                break;            case SDL_TEXTINPUT: {                handle_text_input(&event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                handle_key(&event.key);                break;            case SDL_MOUSEMOTION:                handle_mouse_motion(&event.motion, frame_size);                break;            case SDL_MOUSEWHEEL: {                struct position position = {                    .screen_size = frame_size,                    .point = get_mouse_point(),                };                handle_mouse_wheel(&event.wheel, position);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                handle_mouse_button(&event.button, frame_size);                break;            }        }    }}
void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");                return;            case SDL_QUIT:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!handle_new_frame()) {                    return;                }                texture_empty = SDL_FALSE;                count_frame(); // display fps for debug                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    render(renderer, texture_empty ? NULL : texture);                    break;                }                break;            case SDL_TEXTINPUT: {                handle_text_input(&event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                handle_key(&event.key);                break;            case SDL_MOUSEMOTION:                handle_mouse_motion(&event.motion, frame_size);                break;            case SDL_MOUSEWHEEL: {                struct position position = {                    .screen_size = frame_size,                    .point = get_mouse_point(),                };                handle_mouse_wheel(&event.wheel, position);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                handle_mouse_button(&event.button, frame_size);                break;            }        }    }}
    private boolean handleEvent() throws IOException {        ControlEvent controlEvent = connection.receiveControlEvent();        if (controlEvent == null) {            return false;        }        switch (controlEvent.getType()) {            case ControlEvent.TYPE_KEYCODE:                injectKeycode(controlEvent.getAction(), controlEvent.getKeycode(), controlEvent.getMetaState());                break;            case ControlEvent.TYPE_TEXT:                injectText(controlEvent.getText());                break;            case ControlEvent.TYPE_MOUSE:                injectMouse(controlEvent.getAction(), controlEvent.getButtons(), controlEvent.getPosition());                break;            case ControlEvent.TYPE_SCROLL:                injectScroll(controlEvent.getPosition(), controlEvent.getHScroll(), controlEvent.getVScroll());                break;            case ControlEvent.TYPE_COMMAND:                executeCommand(controlEvent.getAction());                break;        }        return true;    }
    public void control() throws IOException {        while (handleEvent()) ;    }
    private void handleEvent() throws IOException {        ControlEvent controlEvent = connection.receiveControlEvent();        switch (controlEvent.getType()) {            case ControlEvent.TYPE_KEYCODE:                injectKeycode(controlEvent.getAction(), controlEvent.getKeycode(), controlEvent.getMetaState());                break;            case ControlEvent.TYPE_TEXT:                injectText(controlEvent.getText());                break;            case ControlEvent.TYPE_MOUSE:                injectMouse(controlEvent.getAction(), controlEvent.getButtons(), controlEvent.getPosition());                break;            case ControlEvent.TYPE_SCROLL:                injectScroll(controlEvent.getPosition(), controlEvent.getHScroll(), controlEvent.getVScroll());                break;            case ControlEvent.TYPE_COMMAND:                executeCommand(controlEvent.getAction());                break;        }    }
    public void control() throws IOException {        while (true) {            handleEvent();        }    }
    buf[0] = value >> 24;    buf[1] = value >> 16;    buf[2] = value >> 8;    buf[3] = value;}int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {    case CONTROL_EVENT_TYPE_KEYCODE:
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {    case CONTROL_EVENT_TYPE_KEYCODE:        buf[1] = event->keycode_event.action;        write32(&buf[2], event->keycode_event.keycode);        write32(&buf[6], event->keycode_event.metastate);        return 10;    case CONTROL_EVENT_TYPE_TEXT: {        // write length (1 byte) + date (non nul-terminated)        size_t len = strlen(event->text_event.text);        if (len > TEXT_MAX_LENGTH) {            len = TEXT_MAX_LENGTH;        }        buf[1] = (Uint8) len;        memcpy(&buf[2], &event->text_event.text, len);        return 2 + len;    }    case CONTROL_EVENT_TYPE_MOUSE:        buf[1] = event->mouse_event.action;        write32(&buf[2], event->mouse_event.buttons);        write32(&buf[6], (Uint32) event->mouse_event.x);        write32(&buf[10], (Uint32) event->mouse_event.y);        return 14;    case CONTROL_EVENT_TYPE_SCROLL:        write32(&buf[1], (Uint32) event->scroll_event.x);        write32(&buf[5], (Uint32) event->scroll_event.y);        write32(&buf[9], (Uint32) event->scroll_event.hscroll);        write32(&buf[13], (Uint32) event->scroll_event.vscroll);        return 17;    default:        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Unknown event type: %u\n", (unsigned) event->type);        return 0;    }}
static void write_point(Uint8 *buf, const struct point *point) {    write16(&buf[0], point->position.x);    write16(&buf[2], point->position.y);    write16(&buf[4], point->screen_size.width);    write16(&buf[6], point->screen_size.height);}
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {    case CONTROL_EVENT_TYPE_KEYCODE:        buf[1] = event->keycode_event.action;        write32(&buf[2], event->keycode_event.keycode);        write32(&buf[6], event->keycode_event.metastate);        return 10;    case CONTROL_EVENT_TYPE_TEXT: {        // write length (1 byte) + date (non nul-terminated)        size_t len = strlen(event->text_event.text);        if (len > TEXT_MAX_LENGTH) {            len = TEXT_MAX_LENGTH;        }        buf[1] = (Uint8) len;        memcpy(&buf[2], &event->text_event.text, len);        return 2 + len;    }    case CONTROL_EVENT_TYPE_MOUSE:        buf[1] = event->mouse_event.action;        write32(&buf[2], event->mouse_event.buttons);        write_point(&buf[6], &event->mouse_event.point);        return 14;    case CONTROL_EVENT_TYPE_SCROLL:        write_point(&buf[1], &event->scroll_event.point);        write32(&buf[9], (Uint32) event->scroll_event.hscroll);        write32(&buf[13], (Uint32) event->scroll_event.vscroll);        return 17;    default:        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Unknown event type: %u\n", (unsigned) event->type);        return 0;    }}
SDL_bool mouse_wheel_from_sdl_to_android(const struct complete_mouse_wheel_event *from, struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_SCROLL;    to->scroll_event.x = from->x;    to->scroll_event.y = from->y;    SDL_MouseWheelEvent *wheel = from->mouse_wheel_event;    int mul = wheel->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    to->scroll_event.hscroll = mul * wheel->x;    to->scroll_event.vscroll = mul * wheel->y;    return SDL_TRUE;}
SDL_bool mouse_motion_from_sdl_to_android(const SDL_MouseMotionEvent *from, struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    to->mouse_event.action = AMOTION_EVENT_ACTION_MOVE;    to->mouse_event.buttons = convert_mouse_buttons(from->state);    to->mouse_event.x = from->x;    to->mouse_event.y = from->y;    return SDL_TRUE;}
SDL_bool mouse_motion_from_sdl_to_android(const SDL_MouseMotionEvent *from, struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    to->mouse_event.action = AMOTION_EVENT_ACTION_MOVE;    to->mouse_event.buttons = convert_mouse_buttons(from->state);    to->mouse_event.x = from->x;    to->mouse_event.y = from->y;    return SDL_TRUE;}
SDL_bool input_key_from_sdl_to_android(const SDL_KeyboardEvent *from, struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_KEYCODE;    if (!convert_keycode_action(from->type, &to->keycode_event.action)) {        return SDL_FALSE;    }    if (!convert_keycode(from->keysym.sym, &to->keycode_event.keycode)) {        return SDL_FALSE;    }    to->keycode_event.metastate = convert_meta_state(from->keysym.mod);    return SDL_TRUE;}
SDL_bool mouse_button_from_sdl_to_android(const SDL_MouseButtonEvent *from, struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    if (!convert_mouse_action(from->type, &to->mouse_event.action)) {        return SDL_FALSE;    }    to->mouse_event.buttons = convert_mouse_buttons(SDL_BUTTON(from->button));    to->mouse_event.x = from->x;    to->mouse_event.y = from->y;    return SDL_TRUE;}
SDL_bool mouse_button_from_sdl_to_android(const SDL_MouseButtonEvent *from, struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    if (!convert_mouse_action(from->type, &to->mouse_event.action)) {        return SDL_FALSE;    }    to->mouse_event.buttons = convert_mouse_buttons(SDL_BUTTON(from->button));    to->mouse_event.x = from->x;    to->mouse_event.y = from->y;    return SDL_TRUE;}
SDL_bool mouse_wheel_from_sdl_to_android(const struct complete_mouse_wheel_event *from, struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_SCROLL;    to->scroll_event.x = from->x;    to->scroll_event.y = from->y;    SDL_MouseWheelEvent *wheel = from->mouse_wheel_event;    int mul = wheel->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    to->scroll_event.hscroll = mul * wheel->x;    to->scroll_event.vscroll = mul * wheel->y;    return SDL_TRUE;}
SDL_bool mouse_wheel_from_sdl_to_android(const SDL_MouseWheelEvent *from,                                         const struct point point,                                         struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_SCROLL;    to->scroll_event.point = point;    int mul = from->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    to->scroll_event.hscroll = mul * from->x;    to->scroll_event.vscroll = mul * from->y;    return SDL_TRUE;}
    return SDL_TRUE;}SDL_bool mouse_motion_from_sdl_to_android(const SDL_MouseMotionEvent *from,                                          const struct size screen_size,                                          struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    to->mouse_event.action = AMOTION_EVENT_ACTION_MOVE;    to->mouse_event.buttons = convert_mouse_buttons(from->state);
SDL_bool mouse_motion_from_sdl_to_android(const SDL_MouseMotionEvent *from,                                          const struct size screen_size,                                          struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    to->mouse_event.action = AMOTION_EVENT_ACTION_MOVE;    to->mouse_event.buttons = convert_mouse_buttons(from->state);    to->mouse_event.point.screen_size = screen_size;    to->mouse_event.point.position.x = from->x;    to->mouse_event.point.position.y = from->y;    return SDL_TRUE;}
SDL_bool input_key_from_sdl_to_android(const SDL_KeyboardEvent *from,                                       struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_KEYCODE;    if (!convert_keycode_action(from->type, &to->keycode_event.action)) {        return SDL_FALSE;    }    if (!convert_keycode(from->keysym.sym, &to->keycode_event.keycode)) {        return SDL_FALSE;    }    to->keycode_event.metastate = convert_meta_state(from->keysym.mod);    return SDL_TRUE;}
SDL_bool mouse_button_from_sdl_to_android(const SDL_MouseButtonEvent *from,                                          struct size screen_size,                                          struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    if (!convert_mouse_action(from->type, &to->mouse_event.action)) {        return SDL_FALSE;    }    to->mouse_event.buttons = convert_mouse_buttons(SDL_BUTTON(from->button));    to->mouse_event.point.screen_size = screen_size;    to->mouse_event.point.position.x = (Uint16) from->x;    to->mouse_event.point.position.y = (Uint16) from->y;
SDL_bool mouse_button_from_sdl_to_android(const SDL_MouseButtonEvent *from,                                          struct size screen_size,                                          struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    if (!convert_mouse_action(from->type, &to->mouse_event.action)) {        return SDL_FALSE;    }    to->mouse_event.buttons = convert_mouse_buttons(SDL_BUTTON(from->button));    to->mouse_event.point.screen_size = screen_size;    to->mouse_event.point.position.x = (Uint16) from->x;    to->mouse_event.point.position.y = (Uint16) from->y;    return SDL_TRUE;}
    to->mouse_event.point.screen_size = screen_size;    to->mouse_event.point.position.x = from->x;    to->mouse_event.point.position.y = from->y;    return SDL_TRUE;}SDL_bool mouse_wheel_from_sdl_to_android(const SDL_MouseWheelEvent *from,                                         const struct point point,                                         struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_SCROLL;    to->scroll_event.point = point;
static void handle_mouse_button(const SDL_MouseButtonEvent *event) {    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse button event");        }    }}
static void handle_mouse_button(const SDL_MouseButtonEvent *event) {    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse button event");        }    }}
static struct size get_optimal_size(struct size current_size, struct size frame_size) {    struct size display_size;    // 32 bits because we need to multiply two 16 bits values    Uint32 w;    Uint32 h;    if (!get_preferred_display_bounds(&display_size)) {        // cannot get display bounds, do not constraint the size        w = current_size.width;        h = current_size.height;    } else {        w = MIN(current_size.width, display_size.width);        h = MIN(current_size.height, display_size.height);    }    SDL_bool keep_width = frame_size.width * h > frame_size.height * w;    if (keep_width) {        // remove black borders on top and bottom        h = frame_size.height * w / frame_size.width;    } else {        // remove black borders on left and right (or none at all if it already fits)        w = frame_size.width * h / frame_size.height;    }    // w and h must fit into 16 bits    SDL_assert_release(!(w & ~0xffff) && !(h & ~0xffff));    return (struct size) {w, h};}
static struct size get_optimal_size(struct size current_size, struct size frame_size) {    struct size display_size;    // 32 bits because we need to multiply two 16 bits values    Uint32 w;    Uint32 h;    if (!get_preferred_display_bounds(&display_size)) {        // cannot get display bounds, do not constraint the size        w = current_size.width;        h = current_size.height;    } else {        w = MIN(current_size.width, display_size.width);        h = MIN(current_size.height, display_size.height);    }    SDL_bool keep_width = frame_size.width * h > frame_size.height * w;    if (keep_width) {        // remove black borders on top and bottom        h = frame_size.height * w / frame_size.width;    } else {        // remove black borders on left and right (or none at all if it already fits)        w = frame_size.width * h / frame_size.height;    }    // w and h must fit into 16 bits    SDL_assert_release(!(w & ~0xffff) && !(h & ~0xffff));    return (struct size) {w, h};}
static void handle_mouse_motion(const SDL_MouseMotionEvent *event) {    struct control_event control_event;    if (mouse_motion_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse motion event");        }    }}
static void handle_mouse_motion(const SDL_MouseMotionEvent *event) {    struct control_event control_event;    if (mouse_motion_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse motion event");        }    }}
void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            return;        case EVENT_NEW_FRAME:            if (!handle_new_frame()) {                return;            }            texture_empty = SDL_FALSE;            count_frame(); // display fps for debug            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_TEXTINPUT: {            handle_text_input(&event.text);            break;        }        case SDL_KEYDOWN:        case SDL_KEYUP:            handle_key(&event.key);            break;        case SDL_MOUSEMOTION:            handle_mouse_motion(&event.motion);            break;        case SDL_MOUSEWHEEL: {            struct complete_mouse_wheel_event complete_event;            complete_event.mouse_wheel_event = &event.wheel;            int x;            int y;            SDL_GetMouseState(&x, &y);            complete_event.x = (Sint32) x;            complete_event.y = (Sint32) y;            handle_mouse_wheel(&complete_event);            break;        }        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            handle_mouse_button(&event.button);            break;        }    }}
static void handle_mouse_wheel(const struct complete_mouse_wheel_event *event) {    struct control_event control_event;    if (mouse_wheel_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send wheel button event");        }    }}
static void handle_mouse_wheel(const struct complete_mouse_wheel_event *event) {    struct control_event control_event;    if (mouse_wheel_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send wheel button event");        }    }}
static void handle_mouse_button(const SDL_MouseButtonEvent *event, struct size screen_size) {    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, screen_size, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse button event");        }    }}
            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse motion event");        }    }}static void handle_mouse_button(const SDL_MouseButtonEvent *event, struct size screen_size) {    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, screen_size, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {
static struct size get_optimal_size(struct size current_size, struct size frame_size) {    struct size display_size;    // 32 bits because we need to multiply two 16 bits values    Uint32 w;    Uint32 h;    if (!get_preferred_display_bounds(&display_size)) {        // cannot get display bounds, do not constraint the size        w = current_size.width;        h = current_size.height;    } else {        w = MIN(current_size.width, display_size.width);        h = MIN(current_size.height, display_size.height);    }    SDL_bool keep_width = frame_size.width * h > frame_size.height * w;    if (keep_width) {        // remove black borders on top and bottom        h = frame_size.height * w / frame_size.width;    } else {        // remove black borders on left and right (or none at all if it already fits)        w = frame_size.width * h / frame_size.height;    }    // w and h must fit into 16 bits    SDL_assert_release(w < 0x10000 && h < 0x10000);    return (struct size) {w, h};}
static inline struct position get_mouse_position() {    int x;    int y;    SDL_GetMouseState(&x, &y);    SDL_assert_release(x >= 0 && x < 0x10000 && y >= 0 && y < 0x10000);    return (struct position) {        .x = (Uint16) x,        .y = (Uint16) y,    };}
static void handle_mouse_motion(const SDL_MouseMotionEvent *event, struct size screen_size) {    struct control_event control_event;    if (mouse_motion_from_sdl_to_android(event, screen_size, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse motion event");        }    }}
            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}static void handle_mouse_motion(const SDL_MouseMotionEvent *event, struct size screen_size) {    struct control_event control_event;    if (mouse_motion_from_sdl_to_android(event, screen_size, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {
void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            return;        case EVENT_NEW_FRAME:            if (!handle_new_frame()) {                return;            }            texture_empty = SDL_FALSE;            count_frame(); // display fps for debug            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_TEXTINPUT: {            handle_text_input(&event.text);            break;        }        case SDL_KEYDOWN:        case SDL_KEYUP:            handle_key(&event.key);            break;        case SDL_MOUSEMOTION:            handle_mouse_motion(&event.motion, frame_size);            break;        case SDL_MOUSEWHEEL: {            struct point point = {                .screen_size = frame_size,                .position = get_mouse_position(),            };            handle_mouse_wheel(&event.wheel, point);            break;        }        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP: {            handle_mouse_button(&event.button, frame_size);            break;        }        }    }}
static void handle_mouse_wheel(const SDL_MouseWheelEvent *event, struct point point) {    struct control_event control_event;    if (mouse_wheel_from_sdl_to_android(event, point, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send wheel button event");        }    }}
            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse button event");        }    }}static void handle_mouse_wheel(const SDL_MouseWheelEvent *event, struct point point) {    struct control_event control_event;    if (mouse_wheel_from_sdl_to_android(event, point, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {
static void test_serialize_scroll_event() {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_SCROLL,        .scroll_event = {            .x = 260,            .y = 1026,            .hscroll = 1,            .vscroll = -1,        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 17);    const unsigned char expected[] = {        0x03, // CONTROL_EVENT_TYPE_SCROLL        0x00, 0x00, 0x01, 0x04, // 260        0x00, 0x00, 0x04, 0x02, // 1026        0x00, 0x00, 0x00, 0x01, // 1        0xFF, 0xFF, 0xFF, 0xFF, // -1    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_mouse_event() {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_MOUSE,        .mouse_event = {            .action = AMOTION_EVENT_ACTION_DOWN,            .buttons = AMOTION_EVENT_BUTTON_PRIMARY,            .x = 260,            .y = 1026,        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 14);    const unsigned char expected[] = {        0x02, // CONTROL_EVENT_TYPE_MOUSE        0x00, // AKEY_EVENT_ACTION_DOWN        0x00, 0x00, 0x00, 0x01, // AMOTION_EVENT_BUTTON_PRIMARY        0x00, 0x00, 0x01, 0x04, // 260        0x00, 0x00, 0x04, 0x02, // 1026    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_scroll_event() {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_SCROLL,        .scroll_event = {            .point = {                .position = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },            .hscroll = 1,            .vscroll = -1,        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 17);    const unsigned char expected[] = {        0x03, // CONTROL_EVENT_TYPE_SCROLL        0x01, 0x04, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920        0x00, 0x00, 0x00, 0x01, // 1        0xFF, 0xFF, 0xFF, 0xFF, // -1    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_mouse_event() {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_MOUSE,        .mouse_event = {            .action = AMOTION_EVENT_ACTION_DOWN,            .buttons = AMOTION_EVENT_BUTTON_PRIMARY,            .point = {                .position = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 14);    const unsigned char expected[] = {        0x02, // CONTROL_EVENT_TYPE_MOUSE        0x00, // AKEY_EVENT_ACTION_DOWN        0x00, 0x00, 0x00, 0x01, // AMOTION_EVENT_BUTTON_PRIMARY        0x01, 0x04, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920    };    assert(!memcmp(buf, expected, sizeof(expected)));}
    public static ControlEvent createScrollControlEvent(int x, int y, int hScroll, int vScroll) {        ControlEvent event = new ControlEvent();        event.type = TYPE_SCROLL;        event.x = x;        event.y = y;        event.hScroll = hScroll;        event.vScroll = vScroll;        return event;    }
    public static ControlEvent createScrollControlEvent(int x, int y, int hScroll, int vScroll) {        ControlEvent event = new ControlEvent();        event.type = TYPE_SCROLL;        event.x = x;        event.y = y;        event.hScroll = hScroll;        event.vScroll = vScroll;        return event;    }
    public int getX() {        return x;    }
    public int getX() {        return x;    }
    public int getY() {        return y;    }
    public static ControlEvent createMotionControlEvent(int action, int buttons, int x, int y) {        ControlEvent event = new ControlEvent();        event.type = TYPE_MOUSE;        event.action = action;        event.buttons = buttons;        event.x = x;        event.y = y;        return event;    }
    public static ControlEvent createMotionControlEvent(int action, int buttons, int x, int y) {        ControlEvent event = new ControlEvent();        event.type = TYPE_MOUSE;        event.action = action;        event.buttons = buttons;        event.x = x;        event.y = y;        return event;    }
        event.type = TYPE_SCROLL;        event.point = point;        event.hScroll = hScroll;        event.vScroll = vScroll;        return event;    }    public int getType() {        return type;    }
    public static ControlEvent createScrollControlEvent(Point point, int hScroll, int vScroll) {        ControlEvent event = new ControlEvent();        event.type = TYPE_SCROLL;        event.point = point;        event.hScroll = hScroll;        event.vScroll = vScroll;        return event;    }
    public int getHScroll() {        return hScroll;    }
    public Point getPoint() {        return point;    }
    public int getVScroll() {        return vScroll;    }
    public static ControlEvent createMotionControlEvent(int action, int buttons, Point point) {        ControlEvent event = new ControlEvent();        event.type = TYPE_MOUSE;        event.action = action;        event.buttons = buttons;        event.point = point;        return event;    }
        ControlEvent event = new ControlEvent();        event.type = TYPE_MOUSE;        event.action = action;        event.buttons = buttons;        event.point = point;        return event;    }    public static ControlEvent createScrollControlEvent(Point point, int hScroll, int vScroll) {        ControlEvent event = new ControlEvent();
    public ControlEvent next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        switch (type) {            case ControlEvent.TYPE_KEYCODE: {                if (buffer.remaining() < KEYCODE_PAYLOAD_LENGTH) {                    break;                }                int action = buffer.get() & 0xff; // unsigned                int keycode = buffer.getInt();                int metaState = buffer.getInt();                return ControlEvent.createKeycodeControlEvent(action, keycode, metaState);            }            case ControlEvent.TYPE_TEXT: {                if (buffer.remaining() < 1) {                    break;                }                int len = buffer.get() & 0xff; // unsigned                if (buffer.remaining() < len) {                    break;                }                buffer.get(textBuffer, 0, len);                String text = new String(textBuffer, 0, len, StandardCharsets.UTF_8);                return ControlEvent.createTextControlEvent(text);            }            case ControlEvent.TYPE_MOUSE: {                if (buffer.remaining() < MOUSE_PAYLOAD_LENGTH) {                    break;                }                int action = buffer.get() & 0xff; // unsigned                int buttons = buffer.getInt();                int x = buffer.getInt();                int y = buffer.getInt();                return ControlEvent.createMotionControlEvent(action, buttons, x, y);            }            case ControlEvent.TYPE_SCROLL: {                if (buffer.remaining() < SCROLL_PAYLOAD_LENGTH) {                    break;                }                int x = buffer.getInt();                int y = buffer.getInt();                int hscroll = buffer.getInt();                int vscroll = buffer.getInt();                return ControlEvent.createScrollControlEvent(x, y, hscroll, vscroll);            }            default:                Ln.w("Unknown event type: " + type);        }        // failure, reset savedPosition        buffer.position(savedPosition);        return null;    }}
    public ControlEvent next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        switch (type) {            case ControlEvent.TYPE_KEYCODE: {                if (buffer.remaining() < KEYCODE_PAYLOAD_LENGTH) {                    break;                }                int action = buffer.get() & 0xff; // unsigned                int keycode = buffer.getInt();                int metaState = buffer.getInt();                return ControlEvent.createKeycodeControlEvent(action, keycode, metaState);            }            case ControlEvent.TYPE_TEXT: {                if (buffer.remaining() < 1) {                    break;                }                int len = buffer.get() & 0xff; // unsigned                if (buffer.remaining() < len) {                    break;                }                buffer.get(textBuffer, 0, len);                String text = new String(textBuffer, 0, len, StandardCharsets.UTF_8);                return ControlEvent.createTextControlEvent(text);            }            case ControlEvent.TYPE_MOUSE: {                if (buffer.remaining() < MOUSE_PAYLOAD_LENGTH) {                    break;                }                int action = buffer.get() & 0xff; // unsigned                int buttons = buffer.getInt();                int x = buffer.getInt();                int y = buffer.getInt();                return ControlEvent.createMotionControlEvent(action, buttons, x, y);            }            case ControlEvent.TYPE_SCROLL: {                if (buffer.remaining() < SCROLL_PAYLOAD_LENGTH) {                    break;                }                int x = buffer.getInt();                int y = buffer.getInt();                int hscroll = buffer.getInt();                int vscroll = buffer.getInt();                return ControlEvent.createScrollControlEvent(x, y, hscroll, vscroll);            }            default:                Ln.w("Unknown event type: " + type);        }        // failure, reset savedPosition        buffer.position(savedPosition);        return null;    }}
    public ControlEvent next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        switch (type) {            case ControlEvent.TYPE_KEYCODE: {                if (buffer.remaining() < KEYCODE_PAYLOAD_LENGTH) {                    break;                }                int action = buffer.get() & 0xff; // unsigned                int keycode = buffer.getInt();                int metaState = buffer.getInt();                return ControlEvent.createKeycodeControlEvent(action, keycode, metaState);            }            case ControlEvent.TYPE_TEXT: {                if (buffer.remaining() < 1) {                    break;                }                int len = buffer.get() & 0xff; // unsigned                if (buffer.remaining() < len) {                    break;                }                buffer.get(textBuffer, 0, len);                String text = new String(textBuffer, 0, len, StandardCharsets.UTF_8);                return ControlEvent.createTextControlEvent(text);            }            case ControlEvent.TYPE_MOUSE: {                if (buffer.remaining() < MOUSE_PAYLOAD_LENGTH) {                    break;                }                int action = buffer.get() & 0xff; // unsigned                int buttons = buffer.getInt();                int x = buffer.getInt();                int y = buffer.getInt();                return ControlEvent.createMotionControlEvent(action, buttons, x, y);            }            case ControlEvent.TYPE_SCROLL: {                if (buffer.remaining() < SCROLL_PAYLOAD_LENGTH) {                    break;                }                int x = buffer.getInt();                int y = buffer.getInt();                int hscroll = buffer.getInt();                int vscroll = buffer.getInt();                return ControlEvent.createScrollControlEvent(x, y, hscroll, vscroll);            }            default:                Ln.w("Unknown event type: " + type);        }        // failure, reset savedPosition        buffer.position(savedPosition);        return null;    }}
    public ControlEvent next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        switch (type) {            case ControlEvent.TYPE_KEYCODE: {                if (buffer.remaining() < KEYCODE_PAYLOAD_LENGTH) {                    break;                }                int action = buffer.get() & 0xff; // unsigned                int keycode = buffer.getInt();                int metaState = buffer.getInt();                return ControlEvent.createKeycodeControlEvent(action, keycode, metaState);            }            case ControlEvent.TYPE_TEXT: {                if (buffer.remaining() < 1) {                    break;                }                int len = buffer.get() & 0xff; // unsigned                if (buffer.remaining() < len) {                    break;                }                buffer.get(textBuffer, 0, len);                String text = new String(textBuffer, 0, len, StandardCharsets.UTF_8);                return ControlEvent.createTextControlEvent(text);            }            case ControlEvent.TYPE_MOUSE: {                if (buffer.remaining() < MOUSE_PAYLOAD_LENGTH) {                    break;                }                int action = buffer.get() & 0xff; // unsigned                int buttons = buffer.getInt();                int x = buffer.getInt();                int y = buffer.getInt();                return ControlEvent.createMotionControlEvent(action, buttons, x, y);            }            case ControlEvent.TYPE_SCROLL: {                if (buffer.remaining() < SCROLL_PAYLOAD_LENGTH) {                    break;                }                int x = buffer.getInt();                int y = buffer.getInt();                int hscroll = buffer.getInt();                int vscroll = buffer.getInt();                return ControlEvent.createScrollControlEvent(x, y, hscroll, vscroll);            }            default:                Ln.w("Unknown event type: " + type);        }        // failure, reset savedPosition        buffer.position(savedPosition);        return null;    }}
    public ControlEvent next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        switch (type) {            case ControlEvent.TYPE_KEYCODE: {                if (buffer.remaining() < KEYCODE_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                int keycode = buffer.getInt();                int metaState = buffer.getInt();                return ControlEvent.createKeycodeControlEvent(action, keycode, metaState);            }            case ControlEvent.TYPE_TEXT: {                if (buffer.remaining() < 1) {                    break;                }                int len = toUnsigned(buffer.get());                if (buffer.remaining() < len) {                    break;                }                buffer.get(textBuffer, 0, len);                String text = new String(textBuffer, 0, len, StandardCharsets.UTF_8);                return ControlEvent.createTextControlEvent(text);            }            case ControlEvent.TYPE_MOUSE: {                if (buffer.remaining() < MOUSE_PAYLOAD_LENGTH) {                    break;                }                int action = toUnsigned(buffer.get());                int buttons = buffer.getInt();                Point point = readPoint(buffer);                return ControlEvent.createMotionControlEvent(action, buttons, point);            }            case ControlEvent.TYPE_SCROLL: {                if (buffer.remaining() < SCROLL_PAYLOAD_LENGTH) {                    break;                }                Point point = readPoint(buffer);                int hscroll = buffer.getInt();                int vscroll = buffer.getInt();                return ControlEvent.createScrollControlEvent(point, hscroll, vscroll);            }            default:                Ln.w("Unknown event type: " + type);        }        // failure, reset savedPosition        buffer.position(savedPosition);        return null;    }
    private static int toUnsigned(short value) {        return value & 0xffff;    }
    private static int toUnsigned(byte value) {        return value & 0xff;    }}
    private static Point readPoint(ByteBuffer buffer) {        int x = toUnsigned(buffer.getShort());        int y = toUnsigned(buffer.getShort());        int screenWidth = toUnsigned(buffer.getShort());        int screenHeight = toUnsigned(buffer.getShort());        return new Point(x, y, screenWidth, screenHeight);    }
    }    public synchronized ScreenInfo getScreenInfo() {        if (screenInfo == null) {            screenInfo = readScreenInfo();        }        return screenInfo;    }    private ScreenInfo readScreenInfo() {        return serviceManager.getDisplayManager().getScreenInfo();    }    public static String getDeviceName() {        return Build.MODEL;    }    public InputManager getInputManager() {        return serviceManager.getInputManager();    }    public void registerRotationWatcher(IRotationWatcher rotationWatcher) {        serviceManager.getWindowManager().registerRotationWatcher(rotationWatcher);    }    public synchronized void setRotationListener(RotationListener rotationListener) {        this.rotationListener = rotationListener;    }}
    public RawPoint getPhysicalPoint(Point point) {        ScreenInfo screenInfo = getScreenInfo();        int deviceWidth = screenInfo.getLogicalWidth();        int deviceHeight = screenInfo.getLogicalHeight();        int scaledX = point.getX() * deviceWidth / point.getScreenWidth();        int scaledY = point.getY() * deviceHeight / point.getScreenHeight();        return new RawPoint(scaledX, scaledY);    }
    private boolean injectMouse(int action, int buttons, int x, int y) {        long now = SystemClock.uptimeMillis();        if (action == MotionEvent.ACTION_DOWN) {            lastMouseDown = now;        }        setPointerCoords(x, y);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, action, 1, pointerProperties, pointerCoords, 0, buttons, 1f, 1f, 0, 0, InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
    private boolean handleEvent() throws IOException {        ControlEvent controlEvent = connection.receiveControlEvent();        if (controlEvent == null) {            return false;        }        switch (controlEvent.getType()) {            case ControlEvent.TYPE_KEYCODE:                injectKeycode(controlEvent.getAction(), controlEvent.getKeycode(), controlEvent.getMetaState());                break;            case ControlEvent.TYPE_TEXT:                injectText(controlEvent.getText());                break;            case ControlEvent.TYPE_MOUSE:                injectMouse(controlEvent.getAction(), controlEvent.getButtons(), controlEvent.getX(), controlEvent.getY());                break;            case ControlEvent.TYPE_SCROLL:                injectScroll(controlEvent.getButtons(), controlEvent.getX(), controlEvent.getY(), controlEvent.getHScroll(), controlEvent.getVScroll());        }        return true;    }
    private void setPointerCoords(int x, int y) {        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.x = x;        coords.y = y;    }
    private boolean injectMouse(int action, int buttons, int x, int y) {        long now = SystemClock.uptimeMillis();        if (action == MotionEvent.ACTION_DOWN) {            lastMouseDown = now;        }        setPointerCoords(x, y);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, action, 1, pointerProperties, pointerCoords, 0, buttons, 1f, 1f, 0, 0, InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
    private boolean injectScroll(int buttons, int x, int y, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        setPointerCoords(x, y);        setScroll(hScroll, vScroll);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, MotionEvent.ACTION_SCROLL, 1, pointerProperties, pointerCoords, 0, 0, 1f, 1f, 0, 0, InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
    private void setPointerCoords(int x, int y) {        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.x = x;        coords.y = y;    }
    private boolean injectScroll(int buttons, int x, int y, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        setPointerCoords(x, y);        setScroll(hScroll, vScroll);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, MotionEvent.ACTION_SCROLL, 1, pointerProperties, pointerCoords, 0, 0, 1f, 1f, 0, 0, InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
    private boolean injectMouse(int action, int buttons, Point point) {        long now = SystemClock.uptimeMillis();        if (action == MotionEvent.ACTION_DOWN) {            lastMouseDown = now;        }        RawPoint rawPoint = Device.getInstance().getPhysicalPoint(point);        if (rawPoint == null) {            // ignore event            return false;        }
    private boolean handleEvent() throws IOException {        ControlEvent controlEvent = connection.receiveControlEvent();        if (controlEvent == null) {            return false;        }        switch (controlEvent.getType()) {            case ControlEvent.TYPE_KEYCODE:                injectKeycode(controlEvent.getAction(), controlEvent.getKeycode(), controlEvent.getMetaState());                break;            case ControlEvent.TYPE_TEXT:                injectText(controlEvent.getText());                break;            case ControlEvent.TYPE_MOUSE:                injectMouse(controlEvent.getAction(), controlEvent.getButtons(), controlEvent.getPoint());                break;            case ControlEvent.TYPE_SCROLL:                injectScroll(controlEvent.getPoint(), controlEvent.getHScroll(), controlEvent.getVScroll());        }        return true;    }
    private void setPointerCoords(RawPoint rawPoint) {        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.x = rawPoint.getX();        coords.y = rawPoint.getY();    }
    private boolean injectMouse(int action, int buttons, Point point) {        long now = SystemClock.uptimeMillis();        if (action == MotionEvent.ACTION_DOWN) {            lastMouseDown = now;        }        RawPoint rawPoint = Device.getInstance().getPhysicalPoint(point);        if (rawPoint == null) {            // ignore event            return false;        }        setPointerCoords(rawPoint);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, action, 1, pointerProperties, pointerCoords, 0, buttons, 1f, 1f, 0, 0, InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
    private boolean injectScroll(Point point, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        RawPoint rawPoint = Device.getInstance().getPhysicalPoint(point);        if (rawPoint == null) {            // ignore event            return false;        }        setPointerCoords(rawPoint);        setScroll(hScroll, vScroll);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, MotionEvent.ACTION_SCROLL, 1, pointerProperties, pointerCoords, 0, 0, 1f, 1f, 0, 0, InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }
    private void setPointerCoords(RawPoint rawPoint) {        MotionEvent.PointerCoords coords = pointerCoords[0];        coords.x = rawPoint.getX();        coords.y = rawPoint.getY();    }
        setPointerCoords(rawPoint);        MotionEvent event = MotionEvent.obtain(lastMouseDown, now, action, 1, pointerProperties, pointerCoords, 0, buttons, 1f, 1f, 0, 0, InputDevice.SOURCE_MOUSE, 0);        return injectEvent(event);    }    private boolean injectScroll(Point point, int hScroll, int vScroll) {        long now = SystemClock.uptimeMillis();        RawPoint rawPoint = Device.getInstance().getPhysicalPoint(point);
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"bit-rate",     required_argument, NULL, 'b'},        {"help",         no_argument,       NULL, 'h'},        {"max-size",     required_argument, NULL, 'm'},        {"port",         required_argument, NULL, 'p'},        {"serial",       required_argument, NULL, 's'},        {"show-touches", no_argument,       NULL, 't'},        {"version",      no_argument,       NULL, 'v'},        {NULL,           0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:hm:p:s:tv", long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = SDL_TRUE;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    return SDL_TRUE;}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .port = args.port,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"bit-rate",     required_argument, NULL, 'b'},        {"crop",         required_argument, NULL, 'c'},        {"help",         no_argument,       NULL, 'h'},        {"max-size",     required_argument, NULL, 'm'},        {"port",         required_argument, NULL, 'p'},        {"serial",       required_argument, NULL, 's'},        {"show-touches", no_argument,       NULL, 't'},        {"version",      no_argument,       NULL, 'v'},        {NULL,           0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:hm:p:s:tv", long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'c':                args->crop = optarg;                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = SDL_TRUE;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    return SDL_TRUE;}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!installer_init(&installer, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_installer;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_installer:    installer_stop(&installer);    installer_join(&installer);    installer_destroy(&installer);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!installer_init(&installer, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_installer;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_installer:    installer_stop(&installer);    installer_join(&installer);    installer_destroy(&installer);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
SDL_bool server_start(struct server *server, const char *serial, Uint16 local_port,                      Uint16 max_size, Uint32 bit_rate) {    server->local_port = local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return SDL_FALSE;        }    }    if (!push_server(serial)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    server->server_copied_to_device = SDL_TRUE;    if (!enable_tunnel(server)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no need to        // try to connect until the server socket is listening on the device.        server->server_socket = listen_on_port(local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, local_port);            disable_tunnel(server);            SDL_free((void *) server->serial);            return SDL_FALSE;        }    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate, server->tunnel_forward);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free((void *) server->serial);        return SDL_FALSE;    }    server->tunnel_enabled = SDL_TRUE;    return SDL_TRUE;}
static process_t execute_server(const char *serial,                                Uint16 max_size, Uint32 bit_rate, SDL_bool tunnel_forward) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        tunnel_forward ? "true" : "false",    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
SDL_bool server_start(struct server *server, const char *serial, Uint16 local_port,                      Uint16 max_size, Uint32 bit_rate) {    server->local_port = local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return SDL_FALSE;        }    }    if (!push_server(serial)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    server->server_copied_to_device = SDL_TRUE;    if (!enable_tunnel(server)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no need to        // try to connect until the server socket is listening on the device.        server->server_socket = listen_on_port(local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, local_port);            disable_tunnel(server);            SDL_free((void *) server->serial);            return SDL_FALSE;        }    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate, server->tunnel_forward);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free((void *) server->serial);        return SDL_FALSE;    }    server->tunnel_enabled = SDL_TRUE;    return SDL_TRUE;}
static process_t execute_server(const char *serial,                                Uint16 max_size, Uint32 bit_rate, SDL_bool tunnel_forward) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        tunnel_forward ? "true" : "false",    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
SDL_bool server_start(struct server *server, const char *serial, Uint16 local_port,                      Uint16 max_size, Uint32 bit_rate, const char *crop) {    server->local_port = local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return SDL_FALSE;        }    }    if (!push_server(serial)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    server->server_copied_to_device = SDL_TRUE;    if (!enable_tunnel(server)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no need to        // try to connect until the server socket is listening on the device.        server->server_socket = listen_on_port(local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, local_port);            disable_tunnel(server);            SDL_free((void *) server->serial);            return SDL_FALSE;        }    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate, crop,                                     server->tunnel_forward);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free((void *) server->serial);        return SDL_FALSE;    }    server->tunnel_enabled = SDL_TRUE;    return SDL_TRUE;}
static process_t execute_server(const char *serial,                                Uint16 max_size, Uint32 bit_rate,                                const char *crop, SDL_bool tunnel_forward) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        tunnel_forward ? "true" : "false",        crop ? crop : "",    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
}SDL_bool server_start(struct server *server, const char *serial, Uint16 local_port,                      Uint16 max_size, Uint32 bit_rate, const char *crop) {    server->local_port = local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return SDL_FALSE;        }    }    if (!push_server(serial)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    server->server_copied_to_device = SDL_TRUE;    if (!enable_tunnel(server)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no need to        // try to connect until the server socket is listening on the device.        server->server_socket = listen_on_port(local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, local_port);            disable_tunnel(server);            SDL_free((void *) server->serial);            return SDL_FALSE;        }    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate, crop,                                     server->tunnel_forward);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free((void *) server->serial);        return SDL_FALSE;    }    server->tunnel_enabled = SDL_TRUE;
static process_t execute_server(const char *serial,                                Uint16 max_size, Uint32 bit_rate,                                const char *crop, SDL_bool tunnel_forward) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        tunnel_forward ? "true" : "false",        crop ? crop : "",    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));
    public Point getPhysicalPoint(Position position) {        // it hides the field on purpose, to read it with a lock        @SuppressWarnings("checkstyle:HiddenField")        ScreenInfo screenInfo = getScreenInfo(); // read with synchronization        Size videoSize = screenInfo.getVideoSize();        Size clientVideoSize = position.getScreenSize();        if (!videoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event            return null;        }        Size deviceSize = screenInfo.getDeviceSize();        Point point = position.getPoint();        int scaledX = point.x * deviceSize.getWidth() / videoSize.getWidth();        int scaledY = point.y * deviceSize.getHeight() / videoSize.getHeight();        return new Point(scaledX, scaledY);    }
    private static Size computeVideoSize(Size inputSize, int maxSize) {        // Compute the video size and the padding of the content inside this video.        // Principle:        // - scale down the great side of the screen to maxSize (if necessary);        // - scale down the other side so that the aspect ratio is preserved;        // - round this value to the nearest multiple of 8 (H.264 only accepts multiples of 8)        int w = inputSize.getWidth() & ~7; // in case it's not a multiple of 8        int h = inputSize.getHeight() & ~7;        if (maxSize > 0) {            if (BuildConfig.DEBUG && maxSize % 8 != 0) {                throw new AssertionError("Max size must be a multiple of 8");            }            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;            if (major > maxSize) {                int minorExact = minor * maxSize / major;                // +4 to round the value to the nearest multiple of 8                minor = (minorExact + 4) & ~7;                major = maxSize;            }            w = portrait ? minor : major;            h = portrait ? major : minor;        }        return new Size(w, h);    }
    private static Size computeVideoSize(Size inputSize, int maxSize) {        // Compute the video size and the padding of the content inside this video.        // Principle:        // - scale down the great side of the screen to maxSize (if necessary);        // - scale down the other side so that the aspect ratio is preserved;        // - round this value to the nearest multiple of 8 (H.264 only accepts multiples of 8)        int w = inputSize.getWidth() & ~7; // in case it's not a multiple of 8        int h = inputSize.getHeight() & ~7;        if (maxSize > 0) {            if (BuildConfig.DEBUG && maxSize % 8 != 0) {                throw new AssertionError("Max size must be a multiple of 8");            }            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;            if (major > maxSize) {                int minorExact = minor * maxSize / major;                // +4 to round the value to the nearest multiple of 8                minor = (minorExact + 4) & ~7;                major = maxSize;            }            w = portrait ? minor : major;            h = portrait ? major : minor;        }        return new Size(w, h);    }
    public Device(Options options) {        screenInfo = computeScreenInfo(options.getMaxSize());        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    screenInfo = screenInfo.withRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        });    }
    private ScreenInfo computeScreenInfo(int maxSize) {        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        Size videoSize = computeVideoSize(deviceSize, maxSize);        return new ScreenInfo(deviceSize, videoSize, rotated);    }
    private ScreenInfo computeScreenInfo(int maxSize) {        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        Size videoSize = computeVideoSize(deviceSize, maxSize);        return new ScreenInfo(deviceSize, videoSize, rotated);    }
    private ScreenInfo computeScreenInfo(int maxSize) {        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        Size videoSize = computeVideoSize(deviceSize, maxSize);        return new ScreenInfo(deviceSize, videoSize, rotated);    }
    private ScreenInfo computeScreenInfo(int maxSize) {        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        Size videoSize = computeVideoSize(deviceSize, maxSize);        return new ScreenInfo(deviceSize, videoSize, rotated);    }
    public Point getPhysicalPoint(Position position) {        // it hides the field on purpose, to read it with a lock        @SuppressWarnings("checkstyle:HiddenField")        ScreenInfo screenInfo = getScreenInfo(); // read with synchronization        Size videoSize = screenInfo.getVideoSize();        Size clientVideoSize = position.getScreenSize();        if (!videoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event            return null;        }        Rect contentRect = screenInfo.getContentRect();        Point point = position.getPoint();        int scaledX = contentRect.left + point.x * contentRect.width() / videoSize.getWidth();        int scaledY = contentRect.top + point.y * contentRect.height() / videoSize.getHeight();        return new Point(scaledX, scaledY);    }
                crop = flipRect(crop);            }            if (!contentRect.intersect(crop)) {                // intersect() changes contentRect so that it is intersected with crop                Ln.w("Crop rectangle (" + formatCrop(crop) + ") does not intersect device screen (" + formatCrop(deviceSize.toRect()) + ")");                contentRect = new Rect(); // empty            }        }        Size videoSize = computeVideoSize(contentRect.width(), contentRect.height(), maxSize);        return new ScreenInfo(contentRect, videoSize, rotated);    }    private static String formatCrop(Rect rect) {        return rect.width() + ":" + rect.height() + ":" + rect.left + ":" + rect.top;    }    @SuppressWarnings("checkstyle:MagicNumber")    private static Size computeVideoSize(int w, int h, int maxSize) {        // Compute the video size and the padding of the content inside this video.        // Principle:        // - scale down the great side of the screen to maxSize (if necessary);        // - scale down the other side so that the aspect ratio is preserved;        // - round this value to the nearest multiple of 8 (H.264 only accepts multiples of 8)        w &= ~7; // in case it's not a multiple of 8        h &= ~7;        if (maxSize > 0) {
    private static Size computeVideoSize(int w, int h, int maxSize) {        // Compute the video size and the padding of the content inside this video.        // Principle:        // - scale down the great side of the screen to maxSize (if necessary);        // - scale down the other side so that the aspect ratio is preserved;        // - round this value to the nearest multiple of 8 (H.264 only accepts multiples of 8)        w &= ~7; // in case it's not a multiple of 8        h &= ~7;        if (maxSize > 0) {            if (BuildConfig.DEBUG && maxSize % 8 != 0) {                throw new AssertionError("Max size must be a multiple of 8");            }            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;            if (major > maxSize) {                int minorExact = minor * maxSize / major;                // +4 to round the value to the nearest multiple of 8                minor = (minorExact + 4) & ~7;                major = maxSize;            }            w = portrait ? minor : major;            h = portrait ? major : minor;        }        return new Size(w, h);    }
    public Device(Options options) {        screenInfo = computeScreenInfo(options.getCrop(), options.getMaxSize());        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    screenInfo = screenInfo.withRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        });    }
    private ScreenInfo computeScreenInfo(Rect crop, int maxSize) {        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        Rect contentRect = new Rect(0, 0, deviceSize.getWidth(), deviceSize.getHeight());        if (crop != null) {            if (rotated) {
    private ScreenInfo computeScreenInfo(Rect crop, int maxSize) {        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        Rect contentRect = new Rect(0, 0, deviceSize.getWidth(), deviceSize.getHeight());        if (crop != null) {            if (rotated) {                // the crop (provided by the user) is expressed in the natural orientation                crop = flipRect(crop);            }            if (!contentRect.intersect(crop)) {                // intersect() changes contentRect so that it is intersected with crop                Ln.w("Crop rectangle (" + formatCrop(crop) + ") does not intersect device screen (" + formatCrop(deviceSize.toRect()) + ")");                contentRect = new Rect(); // empty            }        }        Size videoSize = computeVideoSize(contentRect.width(), contentRect.height(), maxSize);        return new ScreenInfo(contentRect, videoSize, rotated);    }
    static Rect flipRect(Rect crop) {        return new Rect(crop.top, crop.left, crop.bottom, crop.right);    }}
    private static String formatCrop(Rect rect) {        return rect.width() + ":" + rect.height() + ":" + rect.left + ":" + rect.top;    }
    public void streamScreen(Device device, OutputStream outputStream) throws IOException {        MediaFormat format = createFormat(bitRate, frameRate, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                Rect deviceRect = device.getScreenInfo().getDeviceSize().toRect();                Rect videoRect = device.getScreenInfo().getVideoSize().toRect();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, deviceRect, videoRect);                codec.start();                try {                    alive = encode(codec, outputStream);                } finally {                    codec.stop();                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    public void streamScreen(Device device, OutputStream outputStream) throws IOException {        MediaFormat format = createFormat(bitRate, frameRate, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                Rect contentRect = device.getScreenInfo().getContentRect();                Rect videoRect = device.getScreenInfo().getVideoSize().toRect();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, contentRect, videoRect);                codec.start();                try {                    alive = encode(codec, outputStream);                } finally {                    codec.stop();                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    public ScreenInfo withRotation(int rotation) {        boolean newRotated = (rotation & 1) != 0;        if (rotated == newRotated) {            return this;        }        return new ScreenInfo(deviceSize.rotate(), videoSize.rotate(), newRotated);    }}
    public ScreenInfo(Size deviceSize, Size videoSize, boolean rotated) {        this.deviceSize = deviceSize;        this.videoSize = videoSize;        this.rotated = rotated;    }
    public Size getDeviceSize() {        return deviceSize;    }
    public ScreenInfo(Size deviceSize, Size videoSize, boolean rotated) {        this.deviceSize = deviceSize;        this.videoSize = videoSize;        this.rotated = rotated;    }
    public ScreenInfo withRotation(int rotation) {        boolean newRotated = (rotation & 1) != 0;        if (rotated == newRotated) {            return this;        }        return new ScreenInfo(Device.flipRect(contentRect), videoSize.rotate(), newRotated);    }}
    public ScreenInfo(Rect contentRect, Size videoSize, boolean rotated) {        this.contentRect = contentRect;        this.videoSize = videoSize;        this.rotated = rotated;    }
    }    public Rect getContentRect() {        return contentRect;
    private final boolean rotated;    public ScreenInfo(Rect contentRect, Size videoSize, boolean rotated) {        this.contentRect = contentRect;        this.videoSize = videoSize;        this.rotated = rotated;
        // not instantiable    }    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        boolean tunnelForward = options.isTunnelForward();
    private static Options createOptions(String... args) {        Options options = new Options();        if (args.length < 1) {            return options;        }        int maxSize = Integer.parseInt(args[0]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        if (args.length < 2) {            return options;        }        int bitRate = Integer.parseInt(args[1]);        options.setBitRate(bitRate);        if (args.length < 3) {            return options;        }        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[2]);        options.setTunnelForward(tunnelForward);        return options;    }
    private static Rect parseCrop(String crop) {        if (crop.isEmpty()) {            return null;        }        // input format: "width:height:x:y"        String[] tokens = crop.split(":");        if (tokens.length != 4) {            throw new IllegalArgumentException("Crop must contains 4 values separated by colons: \"" + crop + "\"");        }        int width = Integer.parseInt(tokens[0]);        int height = Integer.parseInt(tokens[1]);        int x = Integer.parseInt(tokens[2]);        int y = Integer.parseInt(tokens[3]);        return new Rect(x, y, x + width, y + height);    }
    private static Options createOptions(String... args) {        Options options = new Options();        if (args.length < 1) {            return options;        }        int maxSize = Integer.parseInt(args[0]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        if (args.length < 2) {            return options;        }        int bitRate = Integer.parseInt(args[1]);        options.setBitRate(bitRate);        if (args.length < 3) {            return options;        }        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[2]);        options.setTunnelForward(tunnelForward);        if (args.length < 4) {            return options;        }        Rect crop = parseCrop(args[3]);        options.setCrop(crop);        return options;    }
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!installer_init(&installer, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_installer;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_installer:    installer_stop(&installer);    installer_join(&installer);    installer_destroy(&installer);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
static void event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return;            case SDL_QUIT:                LOGD("User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                    case SDL_WINDOWEVENT_EXPOSED:                    case SDL_WINDOWEVENT_SIZE_CHANGED:                        screen_render(&screen);                        break;                }                break;            case SDL_TEXTINPUT:                input_manager_process_text_input(&input_manager, &event.text);                break;            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL:                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP:                input_manager_process_mouse_button(&input_manager, &event.button);                break;            case SDL_DROPFILE:                installer_install_apk(&installer, event.drop.file);                break;        }    }}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!installer_init(&installer, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_installer;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_installer:    installer_stop(&installer);    installer_join(&installer);    installer_destroy(&installer);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
static SDL_bool event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return SDL_FALSE;            case SDL_QUIT:                LOGD("User requested to quit");                return SDL_TRUE;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return SDL_FALSE;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                    case SDL_WINDOWEVENT_EXPOSED:                    case SDL_WINDOWEVENT_SIZE_CHANGED:                        screen_render(&screen);                        break;                }                break;            case SDL_TEXTINPUT:                input_manager_process_text_input(&input_manager, &event.text);                break;            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL:                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP:                input_manager_process_mouse_button(&input_manager, &event.button);                break;            case SDL_DROPFILE:                installer_install_apk(&installer, event.drop.file);                break;        }    }    return SDL_FALSE;}
void input_manager_process_mouse_button(struct input_manager *input_manager,                                        const SDL_MouseButtonEvent *event) {    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(input_manager->controller);            return;        }        if (event->button == SDL_BUTTON_MIDDLE) {            action_home(input_manager->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            SDL_bool outside_device_screen =                    event->x < 0 || event->x >= input_manager->screen->frame_size.width ||                    event->y < 0 || event->y >= input_manager->screen->frame_size.height;            if (outside_device_screen) {                screen_resize_to_fit(input_manager->screen);                return;            }            // otherwise, send the click event to the device        }    };    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, input_manager->screen->frame_size, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send mouse button event");        }    }}
void input_manager_process_mouse_button(struct input_manager *input_manager,                                        const SDL_MouseButtonEvent *event) {    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(input_manager->controller);            return;        }        if (event->button == SDL_BUTTON_MIDDLE) {            action_home(input_manager->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            SDL_bool outside_device_screen =                    event->x < 0 || event->x >= input_manager->screen->frame_size.width ||                    event->y < 0 || event->y >= input_manager->screen->frame_size.height;            if (outside_device_screen) {                screen_resize_to_fit(input_manager->screen);                return;            }            // otherwise, send the click event to the device        }    }    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, input_manager->screen->frame_size, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send mouse button event");        }    }}
static int read_packet(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    uint8_t header[HEADER_SIZE];    int remaining;    int ret;    remaining = decoder->remaining;    if (remaining == 0) {        // FIXME what if only part of the header is available?        ret = net_recv(decoder->video_socket, header, HEADER_SIZE);        if (ret <= 0)            return ret;        decoder->pts = from_be(header, 8);        decoder->buffer_info_flags = from_be(header + 8, 4);        remaining = from_be(header + 12, 4);    }    if (buf_size > remaining)        buf_size = remaining;    ret = net_recv(decoder->video_socket, buf, buf_size);    if (ret <= 0)        return ret;    remaining -= ret;    decoder->remaining = remaining;    return ret;}
static int read_packet(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    uint8_t header[HEADER_SIZE];    int remaining;    int ret;    remaining = decoder->remaining;    if (remaining == 0) {        // the previous PTS read is now for the current frame        decoder->pts = decoder->next_pts;        // FIXME what if only part of the header is available?        ret = net_recv(decoder->video_socket, header, HEADER_SIZE);        if (ret <= 0)            return ret;        // read the PTS for the next frame        decoder->next_pts = from_be(header, 8);        decoder->buffer_info_flags = from_be(header + 8, 4);        remaining = from_be(header + 12, 4);    }    if (buf_size > remaining)        buf_size = remaining;    ret = net_recv(decoder->video_socket, buf, buf_size);    if (ret <= 0)        return ret;    remaining -= ret;    decoder->remaining = remaining;    return ret;}
    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        if (decoder->recorder) {            packet.pts = decoder->receiver_state.pts;            packet.dts = decoder->receiver_state.pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(decoder->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto run_quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}void decoder_init(struct decoder *decoder, struct frames *frames,                  socket_t video_socket, struct recorder *recorder) {    decoder->frames = frames;    decoder->video_socket = video_socket;    decoder->recorder = recorder;}SDL_bool decoder_start(struct decoder *decoder) {    LOGD("Starting decoder thread");    decoder->thread = SDL_CreateThread(run_decoder, "video_decoder", decoder);    if (!decoder->thread) {        LOGC("Could not start decoder thread");        return SDL_FALSE;    }    return SDL_TRUE;}void decoder_stop(struct decoder *decoder) {    frames_stop(decoder->frames);}void decoder_join(struct decoder *decoder) {    SDL_WaitThread(decoder->thread, NULL);}
static int read_packet(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    struct receiver_state *state = &decoder->receiver_state;    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    if (!state->remaining) {        // the next PTS is now for the current frame        state->pts = state->next_pts;#define HEADER_SIZE 12        uint8_t header[HEADER_SIZE];        ssize_t ret = net_recv_all(decoder->video_socket, header, HEADER_SIZE);        if (ret <= 0) {            return ret;        }        // no partial read (net_recv_all())        SDL_assert_release(ret == HEADER_SIZE);        state->next_pts = buffer_read64be(header);        state->remaining = buffer_read32be(&header[8]);    }    SDL_assert(state->remaining);    if (buf_size > state->remaining)        buf_size = state->remaining;    ssize_t ret = net_recv(decoder->video_socket, buf, buf_size);    if (ret <= 0) {        return ret;    }    SDL_assert(state->remaining >= ret);    state->remaining -= ret;    return ret;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    // initialize the receiver state    decoder->receiver_state.remaining = 0;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        if (decoder->recorder) {            packet.pts = decoder->receiver_state.pts;            packet.dts = decoder->receiver_state.pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(decoder->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto run_quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    // initialize the receiver state    decoder->receiver_state.remaining = 0;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        if (decoder->recorder) {            packet.pts = decoder->receiver_state.pts;            packet.dts = decoder->receiver_state.pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(decoder->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto run_quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static int read_raw_packet(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    return net_recv(decoder->video_socket, buf, buf_size);}
static int read_packet_with_meta(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    struct receiver_state *state = &decoder->receiver_state;    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    if (!state->remaining) {        // the next PTS is now for the current frame        state->pts = state->next_pts;#define HEADER_SIZE 12        uint8_t header[HEADER_SIZE];        ssize_t ret = net_recv_all(decoder->video_socket, header, HEADER_SIZE);        if (ret <= 0) {            return ret;        }        // no partial read (net_recv_all())        SDL_assert_release(ret == HEADER_SIZE);        state->next_pts = buffer_read64be(header);        state->remaining = buffer_read32be(&header[8]);    }    SDL_assert(state->remaining);    if (buf_size > state->remaining)        buf_size = state->remaining;    ssize_t ret = net_recv(decoder->video_socket, buf, buf_size);    if (ret <= 0) {        return ret;    }    SDL_assert(state->remaining >= ret);    state->remaining -= ret;    return ret;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    // initialize the receiver state    decoder->receiver_state.remaining = 0;    // if recording is enabled, a "header" is sent between raw packets    int (*read_packet)(void *, uint8_t *, int) =            decoder->recorder ? read_packet_with_meta : read_raw_packet;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder,                                               read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        if (decoder->recorder) {            packet.pts = decoder->receiver_state.pts;            packet.dts = decoder->receiver_state.pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(decoder->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto run_quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static int read_packet_with_meta(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    struct receiver_state *state = &decoder->receiver_state;    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    if (!state->remaining) {        // the next PTS is now for the current frame        state->pts = state->next_pts;#define HEADER_SIZE 12        uint8_t header[HEADER_SIZE];        ssize_t ret = net_recv_all(decoder->video_socket, header, HEADER_SIZE);        if (ret <= 0) {            return ret;        }        // no partial read (net_recv_all())        SDL_assert_release(ret == HEADER_SIZE);        state->next_pts = buffer_read64be(header);        state->remaining = buffer_read32be(&header[8]);    }    SDL_assert(state->remaining);    if (buf_size > state->remaining)        buf_size = state->remaining;    ssize_t ret = net_recv(decoder->video_socket, buf, buf_size);    if (ret <= 0) {        return ret;    }    SDL_assert(state->remaining >= ret);    state->remaining -= ret;    return ret;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    struct recorder *rec = NULL;    if (options->record_filename) {        if (!recorder_init(&recorder, options->record_filename, frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    decoder_init(&decoder, &frames, device_socket, rec);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_recorder:    if (options->record_filename) {        recorder_destroy(&recorder);    }finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    SDL_bool send_frame_meta = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      send_frame_meta)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    struct recorder *rec = NULL;    if (options->record_filename) {        if (!recorder_init(&recorder, options->record_filename, frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    decoder_init(&decoder, &frames, device_socket, rec);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_recorder:    if (options->record_filename) {        recorder_destroy(&recorder);    }finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
static process_t execute_server(const char *serial,                                Uint16 max_size, Uint32 bit_rate,                                const char *crop, SDL_bool tunnel_forward) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        tunnel_forward ? "true" : "false",        crop ? crop : "",    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
SDL_bool server_start(struct server *server, const char *serial, Uint16 local_port,                      Uint16 max_size, Uint32 bit_rate, const char *crop) {    server->local_port = local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return SDL_FALSE;        }    }    if (!push_server(serial)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    server->server_copied_to_device = SDL_TRUE;    if (!enable_tunnel(server)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no need to        // try to connect until the server socket is listening on the device.        server->server_socket = listen_on_port(local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, local_port);            disable_tunnel(server);            SDL_free((void *) server->serial);            return SDL_FALSE;        }    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate, crop,                                     server->tunnel_forward);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free((void *) server->serial);        return SDL_FALSE;    }    server->tunnel_enabled = SDL_TRUE;    return SDL_TRUE;}
static process_t execute_server(const char *serial,                                Uint16 max_size, Uint32 bit_rate,                                const char *crop, SDL_bool tunnel_forward) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        tunnel_forward ? "true" : "false",        crop ? crop : "",    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
SDL_bool server_start(struct server *server, const char *serial, Uint16 local_port,                      Uint16 max_size, Uint32 bit_rate, const char *crop) {    server->local_port = local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return SDL_FALSE;        }    }    if (!push_server(serial)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    server->server_copied_to_device = SDL_TRUE;    if (!enable_tunnel(server)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no need to        // try to connect until the server socket is listening on the device.        server->server_socket = listen_on_port(local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, local_port);            disable_tunnel(server);            SDL_free((void *) server->serial);            return SDL_FALSE;        }    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate, crop,                                     server->tunnel_forward);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free((void *) server->serial);        return SDL_FALSE;    }    server->tunnel_enabled = SDL_TRUE;    return SDL_TRUE;}
static process_t execute_server(const char *serial,                                Uint16 max_size, Uint32 bit_rate,                                SDL_bool tunnel_forward, const char *crop,                                SDL_bool send_frame_meta) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        tunnel_forward ? "true" : "false",        crop ? crop : "''",        send_frame_meta ? "true" : "false",    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));
SDL_bool server_start(struct server *server, const char *serial,                      Uint16 local_port, Uint16 max_size, Uint32 bit_rate,                      const char *crop, SDL_bool send_frame_meta) {    server->local_port = local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return SDL_FALSE;        }    }    if (!push_server(serial)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    server->server_copied_to_device = SDL_TRUE;    if (!enable_tunnel(server)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no need to        // try to connect until the server socket is listening on the device.        server->server_socket = listen_on_port(local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, local_port);            disable_tunnel(server);            SDL_free((void *) server->serial);            return SDL_FALSE;        }    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate,                                     server->tunnel_forward, crop,                                     send_frame_meta);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free((void *) server->serial);        return SDL_FALSE;    }    server->tunnel_enabled = SDL_TRUE;    return SDL_TRUE;}
static process_t execute_server(const char *serial,                                Uint16 max_size, Uint32 bit_rate,                                SDL_bool tunnel_forward, const char *crop,                                SDL_bool send_frame_meta) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        tunnel_forward ? "true" : "false",        crop ? crop : "''",        send_frame_meta ? "true" : "false",    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
}SDL_bool server_start(struct server *server, const char *serial,                      Uint16 local_port, Uint16 max_size, Uint32 bit_rate,                      const char *crop, SDL_bool send_frame_meta) {    server->local_port = local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return SDL_FALSE;        }    }    if (!push_server(serial)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    server->server_copied_to_device = SDL_TRUE;    if (!enable_tunnel(server)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no need to        // try to connect until the server socket is listening on the device.        server->server_socket = listen_on_port(local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, local_port);            disable_tunnel(server);            SDL_free((void *) server->serial);            return SDL_FALSE;        }    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate,                                     server->tunnel_forward, crop,                                     send_frame_meta);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free((void *) server->serial);        return SDL_FALSE;    }
    private boolean encode(MediaCodec codec, FileDescriptor fd) throws IOException {        boolean eof = false;        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();        ByteBuffer bBuffer = ByteBuffer.allocate(12);        while (!consumeRotationChange() && !eof) {            int outputBufferId = codec.dequeueOutputBuffer(bufferInfo, -1);            eof = (bufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;            try {                if (consumeRotationChange()) {                    // must restart encoding with new size                    break;                }                if (outputBufferId >= 0) {                    ByteBuffer codecBuffer = codec.getOutputBuffer(outputBufferId);                    bBuffer.clear();                    long pts;                    if ((bufferInfo.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {                        pts = 0; // non-media data packet                    } else {                        if (ptsOrigin == 0) {                            ptsOrigin = bufferInfo.presentationTimeUs;                        }                        pts = bufferInfo.presentationTimeUs - ptsOrigin;                    }                    bBuffer.putLong(pts);                    bBuffer.putInt(codecBuffer.remaining());                    bBuffer.flip();                    IO.writeFully(fd, bBuffer);                    IO.writeFully(fd, codecBuffer);                }            } finally {                if (outputBufferId >= 0) {                    codec.releaseOutputBuffer(outputBufferId, false);                }            }        }        return !eof;    }
    public ScreenEncoder(int bitRate) {        this(bitRate, DEFAULT_FRAME_RATE, DEFAULT_I_FRAME_INTERVAL);    }
    public ScreenEncoder(int bitRate, int frameRate, int iFrameInterval) {        this.bitRate = bitRate;        this.frameRate = frameRate;        this.iFrameInterval = iFrameInterval;    }
    public ScreenEncoder(int bitRate, int frameRate, int iFrameInterval) {        this.bitRate = bitRate;        this.frameRate = frameRate;        this.iFrameInterval = iFrameInterval;    }
    public ScreenEncoder(int bitRate) {        this(bitRate, DEFAULT_FRAME_RATE, DEFAULT_I_FRAME_INTERVAL);    }
    public ScreenEncoder(int bitRate) {        this(bitRate, DEFAULT_FRAME_RATE, DEFAULT_I_FRAME_INTERVAL);    }
    private boolean encode(MediaCodec codec, FileDescriptor fd) throws IOException {        boolean eof = false;        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();        while (!consumeRotationChange() && !eof) {            int outputBufferId = codec.dequeueOutputBuffer(bufferInfo, -1);            eof = (bufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;            try {                if (consumeRotationChange()) {                    // must restart encoding with new size                    break;                }                if (outputBufferId >= 0) {                    ByteBuffer codecBuffer = codec.getOutputBuffer(outputBufferId);                    if (sendFrameMeta) {                        writeFrameMeta(fd, bufferInfo, codecBuffer.remaining());                    }                    IO.writeFully(fd, codecBuffer);                }            } finally {                if (outputBufferId >= 0) {                    codec.releaseOutputBuffer(outputBufferId, false);                }            }        }        return !eof;    }
        this.iFrameInterval = iFrameInterval;    }    public ScreenEncoder(boolean sendFrameMeta, int bitRate) {
    private long ptsOrigin;    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int frameRate, int iFrameInterval) {        this.sendFrameMeta = sendFrameMeta;        this.bitRate = bitRate;        this.frameRate = frameRate;
    private void writeFrameMeta(FileDescriptor fd, MediaCodec.BufferInfo bufferInfo, int packetSize) throws IOException {        headerBuffer.clear();        long pts;        if ((bufferInfo.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {            pts = 0; // non-media data packet        } else {            if (ptsOrigin == 0) {                ptsOrigin = bufferInfo.presentationTimeUs;            }            pts = bufferInfo.presentationTimeUs - ptsOrigin;        }        headerBuffer.putLong(pts);        headerBuffer.putInt(packetSize);        headerBuffer.flip();        IO.writeFully(fd, headerBuffer);    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate, int frameRate, int iFrameInterval) {        this.sendFrameMeta = sendFrameMeta;        this.bitRate = bitRate;        this.frameRate = frameRate;        this.iFrameInterval = iFrameInterval;    }
    public ScreenEncoder(boolean sendFrameMeta, int bitRate) {        this(sendFrameMeta, bitRate, DEFAULT_FRAME_RATE, DEFAULT_I_FRAME_INTERVAL);    }
    private static Options createOptions(String... args) {        Options options = new Options();        if (args.length < 1) {            return options;        }        int maxSize = Integer.parseInt(args[0]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        if (args.length < 2) {            return options;        }        int bitRate = Integer.parseInt(args[1]);        options.setBitRate(bitRate);        if (args.length < 3) {            return options;        }        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[2]);        options.setTunnelForward(tunnelForward);        if (args.length < 4) {            return options;        }        Rect crop = parseCrop(args[3]);        options.setCrop(crop);        return options;    }
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getBitRate());            // asynchronous            startEventController(device, connection);            try {                // synchronous                screenEncoder.streamScreen(device, connection.getFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    private static Options createOptions(String... args) {        Options options = new Options();        if (args.length < 1) {            return options;        }        int maxSize = Integer.parseInt(args[0]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        if (args.length < 2) {            return options;        }        int bitRate = Integer.parseInt(args[1]);        options.setBitRate(bitRate);        if (args.length < 3) {            return options;        }        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[2]);        options.setTunnelForward(tunnelForward);        if (args.length < 4) {            return options;        }        Rect crop = parseCrop(args[3]);        options.setCrop(crop);        if (args.length < 5) {            return options;        }        boolean sendFrameMeta = Boolean.parseBoolean(args[4]);        options.setSendFrameMeta(sendFrameMeta);        return options;    }
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate());            // asynchronous            startEventController(device, connection);            try {                // synchronous                screenEncoder.streamScreen(device, connection.getFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    // initialize the receiver state    decoder->receiver_state.frame_meta_queue = NULL;    decoder->receiver_state.remaining = 0;    // if recording is enabled, a "header" is sent between raw packets    int (*read_packet)(void *, uint8_t *, int) =            decoder->recorder ? read_packet_with_meta : read_raw_packet;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder,                                               read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        if (decoder->recorder) {            // we retrieve the PTS in order they were received, so they will            // be assigned to the correct frame            uint64_t pts = receiver_state_take_meta(&decoder->receiver_state);            packet.pts = pts;            packet.dts = pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(decoder->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto run_quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    // initialize the receiver state    decoder->receiver_state.frame_meta_queue = NULL;    decoder->receiver_state.remaining = 0;    // if recording is enabled, a "header" is sent between raw packets    int (*read_packet)(void *, uint8_t *, int) =            decoder->recorder ? read_packet_with_meta : read_raw_packet;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder,                                               read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        if (decoder->recorder) {            // we retrieve the PTS in order they were received, so they will            // be assigned to the correct frame            uint64_t pts = receiver_state_take_meta(&decoder->receiver_state);            packet.pts = pts;            packet.dts = pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(decoder->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto run_quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_free(avio_ctx->buffer);    av_free(avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
SDL_bool server_start(struct server *server, const char *serial, Uint16 local_port,                      Uint16 max_size, Uint32 bit_rate) {    server->local_port = local_port;    if (serial) {        server->serial = SDL_strdup(serial);    }    if (!push_server(serial)) {        return SDL_FALSE;    }    server->server_copied_to_device = SDL_TRUE;    if (!enable_tunnel(server)) {        return SDL_FALSE;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no need to        // try to connect until the server socket is listening on the device.        server->server_socket = listen_on_port(local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, local_port);            disable_tunnel(server);            return SDL_FALSE;        }    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate, server->tunnel_forward);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        return SDL_FALSE;    }    server->tunnel_enabled = SDL_TRUE;    return SDL_TRUE;}
SDL_bool server_start(struct server *server, const char *serial, Uint16 local_port,                      Uint16 max_size, Uint32 bit_rate) {    server->local_port = local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return SDL_FALSE;        }    }    if (!push_server(serial)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    server->server_copied_to_device = SDL_TRUE;    if (!enable_tunnel(server)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no need to        // try to connect until the server socket is listening on the device.        server->server_socket = listen_on_port(local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, local_port);            disable_tunnel(server);            SDL_free((void *) server->serial);            return SDL_FALSE;        }    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate, server->tunnel_forward);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free((void *) server->serial);        return SDL_FALSE;    }    server->tunnel_enabled = SDL_TRUE;    return SDL_TRUE;}
HANDLE cmd_execute(const char *path, const char *const argv[]) {    STARTUPINFO si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    // Windows command-line parsing is WTF:    // <http://daviddeley.com/autohotkey/parameters/parameters.htm#WINPASS>    // only make it work for this very specific program    // (don't handle escaping nor quotes)    char cmd[256];    size_t ret = xstrjoin(cmd, argv, ' ', sizeof(cmd));    if (ret >= sizeof(cmd)) {        LOGE("Command too long (%" PRIsizet " chars)", sizeof(cmd) - 1);        return NULL;    }    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {        return NULL;    }    return pi.hProcess;}
HANDLE cmd_execute(const char *path, const char *const argv[]) {    STARTUPINFO si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    // Windows command-line parsing is WTF:    // <http://daviddeley.com/autohotkey/parameters/parameters.htm#WINPASS>    // only make it work for this very specific program    // (don't handle escaping nor quotes)    char cmd[256];    size_t ret = xstrjoin(cmd, argv, ' ', sizeof(cmd));    if (ret >= sizeof(cmd)) {        LOGE("Command too long (%" PRIsizet " chars)", sizeof(cmd) - 1);        return NULL;    }    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi)) {        return NULL;    }    return pi.hProcess;}
socket_t server_connect_to(struct server *server, Uint32 timeout_ms) {    if (!server->tunnel_forward) {        server->device_socket = net_accept(server->server_socket);    } else {        Uint32 attempts = 10;        Uint32 delay = 100; // ms        server->device_socket = connect_to_server(server->local_port, attempts, delay);    }    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    if (!server->tunnel_forward) {        // we don't need the server socket anymore        close_socket(&server->server_socket);    }    // the server is started, we can clean up the jar from the temporary folder    remove_server(server->serial); // ignore failure    server->server_copied_to_device = SDL_FALSE;    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = SDL_FALSE;    return server->device_socket;}
socket_t server_connect_to(struct server *server, Uint32 timeout_ms) {    if (!server->tunnel_forward) {        server->device_socket = net_accept(server->server_socket);    } else {        Uint32 attempts = 50;        Uint32 delay = 100; // ms        server->device_socket = connect_to_server(server->local_port, attempts, delay);    }    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    if (!server->tunnel_forward) {        // we don't need the server socket anymore        close_socket(&server->server_socket);    }    // the server is started, we can clean up the jar from the temporary folder    remove_server(server->serial); // ignore failure    server->server_copied_to_device = SDL_FALSE;    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = SDL_FALSE;    return server->device_socket;}
process_t adb_remove_path(const char *serial, const char *path) {    const char *const adb_cmd[] = {"shell", "rm", path};    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
SDL_bool process_check_success(process_t proc, const char *name) {    if (proc == PROCESS_NONE) {        LOGE("Could not execute \"%s\"", name);        return SDL_FALSE;    }
socket_t server_connect_to(struct server *server) {    if (!server->tunnel_forward) {        server->device_socket = net_accept(server->server_socket);    } else {        Uint32 attempts = 100;        Uint32 delay = 100; // ms        server->device_socket = connect_to_server(server->local_port, attempts, delay);    }    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    if (!server->tunnel_forward) {        // we don't need the server socket anymore        close_socket(&server->server_socket);    }    // the server is started, we can clean up the jar from the temporary folder    remove_server(server->serial); // ignore failure    server->server_copied_to_device = SDL_FALSE;    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = SDL_FALSE;    return server->device_socket;}
SDL_bool server_start(struct server *server, const char *serial,                      Uint16 local_port, Uint16 max_size, Uint32 bit_rate,                      const char *crop, SDL_bool send_frame_meta) {    server->local_port = local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return SDL_FALSE;        }    }    if (!push_server(serial)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    server->server_copied_to_device = SDL_TRUE;    if (!enable_tunnel(server)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no need to        // try to connect until the server socket is listening on the device.        server->server_socket = listen_on_port(local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, local_port);            disable_tunnel(server);            SDL_free((void *) server->serial);            return SDL_FALSE;        }    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate,                                     server->tunnel_forward, crop,                                     send_frame_meta);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free((void *) server->serial);        return SDL_FALSE;    }    server->tunnel_enabled = SDL_TRUE;    return SDL_TRUE;}
void server_stop(struct server *server) {    SDL_assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Cannot terminate server");    }    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->tunnel_enabled) {        // ignore failure        disable_tunnel(server);    }    if (server->server_copied_to_device) {        remove_server(server->serial); // ignore failure    }}
static SDL_bool remove_server(const char *serial) {    process_t process = adb_remove_path(serial, DEVICE_SERVER_PATH);    return process_check_success(process, "adb shell rm");}
    }    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    if (!server->tunnel_forward) {        // we don't need the server socket anymore        close_socket(&server->server_socket);    }    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = SDL_FALSE;    return server->device_socket;}void server_stop(struct server *server) {    SDL_assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Cannot terminate server");    }    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->tunnel_enabled) {
    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return SDL_FALSE;        }    }    if (!push_server(serial)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    if (!enable_tunnel(server)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no need to        // try to connect until the server socket is listening on the device.        server->server_socket = listen_on_port(local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, local_port);            disable_tunnel(server);            SDL_free((void *) server->serial);            return SDL_FALSE;        }    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate,                                     server->tunnel_forward, crop,                                     send_frame_meta);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free((void *) server->serial);        return SDL_FALSE;    }    server->tunnel_enabled = SDL_TRUE;    return SDL_TRUE;}socket_t server_connect_to(struct server *server) {    if (!server->tunnel_forward) {        server->device_socket = net_accept(server->server_socket);    } else {        Uint32 attempts = 100;        Uint32 delay = 100; // ms        server->device_socket = connect_to_server(server->local_port, attempts, delay);
        // ignore failure        disable_tunnel(server);    }}void server_destroy(struct server *server) {    if (server->server_socket != INVALID_SOCKET) {        close_socket(&server->server_socket);    }    if (server->device_socket != INVALID_SOCKET) {        close_socket(&server->device_socket);    }    SDL_free((void *) server->serial);}
static SDL_bool enable_tunnel_reverse(const char *serial, Uint16 local_port) {    process_t process = adb_reverse(serial, SOCKET_NAME, local_port);    return process_check_success(process, "adb reverse");}
                try {                    new EventController(device, connection).control();                } catch (IOException e) {                    // this is expected on close                    Ln.d("Event controller stopped");
    public static void main(String... args) throws Exception {        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {            @Override            public void uncaughtException(Thread t, Throwable e) {                Ln.e("Exception on thread " + t, e);            }        });        Options options = createOptions(args);        scrcpy(options);    }}
    private static void unlinkSelf() {        try {            new File(SERVER_PATH).delete();        } catch (Exception e) {            Ln.e("Cannot unlink server", e);        }    }
    public static void main(String... args) throws Exception {        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {            @Override            public void uncaughtException(Thread t, Throwable e) {                Ln.e("Exception on thread " + t, e);            }        });        unlinkSelf();        Options options = createOptions(args);        scrcpy(options);    }}
    public void testParseMouseEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_KEYCODE);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_KEYCODE, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());    }
    public void testParseMouseEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_MOUSE_EVENT);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(100);        dos.writeInt(200);        dos.writeShort(1080);        dos.writeShort(1920);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_MOUSE_EVENT, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getButtons());        Assert.assertEquals(100, event.getPosition().getPoint().getX());        Assert.assertEquals(200, event.getPosition().getPoint().getY());        Assert.assertEquals(1080, event.getPosition().getScreenSize().getWidth());        Assert.assertEquals(1920, event.getPosition().getScreenSize().getHeight());    }
static void push_frame(struct decoder *decoder) {    struct frames *frames = decoder->frames;    mutex_lock(frames->mutex);#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then the decoder must wait for the current    // frame to be consumed    while (!frames->rendering_frame_consumed) {        cond_wait(frames->rendering_frame_consumed_cond, frames->mutex);    }#else    if (!frames->rendering_frame_consumed) {        SDL_LogInfo(SDL_LOG_CATEGORY_RENDER, "Skip frame");    }#endif    frames_swap(frames);    frames->rendering_frame_consumed = SDL_FALSE;    mutex_unlock(frames->mutex);    static SDL_Event new_frame_event = {        .type = EVENT_NEW_FRAME,    };    SDL_PushEvent(&new_frame_event);}
static void push_frame(struct decoder *decoder) {    SDL_bool previous_frame_consumed = frames_offer_decoded_frame(decoder->frames);    if (!previous_frame_consumed) {        // the previous EVENT_NEW_FRAME will consume this frame        return;    }    static SDL_Event new_frame_event = {        .type = EVENT_NEW_FRAME,    };    SDL_PushEvent(&new_frame_event);}
        goto error_2;    }#endif    frames->rendering_frame_consumed = SDL_TRUE;    return SDL_TRUE;error_2:    av_frame_free(&frames->rendering_frame);error_1:    av_frame_free(&frames->decoding_frame);error_0:    return SDL_FALSE;}void frames_destroy(struct frames *frames) {#ifndef SKIP_FRAMES    SDL_DestroyCond(frames->rendering_frame_consumed_cond);#endif    SDL_DestroyMutex(frames->mutex);    av_frame_free(&frames->rendering_frame);    av_frame_free(&frames->decoding_frame);}
SDL_bool frames_init(struct frames *frames) {    if (!(frames->decoding_frame = av_frame_alloc())) {        goto error_0;    }    if (!(frames->rendering_frame = av_frame_alloc())) {        goto error_1;    }    if (!(frames->mutex = SDL_CreateMutex())) {        goto error_2;    }#ifndef SKIP_FRAMES    if (!(frames->rendering_frame_consumed_cond = SDL_CreateCond())) {        SDL_DestroyMutex(frames->mutex);        goto error_2;    }#endif    frames->rendering_frame_consumed = SDL_TRUE;    return SDL_TRUE;error_2:    av_frame_free(&frames->rendering_frame);error_1:    av_frame_free(&frames->decoding_frame);error_0:    return SDL_FALSE;}
void frames_swap(struct frames *frames) {    AVFrame *tmp = frames->decoding_frame;    frames->decoding_frame = frames->rendering_frame;    frames->rendering_frame = tmp;}
void frames_swap(struct frames *frames) {    AVFrame *tmp = frames->decoding_frame;    frames->decoding_frame = frames->rendering_frame;    frames->rendering_frame = tmp;}
const AVFrame *frames_consume_rendered_frame(struct frames *frames) {    SDL_assert(!frames->rendering_frame_consumed);    frames->rendering_frame_consumed = SDL_TRUE;#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then notify the decoder the current frame is    // consumed, so that it may push a new one    cond_signal(frames->rendering_frame_consumed_cond);#endif    return frames->rendering_frame;}
SDL_bool frames_init(struct frames *frames) {    if (!(frames->decoding_frame = av_frame_alloc())) {        goto error_0;    }    if (!(frames->rendering_frame = av_frame_alloc())) {        goto error_1;    }    if (!(frames->mutex = SDL_CreateMutex())) {        goto error_2;    }#ifndef SKIP_FRAMES    if (!(frames->rendering_frame_consumed_cond = SDL_CreateCond())) {        SDL_DestroyMutex(frames->mutex);        goto error_2;    }#endif    // there is initially no rendering frame, so consider it has already been    // consumed    frames->rendering_frame_consumed = SDL_TRUE;    return SDL_TRUE;error_2:    av_frame_free(&frames->rendering_frame);error_1:    av_frame_free(&frames->decoding_frame);error_0:    return SDL_FALSE;}
static void frames_swap(struct frames *frames) {    AVFrame *tmp = frames->decoding_frame;    frames->decoding_frame = frames->rendering_frame;    frames->rendering_frame = tmp;}
SDL_bool frames_offer_decoded_frame(struct frames *frames) {    mutex_lock(frames->mutex);    SDL_bool previous_frame_consumed;#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then the decoder must wait for the current    // frame to be consumed    while (!frames->rendering_frame_consumed) {        cond_wait(frames->rendering_frame_consumed_cond, frames->mutex);    }    // by definition, we are not skipping the frames    previous_frame_consumed = SDL_TRUE;#else    previous_frame_consumed = frames->rendering_frame_consumed;    if (!previous_frame_consumed) {        SDL_LogDebug(SDL_LOG_CATEGORY_RENDER, "Skip frame");    }#endif    frames_swap(frames);    frames->rendering_frame_consumed = SDL_FALSE;    mutex_unlock(frames->mutex);    return previous_frame_consumed;}
static SDL_bool handle_new_frame(void) {    mutex_lock(frames.mutex);    AVFrame *frame = frames.rendering_frame;    frames.rendering_frame_consumed = SDL_TRUE;#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then notify the decoder the current frame is    // consumed, so that it may push a new one    cond_signal(frames.rendering_frame_consumed_cond);#endif    if (!screen_update(&screen, frame)){        mutex_unlock(frames.mutex);        return SDL_FALSE;    }    mutex_unlock(frames.mutex);    screen_render(&screen);    return SDL_TRUE;}
static SDL_bool handle_new_frame(void) {    mutex_lock(frames.mutex);    const AVFrame *frame = frames_consume_rendered_frame(&frames);    if (!screen_update(&screen, frame)){        mutex_unlock(frames.mutex);        return SDL_FALSE;    }    mutex_unlock(frames.mutex);    screen_render(&screen);    return SDL_TRUE;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    SDL_bool ret = SDL_TRUE;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, max_size, bit_rate);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable mouse focus clickthrough");    }    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_Surface *icon = IMG_ReadXPMFromArray(icon_xpm);    if (!icon) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not load icon: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_SetWindowIcon(window, icon);    SDL_FreeSurface(icon);    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    SDL_bool ret = SDL_TRUE;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, max_size, bit_rate);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }#if SDL_VERSION_ATLEAST(2, 0, 5)    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable mouse focus clickthrough");    }#endif    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_Surface *icon = IMG_ReadXPMFromArray(icon_xpm);    if (!icon) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not load icon: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_SetWindowIcon(window, icon);    SDL_FreeSurface(icon);    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
static long timestamp_ms() {    struct timeval tv;    gettimeofday(&tv, NULL);    return tv.tv_sec * 1000 + tv.tv_usec / 1000;}
static long timestamp_ms() {    struct timeval tv;    gettimeofday(&tv, NULL);    return tv.tv_sec * 1000 + tv.tv_usec / 1000;}
static long timestamp_ms(void) {    struct timeval tv;    gettimeofday(&tv, NULL);    return tv.tv_sec * 1000 + tv.tv_usec / 1000;}
static long timestamp_ms(void) {    struct timeval tv;    gettimeofday(&tv, NULL);    return tv.tv_sec * 1000 + tv.tv_usec / 1000;}
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            buffer_write32be(&buf[2], event->keycode_event.keycode);            buffer_write32be(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (1 byte) + date (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > TEXT_MAX_LENGTH) {                // injecting a text takes time, so limit the text length                len = TEXT_MAX_LENGTH;            }            buffer_write16be(&buf[1], (Uint16) len);            memcpy(&buf[3], event->text_event.text, len);            return 3 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            buffer_write32be(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 18;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            buffer_write32be(&buf[13], (Uint32) event->scroll_event.hscroll);            buffer_write32be(&buf[17], (Uint32) event->scroll_event.vscroll);            return 21;        case CONTROL_EVENT_TYPE_COMMAND:            buf[1] = event->command_event.action;            return 2;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            buffer_write32be(&buf[2], event->keycode_event.keycode);            buffer_write32be(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (2 bytes) + string (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > TEXT_MAX_LENGTH) {                // injecting a text takes time, so limit the text length                len = TEXT_MAX_LENGTH;            }            buffer_write16be(&buf[1], (Uint16) len);            memcpy(&buf[3], event->text_event.text, len);            return 3 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            buffer_write32be(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 18;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            buffer_write32be(&buf[13], (Uint32) event->scroll_event.hscroll);            buffer_write32be(&buf[17], (Uint32) event->scroll_event.vscroll);            return 21;        case CONTROL_EVENT_TYPE_COMMAND:            buf[1] = event->command_event.action;            return 2;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
socket_t net_listen(Uint32 addr, Uint16 port, int backlog) {    socket_t sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        perror("socket");        return INVALID_SOCKET;    }    SOCKADDR_IN sin;    sin.sin_family = AF_INET;    sin.sin_addr.s_addr = htonl(addr); // htonl() harmless on INADDR_ANY    sin.sin_port = htons(port);    if (bind(sock, (SOCKADDR *) &sin, sizeof(sin)) == SOCKET_ERROR) {        perror("bind");        return INVALID_SOCKET;    }    if (listen(sock, backlog) == SOCKET_ERROR) {        perror("listen");        return INVALID_SOCKET;    }    return sock;}
socket_t net_listen(Uint32 addr, Uint16 port, int backlog) {    socket_t sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        perror("socket");        return INVALID_SOCKET;    }    int reuse = 1;    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (const void *) &reuse, sizeof(reuse)) == -1) {        perror("setsockopt(SO_REUSEADDR)");    }    SOCKADDR_IN sin;    sin.sin_family = AF_INET;    sin.sin_addr.s_addr = htonl(addr); // htonl() harmless on INADDR_ANY    sin.sin_port = htons(port);    if (bind(sock, (SOCKADDR *) &sin, sizeof(sin)) == SOCKET_ERROR) {        perror("bind");        return INVALID_SOCKET;    }    if (listen(sock, backlog) == SOCKET_ERROR) {        perror("listen");        return INVALID_SOCKET;    }    return sock;}
    private boolean injectText(String text) {        for (char c : text.toCharArray()) {            if (!injectChar(c)) {                return false;            }        }        return true;    }
    private int injectText(String text) {        int successCount = 0;        for (char c : text.toCharArray()) {            if (!injectChar(c)) {                continue;            }            successCount++;        }        return successCount;    }
void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");                return;            case SDL_QUIT:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!handle_new_frame()) {                    return;                }                texture_empty = SDL_FALSE;                count_frame(); // display fps for debug                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    render(renderer, texture_empty ? NULL : texture);                    break;                }                break;            case SDL_TEXTINPUT: {                handle_text_input(&event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                handle_key(&event.key);                break;            case SDL_MOUSEMOTION:                handle_mouse_motion(&event.motion, frame_size);                break;            case SDL_MOUSEWHEEL: {                struct position position = {                    .screen_size = frame_size,                    .point = get_mouse_point(),                };                handle_mouse_wheel(&event.wheel, position);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                handle_mouse_button(&event.button, frame_size);                break;            }        }    }}
SDL_bool read_initial_device_info(TCPsocket socket, char *device_name, struct size *size) {    unsigned char buf[DEVICE_NAME_FIELD_LENGTH + 4];    if (SDLNet_TCP_Recv(socket, buf, sizeof(buf)) <= 0) {        return SDL_FALSE;    }    buf[DEVICE_NAME_FIELD_LENGTH - 1] = '\0'; // in case the client sends garbage    // scrcpy is safe here, since name contains at least DEVICE_NAME_FIELD_LENGTH bytes    // and strlen(buf) < DEVICE_NAME_FIELD_LENGTH    strcpy(device_name, (char *) buf);    size->width = (buf[DEVICE_NAME_FIELD_LENGTH] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 1];    size->height = (buf[DEVICE_NAME_FIELD_LENGTH + 2] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 3];    return SDL_TRUE;}
static void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");                return;            case SDL_QUIT:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!handle_new_frame()) {                    return;                }                texture_empty = SDL_FALSE;                count_frame(); // display fps for debug                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    render(renderer, texture_empty ? NULL : texture);                    break;                }                break;            case SDL_TEXTINPUT: {                handle_text_input(&event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                handle_key(&event.key);                break;            case SDL_MOUSEMOTION:                handle_mouse_motion(&event.motion, frame_size);                break;            case SDL_MOUSEWHEEL: {                struct position position = {                    .screen_size = frame_size,                    .point = get_mouse_point(),                };                handle_mouse_wheel(&event.wheel, position);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                handle_mouse_button(&event.button, frame_size);                break;            }        }    }}
static SDL_bool read_initial_device_info(TCPsocket socket, char *device_name, struct size *size) {    unsigned char buf[DEVICE_NAME_FIELD_LENGTH + 4];    if (SDLNet_TCP_Recv(socket, buf, sizeof(buf)) <= 0) {        return SDL_FALSE;    }    buf[DEVICE_NAME_FIELD_LENGTH - 1] = '\0'; // in case the client sends garbage    // scrcpy is safe here, since name contains at least DEVICE_NAME_FIELD_LENGTH bytes    // and strlen(buf) < DEVICE_NAME_FIELD_LENGTH    strcpy(device_name, (char *) buf);    size->width = (buf[DEVICE_NAME_FIELD_LENGTH] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 1];    size->height = (buf[DEVICE_NAME_FIELD_LENGTH + 2] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 3];    return SDL_TRUE;}
SDL_bool installer_init(struct installer *installer, const char *serial) {    if (!apk_queue_init(&installer->queue)) {        return SDL_FALSE;    }    if (!(installer->mutex = SDL_CreateMutex())) {        return SDL_FALSE;    }    if (!(installer->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(installer->mutex);        return SDL_FALSE;    }    if (serial) {        installer->serial = SDL_strdup(serial);        if (!installer->serial) {            LOGW("Cannot strdup serial");            return SDL_FALSE;        }    } else {        installer->serial = NULL;    }    // lazy initialization    installer->initialized = SDL_FALSE;    installer->stopped = SDL_FALSE;    installer->current_process = PROCESS_NONE;    return SDL_TRUE;}
SDL_bool installer_init(struct installer *installer, const char *serial) {    if (!apk_queue_init(&installer->queue)) {        return SDL_FALSE;    }    if (!(installer->mutex = SDL_CreateMutex())) {        return SDL_FALSE;    }    if (!(installer->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(installer->mutex);        return SDL_FALSE;    }    if (serial) {        installer->serial = SDL_strdup(serial);        if (!installer->serial) {            LOGW("Cannot strdup serial");            SDL_DestroyMutex(installer->mutex);            return SDL_FALSE;        }    } else {        installer->serial = NULL;    }    // lazy initialization    installer->initialized = SDL_FALSE;    installer->stopped = SDL_FALSE;    installer->current_process = PROCESS_NONE;    return SDL_TRUE;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    Ctrl+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+c\n"        "        copy device clipboard to computer\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    Ctrl+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+c\n"        "        copy device clipboard to computer\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
show_adb_err_msg(enum process_result err) {    switch (err) {        case PROCESS_ERROR_GENERIC:            LOGE("Failed to execute adb");            break;        case PROCESS_ERROR_MISSING_BINARY:            LOGE("'adb' command not found (make it accessible from your PATH "                  "or define its full path in the ADB environment variable)");            break;        case PROCESS_SUCCESS:            /* do nothing */            break;    }}
show_adb_err_msg(enum process_result err) {    switch (err) {        case PROCESS_ERROR_GENERIC:            LOGE("Failed to execute adb");            break;        case PROCESS_ERROR_MISSING_BINARY:            LOGE("'adb' command not found (make it accessible from your PATH "                  "or define its full path in the ADB environment variable)");            break;        case PROCESS_SUCCESS:            /* do nothing */            break;    }}
adb_execute(const char *serial, const char *const adb_cmd[], size_t len) {    const char *cmd[len + 4];    int i;    process_t process;    cmd[0] = get_adb_command();    if (serial) {        cmd[1] = "-s";        cmd[2] = serial;        i = 3;    } else {        i = 1;    }    memcpy(&cmd[i], adb_cmd, len * sizeof(const char *));    cmd[len + i] = NULL;    enum process_result r = cmd_execute(cmd[0], cmd, &process);    if (r != PROCESS_SUCCESS) {        show_adb_err_msg(r);        return PROCESS_NONE;    }    return process;}
adb_execute(const char *serial, const char *const adb_cmd[], size_t len) {    const char *cmd[len + 4];    int i;    process_t process;    cmd[0] = get_adb_command();    if (serial) {        cmd[1] = "-s";        cmd[2] = serial;        i = 3;    } else {        i = 1;    }    memcpy(&cmd[i], adb_cmd, len * sizeof(const char *));    cmd[len + i] = NULL;    enum process_result r = cmd_execute(cmd[0], cmd, &process);    if (r != PROCESS_SUCCESS) {        show_adb_err_msg(r);        return PROCESS_NONE;    }    return process;}
show_adb_err_msg(enum process_result err, const char *const argv[]) {    char buf[512];    switch (err) {        case PROCESS_ERROR_GENERIC:            argv_to_string(argv, buf, sizeof(buf));            LOGE("Failed to execute: %s", buf);            break;        case PROCESS_ERROR_MISSING_BINARY:            argv_to_string(argv, buf, sizeof(buf));            LOGE("Command not found: %s", buf);            LOGE("(make 'adb' accessible from your PATH or define its full"                 "path in the ADB environment variable)");            break;        case PROCESS_SUCCESS:            /* do nothing */            break;    }}
// serialize argv to string "[arg1], [arg2], [arg3]"static size_targv_to_string(const char *const *argv, char *buf, size_t bufsize) {    size_t idx = 0;    bool first = true;    while (*argv) {        const char *arg = *argv;        size_t len = strlen(arg);        // count space for "[], ...\0"        if (idx + len + 8 >= bufsize) {            // not enough space, truncate            assert(idx < bufsize - 4);            memcpy(&buf[idx], "...", 3);            idx += 3;            break;
adb_execute(const char *serial, const char *const adb_cmd[], size_t len) {    const char *cmd[len + 4];    int i;    process_t process;    cmd[0] = get_adb_command();    if (serial) {        cmd[1] = "-s";        cmd[2] = serial;        i = 3;    } else {        i = 1;    }    memcpy(&cmd[i], adb_cmd, len * sizeof(const char *));    cmd[len + i] = NULL;    enum process_result r = cmd_execute(cmd[0], cmd, &process);    if (r != PROCESS_SUCCESS) {        show_adb_err_msg(r, cmd);        return PROCESS_NONE;    }    return process;}
argv_to_string(const char *const *argv, char *buf, size_t bufsize) {    size_t idx = 0;    bool first = true;    while (*argv) {        const char *arg = *argv;        size_t len = strlen(arg);        // count space for "[], ...\0"        if (idx + len + 8 >= bufsize) {            // not enough space, truncate            assert(idx < bufsize - 4);            memcpy(&buf[idx], "...", 3);            idx += 3;            break;        }        if (first) {            first = false;        } else {            buf[idx++] = ',';            buf[idx++] = ' ';        }        buf[idx++] = '[';        memcpy(&buf[idx], arg, len);        idx += len;        buf[idx++] = ']';        argv++;    }    assert(idx < bufsize);    buf[idx] = '\0';    return idx;}
static int parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"help",     no_argument,       NULL, 'h'},        {"port",     required_argument, NULL, 'p'},        {"max-size", required_argument, NULL, 'm'},        {"bit-rate", required_argument, NULL, 'b'},        {"version",  no_argument,       NULL, 'v'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "hvp:m:b:", long_options, NULL)) != -1) {        switch (c) {            case 'h': {                args->help = SDL_TRUE;                break;            }            case 'v': {                args->version = SDL_TRUE;                break;            }            case 'p': {                char *endptr;                if (*optarg == '\0') {                    LOGE("Invalid port parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                if (*endptr != '\0') {                    LOGE("Invalid port: %s", optarg);                    return -1;                }                if (value & ~0xffff) {                    LOGE("Port out of range: %ld", value);                    return -1;                }                args->port = (Uint16) value;                break;            }            case 'm': {                char *endptr;                if (*optarg == '\0') {                    LOGE("Max size parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                if (*endptr != '\0') {                    LOGE("Invalid max size: %s", optarg);                    return -1;                }                if (value & ~0xffff) {                    LOGE("Max size must be between 0 and 65535: %ld", value);                    return -1;                }                args->max_size = (Uint16) value;                break;            }            case 'b': {                char *endptr;                if (*optarg == '\0') {                    LOGE("Bit-rate parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                int mul = 1;                if (*endptr != '\0') {                    if (optarg == endptr) {                        LOGE("Invalid bit-rate: %s", optarg);                        return -1;                    }                    if ((*endptr == 'M' || *endptr == 'm') && endptr[1] == '\0') {                        mul = 1000000;                    } else if ((*endptr == 'K' || *endptr == 'k') && endptr[1] == '\0') {                        mul = 1000;                    } else {                        LOGE("Invalid bit-rate unit: %s", optarg);                        return -1;                    }                }                if (value < 0 || ((Uint32) -1) / mul < value) {                    LOGE("Bitrate must be positive and less than 2^32: %s", optarg);                    return -1;                }                args->bit_rate = (Uint32) value * mul;                break;            }            default:                // getopt prints the error message on stderr                return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return -1;    }    return 0;}
static int parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"bit-rate", required_argument, NULL, 'b'},        {"help",     no_argument,       NULL, 'h'},        {"max-size", required_argument, NULL, 'm'},        {"port",     required_argument, NULL, 'p'},        {"version",  no_argument,       NULL, 'v'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:hm:p:v", long_options, NULL)) != -1) {        switch (c) {            case 'b': {                char *endptr;                if (*optarg == '\0') {                    LOGE("Bit-rate parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                int mul = 1;                if (*endptr != '\0') {                    if (optarg == endptr) {                        LOGE("Invalid bit-rate: %s", optarg);                        return -1;                    }                    if ((*endptr == 'M' || *endptr == 'm') && endptr[1] == '\0') {                        mul = 1000000;                    } else if ((*endptr == 'K' || *endptr == 'k') && endptr[1] == '\0') {                        mul = 1000;                    } else {                        LOGE("Invalid bit-rate unit: %s", optarg);                        return -1;                    }                }                if (value < 0 || ((Uint32) -1) / mul < value) {                    LOGE("Bitrate must be positive and less than 2^32: %s", optarg);                    return -1;                }                args->bit_rate = (Uint32) value * mul;                break;            }            case 'h': {                args->help = SDL_TRUE;                break;            }            case 'm': {                char *endptr;                if (*optarg == '\0') {                    LOGE("Max size parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                if (*endptr != '\0') {                    LOGE("Invalid max size: %s", optarg);                    return -1;                }                if (value & ~0xffff) {                    LOGE("Max size must be between 0 and 65535: %ld", value);                    return -1;                }                args->max_size = (Uint16) value;                break;            }            case 'p': {                char *endptr;                if (*optarg == '\0') {                    LOGE("Invalid port parameter is empty");                    return -1;                }                long value = strtol(optarg, &endptr, 0);                if (*endptr != '\0') {                    LOGE("Invalid port: %s", optarg);                    return -1;                }                if (value & ~0xffff) {                    LOGE("Port out of range: %ld", value);                    return -1;                }                args->port = (Uint16) value;                break;            }            case 'v': {                args->version = SDL_TRUE;                break;            }            default:                // getopt prints the error message on stderr                return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return -1;    }    return 0;}
static void usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (only supported on\n"        "        devices with Android >= 10).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (only supported on\n"        "        devices with Android >= 10).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the --record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
SDL_bool controller_init(struct controller *controller, TCPsocket video_socket) {    if (!control_event_queue_init(&controller->queue)) {        return SDL_FALSE;    }    if (!(controller->mutex = SDL_CreateMutex())) {        return SDL_FALSE;    }    if (!(controller->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(controller->mutex);        return SDL_FALSE;    }    controller->video_socket = video_socket;    controller->stopped = SDL_FALSE;    return SDL_TRUE;}
static SDL_bool process_event(struct controller *controller, const struct control_event *event) {    unsigned char serialized_event[SERIALIZED_EVENT_MAX_SIZE];    int length = control_event_serialize(event, serialized_event);    if (!length) {        return SDL_FALSE;    }    int w = SDLNet_TCP_Send(controller->video_socket, serialized_event, length);    return w == length;}
SDL_bool controller_init(struct controller *controller, TCPsocket video_socket) {    if (!control_event_queue_init(&controller->queue)) {        return SDL_FALSE;    }    if (!(controller->mutex = SDL_CreateMutex())) {        return SDL_FALSE;    }    if (!(controller->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(controller->mutex);        return SDL_FALSE;    }    controller->video_socket = video_socket;    controller->stopped = SDL_FALSE;    return SDL_TRUE;}
SDL_bool controller_init(struct controller *controller, socket_t video_socket) {    if (!control_event_queue_init(&controller->queue)) {        return SDL_FALSE;    }    if (!(controller->mutex = SDL_CreateMutex())) {        return SDL_FALSE;    }    if (!(controller->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(controller->mutex);        return SDL_FALSE;    }    controller->video_socket = video_socket;    controller->stopped = SDL_FALSE;    return SDL_TRUE;}
static SDL_bool process_event(struct controller *controller, const struct control_event *event) {    unsigned char serialized_event[SERIALIZED_EVENT_MAX_SIZE];    int length = control_event_serialize(event, serialized_event);    if (!length) {        return SDL_FALSE;    }    int w = net_send(controller->video_socket, serialized_event, length);    return w == length;}
SDL_bool controller_init(struct controller *controller, socket_t video_socket) {    if (!control_event_queue_init(&controller->queue)) {        return SDL_FALSE;    }    if (!(controller->mutex = SDL_CreateMutex())) {        return SDL_FALSE;    }    if (!(controller->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(controller->mutex);        return SDL_FALSE;    }    controller->video_socket = video_socket;    controller->stopped = SDL_FALSE;    return SDL_TRUE;}
void decoder_init(struct decoder *decoder, struct frames *frames, TCPsocket video_socket) {    decoder->frames = frames;    decoder->video_socket = video_socket;}
void decoder_init(struct decoder *decoder, struct frames *frames, TCPsocket video_socket) {    decoder->frames = frames;    decoder->video_socket = video_socket;}
static int read_packet(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    return SDLNet_TCP_Recv(decoder->video_socket, buf, buf_size);}
void decoder_init(struct decoder *decoder, struct frames *frames, socket_t video_socket) {    decoder->frames = frames;    decoder->video_socket = video_socket;}
    decoder->frames = frames;    decoder->video_socket = video_socket;}SDL_bool decoder_start(struct decoder *decoder) {
static int read_packet(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    return net_recv(decoder->video_socket, buf, buf_size);}
SDL_bool device_read_info(TCPsocket device_socket, char *device_name, struct size *size) {    unsigned char buf[DEVICE_NAME_FIELD_LENGTH + 4];    if (SDLNet_TCP_Recv(device_socket, buf, sizeof(buf)) <= 0) {        LOGE("Could not retrieve device information");        return SDL_FALSE;    }    buf[DEVICE_NAME_FIELD_LENGTH - 1] = '\0'; // in case the client sends garbage    // strcpy is safe here, since name contains at least DEVICE_NAME_FIELD_LENGTH bytes    // and strlen(buf) < DEVICE_NAME_FIELD_LENGTH    strcpy(device_name, (char *) buf);    size->width = (buf[DEVICE_NAME_FIELD_LENGTH] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 1];    size->height = (buf[DEVICE_NAME_FIELD_LENGTH + 2] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 3];    return SDL_TRUE;}
SDL_bool device_read_info(TCPsocket device_socket, char *device_name, struct size *size) {    unsigned char buf[DEVICE_NAME_FIELD_LENGTH + 4];    if (SDLNet_TCP_Recv(device_socket, buf, sizeof(buf)) <= 0) {        LOGE("Could not retrieve device information");        return SDL_FALSE;    }    buf[DEVICE_NAME_FIELD_LENGTH - 1] = '\0'; // in case the client sends garbage    // strcpy is safe here, since name contains at least DEVICE_NAME_FIELD_LENGTH bytes    // and strlen(buf) < DEVICE_NAME_FIELD_LENGTH    strcpy(device_name, (char *) buf);    size->width = (buf[DEVICE_NAME_FIELD_LENGTH] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 1];    size->height = (buf[DEVICE_NAME_FIELD_LENGTH + 2] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 3];    return SDL_TRUE;}
SDL_bool device_read_info(socket_t device_socket, char *device_name, struct size *size) {    unsigned char buf[DEVICE_NAME_FIELD_LENGTH + 4];    if (net_recv(device_socket, buf, sizeof(buf)) <= 0) {        LOGE("Could not retrieve device information");        return SDL_FALSE;    }    buf[DEVICE_NAME_FIELD_LENGTH - 1] = '\0'; // in case the client sends garbage    // strcpy is safe here, since name contains at least DEVICE_NAME_FIELD_LENGTH bytes    // and strlen(buf) < DEVICE_NAME_FIELD_LENGTH    strcpy(device_name, (char *) buf);    size->width = (buf[DEVICE_NAME_FIELD_LENGTH] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 1];    size->height = (buf[DEVICE_NAME_FIELD_LENGTH + 2] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 3];    return SDL_TRUE;}
SDL_bool device_read_info(socket_t device_socket, char *device_name, struct size *size) {    unsigned char buf[DEVICE_NAME_FIELD_LENGTH + 4];    if (net_recv(device_socket, buf, sizeof(buf)) <= 0) {        LOGE("Could not retrieve device information");        return SDL_FALSE;    }    buf[DEVICE_NAME_FIELD_LENGTH - 1] = '\0'; // in case the client sends garbage    // strcpy is safe here, since name contains at least DEVICE_NAME_FIELD_LENGTH bytes    // and strlen(buf) < DEVICE_NAME_FIELD_LENGTH    strcpy(device_name, (char *) buf);    size->width = (buf[DEVICE_NAME_FIELD_LENGTH] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 1];    size->height = (buf[DEVICE_NAME_FIELD_LENGTH + 2] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 3];    return SDL_TRUE;}
static void print_version(void) {    fprintf(stderr, "scrcpy v%s\n\n", SCRCPY_VERSION);    fprintf(stderr, "dependencies:\n");    fprintf(stderr, " - SDL %d.%d.%d\n", SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL);    fprintf(stderr, " - SDL_net %d.%d.%d\n", SDL_NET_MAJOR_VERSION, SDL_NET_MINOR_VERSION, SDL_NET_PATCHLEVEL);    fprintf(stderr, " - libavcodec %d.%d.%d\n", LIBAVCODEC_VERSION_MAJOR, LIBAVCODEC_VERSION_MINOR, LIBAVCODEC_VERSION_MICRO);    fprintf(stderr, " - libavformat %d.%d.%d\n", LIBAVFORMAT_VERSION_MAJOR, LIBAVFORMAT_VERSION_MINOR, LIBAVFORMAT_VERSION_MICRO);    fprintf(stderr, " - libavutil %d.%d.%d\n", LIBAVUTIL_VERSION_MAJOR, LIBAVUTIL_VERSION_MINOR, LIBAVUTIL_VERSION_MICRO);}
    fprintf(stderr, "scrcpy v%s\n\n", SCRCPY_VERSION);    fprintf(stderr, "dependencies:\n");    fprintf(stderr, " - SDL %d.%d.%d\n", SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL);    fprintf(stderr, " - libavcodec %d.%d.%d\n", LIBAVCODEC_VERSION_MAJOR, LIBAVCODEC_VERSION_MINOR, LIBAVCODEC_VERSION_MICRO);    fprintf(stderr, " - libavformat %d.%d.%d\n", LIBAVFORMAT_VERSION_MAJOR, LIBAVFORMAT_VERSION_MINOR, LIBAVFORMAT_VERSION_MICRO);    fprintf(stderr, " - libavutil %d.%d.%d\n", LIBAVUTIL_VERSION_MAJOR, LIBAVUTIL_VERSION_MINOR, LIBAVUTIL_VERSION_MICRO);}static SDL_bool parse_bit_rate(char *optarg, Uint32 *bit_rate) {    char *endptr;
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    // SDL initialization replace the signal handler for SIGTERM, so Ctrl+C is    // managed by the event loop. This blocking call blocks the event loop, so    // timeout the connection not to block indefinitely in case of SIGTERM.#define SERVER_CONNECT_TIMEOUT_MS 2000    TCPsocket device_socket = server_connect_to(&server, serial, SERVER_CONNECT_TIMEOUT_MS);    if (!device_socket) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server, serial);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // kill the server before decoder_join() to wake up the decoder    server_stop(&server, serial);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    // SDL initialization replace the signal handler for SIGTERM, so Ctrl+C is    // managed by the event loop. This blocking call blocks the event loop, so    // timeout the connection not to block indefinitely in case of SIGTERM.#define SERVER_CONNECT_TIMEOUT_MS 2000    socket_t device_socket = server_connect_to(&server, serial, SERVER_CONNECT_TIMEOUT_MS);    if (device_socket == INVALID_SOCKET) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server, serial);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // kill the server before decoder_join() to wake up the decoder    server_stop(&server, serial);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
static TCPsocket listen_on_port(Uint16 port) {    IPaddress addr = {        .host = INADDR_ANY,        .port = SDL_SwapBE16(port),    };    return SDLNet_TCP_Open(&addr);}
SDL_bool server_start(struct server *server, const char *serial, Uint16 local_port,                      Uint16 max_size, Uint32 bit_rate) {    if (!push_server(serial)) {        return SDL_FALSE;    }    if (!enable_tunnel(serial, local_port)) {        return SDL_FALSE;    }    // At the application level, the device part is "the server" because it    // serves video stream and control. However, at network level, the client    // listens and the server connects to the client. That way, the client can    // listen before starting the server app, so there is no need to try to    // connect until the server socket is listening on the device.    server->server_socket = listen_on_port(local_port);    if (!server->server_socket) {        LOGE("Could not listen on port %" PRIu16, local_port);        disable_tunnel(serial);        return SDL_FALSE;    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate);    if (server->process == PROCESS_NONE) {        SDLNet_TCP_Close(server->server_socket);        disable_tunnel(serial);        return SDL_FALSE;    }    server->adb_reverse_enabled = SDL_TRUE;    return SDL_TRUE;}
TCPsocket server_connect_to(struct server *server, const char *serial, Uint32 timeout_ms) {    SDL_assert(server->server_socket);    server->device_socket = server_socket_accept(server->server_socket, timeout_ms);    // we don't need the server socket anymore    SDLNet_TCP_Close(server->server_socket);    server->server_socket = NULL;    // we don't need the adb tunnel anymore    disable_tunnel(serial); // ignore failure    server->adb_reverse_enabled = SDL_FALSE;    return server->device_socket;}
void server_destroy(struct server *server) {    if (server->server_socket) {        SDLNet_TCP_Close(server->server_socket);    }    if (server->device_socket) {        SDLNet_TCP_Close(server->device_socket);    }}
static socket_t listen_on_port(Uint16 port) {#define IPV4_LOCALHOST 0x7F000001    return net_listen(IPV4_LOCALHOST, port, 1);}
SDL_bool server_start(struct server *server, const char *serial, Uint16 local_port,                      Uint16 max_size, Uint32 bit_rate) {    if (!push_server(serial)) {        return SDL_FALSE;    }    if (!enable_tunnel(serial, local_port)) {        return SDL_FALSE;    }    // At the application level, the device part is "the server" because it    // serves video stream and control. However, at network level, the client    // listens and the server connects to the client. That way, the client can    // listen before starting the server app, so there is no need to try to    // connect until the server socket is listening on the device.    server->server_socket = listen_on_port(local_port);    if (server->server_socket == INVALID_SOCKET) {        LOGE("Could not listen on port %" PRIu16, local_port);        disable_tunnel(serial);        return SDL_FALSE;    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate);    if (server->process == PROCESS_NONE) {        net_close(server->server_socket);        disable_tunnel(serial);        return SDL_FALSE;    }    server->adb_reverse_enabled = SDL_TRUE;    return SDL_TRUE;}
socket_t server_connect_to(struct server *server, const char *serial, Uint32 timeout_ms) {    server->device_socket = net_accept(server->server_socket);    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    // we don't need the server socket anymore    net_close(server->server_socket);    server->server_socket = INVALID_SOCKET;    // we don't need the adb tunnel anymore    disable_tunnel(serial); // ignore failure    server->adb_reverse_enabled = SDL_FALSE;    return server->device_socket;}
void server_destroy(struct server *server) {    if (server->server_socket != INVALID_SOCKET) {        net_close(server->server_socket);    }    if (server->device_socket != INVALID_SOCKET) {        net_close(server->device_socket);    }}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet) && !avio_ctx->eof_reached) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif    }    LOGD("End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet) && !avio_ctx->eof_reached) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        av_packet_unref(&packet);    }    LOGD("End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = show_screen(args.serial, args.port) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = show_screen(args.serial, args.port) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = show_screen(args.serial, args.port) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = show_screen(args.serial, args.port) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = show_screen(args.serial, args.port) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = show_screen(args.serial, args.port) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = show_screen(args.serial, args.port) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = show_screen(args.serial, args.port) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = show_screen(args.serial, args.port) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = show_screen(args.serial, args.port) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = show_screen(args.serial, args.port) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = show_screen(args.serial, args.port) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = show_screen(args.serial, args.port) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = show_screen(args.serial, args.port) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = show_screen(args.serial, args.port) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = show_screen(args.serial, args.port) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = show_screen(args.serial, args.port) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int parse_args(struct args *args, int argc, char *argv[]) {    int c;    while ((c = getopt(argc, argv, "p:")) != -1) {        switch (c) {        case 'p': {            char *endptr;            long int value = strtol(optarg, &endptr, 0);            if (*optarg == '\0' || *endptr != '\0') {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s\n", optarg);                return -1;            }            if (value & ~0xffff) {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld\n", value);                return -1;            }            args->port = (Uint16) value;            break;        }        default:            // getopt prints the error message on stderr            return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s\n", argv[index]);        return -1;    }    return 0;}
int parse_args(struct args *args, int argc, char *argv[]) {    int c;    while ((c = getopt(argc, argv, "p:")) != -1) {        switch (c) {        case 'p': {            char *endptr;            long int value = strtol(optarg, &endptr, 0);            if (*optarg == '\0' || *endptr != '\0') {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s\n", optarg);                return -1;            }            if (value & ~0xffff) {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld\n", value);                return -1;            }            args->port = (Uint16) value;            break;        }        default:            // getopt prints the error message on stderr            return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s\n", argv[index]);        return -1;    }    return 0;}
int parse_args(struct args *args, int argc, char *argv[]) {    int c;    while ((c = getopt(argc, argv, "p:")) != -1) {        switch (c) {        case 'p': {            char *endptr;            long int value = strtol(optarg, &endptr, 0);            if (*optarg == '\0' || *endptr != '\0') {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s\n", optarg);                return -1;            }            if (value & ~0xffff) {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld\n", value);                return -1;            }            args->port = (Uint16) value;            break;        }        default:            // getopt prints the error message on stderr            return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s\n", argv[index]);        return -1;    }    return 0;}
int parse_args(struct args *args, int argc, char *argv[]) {    int c;    while ((c = getopt(argc, argv, "p:")) != -1) {        switch (c) {        case 'p': {            char *endptr;            long int value = strtol(optarg, &endptr, 0);            if (*optarg == '\0' || *endptr != '\0') {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s\n", optarg);                return -1;            }            if (value & ~0xffff) {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld\n", value);                return -1;            }            args->port = (Uint16) value;            break;        }        default:            // getopt prints the error message on stderr            return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s\n", argv[index]);        return -1;    }    return 0;}
int parse_args(struct args *args, int argc, char *argv[]) {    int c;    while ((c = getopt(argc, argv, "p:")) != -1) {        switch (c) {        case 'p': {            char *endptr;            long int value = strtol(optarg, &endptr, 0);            if (*optarg == '\0' || *endptr != '\0') {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s\n", optarg);                return -1;            }            if (value & ~0xffff) {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld\n", value);                return -1;            }            args->port = (Uint16) value;            break;        }        default:            // getopt prints the error message on stderr            return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s\n", argv[index]);        return -1;    }    return 0;}
int parse_args(struct args *args, int argc, char *argv[]) {    int c;    while ((c = getopt(argc, argv, "p:")) != -1) {        switch (c) {        case 'p': {            char *endptr;            long int value = strtol(optarg, &endptr, 0);            if (*optarg == '\0' || *endptr != '\0') {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s\n", optarg);                return -1;            }            if (value & ~0xffff) {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld\n", value);                return -1;            }            args->port = (Uint16) value;            break;        }        default:            // getopt prints the error message on stderr            return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s\n", argv[index]);        return -1;    }    return 0;}
int parse_args(struct args *args, int argc, char *argv[]) {    int c;    while ((c = getopt(argc, argv, "p:")) != -1) {        switch (c) {        case 'p': {            char *endptr;            long int value = strtol(optarg, &endptr, 0);            if (*optarg == '\0' || *endptr != '\0') {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s\n", optarg);                return -1;            }            if (value & ~0xffff) {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld\n", value);                return -1;            }            args->port = (Uint16) value;            break;        }        default:            // getopt prints the error message on stderr            return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s\n", argv[index]);        return -1;    }    return 0;}
        ts = now;        nbframes = 0;    }}static TCPsocket listen_on_port(Uint16 port) {    IPaddress addr = {        .host = INADDR_ANY,        .port = SDL_SwapBE16(port),    };    return SDLNet_TCP_Open(&addr);}// name must be at least DEVICE_NAME_FIELD_LENGTH bytesSDL_bool read_initial_device_info(TCPsocket socket, char *device_name, struct size *size) {    unsigned char buf[DEVICE_NAME_FIELD_LENGTH + 4];    if (SDLNet_TCP_Recv(socket, buf, sizeof(buf)) <= 0) {        return SDL_FALSE;    }    buf[DEVICE_NAME_FIELD_LENGTH - 1] = '\0'; // in case the client sends garbage    // scrcpy is safe here, since name contains at least DEVICE_NAME_FIELD_LENGTH bytes    // and strlen(buf) < DEVICE_NAME_FIELD_LENGTH    strcpy(device_name, (char *) buf);    size->width = (buf[DEVICE_NAME_FIELD_LENGTH] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 1];    size->height = (buf[DEVICE_NAME_FIELD_LENGTH + 2] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 3];    return SDL_TRUE;
static void count_frame(void) {    static long ts = 0;    static int nbframes = 0;    long now = timestamp_ms();    ++nbframes;    if (now - ts > 1000) {        SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "%d fps", nbframes);        ts = now;        nbframes = 0;    }}
static inline struct size get_window_size(SDL_Window *window) {    int width;    int height;    SDL_GetWindowSize(window, &width, &height);    struct size size;    size.width = width;    size.height = height;    return size;}
static SDL_bool handle_new_frame(void) {    mutex_lock(frames.mutex);    AVFrame *frame = frames.rendering_frame;    frames.rendering_frame_consumed = SDL_TRUE;    if (!decoder.skip_frames) {        cond_signal(frames.rendering_frame_consumed_cond);    }    struct size current_frame_size = {frame->width, frame->height};    if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {        return SDL_FALSE;    }    frame_size = current_frame_size;    update_texture(frame, texture);    mutex_unlock(frames.mutex);    render(renderer, texture);    return SDL_TRUE;}
static struct size get_optimal_size(struct size current_size, struct size frame_size) {    struct size display_size;    // 32 bits because we need to multiply two 16 bits values    Uint32 w;    Uint32 h;    if (!get_preferred_display_bounds(&display_size)) {        // cannot get display bounds, do not constraint the size        w = current_size.width;        h = current_size.height;    } else {        w = MIN(current_size.width, display_size.width);        h = MIN(current_size.height, display_size.height);    }    SDL_bool keep_width = frame_size.width * h > frame_size.height * w;    if (keep_width) {        // remove black borders on top and bottom        h = frame_size.height * w / frame_size.width;    } else {        // remove black borders on left and right (or none at all if it already fits)        w = frame_size.width * h / frame_size.height;    }    // w and h must fit into 16 bits    SDL_assert_release(w < 0x10000 && h < 0x10000);    return (struct size) {w, h};}
static inline struct position get_mouse_position() {    int x;    int y;    SDL_GetMouseState(&x, &y);    SDL_assert_release(x >= 0 && x < 0x10000 && y >= 0 && y < 0x10000);    return (struct position) {        .x = (Uint16) x,        .y = (Uint16) y,    };}
static void handle_mouse_motion(const SDL_MouseMotionEvent *event, struct size screen_size) {    struct control_event control_event;    if (mouse_motion_from_sdl_to_android(event, screen_size, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse motion event");        }    }}
static void update_texture(const AVFrame *frame, SDL_Texture *texture) {    SDL_UpdateYUVTexture(texture, NULL,            frame->data[0], frame->linesize[0],            frame->data[1], frame->linesize[1],            frame->data[2], frame->linesize[2]);}
static void handle_text_input(const SDL_TextInputEvent *event) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    strncpy(control_event.text_event.text, event->text, TEXT_MAX_LENGTH);    control_event.text_event.text[TEXT_MAX_LENGTH] = '\0';    if (!controller_push_event(&controller, &control_event)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send text event");    }}
SDL_bool scrcpy(const char *serial, Uint16 local_port) {    SDL_bool ret = 0;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            return;        case EVENT_NEW_FRAME:            if (!handle_new_frame()) {                return;            }            texture_empty = SDL_FALSE;            count_frame(); // display fps for debug            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_TEXTINPUT: {            handle_text_input(&event.text);            break;        }        case SDL_KEYDOWN:        case SDL_KEYUP:            handle_key(&event.key);            break;        case SDL_MOUSEMOTION:            handle_mouse_motion(&event.motion, frame_size);            break;        case SDL_MOUSEWHEEL: {            struct point point = {                .screen_size = frame_size,                .position = get_mouse_position(),            };            handle_mouse_wheel(&event.wheel, point);            break;        }        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP: {            handle_mouse_button(&event.button, frame_size);            break;        }        }    }}
static int wait_for_success(process_t proc, const char *name) {    if (proc == PROCESS_NONE) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not execute \"%s\"", name);        return -1;    }    exit_code_t exit_code;    if (!cmd_simple_wait(proc, &exit_code)) {        if (exit_code != NO_EXIT_CODE) {            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "\"%s\" returned with value %" PRIexitcode, name, exit_code);        } else {            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "\"%s\" exited unexpectedly", name);        }        return -1;    }    return 0;}
static long timestamp_ms(void) {    struct timeval tv;    gettimeofday(&tv, NULL);    return tv.tv_sec * 1000 + tv.tv_usec / 1000;}
static void render(SDL_Renderer *renderer, SDL_Texture *texture) {    SDL_RenderClear(renderer);    if (texture) {        SDL_RenderCopy(renderer, texture, NULL, NULL);    }    SDL_RenderPresent(renderer);}
static SDL_bool get_preferred_display_bounds(struct size *bounds) {    SDL_Rect rect;    if (GET_DISPLAY_BOUNDS(0, &rect)) {        SDL_LogWarn(SDL_LOG_CATEGORY_SYSTEM, "Could not get display usable bounds: %s", SDL_GetError());        return SDL_FALSE;    }    bounds->width = MAX(0, rect.w - DISPLAY_MARGINS);    bounds->height = MAX(0, rect.h - DISPLAY_MARGINS);    return SDL_TRUE;}
static void handle_mouse_wheel(const SDL_MouseWheelEvent *event, struct point point) {    struct control_event control_event;    if (mouse_wheel_from_sdl_to_android(event, point, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send wheel button event");        }    }}
static inline struct size get_initial_optimal_size(struct size frame_size) {    return get_optimal_size(frame_size, frame_size);}
#include "convert.h"#include "decoder.h"#include "events.h"#include "frames.h"#include "lockutil.h"#include "netutil.h"#include "server.h"#define DEVICE_NAME_FIELD_LENGTH 64#define DISPLAY_MARGINS 96static struct frames frames;static struct decoder decoder;static struct controller controller;static SDL_Window *window;static SDL_Renderer *renderer;static SDL_Texture *texture;static struct size frame_size;static SDL_bool texture_empty = SDL_TRUE;static SDL_bool fullscreen = SDL_FALSE;static long timestamp_ms(void) {    struct timeval tv;    gettimeofday(&tv, NULL);    return tv.tv_sec * 1000 + tv.tv_usec / 1000;}static void count_frame(void) {    static long ts = 0;    static int nbframes = 0;    long now = timestamp_ms();    ++nbframes;    if (now - ts > 1000) {        SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "%d fps", nbframes);
static inline struct size get_optimal_window_size(SDL_Window *window, struct size frame_size) {    struct size current_size = get_window_size(window);    return get_optimal_size(current_size, frame_size);}
SDL_bool read_initial_device_info(TCPsocket socket, char *device_name, struct size *size) {    unsigned char buf[DEVICE_NAME_FIELD_LENGTH + 4];    if (SDLNet_TCP_Recv(socket, buf, sizeof(buf)) <= 0) {        return SDL_FALSE;    }    buf[DEVICE_NAME_FIELD_LENGTH - 1] = '\0'; // in case the client sends garbage    // scrcpy is safe here, since name contains at least DEVICE_NAME_FIELD_LENGTH bytes    // and strlen(buf) < DEVICE_NAME_FIELD_LENGTH    strcpy(device_name, (char *) buf);    size->width = (buf[DEVICE_NAME_FIELD_LENGTH] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 1];    size->height = (buf[DEVICE_NAME_FIELD_LENGTH + 2] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 3];    return SDL_TRUE;}
static inline SDL_bool prepare_for_frame(SDL_Window *window, SDL_Renderer *renderer, SDL_Texture **texture,                                         struct size old_frame_size, struct size frame_size) {    (void) window; // might be used to resize the window automatically    if (old_frame_size.width != frame_size.width || old_frame_size.height != frame_size.height) {        if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {            SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());            return SDL_FALSE;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(*texture);        struct size current_size = get_window_size(window);        struct size target_size = {            (Uint32) current_size.width * frame_size.width / old_frame_size.width,            (Uint32) current_size.height * frame_size.height / old_frame_size.height,        };        target_size = get_optimal_size(target_size, frame_size);        SDL_SetWindowSize(window, target_size.width, target_size.height);        SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "New texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);        *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);        if (!*texture) {            SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());            return SDL_FALSE;        }    }    return SDL_TRUE;}
static TCPsocket listen_on_port(Uint16 port) {    IPaddress addr = {        .host = INADDR_ANY,        .port = SDL_SwapBE16(port),    };    return SDLNet_TCP_Open(&addr);}
static void handle_mouse_button(const SDL_MouseButtonEvent *event, struct size screen_size) {    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, screen_size, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send mouse button event");        }    }}
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // Capture Ctrl+x: optimal size    if (keycode == SDLK_x && !repeat && ctrl && !shift) {        if (event->type == SDL_KEYDOWN) {            struct size optimal_size = get_optimal_window_size(window, frame_size);            SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);        }        return;    }    // Capture Ctrl+f: switch fullscreen    if (keycode == SDLK_f && !repeat && ctrl && !shift) {        if (event->type == SDL_KEYDOWN) {            Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;            if (!SDL_SetWindowFullscreen(window, new_mode)) {                fullscreen = !fullscreen;                render(renderer, texture_empty ? NULL : texture);            } else {                SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());            }        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    char max_fps_string[6];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    sprintf(max_fps_string, "%"PRIu16, params->max_fps);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/" SERVER_FILENAME,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,        max_size_string,        bit_rate_string,        max_fps_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    char max_fps_string[6];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    sprintf(max_fps_string, "%"PRIu16, params->max_fps);    const char *const cmd[] = {        "shell",        "CLASSPATH=" DEVICE_SERVER_PATH,        "app_process",#ifdef SERVER_DEBUGGER# define SERVER_DEBUGGER_PORT "5005"        "-agentlib:jdwp=transport=dt_socket,suspend=y,server=y,address="            SERVER_DEBUGGER_PORT,#endif        "/", // unused        "com.genymobile.scrcpy.Server",        SCRCPY_VERSION,        max_size_string,        bit_rate_string,        max_fps_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",    };#ifdef SERVER_DEBUGGER    LOGI("Server debugger waiting for a client on device port "         SERVER_DEBUGGER_PORT "...");    // From the computer, run    //     adb forward tcp:5005 tcp:5005    // Then, from Android Studio: Run > Debug > Edit configurations...    // On the left, click on '+', "Remote", with:    //     Host: localhost    //     Port: 5005    // Then click on "Debug"#endif    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+m\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+s\n"        "        click on MENU\n"        "\n"        "    Ctrl+'+'\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+'-'\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+'+'\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+'-'\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
input_manager_process_mouse_button(struct input_manager *input_manager,                                   const SDL_MouseButtonEvent *event,                                   bool control) {    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (control && event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(input_manager->controller);            return;        }        if (control && event->button == SDL_BUTTON_MIDDLE) {            action_home(input_manager->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            bool outside =                is_outside_device_screen(input_manager, event->x, event->y);            if (outside) {                screen_resize_to_fit(input_manager->screen);                return;            }        }        // otherwise, send the click event to the device    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_mouse_button(event, input_manager->screen->frame_size, &msg)) {        if (!controller_push_msg(input_manager->controller, &msg)) {            LOGW("Could not request 'inject mouse button event'");        }    }}
input_manager_process_mouse_motion(struct input_manager *input_manager,                                   const SDL_MouseMotionEvent *event) {    if (!event->state) {        // do not send motion events when no button is pressed        return;    }    struct control_msg msg;    if (convert_mouse_motion(event, input_manager->screen->frame_size, &msg)) {        if (!controller_push_msg(input_manager->controller, &msg)) {            LOGW("Could not request 'inject mouse motion event'");        }    }}
input_manager_process_mouse_button(struct input_manager *input_manager,                                   const SDL_MouseButtonEvent *event,                                   bool control) {    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (control && event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(input_manager->controller);            return;        }        if (control && event->button == SDL_BUTTON_MIDDLE) {            action_home(input_manager->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            bool outside =                is_outside_device_screen(input_manager, event->x, event->y);            if (outside) {                screen_resize_to_fit(input_manager->screen);                return;            }        }        // otherwise, send the click event to the device    }    if (!control) {        return;    }    struct control_msg msg;    if (convert_mouse_button(event, input_manager->screen->frame_size, &msg)) {        if (!controller_push_msg(input_manager->controller, &msg)) {            LOGW("Could not request 'inject mouse button event'");        }    }}
input_manager_process_mouse_motion(struct input_manager *input_manager,                                   const SDL_MouseMotionEvent *event) {    if (!event->state) {        // do not send motion events when no button is pressed        return;    }    if (event->which == SDL_TOUCH_MOUSEID) {        // simulated from touch events, so it's a duplicate        return;    }    struct control_msg msg;    if (convert_mouse_motion(event, input_manager->screen->frame_size, &msg)) {        if (!controller_push_msg(input_manager->controller, &msg)) {            LOGW("Could not request 'inject mouse motion event'");        }    }}
SDL_bool mouse_button_from_sdl_to_android(const SDL_MouseButtonEvent *from,                                          struct size screen_size,                                          struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    if (!convert_mouse_action(from->type, &to->mouse_event.action)) {        return SDL_FALSE;    }    to->mouse_event.buttons = convert_mouse_buttons(SDL_BUTTON(from->button));    to->mouse_event.position.screen_size = screen_size;    to->mouse_event.position.point.x = (Uint16) from->x;    to->mouse_event.position.point.y = (Uint16) from->y;    return SDL_TRUE;}
SDL_bool mouse_button_from_sdl_to_android(const SDL_MouseButtonEvent *from,                                          struct size screen_size,                                          struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    if (!convert_mouse_action(from->type, &to->mouse_event.action)) {        return SDL_FALSE;    }    to->mouse_event.buttons = convert_mouse_buttons(SDL_BUTTON(from->button));    to->mouse_event.position.screen_size = screen_size;    to->mouse_event.position.point.x = from->x;    to->mouse_event.position.point.y = from->y;    return SDL_TRUE;}
control_event_destroy(struct control_event *event) {    if (event->type == CONTROL_EVENT_TYPE_TEXT) {        SDL_free(event->text_event.text);    }}
control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            buffer_write32be(&buf[2], event->keycode_event.keycode);            buffer_write32be(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            size_t len = write_string(event->text_event.text,                                      CONTROL_EVENT_TEXT_MAX_LENGTH, &buf[1]);            return 1 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            buffer_write32be(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 18;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            buffer_write32be(&buf[13], (uint32_t) event->scroll_event.hscroll);            buffer_write32be(&buf[17], (uint32_t) event->scroll_event.vscroll);            return 21;        case CONTROL_EVENT_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_EVENT_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_EVENT_TYPE_COLLAPSE_NOTIFICATION_PANEL:        case CONTROL_EVENT_TYPE_GET_CLIPBOARD:            // no additional data            return 1;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
control_event_destroy(struct control_event *event) {    switch (event->type) {        case CONTROL_EVENT_TYPE_TEXT:            SDL_free(event->text_event.text);            break;        case CONTROL_EVENT_TYPE_SET_CLIPBOARD:            SDL_free(event->set_clipboard_event.text);            break;        default:            // do nothing            break;    }}
control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            buffer_write32be(&buf[2], event->keycode_event.keycode);            buffer_write32be(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            size_t len = write_string(event->text_event.text,                                      CONTROL_EVENT_TEXT_MAX_LENGTH, &buf[1]);            return 1 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            buffer_write32be(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 18;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            buffer_write32be(&buf[13], (uint32_t) event->scroll_event.hscroll);            buffer_write32be(&buf[17], (uint32_t) event->scroll_event.vscroll);            return 21;        case CONTROL_EVENT_TYPE_SET_CLIPBOARD: {            size_t len = write_string(event->text_event.text,                                      CONTROL_EVENT_CLIPBOARD_TEXT_MAX_LENGTH,                                      &buf[1]);            return 1 + len;        }        case CONTROL_EVENT_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_EVENT_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_EVENT_TYPE_COLLAPSE_NOTIFICATION_PANEL:        case CONTROL_EVENT_TYPE_GET_CLIPBOARD:            // no additional data            return 1;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
    SDL_GetMouseState(&x, &y);    convert_to_renderer_coordinates(screen->renderer, &x, &y);    return (struct point) {        .x = x,        .y = y,    };}static const int ACTION_DOWN = 1;static const int ACTION_UP = 1 << 1;static voidsend_keycode(struct controller *controller, enum android_keycode keycode,             int actions, const char *name) {    // send DOWN event    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_KEYCODE;    control_event.keycode_event.keycode = keycode;    control_event.keycode_event.metastate = 0;    if (actions & ACTION_DOWN) {        control_event.keycode_event.action = AKEY_EVENT_ACTION_DOWN;        if (!controller_push_event(controller, &control_event)) {            LOGW("Cannot send %s (DOWN)", name);            return;        }    }    if (actions & ACTION_UP) {        control_event.keycode_event.action = AKEY_EVENT_ACTION_UP;        if (!controller_push_event(controller, &control_event)) {            LOGW("Cannot send %s (UP)", name);        }    }}
set_device_clipboard(struct controller *controller) {    char *text = SDL_GetClipboardText();    if (!text) {        LOGW("Cannot get clipboard text: %s", SDL_GetError());        return;    }    if (!*text) {        // empty text        SDL_free(text);        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_SET_CLIPBOARD;    control_event.set_clipboard_event.text = text;    if (!controller_push_event(controller, &control_event)) {        SDL_free(text);        LOGW("Cannot send clipboard paste event");    }}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+c\n"        "        copy device clipboard to computer\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+c\n"        "        copy device clipboard to computer\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
            .text = "hello, world!",        },    };    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 16);    const unsigned char expected[] = {        0x01, // CONTROL_EVENT_TYPE_TEXT        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}static void test_serialize_long_text_event(void) {    struct control_event event;    event.type = CONTROL_EVENT_TYPE_TEXT;    char text[CONTROL_EVENT_TEXT_MAX_LENGTH + 1];    memset(text, 'a', sizeof(text));    text[CONTROL_EVENT_TEXT_MAX_LENGTH] = '\0';    event.text_event.text = text;    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 3 + CONTROL_EVENT_TEXT_MAX_LENGTH);    unsigned char expected[3 + CONTROL_EVENT_TEXT_MAX_LENGTH];    expected[0] = 0x01; // CONTROL_EVENT_TYPE_KEYCODE    expected[1] = 0x01;    expected[2] = 0x2c; // text length (16 bits)    memset(&expected[3], 'a', CONTROL_EVENT_TEXT_MAX_LENGTH);    assert(!memcmp(buf, expected, sizeof(expected)));}static void test_serialize_mouse_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_MOUSE,        .mouse_event = {            .action = AMOTION_EVENT_ACTION_DOWN,            .buttons = AMOTION_EVENT_BUTTON_PRIMARY,            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },        },    };    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 18);    const unsigned char expected[] = {        0x02, // CONTROL_EVENT_TYPE_MOUSE        0x00, // AKEY_EVENT_ACTION_DOWN        0x00, 0x00, 0x00, 0x01, // AMOTION_EVENT_BUTTON_PRIMARY        0x00, 0x00, 0x01, 0x04, 0x00, 0x00, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920    };    assert(!memcmp(buf, expected, sizeof(expected)));}static void test_serialize_scroll_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_SCROLL,        .scroll_event = {            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },            .hscroll = 1,            .vscroll = -1,        },    };    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 21);    const unsigned char expected[] = {        0x03, // CONTROL_EVENT_TYPE_SCROLL        0x00, 0x00, 0x01, 0x04, 0x00, 0x00, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920        0x00, 0x00, 0x00, 0x01, // 1        0xFF, 0xFF, 0xFF, 0xFF, // -1    };    assert(!memcmp(buf, expected, sizeof(expected)));}static void test_serialize_back_or_screen_on_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_BACK_OR_SCREEN_ON,    };    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 1);    const unsigned char expected[] = {        0x04, // CONTROL_EVENT_TYPE_BACK_OR_SCREEN_ON    };    assert(!memcmp(buf, expected, sizeof(expected)));}static void test_serialize_expand_notification_panel_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_EXPAND_NOTIFICATION_PANEL,    };    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);
int main(void) {    test_serialize_keycode_event();    test_serialize_text_event();    test_serialize_long_text_event();    test_serialize_mouse_event();    test_serialize_scroll_event();    test_serialize_back_or_screen_on_event();    test_serialize_expand_notification_panel_event();    test_serialize_collapse_notification_panel_event();    test_serialize_get_clipboard_event();    return 0;}
static void test_serialize_set_clipboard_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_SET_CLIPBOARD,        .text_event = {            .text = "hello, world!",        },    };    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 16);    const unsigned char expected[] = {        0x08, // CONTROL_EVENT_TYPE_SET_CLIPBOARD        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
int main(void) {    test_serialize_keycode_event();    test_serialize_text_event();    test_serialize_long_text_event();    test_serialize_mouse_event();    test_serialize_scroll_event();    test_serialize_back_or_screen_on_event();    test_serialize_expand_notification_panel_event();    test_serialize_collapse_notification_panel_event();    test_serialize_get_clipboard_event();    test_serialize_set_clipboard_event();    return 0;}
    public ControlEvent next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        ControlEvent controlEvent;        switch (type) {            case ControlEvent.TYPE_KEYCODE:                controlEvent = parseKeycodeControlEvent();                break;            case ControlEvent.TYPE_TEXT:                controlEvent = parseTextControlEvent();                break;            case ControlEvent.TYPE_MOUSE:                controlEvent = parseMouseControlEvent();                break;            case ControlEvent.TYPE_SCROLL:                controlEvent = parseScrollControlEvent();                break;            case ControlEvent.TYPE_BACK_OR_SCREEN_ON:            case ControlEvent.TYPE_EXPAND_NOTIFICATION_PANEL:            case ControlEvent.TYPE_COLLAPSE_NOTIFICATION_PANEL:            case ControlEvent.TYPE_GET_CLIPBOARD:                controlEvent = ControlEvent.createSimpleControlEvent(type);                break;            default:                Ln.w("Unknown event type: " + type);                controlEvent = null;                break;        }        if (controlEvent == null) {            // failure, reset savedPosition            buffer.position(savedPosition);        }        return controlEvent;    }
    public ControlEvent next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        ControlEvent controlEvent;        switch (type) {            case ControlEvent.TYPE_KEYCODE:                controlEvent = parseKeycodeControlEvent();                break;            case ControlEvent.TYPE_TEXT:                controlEvent = parseTextControlEvent();                break;            case ControlEvent.TYPE_MOUSE:                controlEvent = parseMouseControlEvent();                break;            case ControlEvent.TYPE_SCROLL:                controlEvent = parseScrollControlEvent();                break;            case ControlEvent.TYPE_SET_CLIPBOARD:                controlEvent = parseSetClipboardEvent();                break;            case ControlEvent.TYPE_BACK_OR_SCREEN_ON:            case ControlEvent.TYPE_EXPAND_NOTIFICATION_PANEL:            case ControlEvent.TYPE_COLLAPSE_NOTIFICATION_PANEL:            case ControlEvent.TYPE_GET_CLIPBOARD:                controlEvent = ControlEvent.createSimpleControlEvent(type);                break;            default:                Ln.w("Unknown event type: " + type);                controlEvent = null;                break;        }        if (controlEvent == null) {            // failure, reset savedPosition            buffer.position(savedPosition);        }        return controlEvent;    }
        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        Rect contentRect = new Rect(0, 0, deviceSize.getWidth(), deviceSize.getHeight());        if (crop != null) {            if (rotated) {                // the crop (provided by the user) is expressed in the natural orientation                crop = flipRect(crop);            }            if (!contentRect.intersect(crop)) {                // intersect() changes contentRect so that it is intersected with crop                Ln.w("Crop rectangle (" + formatCrop(crop) + ") does not intersect device screen (" + formatCrop(deviceSize.toRect()) + ")");                contentRect = new Rect(); // empty            }        }        Size videoSize = computeVideoSize(contentRect.width(), contentRect.height(), maxSize);        return new ScreenInfo(contentRect, videoSize, rotated);    }    private static String formatCrop(Rect rect) {        return rect.width() + ":" + rect.height() + ":" + rect.left + ":" + rect.top;    }    @SuppressWarnings("checkstyle:MagicNumber")    private static Size computeVideoSize(int w, int h, int maxSize) {        // Compute the video size and the padding of the content inside this video.        // Principle:        // - scale down the great side of the screen to maxSize (if necessary);        // - scale down the other side so that the aspect ratio is preserved;        // - round this value to the nearest multiple of 8 (H.264 only accepts multiples of 8)        w &= ~7; // in case it's not a multiple of 8        h &= ~7;        if (maxSize > 0) {            if (BuildConfig.DEBUG && maxSize % 8 != 0) {                throw new AssertionError("Max size must be a multiple of 8");            }            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;            if (major > maxSize) {
    public void setClipboardText(String text) {        serviceManager.getClipboardManager().setText(text);    }
    private void handleEvent() throws IOException {        ControlEvent controlEvent = connection.receiveControlEvent();        switch (controlEvent.getType()) {            case ControlEvent.TYPE_KEYCODE:                injectKeycode(controlEvent.getAction(), controlEvent.getKeycode(), controlEvent.getMetaState());                break;            case ControlEvent.TYPE_TEXT:                injectText(controlEvent.getText());                break;            case ControlEvent.TYPE_MOUSE:                injectMouse(controlEvent.getAction(), controlEvent.getButtons(), controlEvent.getPosition());                break;            case ControlEvent.TYPE_SCROLL:                injectScroll(controlEvent.getPosition(), controlEvent.getHScroll(), controlEvent.getVScroll());                break;            case ControlEvent.TYPE_BACK_OR_SCREEN_ON:                pressBackOrTurnScreenOn();                break;            case ControlEvent.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlEvent.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlEvent.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            default:                // do nothing        }    }
    private void handleEvent() throws IOException {        ControlEvent controlEvent = connection.receiveControlEvent();        switch (controlEvent.getType()) {            case ControlEvent.TYPE_KEYCODE:                injectKeycode(controlEvent.getAction(), controlEvent.getKeycode(), controlEvent.getMetaState());                break;            case ControlEvent.TYPE_TEXT:                injectText(controlEvent.getText());                break;            case ControlEvent.TYPE_MOUSE:                injectMouse(controlEvent.getAction(), controlEvent.getButtons(), controlEvent.getPosition());                break;            case ControlEvent.TYPE_SCROLL:                injectScroll(controlEvent.getPosition(), controlEvent.getHScroll(), controlEvent.getVScroll());                break;            case ControlEvent.TYPE_BACK_OR_SCREEN_ON:                pressBackOrTurnScreenOn();                break;            case ControlEvent.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlEvent.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlEvent.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlEvent.TYPE_SET_CLIPBOARD:                device.setClipboardText(controlEvent.getText());                break;            default:                // do nothing        }    }
    public ClipboardManager(IInterface manager) {        this.manager = manager;        try {            getPrimaryClipMethod = manager.getClass().getMethod("getPrimaryClip", String.class);        } catch (NoSuchMethodException e) {            throw new AssertionError(e);        }    }
    public ClipboardManager(IInterface manager) {        this.manager = manager;        try {            getPrimaryClipMethod = manager.getClass().getMethod("getPrimaryClip", String.class);            setPrimaryClipMethod = manager.getClass().getMethod("setPrimaryClip", ClipData.class, String.class);        } catch (NoSuchMethodException e) {            throw new AssertionError(e);        }    }
import java.nio.charset.StandardCharsets;import java.util.Arrays;public class ControlEventReaderTest {    @Test    public void testParseKeycodeEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();
    public void testParseSetClipboardEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_SET_CLIPBOARD);        byte[] text = "testé".getBytes(StandardCharsets.UTF_8);        dos.writeShort(text.length);        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_SET_CLIPBOARD, event.getType());        Assert.assertEquals("testé", event.getText());    }
static int run_controller(void *data) {    struct controller *controller = data;    for (;;) {        mutex_lock(controller->mutex);        while (!controller->stopped && control_event_queue_is_empty(&controller->queue)) {            cond_wait(controller->event_cond, controller->mutex);        }        if (controller->stopped) {            // stop immediately, do not process further events            mutex_unlock(controller->mutex);            break;        }        struct control_event event;#ifdef BUILD_DEBUG        bool non_empty = control_event_queue_take(&controller->queue, &event);        SDL_assert(non_empty);#else        control_event_queue_take(&controller->queue, &event);#endif        mutex_unlock(controller->mutex);        SDL_bool ok = process_event(controller, &event);        control_event_destroy(&event);        if (!ok) {            LOGD("Cannot write event to socket");            break;        }    }    return 0;}
static int run_controller(void *data) {    struct controller *controller = data;    for (;;) {        mutex_lock(controller->mutex);        while (!controller->stopped && control_event_queue_is_empty(&controller->queue)) {            cond_wait(controller->event_cond, controller->mutex);        }        if (controller->stopped) {            // stop immediately, do not process further events            mutex_unlock(controller->mutex);            break;        }        struct control_event event;#ifdef BUILD_DEBUG        SDL_bool non_empty = control_event_queue_take(&controller->queue, &event);        SDL_assert(non_empty);#else        control_event_queue_take(&controller->queue, &event);#endif        mutex_unlock(controller->mutex);        SDL_bool ok = process_event(controller, &event);        control_event_destroy(&event);        if (!ok) {            LOGD("Cannot write event to socket");            break;        }    }    return 0;}
static int run_file_handler(void *data) {    struct file_handler *file_handler = data;    for (;;) {        mutex_lock(file_handler->mutex);        file_handler->current_process = PROCESS_NONE;        while (!file_handler->stopped && request_queue_is_empty(&file_handler->queue)) {            cond_wait(file_handler->event_cond, file_handler->mutex);        }        if (file_handler->stopped) {            // stop immediately, do not process further events            mutex_unlock(file_handler->mutex);            break;        }        struct request *req;#ifdef BUILD_DEBUG        bool non_empty = request_queue_take(&file_handler->queue, &req);        SDL_assert(non_empty);#else        request_queue_take(&file_handler->queue, &req);#endif        process_t process;        if (req->action == ACTION_INSTALL_APK) {            LOGI("Installing %s...", req->file);            process = install_apk(file_handler->serial, req->file);        } else {            LOGI("Pushing %s...", req->file);            process = push_file(file_handler->serial, req->file);        }        file_handler->current_process = process;        mutex_unlock(file_handler->mutex);        if (req->action == ACTION_INSTALL_APK) {            if (process_check_success(process, "adb install")) {                LOGI("%s successfully installed", req->file);            } else {                LOGE("Failed to install %s", req->file);            }        } else {            if (process_check_success(process, "adb push")) {                LOGI("%s successfully pushed to /sdcard/", req->file);            } else {                LOGE("Failed to push %s to /sdcard/", req->file);            }        }        request_free(req);    }    return 0;}
static int run_file_handler(void *data) {    struct file_handler *file_handler = data;    for (;;) {        mutex_lock(file_handler->mutex);        file_handler->current_process = PROCESS_NONE;        while (!file_handler->stopped && request_queue_is_empty(&file_handler->queue)) {            cond_wait(file_handler->event_cond, file_handler->mutex);        }        if (file_handler->stopped) {            // stop immediately, do not process further events            mutex_unlock(file_handler->mutex);            break;        }        struct request *req;#ifdef BUILD_DEBUG        SDL_bool non_empty = request_queue_take(&file_handler->queue, &req);        SDL_assert(non_empty);#else        request_queue_take(&file_handler->queue, &req);#endif        process_t process;        if (req->action == ACTION_INSTALL_APK) {            LOGI("Installing %s...", req->file);            process = install_apk(file_handler->serial, req->file);        } else {            LOGI("Pushing %s...", req->file);            process = push_file(file_handler->serial, req->file);        }        file_handler->current_process = process;        mutex_unlock(file_handler->mutex);        if (req->action == ACTION_INSTALL_APK) {            if (process_check_success(process, "adb install")) {                LOGI("%s successfully installed", req->file);            } else {                LOGE("Failed to install %s", req->file);            }        } else {            if (process_check_success(process, "adb push")) {                LOGI("%s successfully pushed to /sdcard/", req->file);            } else {                LOGE("Failed to push %s to /sdcard/", req->file);            }        }        request_free(req);    }    return 0;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate)) {        return SDL_FALSE;    }    process_t proc_show_touches;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
uint64_t buffer_read64be(const uint8_t *buf) {    uint32_t msb = buffer_read32be(buf);    uint32_t lsb = buffer_read32be(&buf[4]);    return ((uint64_t) msb << 32) | lsb;}
buffer_read64be(const uint8_t *buf) {    uint32_t msb = buffer_read32be(buf);    uint32_t lsb = buffer_read32be(&buf[4]);    return ((uint64_t) msb << 32) | lsb;}
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        switch (keycode) {            case SDLK_h:                action_home(input_manager->controller);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(input_manager->controller);                return;            case SDLK_m:                action_app_switch(input_manager->controller);                return;            case SDLK_p:                action_power(input_manager->controller);                return;            case SDLK_f:                screen_switch_fullscreen(input_manager->screen);                return;            case SDLK_x:                screen_resize_to_fit(input_manager->screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(input_manager->screen);                return;            case SDLK_i:                switch_fps_counter_state(input_manager->frames);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    // capture all Ctrl events    if (ctrl) {        SDL_bool repeat = event->repeat;        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        if (shift) {            // currently, there is no shortcut implying SHIFT            return;        }        SDL_Keycode keycode = event->keysym.sym;        switch (keycode) {            case SDLK_h:                action_home(input_manager->controller);                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                action_back(input_manager->controller);                return;            case SDLK_m:                action_app_switch(input_manager->controller);                return;            case SDLK_p:                action_power(input_manager->controller);                return;            case SDLK_f:                screen_switch_fullscreen(input_manager->screen);                return;            case SDLK_x:                screen_resize_to_fit(input_manager->screen);                return;            case SDLK_g:                screen_resize_to_pixel_perfect(input_manager->screen);                return;            case SDLK_i:                switch_fps_counter_state(input_manager->frames);                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
    public void streamScreen(Device device, OutputStream outputStream) throws IOException {        MediaFormat format = createFormat(bitRate, frameRate, iFrameInterval);        MediaCodec codec = createCodec();        IBinder display = createDisplay();        device.setRotationListener(this);        boolean alive;        try {            do {                Rect deviceRect = device.getScreenInfo().getDeviceSize().toRect();                Rect videoRect = device.getScreenInfo().getVideoSize().toRect();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, deviceRect, videoRect);                codec.start();                try {                    alive = encode(codec, outputStream);                } finally {                    codec.stop();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);            destroyDisplay(display);            codec.release();        }    }
    public void streamScreen(Device device, OutputStream outputStream) throws IOException {        MediaFormat format = createFormat(bitRate, frameRate, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                Rect deviceRect = device.getScreenInfo().getDeviceSize().toRect();                Rect videoRect = device.getScreenInfo().getVideoSize().toRect();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, deviceRect, videoRect);                codec.start();                try {                    alive = encode(codec, outputStream);                } finally {                    codec.stop();                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
static void test_serialize_text_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_TEXT,        .text_event = {            .text = "hello, world!",        },    };    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 16);    const unsigned char expected[] = {        0x01, // CONTROL_EVENT_TYPE_KEYCODE        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_text_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_TEXT,        .text_event = {            .text = "hello, world!",        },    };    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 16);    const unsigned char expected[] = {        0x01, // CONTROL_EVENT_TYPE_TEXT        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    SDL_bool ret = SDL_TRUE;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, max_size, bit_rate);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }#if SDL_VERSION_ATLEAST(2, 0, 5)    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable mouse focus clickthrough");    }#endif    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not load icon: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_SetWindowIcon(window, icon);    SDL_FreeSurface(icon);    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    SDL_bool ret = SDL_TRUE;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, max_size, bit_rate);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }#if SDL_VERSION_ATLEAST(2, 0, 5)    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable mouse focus clickthrough");    }#endif    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not load icon: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_SetWindowIcon(window, icon);    SDL_FreeSurface(icon);    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);    // at least we hide it    SDL_HideWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // let the server some time to print any exception trace before killing it    struct timespec timespec = {        .tv_sec = 0,        .tv_nsec = 100000000, // 100ms    };    nanosleep(&timespec, NULL); // ignore error    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
adb_push(const char *serial, const char *local, const char *remote) {#ifdef __WINDOWS__    // Windows will parse the string, so the paths must be quoted    // (see sys/win/command.c)    local = strquote(local);    if (!local) {        return PROCESS_NONE;    }    remote = strquote(remote);    if (!remote) {        free((void *) local);        return PROCESS_NONE;    }#endif    const char *const adb_cmd[] = {"push", local, remote};    process_t proc = adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));#ifdef __WINDOWS__    free((void *) remote);    free((void *) local);#endif    return proc;}
adb_install(const char *serial, const char *local) {#ifdef __WINDOWS__    // Windows will parse the string, so the local name must be quoted    // (see sys/win/command.c)    local = strquote(local);    if (!local) {        return PROCESS_NONE;    }#endif    const char *const adb_cmd[] = {"install", "-r", local};    process_t proc = adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));#ifdef __WINDOWS__    free((void *) local);#endif    return proc;}
adb_push(const char *serial, const char *local, const char *remote) {#ifdef __WINDOWS__    // Windows will parse the string, so the paths must be quoted    // (see sys/win/command.c)    local = strquote(local);    if (!local) {        return PROCESS_NONE;    }    remote = strquote(remote);    if (!remote) {        SDL_free((void *) local);        return PROCESS_NONE;    }#endif    const char *const adb_cmd[] = {"push", local, remote};    process_t proc = adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));#ifdef __WINDOWS__    SDL_free((void *) remote);    SDL_free((void *) local);#endif    return proc;}
adb_install(const char *serial, const char *local) {#ifdef __WINDOWS__    // Windows will parse the string, so the local name must be quoted    // (see sys/win/command.c)    local = strquote(local);    if (!local) {        return PROCESS_NONE;    }#endif    const char *const adb_cmd[] = {"install", "-r", local};    process_t proc = adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));#ifdef __WINDOWS__    SDL_free((void *) local);#endif    return proc;}
utf8_to_wide_char(const char *utf8) {    int len = MultiByteToWideChar(CP_UTF8, 0, utf8, -1, NULL, 0);    if (!len) {        return NULL;    }    wchar_t *wide = malloc(len * sizeof(wchar_t));    if (!wide) {        return NULL;    }    MultiByteToWideChar(CP_UTF8, 0, utf8, -1, wide, len);    return wide;}
strquote(const char *src) {    size_t len = strlen(src);    char *quoted = malloc(len + 3);    if (!quoted) {        return NULL;    }    memcpy(&quoted[1], src, len);    quoted[0] = '"';    quoted[len + 1] = '"';    quoted[len + 2] = '\0';    return quoted;}
utf8_to_wide_char(const char *utf8) {    int len = MultiByteToWideChar(CP_UTF8, 0, utf8, -1, NULL, 0);    if (!len) {        return NULL;    }    wchar_t *wide = SDL_malloc(len * sizeof(wchar_t));    if (!wide) {        return NULL;    }    MultiByteToWideChar(CP_UTF8, 0, utf8, -1, wide, len);    return wide;}
strquote(const char *src) {    size_t len = strlen(src);    char *quoted = SDL_malloc(len + 3);    if (!quoted) {        return NULL;    }    memcpy(&quoted[1], src, len);    quoted[0] = '"';    quoted[len + 1] = '"';    quoted[len + 2] = '\0';    return quoted;}
frame_meta_delete(struct frame_meta *frame_meta) {    free(frame_meta);}
frame_meta_new(uint64_t pts) {    struct frame_meta *meta = malloc(sizeof(*meta));    if (!meta) {        return meta;    }    meta->pts = pts;    meta->next = NULL;    return meta;}
frame_meta_delete(struct frame_meta *frame_meta) {    SDL_free(frame_meta);}
frame_meta_new(uint64_t pts) {    struct frame_meta *meta = SDL_malloc(sizeof(*meta));    if (!meta) {        return meta;    }    meta->pts = pts;    meta->next = NULL;    return meta;}
cmd_execute(const char *path, const char *const argv[], HANDLE *handle) {    STARTUPINFOW si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    char cmd[256];    if (build_cmd(cmd, sizeof(cmd), argv)) {        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }    wchar_t *wide = utf8_to_wide_char(cmd);    if (!wide) {        LOGC("Cannot allocate wide char string");        return PROCESS_ERROR_GENERIC;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcessW(NULL, wide, NULL, NULL, FALSE, flags, NULL, NULL, &si,                        &pi)) {        free(wide);        *handle = NULL;        if (GetLastError() == ERROR_FILE_NOT_FOUND) {            return PROCESS_ERROR_MISSING_BINARY;        }        return PROCESS_ERROR_GENERIC;    }    free(wide);    *handle = pi.hProcess;    return PROCESS_SUCCESS;}
cmd_execute(const char *path, const char *const argv[], HANDLE *handle) {    STARTUPINFOW si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    char cmd[256];    if (build_cmd(cmd, sizeof(cmd), argv)) {        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }    wchar_t *wide = utf8_to_wide_char(cmd);    if (!wide) {        LOGC("Cannot allocate wide char string");        return PROCESS_ERROR_GENERIC;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcessW(NULL, wide, NULL, NULL, FALSE, flags, NULL, NULL, &si,                        &pi)) {        SDL_free(wide);        *handle = NULL;        if (GetLastError() == ERROR_FILE_NOT_FOUND) {            return PROCESS_ERROR_MISSING_BINARY;        }        return PROCESS_ERROR_GENERIC;    }    SDL_free(wide);    *handle = pi.hProcess;    return PROCESS_SUCCESS;}
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    // capture all Ctrl events    if (ctrl) {        SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        if (shift) {            // currently, there is no shortcut involving SHIFT            return;        }        SDL_Keycode keycode = event->keysym.sym;        int action = event->type == SDL_KEYDOWN ? ACTION_DOWN : ACTION_UP;        SDL_bool repeat = event->repeat;        switch (keycode) {            case SDLK_h:                if (!repeat) {                    action_home(input_manager->controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (!repeat) {                    action_back(input_manager->controller, action);                }                return;            case SDLK_s:                if (!repeat) {                    action_app_switch(input_manager->controller, action);                }                return;            case SDLK_m:                if (!repeat) {                    action_menu(input_manager->controller, action);                }                return;            case SDLK_p:                if (!repeat) {                    action_power(input_manager->controller, action);                }                return;            case SDLK_DOWN:                // forward repeated events                action_volume_down(input_manager->controller, action);                return;            case SDLK_UP:                // forward repeated events                action_volume_up(input_manager->controller, action);                return;            case SDLK_v:                if (!repeat && event->type == SDL_KEYDOWN) {                    clipboard_paste(input_manager->controller);                }                return;            case SDLK_f:                if (!repeat && event->type == SDL_KEYDOWN) {                    screen_switch_fullscreen(input_manager->screen);                }                return;            case SDLK_x:                if (!repeat && event->type == SDL_KEYDOWN) {                    screen_resize_to_fit(input_manager->screen);                }                return;            case SDLK_g:                if (!repeat && event->type == SDL_KEYDOWN) {                    screen_resize_to_pixel_perfect(input_manager->screen);                }                return;            case SDLK_i:                if (!repeat && event->type == SDL_KEYDOWN) {                    switch_fps_counter_state(input_manager->frames);                }                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
void input_manager_process_key(struct input_manager *input_manager,                               const SDL_KeyboardEvent *event) {    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool alt = event->keysym.mod & (KMOD_LALT | KMOD_RALT);    SDL_bool meta = event->keysym.mod & (KMOD_LGUI | KMOD_RGUI);    if (alt | meta) {        // no shortcut involves Alt or Meta, and they should not be forwarded        // to the device        return;    }    // capture all Ctrl events    if (ctrl) {        SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);        if (shift) {            // currently, there is no shortcut involving SHIFT            return;        }        SDL_Keycode keycode = event->keysym.sym;        int action = event->type == SDL_KEYDOWN ? ACTION_DOWN : ACTION_UP;        SDL_bool repeat = event->repeat;        switch (keycode) {            case SDLK_h:                if (!repeat) {                    action_home(input_manager->controller, action);                }                return;            case SDLK_b: // fall-through            case SDLK_BACKSPACE:                if (!repeat) {                    action_back(input_manager->controller, action);                }                return;            case SDLK_s:                if (!repeat) {                    action_app_switch(input_manager->controller, action);                }                return;            case SDLK_m:                if (!repeat) {                    action_menu(input_manager->controller, action);                }                return;            case SDLK_p:                if (!repeat) {                    action_power(input_manager->controller, action);                }                return;            case SDLK_DOWN:                // forward repeated events                action_volume_down(input_manager->controller, action);                return;            case SDLK_UP:                // forward repeated events                action_volume_up(input_manager->controller, action);                return;            case SDLK_v:                if (!repeat && event->type == SDL_KEYDOWN) {                    clipboard_paste(input_manager->controller);                }                return;            case SDLK_f:                if (!repeat && event->type == SDL_KEYDOWN) {                    screen_switch_fullscreen(input_manager->screen);                }                return;            case SDLK_x:                if (!repeat && event->type == SDL_KEYDOWN) {                    screen_resize_to_fit(input_manager->screen);                }                return;            case SDLK_g:                if (!repeat && event->type == SDL_KEYDOWN) {                    screen_resize_to_pixel_perfect(input_manager->screen);                }                return;            case SDLK_i:                if (!repeat && event->type == SDL_KEYDOWN) {                    switch_fps_counter_state(input_manager->frames);                }                return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send control event");        }    }}
    if (!len) {        return NULL;    }    wchar_t *wide = SDL_malloc(len * sizeof(wchar_t));    if (!wide) {        return NULL;    }    MultiByteToWideChar(CP_UTF8, 0, utf8, -1, wide, len);    return wide;}#endif
utf8_from_wide_char(const wchar_t *ws) {    int len = WideCharToMultiByte(CP_UTF8, 0, ws, -1, NULL, 0, NULL, NULL);    if (!len) {        return NULL;    }    char *utf8 = SDL_malloc(len);    if (!utf8) {        return NULL;    }    WideCharToMultiByte(CP_UTF8, 0, ws, -1, utf8, len, NULL, NULL);    return utf8;}
static SDL_bool push_server(const char *serial) {    const char *server_path = getenv("SCRCPY_SERVER_JAR");    if (!server_path) {        server_path = "scrcpy-server.jar";    }    process_t process = adb_push(serial, server_path, "/data/local/tmp/scrcpy-server.jar");    return process_check_success(process, "adb push");}
static SDL_bool push_server(const char *serial) {    const char *server_path = getenv("SCRCPY_SERVER_JAR");    if (!server_path) {        server_path = "scrcpy-server.jar";    }    process_t process = adb_push(serial, server_path, "/data/local/tmp/scrcpy-server.jar");    return process_check_success(process, "adb push");}
static SDL_bool push_server(const char *serial) {    process_t process = adb_push(serial, get_server_path(), "/data/local/tmp/scrcpy-server.jar");    return process_check_success(process, "adb push");}
static const char *get_server_path(void) {    const char *server_path = getenv("SCRCPY_SERVER_JAR");    if (!server_path) {        server_path = DEFAULT_SERVER_JAR;    }    return server_path;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    // initialize the receiver state    decoder->receiver_state.frame_meta_queue = NULL;    decoder->receiver_state.remaining = 0;    // if recording is enabled, a "header" is sent between raw packets    int (*read_packet)(void *, uint8_t *, int) =            decoder->recorder ? read_packet_with_meta : read_raw_packet;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder,                                               read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        if (decoder->recorder) {            // we retrieve the PTS in order they were received, so they will            // be assigned to the correct frame            uint64_t pts = receiver_state_take_meta(&decoder->receiver_state);            packet.pts = pts;            packet.dts = pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(decoder->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto run_quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_free(avio_ctx->buffer);    av_free(avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    // initialize the receiver state    decoder->receiver_state.frame_meta_queue = NULL;    decoder->receiver_state.remaining = 0;    // if recording is enabled, a "header" is sent between raw packets    int (*read_packet)(void *, uint8_t *, int) =            decoder->recorder ? read_packet_with_meta : read_raw_packet;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder,                                               read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#ifdef SCRCPY_LAVF_HAS_NEW_ENCODING_DECODING_API        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        if (decoder->recorder) {            // we retrieve the PTS in order they were received, so they will            // be assigned to the correct frame            uint64_t pts = receiver_state_take_meta(&decoder->receiver_state);            packet.pts = pts;            packet.dts = pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(decoder->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto run_quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_free(avio_ctx->buffer);    av_free(avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .record_format = 0,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = SDL_FALSE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .record_format = 0,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = SDL_FALSE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
recorder_write_header(struct recorder *recorder, AVPacket *packet) {    AVStream *ostream = recorder->ctx->streams[0];    uint8_t *extradata = av_malloc(packet->size * sizeof(uint8_t));    if (!extradata) {        LOGC("Cannot allocate extradata");        return SDL_FALSE;    }    // copy the first packet to the extra data    memcpy(extradata, packet->data, packet->size);#ifdef LAVF_NEW_CODEC_API    ostream->codecpar->extradata = extradata;    ostream->codecpar->extradata_size = packet->size;#else    ostream->codec->extradata = extradata;    ostream->codec->extradata_size = packet->size;#endif    int ret = avformat_write_header(recorder->ctx, NULL);    if (ret < 0) {        LOGE("Failed to write header to %s", recorder->filename);        SDL_free(extradata);        avio_closep(&recorder->ctx->pb);        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    return SDL_TRUE;}
SDL_bool recorder_open(struct recorder *recorder, AVCodec *input_codec) {    const char *format_name = recorder_get_format_name(recorder->format);    SDL_assert(format_name);    const AVOutputFormat *format = find_muxer(format_name);    if (!format) {        LOGE("Could not find muxer");        return SDL_FALSE;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return SDL_FALSE;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) format;    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }#ifdef LAVF_NEW_CODEC_API    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    LOGI("Recording started to %s file: %s", format_name, recorder->filename);    return SDL_TRUE;}
static const AVOutputFormat *find_muxer(const char *name) {#if LIBAVFORMAT_VERSION_INT >= AV_VERSION_INT(58, 9, 100)    void *opaque = NULL;#endif    const AVOutputFormat *oformat = NULL;    do {#if LIBAVFORMAT_VERSION_INT >= AV_VERSION_INT(58, 9, 100)        oformat = av_muxer_iterate(&opaque);#else        oformat = av_oformat_next(oformat);#endif        // until null or with name "mp4"    } while (oformat && strcmp(oformat->name, name));    return oformat;}
recorder_write_header(struct recorder *recorder, AVPacket *packet) {    AVStream *ostream = recorder->ctx->streams[0];    uint8_t *extradata = av_malloc(packet->size * sizeof(uint8_t));    if (!extradata) {        LOGC("Cannot allocate extradata");        return SDL_FALSE;    }    // copy the first packet to the extra data    memcpy(extradata, packet->data, packet->size);#ifdef SCRCPY_LAVF_HAS_NEW_CODEC_PARAMS_API    ostream->codecpar->extradata = extradata;    ostream->codecpar->extradata_size = packet->size;#else    ostream->codec->extradata = extradata;    ostream->codec->extradata_size = packet->size;#endif    int ret = avformat_write_header(recorder->ctx, NULL);    if (ret < 0) {        LOGE("Failed to write header to %s", recorder->filename);        SDL_free(extradata);        avio_closep(&recorder->ctx->pb);        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    return SDL_TRUE;}
SDL_bool recorder_open(struct recorder *recorder, AVCodec *input_codec) {    const char *format_name = recorder_get_format_name(recorder->format);    SDL_assert(format_name);    const AVOutputFormat *format = find_muxer(format_name);    if (!format) {        LOGE("Could not find muxer");        return SDL_FALSE;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return SDL_FALSE;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) format;    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }#ifdef SCRCPY_LAVF_HAS_NEW_CODEC_PARAMS_API    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    LOGI("Recording started to %s file: %s", format_name, recorder->filename);    return SDL_TRUE;}
static const AVOutputFormat *find_muxer(const char *name) {#ifdef SCRCPY_LAVF_HAS_NEW_MUXER_ITERATOR_API    void *opaque = NULL;#endif    const AVOutputFormat *oformat = NULL;    do {#ifdef SCRCPY_LAVF_HAS_NEW_MUXER_ITERATOR_API        oformat = av_muxer_iterate(&opaque);#else        oformat = av_oformat_next(oformat);#endif        // until null or with name "mp4"    } while (oformat && strcmp(oformat->name, name));    return oformat;}
SDL_bool sdl_init_and_configure(void) {    if (SDL_Init(SDL_INIT_VIDEO)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return SDL_FALSE;    }    atexit(SDL_Quit);    // Use the best available scale quality    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "2")) {        LOGW("Could not enable bilinear filtering");    }#if SDL_VERSION_ATLEAST(2, 0, 5)    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return SDL_TRUE;}
static SDL_bool get_preferred_display_bounds(struct size *bounds) {    SDL_Rect rect;#if SDL_VERSION_ATLEAST(2, 0, 5)# define GET_DISPLAY_BOUNDS(i, r) SDL_GetDisplayUsableBounds((i), (r))#else# define GET_DISPLAY_BOUNDS(i, r) SDL_GetDisplayBounds((i), (r))#endif    if (GET_DISPLAY_BOUNDS(0, &rect)) {        LOGW("Could not get display usable bounds: %s", SDL_GetError());        return SDL_FALSE;    }    bounds->width = MAX(0, rect.w - DISPLAY_MARGINS);    bounds->height = MAX(0, rect.h - DISPLAY_MARGINS);    return SDL_TRUE;}
SDL_bool sdl_init_and_configure(void) {    if (SDL_Init(SDL_INIT_VIDEO)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return SDL_FALSE;    }    atexit(SDL_Quit);    // Use the best available scale quality    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "2")) {        LOGW("Could not enable bilinear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return SDL_TRUE;}
static SDL_bool get_preferred_display_bounds(struct size *bounds) {    SDL_Rect rect;#ifdef SCRCPY_SDL_HAS_GET_DISPLAY_USABLE_BOUNDS# define GET_DISPLAY_BOUNDS(i, r) SDL_GetDisplayUsableBounds((i), (r))#else# define GET_DISPLAY_BOUNDS(i, r) SDL_GetDisplayBounds((i), (r))#endif    if (GET_DISPLAY_BOUNDS(0, &rect)) {        LOGW("Could not get display usable bounds: %s", SDL_GetError());        return SDL_FALSE;    }    bounds->width = MAX(0, rect.w - DISPLAY_MARGINS);    bounds->height = MAX(0, rect.h - DISPLAY_MARGINS);    return SDL_TRUE;}
static void show_err_msg(int err) {#ifdef __WINDOWS__    (void) err; // unused    LOGE("Failed to execute adb");#else    switch (err) {        case -1:            LOGE("Failed to execute adb");            break;        case ENOENT:            LOGE("'adb' command not found (make it accessible from your PATH "                  "or define its full path in the ADB environment variable)");            break;        default:            LOGE("Failed to execute adb: %s", strerror(err));            break;    }#endif}
static void show_err_msg(int err) {#ifdef __WINDOWS__    (void) err; // unused    LOGE("Failed to execute adb");#else    switch (err) {        case -1:            LOGE("Failed to execute adb");            break;        case ENOENT:            LOGE("'adb' command not found (make it accessible from your PATH "                  "or define its full path in the ADB environment variable)");            break;        default:            LOGE("Failed to execute adb: %s", strerror(err));            break;    }#endif}
process_t adb_execute(const char *serial, const char *const adb_cmd[], int len) {    const char *cmd[len + 4];    int i;    process_t process;    cmd[0] = get_adb_command();    if (serial) {        cmd[1] = "-s";        cmd[2] = serial;        i = 3;    } else {        i = 1;    }    memcpy(&cmd[i], adb_cmd, len * sizeof(const char *));    cmd[len + i] = NULL;    int r = cmd_execute(cmd[0], cmd, &process);    if (r != 0) {        show_err_msg(r);        return PROCESS_NONE;    }    return process;}
            LOGE("Failed to execute adb");            break;        case PROCESS_ERROR_MISSING_BINARY:            LOGE("'adb' command not found (make it accessible from your PATH "                  "or define its full path in the ADB environment variable)");            break;        case PROCESS_SUCCESS:            /* do nothing */            break;    }}process_t adb_execute(const char *serial, const char *const adb_cmd[], int len) {    const char *cmd[len + 4];    int i;    process_t process;    cmd[0] = get_adb_command();    if (serial) {        cmd[1] = "-s";        cmd[2] = serial;
static void show_adb_err_msg(enum process_result err) {    switch (err) {        case PROCESS_ERROR_GENERIC:            LOGE("Failed to execute adb");            break;        case PROCESS_ERROR_MISSING_BINARY:            LOGE("'adb' command not found (make it accessible from your PATH "                  "or define its full path in the ADB environment variable)");            break;        case PROCESS_SUCCESS:            /* do nothing */            break;    }}
process_t adb_execute(const char *serial, const char *const adb_cmd[], int len) {    const char *cmd[len + 4];    int i;    process_t process;    cmd[0] = get_adb_command();    if (serial) {        cmd[1] = "-s";        cmd[2] = serial;        i = 3;    } else {        i = 1;    }    memcpy(&cmd[i], adb_cmd, len * sizeof(const char *));    cmd[len + i] = NULL;    enum process_result r = cmd_execute(cmd[0], cmd, &process);    if (r != PROCESS_SUCCESS) {        show_adb_err_msg(r);        return PROCESS_NONE;    }    return process;}
int cmd_execute(const char *path, const char *const argv[], pid_t *pid) {    int fd[2];    int ret = 0;    if (pipe(fd) == -1) {        perror("pipe");        return -1;    }    *pid = fork();    if (*pid == -1) {        perror("fork");        ret = -1;        goto end;    }    if (*pid > 0) {        // parent close write side        close(fd[1]);        fd[1] = -1;        // wait for EOF or receive errno from child        if (read(fd[0], &ret, sizeof(int)) == -1) {            perror("read");            ret = -1;            goto end;        }    } else if (*pid == 0) {        // child close read side        close(fd[0]);        if (fcntl(fd[1], F_SETFD, FD_CLOEXEC) == 0) {            execvp(path, (char *const *)argv);        } else {            perror("fcntl");        }        // send errno to the parent        ret = errno;        if (write(fd[1], &ret, sizeof(int)) == -1) {            perror("write");        }        // close write side before exiting        close(fd[1]);        _exit(1);    }end:    if (fd[0] != -1) {        close(fd[0]);    }    if (fd[1] != -1) {        close(fd[1]);    }    return ret;}
enum process_result cmd_execute(const char *path, const char *const argv[], pid_t *pid) {    int fd[2];    if (pipe(fd) == -1) {        perror("pipe");        return PROCESS_ERROR_GENERIC;    }    enum process_result ret = PROCESS_SUCCESS;    *pid = fork();    if (*pid == -1) {        perror("fork");        ret = PROCESS_ERROR_GENERIC;        goto end;    }    if (*pid > 0) {        // parent close write side        close(fd[1]);        fd[1] = -1;        // wait for EOF or receive errno from child        if (read(fd[0], &ret, sizeof(ret)) == -1) {            perror("read");            ret = PROCESS_ERROR_GENERIC;            goto end;        }    } else if (*pid == 0) {        // child close read side        close(fd[0]);        if (fcntl(fd[1], F_SETFD, FD_CLOEXEC) == 0) {            execvp(path, (char *const *)argv);            if (errno == ENOENT) {                ret = PROCESS_ERROR_MISSING_BINARY;            } else {                ret = PROCESS_ERROR_GENERIC;            }            perror("exec");        } else {            perror("fcntl");            ret = PROCESS_ERROR_GENERIC;        }        // send ret to the parent        if (write(fd[1], &ret, sizeof(ret)) == -1) {            perror("write");        }        // close write side before exiting        close(fd[1]);        _exit(1);    }end:    if (fd[0] != -1) {        close(fd[0]);    }    if (fd[1] != -1) {        close(fd[1]);    }    return ret;}
int cmd_execute(const char *path, const char *const argv[], HANDLE *handle) {    STARTUPINFO si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    // Windows command-line parsing is WTF:    // <http://daviddeley.com/autohotkey/parameters/parameters.htm#WINPASS>    // only make it work for this very specific program    // (don't handle escaping nor quotes)    char cmd[256];    size_t ret = xstrjoin(cmd, argv, ' ', sizeof(cmd));    if (ret >= sizeof(cmd)) {        LOGE("Command too long (%" PRIsizet " chars)", sizeof(cmd) - 1);        *handle = NULL;        return -1;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, flags, NULL, NULL, &si, &pi)) {        *handle = NULL;        return -1;    }    *handle = pi.hProcess;    return 0;}
enum process_result cmd_execute(const char *path, const char *const argv[], HANDLE *handle) {    STARTUPINFO si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    // Windows command-line parsing is WTF:    // <http://daviddeley.com/autohotkey/parameters/parameters.htm#WINPASS>    // only make it work for this very specific program    // (don't handle escaping nor quotes)    char cmd[256];    size_t ret = xstrjoin(cmd, argv, ' ', sizeof(cmd));    if (ret >= sizeof(cmd)) {        LOGE("Command too long (%" PRIsizet " chars)", sizeof(cmd) - 1);        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, flags, NULL, NULL, &si, &pi)) {        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }    *handle = pi.hProcess;    return PROCESS_SUCCESS;}
    public DisplayManager getDisplayManager() {        return new DisplayManager(getService("display", "android.hardware.display.IDisplayManager"));    }
    public WindowManager getWindowManager() {        return new WindowManager(getService("window", "android.view.IWindowManager"));    }
    public InputManager getInputManager() {        return new InputManager(getService("input", "android.hardware.input.IInputManager"));    }
    public PowerManager getPowerManager() {        return new PowerManager(getService("power", "android.os.IPowerManager"));    }}
    public DisplayManager getDisplayManager() {        if (displayManager == null) {            displayManager = new DisplayManager(getService("display", "android.hardware.display.IDisplayManager"));        }        return displayManager;    }
    public WindowManager getWindowManager() {        if (windowManager == null) {            windowManager = new WindowManager(getService("window", "android.view.IWindowManager"));        }        return windowManager;    }
    public InputManager getInputManager() {        if (inputManager == null) {            inputManager = new InputManager(getService("input", "android.hardware.input.IInputManager"));        }        return inputManager;    }
    public PowerManager getPowerManager() {        if (powerManager == null) {            powerManager = new PowerManager(getService("power", "android.os.IPowerManager"));        }        return powerManager;    }}
file_handler_destroy(struct file_handler *file_handler) {    SDL_DestroyCond(file_handler->event_cond);    SDL_DestroyMutex(file_handler->mutex);    request_queue_destroy(&file_handler->queue);    SDL_free((void *) file_handler->serial);}
file_handler_destroy(struct file_handler *file_handler) {    SDL_DestroyCond(file_handler->event_cond);    SDL_DestroyMutex(file_handler->mutex);    request_queue_destroy(&file_handler->queue);    SDL_free(file_handler->serial);}
static SDL_bool event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return SDL_FALSE;            case SDL_QUIT:                LOGD("User requested to quit");                return SDL_TRUE;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return SDL_FALSE;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                    case SDL_WINDOWEVENT_EXPOSED:                    case SDL_WINDOWEVENT_SIZE_CHANGED:                        screen_render(&screen);                        break;                }                break;            case SDL_TEXTINPUT:                input_manager_process_text_input(&input_manager, &event.text);                break;            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL:                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP:                input_manager_process_mouse_button(&input_manager, &event.button);                break;            case SDL_DROPFILE:                file_handler_do(&file_handler, event.drop.file);                break;        }    }    return SDL_FALSE;}
static SDL_bool event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return SDL_FALSE;            case SDL_QUIT:                LOGD("User requested to quit");                return SDL_TRUE;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return SDL_FALSE;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                    case SDL_WINDOWEVENT_EXPOSED:                    case SDL_WINDOWEVENT_SIZE_CHANGED:                        screen_render(&screen);                        break;                }                break;            case SDL_TEXTINPUT:                input_manager_process_text_input(&input_manager, &event.text);                break;            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL:                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP:                input_manager_process_mouse_button(&input_manager, &event.button);                break;            case SDL_DROPFILE:                file_handler_do(&file_handler, event.drop.file);                break;        }    }    return SDL_FALSE;}
static SDL_bool event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return SDL_FALSE;            case SDL_QUIT:                LOGD("User requested to quit");                return SDL_TRUE;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return SDL_FALSE;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                    case SDL_WINDOWEVENT_EXPOSED:                    case SDL_WINDOWEVENT_SIZE_CHANGED:                        screen_render(&screen);                        break;                }                break;            case SDL_TEXTINPUT:                input_manager_process_text_input(&input_manager, &event.text);                break;            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL:                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP:                input_manager_process_mouse_button(&input_manager, &event.button);                break;            case SDL_DROPFILE: {                file_handler_action_t action;                if (is_apk(event.drop.file)) {                    action = ACTION_INSTALL_APK;                } else {                    action = ACTION_PUSH_FILE;                }                file_handler_request(&file_handler, action, event.drop.file);                break;            }        }    }    return SDL_FALSE;}
static SDL_bool is_apk(const char *file) {    const char *ext = strrchr(file, '.');    return ext && !strcmp(ext, ".apk");}
static void test_serialize_text_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_TEXT,        .text_event = {            .text = "hello, world!",        },    };    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 16);    const unsigned char expected[] = {        0x01, // CONTROL_EVENT_TYPE_TEXT        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_text_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_TEXT,        .text_event = {            .text = "hello, world!",        },    };    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 16);    const unsigned char expected[] = {        0x01, // CONTROL_EVENT_TYPE_TEXT        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_text_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_TEXT,        .text_event = {            .text = "hello, world!",        },    };    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 16);    const unsigned char expected[] = {        0x01, // CONTROL_EVENT_TYPE_TEXT        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}
int main(void) {    test_serialize_keycode_event();    test_serialize_text_event();    test_serialize_long_text_event();    test_serialize_mouse_event();    test_serialize_scroll_event();    return 0;}
static void test_serialize_collapse_notification_panel_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_COLLAPSE_NOTIFICATION_PANEL,    };    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 1);    const unsigned char expected[] = {        0x06, // CONTROL_EVENT_TYPE_COLLAPSE_NOTIFICATION_PANEL    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_expand_notification_panel_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_EXPAND_NOTIFICATION_PANEL,    };    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 1);    const unsigned char expected[] = {        0x05, // CONTROL_EVENT_TYPE_EXPAND_NOTIFICATION_PANEL    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_back_or_screen_on_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_BACK_OR_SCREEN_ON,    };    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 1);    const unsigned char expected[] = {        0x04, // CONTROL_EVENT_TYPE_BACK_OR_SCREEN_ON    };    assert(!memcmp(buf, expected, sizeof(expected)));}
int main(void) {    test_serialize_keycode_event();    test_serialize_text_event();    test_serialize_long_text_event();    test_serialize_mouse_event();    test_serialize_scroll_event();    test_serialize_back_or_screen_on_event();    test_serialize_expand_notification_panel_event();    test_serialize_collapse_notification_panel_event();    return 0;}
        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(KeyEvent.META_CTRL_ON);
        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(KeyEvent.META_CTRL_ON);
        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(KeyEvent.META_CTRL_ON);
        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_KEYCODE);        dos.writeByte(KeyEvent.ACTION_UP);        dos.writeInt(KeyEvent.KEYCODE_ENTER);        dos.writeInt(KeyEvent.META_CTRL_ON);
    public void testParseScrollEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_SCROLL);        dos.writeInt(260);        dos.writeInt(1026);        dos.writeShort(1080);        dos.writeShort(1920);        dos.writeInt(1);        dos.writeInt(-1);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_SCROLL, event.getType());        Assert.assertEquals(260, event.getPosition().getPoint().getX());        Assert.assertEquals(1026, event.getPosition().getPoint().getY());        Assert.assertEquals(1080, event.getPosition().getScreenSize().getWidth());        Assert.assertEquals(1920, event.getPosition().getScreenSize().getHeight());        Assert.assertEquals(1, event.getHScroll());        Assert.assertEquals(-1, event.getVScroll());    }
    public void testParseCollapseNotificationPanelEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_COLLAPSE_NOTIFICATION_PANEL);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_COLLAPSE_NOTIFICATION_PANEL, event.getType());    }
    public void testParseBackOrScreenOnEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_BACK_OR_SCREEN_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_BACK_OR_SCREEN_ON, event.getType());    }
    public void testParseExpandNotificationPanelEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_EXPAND_NOTIFICATION_PANEL);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_EXPAND_NOTIFICATION_PANEL, event.getType());    }
ssize_t net_send(socket_t socket, void *buf, size_t len) {    return send(socket, buf, len, 0);}
ssize_t net_send_all(socket_t socket, void *buf, size_t len) {    ssize_t w;    while (len > 0) {        w = send(socket, buf, len, 0);        if (w == -1) {            return -1;        }        len -= w;        buf += w;    }    return w;}
ssize_t net_send_all(socket_t socket, void *buf, size_t len) {    ssize_t w;    while (len > 0) {        w = send(socket, buf, len, 0);        if (w == -1) {            return -1;        }        len -= w;        buf += w;    }    return w;}
ssize_t net_send(socket_t socket, void *buf, size_t len) {    return send(socket, buf, len, 0);}
ssize_t net_send(socket_t socket, const void *buf, size_t len) {    return send(socket, buf, len, 0);}
ssize_t net_send_all(socket_t socket, const void *buf, size_t len) {    ssize_t w;    while (len > 0) {        w = send(socket, buf, len, 0);        if (w == -1) {            return -1;        }        len -= w;        buf += w;    }    return w;}
ssize_t net_send_all(socket_t socket, const void *buf, size_t len) {    ssize_t w;    while (len > 0) {        w = send(socket, buf, len, 0);        if (w == -1) {            return -1;        }        len -= w;        buf += w;    }    return w;}
ssize_t net_send(socket_t socket, const void *buf, size_t len) {    return send(socket, buf, len, 0);}
socket_t net_listen(Uint32 addr, Uint16 port, int backlog) {    socket_t sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        LOGE("Cannot create socket");        return INVALID_SOCKET;    }    SOCKADDR_IN sin;    sin.sin_family = AF_INET;    sin.sin_addr.s_addr = htonl(addr); // htonl() harmless on INADDR_ANY    sin.sin_port = htons(port);    if (bind(sock, (SOCKADDR *) &sin, sizeof(sin)) == SOCKET_ERROR) {        LOGE("Cannot bind");        return INVALID_SOCKET;    }    if (listen(sock, backlog) == SOCKET_ERROR) {        LOGE("Cannot listen on port %" PRIu16, port);        return INVALID_SOCKET;    }    return sock;}
socket_t net_listen(Uint32 addr, Uint16 port, int backlog) {    socket_t sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        perror("socket");        return INVALID_SOCKET;    }    SOCKADDR_IN sin;    sin.sin_family = AF_INET;    sin.sin_addr.s_addr = htonl(addr); // htonl() harmless on INADDR_ANY    sin.sin_port = htons(port);    if (bind(sock, (SOCKADDR *) &sin, sizeof(sin)) == SOCKET_ERROR) {        perror("bind");        return INVALID_SOCKET;    }    if (listen(sock, backlog) == SOCKET_ERROR) {        perror("listen");        return INVALID_SOCKET;    }    return sock;}
SDL_bool server_start(struct server *server, const char *serial, Uint16 local_port,                      Uint16 max_size, Uint32 bit_rate) {    if (!push_server(serial)) {        return SDL_FALSE;    }    if (!enable_tunnel(serial, local_port)) {        return SDL_FALSE;    }    // At the application level, the device part is "the server" because it    // serves video stream and control. However, at network level, the client    // listens and the server connects to the client. That way, the client can    // listen before starting the server app, so there is no need to try to    // connect until the server socket is listening on the device.    server->server_socket = listen_on_port(local_port);    if (server->server_socket == INVALID_SOCKET) {        LOGE("Could not listen on port %" PRIu16, local_port);        disable_tunnel(serial);        return SDL_FALSE;    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate);    if (server->process == PROCESS_NONE) {        net_close(server->server_socket);        disable_tunnel(serial);        return SDL_FALSE;    }    server->adb_reverse_enabled = SDL_TRUE;    return SDL_TRUE;}
void server_stop(struct server *server, const char *serial) {    SDL_assert(server->process != PROCESS_NONE);    if (server->device_socket != INVALID_SOCKET) {        // shutdown the socket to finish the device process gracefully        net_shutdown(server->device_socket, SHUT_RDWR);    }    LOGD("Waiting the server to complete execution on the device...");    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->adb_reverse_enabled) {        // ignore failure        disable_tunnel(serial);    }}
void server_stop(struct server *server, const char *serial) {    SDL_assert(server->process != PROCESS_NONE);    if (server->device_socket != INVALID_SOCKET) {        // shutdown the socket to finish the device process gracefully        net_shutdown(server->device_socket, SHUT_RDWR);    }    LOGD("Waiting the server to complete execution on the device...");    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->adb_reverse_enabled) {        // ignore failure        disable_tunnel(serial);    }}
socket_t server_connect_to(struct server *server, const char *serial, Uint32 timeout_ms) {    server->device_socket = net_accept(server->server_socket);    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    // we don't need the server socket anymore    net_close(server->server_socket);    server->server_socket = INVALID_SOCKET;    // we don't need the adb tunnel anymore    disable_tunnel(serial); // ignore failure    server->adb_reverse_enabled = SDL_FALSE;    return server->device_socket;}
void server_destroy(struct server *server) {    if (server->server_socket != INVALID_SOCKET) {        net_close(server->server_socket);    }    if (server->device_socket != INVALID_SOCKET) {        net_close(server->device_socket);    }}
SDL_bool server_start(struct server *server, const char *serial, Uint16 local_port,                      Uint16 max_size, Uint32 bit_rate) {    if (!push_server(serial)) {        return SDL_FALSE;    }    if (!enable_tunnel(serial, local_port)) {        return SDL_FALSE;    }    // At the application level, the device part is "the server" because it    // serves video stream and control. However, at network level, the client    // listens and the server connects to the client. That way, the client can    // listen before starting the server app, so there is no need to try to    // connect until the server socket is listening on the device.    server->server_socket = listen_on_port(local_port);    if (server->server_socket == INVALID_SOCKET) {        LOGE("Could not listen on port %" PRIu16, local_port);        disable_tunnel(serial);        return SDL_FALSE;    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate);    if (server->process == PROCESS_NONE) {        close_socket(&server->server_socket);        disable_tunnel(serial);        return SDL_FALSE;    }    server->adb_reverse_enabled = SDL_TRUE;    return SDL_TRUE;}
void server_stop(struct server *server, const char *serial) {    SDL_assert(server->process != PROCESS_NONE);    if (server->device_socket != INVALID_SOCKET) {        // shutdown the socket to finish the device process gracefully        if (!net_shutdown(server->device_socket, SHUT_RDWR)) {            LOGW("Cannot shutdown socket");        }    }    LOGD("Waiting the server to complete execution on the device...");    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->adb_reverse_enabled) {        // ignore failure        disable_tunnel(serial);    }}
static void close_socket(socket_t *socket) {    SDL_assert(*socket != INVALID_SOCKET);    if (!net_close(*socket)) {        LOGW("Cannot close socket");        return;    }    *socket = INVALID_SOCKET;}
socket_t server_connect_to(struct server *server, const char *serial, Uint32 timeout_ms) {    server->device_socket = net_accept(server->server_socket);    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    // we don't need the server socket anymore    close_socket(&server->server_socket);    // we don't need the adb tunnel anymore    disable_tunnel(serial); // ignore failure    server->adb_reverse_enabled = SDL_FALSE;    return server->device_socket;}
void server_destroy(struct server *server) {    if (server->server_socket != INVALID_SOCKET) {        close_socket(&server->server_socket);    }    if (server->device_socket != INVALID_SOCKET) {        close_socket(&server->device_socket);    }}
void net_close(socket_t socket) {    close(socket);}
SDL_bool net_close(socket_t socket) {    return !close(socket);}
void net_close(socket_t socket) {    closesocket(socket);}
SDL_bool net_close(socket_t socket) {    return !closesocket(socket);}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = server_connect_to(&server, serial);    if (!device_socket) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server, serial);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // kill the server before decoder_join() to wake up the decoder    server_stop(&server, serial);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
static void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");                return;            case SDL_QUIT:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!screen_update_frame(&screen, &frames)) {                    return;                }                count_frame(); // display fps for debug                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;                }                break;            case SDL_TEXTINPUT: {                screencontrol_handle_text_input(&controller, &screen, &event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                screencontrol_handle_key(&controller, &screen, &event.key);                break;            case SDL_MOUSEMOTION:                screencontrol_handle_mouse_motion(&controller, &screen, &event.motion);                break;            case SDL_MOUSEWHEEL: {                screencontrol_handle_mouse_wheel(&controller, &screen, &event.wheel);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                screencontrol_handle_mouse_button(&controller, &screen, &event.button);                break;            }        }    }}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = server_connect_to(&server, serial);    if (!device_socket) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server, serial);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // kill the server before decoder_join() to wake up the decoder    server_stop(&server, serial);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
static void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");                return;            case SDL_QUIT:                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return;                }                count_frame(); // display fps for debug                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;                }                break;            case SDL_TEXTINPUT: {                screencontrol_handle_text_input(&controller, &screen, &event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                screencontrol_handle_key(&controller, &screen, &event.key);                break;            case SDL_MOUSEMOTION:                screencontrol_handle_mouse_motion(&controller, &screen, &event.motion);                break;            case SDL_MOUSEWHEEL: {                screencontrol_handle_mouse_wheel(&controller, &screen, &event.wheel);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                screencontrol_handle_mouse_button(&controller, &screen, &event.button);                break;            }        }    }}
SDL_bool screen_init_rendering(struct screen *screen, const char *device_name, struct size frame_size) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!screen->window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1, SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    screen->texture = SDL_CreateTexture(screen->renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                                        frame_size.width, frame_size.height);    if (!screen->texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    screen_render(screen);    return SDL_TRUE;}
void screen_render(struct screen *screen) {    SDL_RenderClear(screen->renderer);    if (screen->texture_initialized) {        SDL_RenderCopy(screen->renderer, screen->texture, NULL, NULL);    }    SDL_RenderPresent(screen->renderer);}
void screen_render(struct screen *screen) {    SDL_RenderClear(screen->renderer);    if (screen->texture_initialized) {        SDL_RenderCopy(screen->renderer, screen->texture, NULL, NULL);    }    SDL_RenderPresent(screen->renderer);}
static void update_texture(struct screen *screen, const AVFrame *frame) {    screen->texture_initialized = SDL_TRUE;    SDL_UpdateYUVTexture(screen->texture, NULL,            frame->data[0], frame->linesize[0],            frame->data[1], frame->linesize[1],            frame->data[2], frame->linesize[2]);}
SDL_bool screen_init_rendering(struct screen *screen, const char *device_name, struct size frame_size) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height, SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE);    if (!screen->window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1, SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    screen->texture = SDL_CreateTexture(screen->renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                                        frame_size.width, frame_size.height);    if (!screen->texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    screen_render(screen);    return SDL_TRUE;}
void screen_render(struct screen *screen) {    SDL_RenderClear(screen->renderer);    SDL_RenderCopy(screen->renderer, screen->texture, NULL, NULL);    SDL_RenderPresent(screen->renderer);}
void screen_show_window(struct screen *screen) {    SDL_ShowWindow(screen->window);}
    return SDL_TRUE;}// write the frame into the texturestatic void update_texture(struct screen *screen, const AVFrame *frame) {    SDL_UpdateYUVTexture(screen->texture, NULL,            frame->data[0], frame->linesize[0],            frame->data[1], frame->linesize[1],
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    if (!scrcpy_parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        scrcpy_print_usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    LOGI("scrcpy " SCRCPY_VERSION " <https://github.com/Genymobile/scrcpy>");#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifndef NDEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    int res = scrcpy(&args.opts) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif#ifndef NDEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_cli_args args = {        .opts = SCRCPY_OPTIONS_DEFAULT,        .help = false,        .version = false,    };    if (!scrcpy_parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        scrcpy_print_usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    LOGI("scrcpy " SCRCPY_VERSION " <https://github.com/Genymobile/scrcpy>");#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }    int res = scrcpy(&args.opts) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
static void event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return;            case SDL_QUIT:                LOGD("User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;                }                break;            case SDL_TEXTINPUT: {                input_manager_process_text_input(&input_manager, &event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL: {                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                input_manager_process_mouse_button(&input_manager, &event.button);                break;            }        }    }}
static void event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return;            case SDL_QUIT:                LOGD("User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                    case SDL_WINDOWEVENT_EXPOSED:                    case SDL_WINDOWEVENT_SIZE_CHANGED:                        screen_render(&screen);                        break;                }                break;            case SDL_TEXTINPUT:                input_manager_process_text_input(&input_manager, &event.text);                break;            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL:                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP:                input_manager_process_mouse_button(&input_manager, &event.button);                break;        }    }}
SDL_bool recorder_write(struct recorder *recorder, AVPacket *packet) {    return av_write_frame(recorder->ctx, packet) >= 0;}
SDL_bool recorder_init(struct recorder *recorder, const char *filename,                       struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Cannot strdup filename");        return SDL_FALSE;    }    recorder->declared_frame_size = declared_frame_size;    return SDL_TRUE;}
SDL_bool recorder_init(struct recorder *recorder, const char *filename,                       struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Cannot strdup filename");        return SDL_FALSE;    }    recorder->declared_frame_size = declared_frame_size;    return SDL_TRUE;}
SDL_bool recorder_open(struct recorder *recorder, AVCodec *input_codec) {    const AVOutputFormat *mp4 = find_mp4_muxer();    if (!mp4) {        LOGE("Could not find mp4 muxer");        return SDL_FALSE;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return SDL_FALSE;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) mp4;    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }// In ffmpeg/doc/APIchanges:// 2016-04-11 - 6f69f7a / 9200514 - lavf 57.33.100 / 57.5.0 - avformat.h//   Add AVStream.codecpar, deprecate AVStream.codec.#if    (LIBAVFORMAT_VERSION_MICRO >= 100 /* FFmpeg */ && \        LIBAVFORMAT_VERSION_INT >= AV_VERSION_INT(57, 33, 100)) \    || (LIBAVFORMAT_VERSION_MICRO < 100 && /* Libav */ \        LIBAVFORMAT_VERSION_INT >= AV_VERSION_INT(57, 5, 0))    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    ostream->time_base = (AVRational) {1, 1000000}; // timestamps in us    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    ret = avformat_write_header(recorder->ctx, NULL);    if (ret < 0) {        LOGE("Failed to write header to %s", recorder->filename);        avio_closep(&recorder->ctx->pb);        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    return SDL_TRUE;}
SDL_bool recorder_write(struct recorder *recorder, AVPacket *packet) {    if (!recorder->header_written) {        SDL_bool ok = recorder_write_header(recorder, packet);        if (!ok) {            return SDL_FALSE;        }        recorder->header_written = SDL_TRUE;    }    return av_write_frame(recorder->ctx, packet) >= 0;}
SDL_bool recorder_init(struct recorder *recorder, const char *filename,                       struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Cannot strdup filename");        return SDL_FALSE;    }    recorder->declared_frame_size = declared_frame_size;    recorder->header_written = SDL_FALSE;    return SDL_TRUE;}
recorder_write_header(struct recorder *recorder, AVPacket *packet) {    AVStream *ostream = recorder->ctx->streams[0];    uint8_t *extradata = SDL_malloc(packet->size * sizeof(uint8_t));    if (!extradata) {        LOGC("Cannot allocate extradata");        return SDL_FALSE;    }    // copy the first packet to the extra data    memcpy(extradata, packet->data, packet->size);#ifdef LAVF_NEW_CODEC_API    ostream->codecpar->extradata = extradata;    ostream->codecpar->extradata_size = packet->size;#else    ostream->codec->extradata = extradata;    ostream->codec->extradata_size = packet->size;#endif    int ret = avformat_write_header(recorder->ctx, NULL);    if (ret < 0) {        LOGE("Failed to write header to %s", recorder->filename);        SDL_free(extradata);        avio_closep(&recorder->ctx->pb);        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    return SDL_TRUE;}
SDL_bool recorder_open(struct recorder *recorder, AVCodec *input_codec) {    const AVOutputFormat *mp4 = find_mp4_muxer();    if (!mp4) {        LOGE("Could not find mp4 muxer");        return SDL_FALSE;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return SDL_FALSE;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) mp4;    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }#ifdef LAVF_NEW_CODEC_API    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    ostream->time_base = (AVRational) {1, 1000000}; // timestamps in us    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    return SDL_TRUE;}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",   no_argument,       NULL, 'T'},        {"bit-rate",        required_argument, NULL, 'b'},        {"crop",            required_argument, NULL, 'c'},        {"fullscreen",      no_argument,       NULL, 'f'},        {"help",            no_argument,       NULL, 'h'},        {"max-size",        required_argument, NULL, 'm'},        {"no-control",      no_argument,       NULL, 'n'},        {"no-display",      no_argument,       NULL, 'N'},        {"port",            required_argument, NULL, 'p'},        {"record",          required_argument, NULL, 'r'},        {"record-format",   required_argument, NULL, 'f'},        {"serial",          required_argument, NULL, 's'},        {"show-touches",    no_argument,       NULL, 't'},        {"turn-screen-off", no_argument,       NULL, 'S'},        {"version",         no_argument,       NULL, 'v'},        {NULL,              0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return false;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = true;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return false;                }                break;            case 'n':                args->no_control = true;                break;            case 'N':                args->no_display = true;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return false;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 'S':                args->turn_screen_off = true;                break;            case 't':                args->show_touches = true;                break;            case 'T':                args->always_on_top = true;                break;            case 'v':                args->version = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (args->no_display && !args->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (args->no_display && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return false;        }    }    return true;}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, 'T'},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, 'c'},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, 'f'},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"version",               no_argument,       NULL, 'v'},        {NULL,                    0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return false;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = true;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return false;                }                break;            case 'n':                args->no_control = true;                break;            case 'N':                args->no_display = true;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return false;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 'S':                args->turn_screen_off = true;                break;            case 't':                args->show_touches = true;                break;            case 'T':                args->always_on_top = true;                break;            case 'v':                args->version = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (args->no_display && !args->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (args->no_display && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return false;        }    }    return true;}
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"bit-rate",     required_argument, NULL, 'b'},        {"crop",         required_argument, NULL, 'c'},        {"fullscreen",   no_argument,       NULL, 'f'},        {"help",         no_argument,       NULL, 'h'},        {"max-size",     required_argument, NULL, 'm'},        {"output-file",  required_argument, NULL, 'o'},        {"port",         required_argument, NULL, 'p'},        {"serial",       required_argument, NULL, 's'},        {"show-touches", no_argument,       NULL, 't'},        {"version",      no_argument,       NULL, 'v'},        {NULL,           0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fhm:o:p:s:tv", long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = SDL_TRUE;                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'o':                args->out_filename = optarg;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = SDL_TRUE;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    return SDL_TRUE;}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .out_filename = args.out_filename,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -o, --output-file\n"        "        Write video output to file.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"bit-rate",     required_argument, NULL, 'b'},        {"crop",         required_argument, NULL, 'c'},        {"fullscreen",   no_argument,       NULL, 'f'},        {"help",         no_argument,       NULL, 'h'},        {"max-size",     required_argument, NULL, 'm'},        {"port",         required_argument, NULL, 'p'},        {"record",       required_argument, NULL, 'r'},        {"serial",       required_argument, NULL, 's'},        {"show-touches", no_argument,       NULL, 't'},        {"version",      no_argument,       NULL, 'v'},        {NULL,           0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fhm:p:r:s:tv", long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = SDL_TRUE;                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = SDL_TRUE;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    return SDL_TRUE;}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    struct recorder *rec = NULL;    if (options->out_filename) {        if (!recorder_init(&recorder, options->out_filename, frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    decoder_init(&decoder, &frames, device_socket, rec);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_recorder:    if (options->out_filename) {        recorder_destroy(&recorder);    }finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    struct recorder *rec = NULL;    if (options->record_filename) {        if (!recorder_init(&recorder, options->record_filename, frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    decoder_init(&decoder, &frames, device_socket, rec);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_recorder:    if (options->record_filename) {        recorder_destroy(&recorder);    }finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .port = args.port,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .port = args.port,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
static int read_packet(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    uint8_t header[HEADER_SIZE];    int remaining;    int ret;    remaining = decoder->remaining;    if (remaining == 0) {        // the previous PTS read is now for the current frame        decoder->pts = decoder->next_pts;        // FIXME what if only part of the header is available?        ret = net_recv(decoder->video_socket, header, HEADER_SIZE);        if (ret <= 0)            return ret;        // read the PTS for the next frame        decoder->next_pts = buffer_read64be(header);        remaining = buffer_read32be(&header[8]);    }    if (buf_size > remaining)        buf_size = remaining;    ret = net_recv(decoder->video_socket, buf, buf_size);    if (ret <= 0)        return ret;    remaining -= ret;    decoder->remaining = remaining;    return ret;}
static int read_packet(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    uint8_t header[HEADER_SIZE];    int remaining;    int ret;    remaining = decoder->remaining;    if (remaining == 0) {        // the previous PTS read is now for the current frame        decoder->pts = decoder->next_pts;        ret = net_recv_all(decoder->video_socket, header, HEADER_SIZE);        if (ret <= 0)            return ret;        // no partial read (net_recv_all())        SDL_assert_release(ret == HEADER_SIZE);        // read the PTS for the next frame        decoder->next_pts = buffer_read64be(header);        remaining = buffer_read32be(&header[8]);    }    if (buf_size > remaining)        buf_size = remaining;    ret = net_recv(decoder->video_socket, buf, buf_size);    if (ret <= 0)        return ret;    remaining -= ret;    decoder->remaining = remaining;    return ret;}
    public static ControlMessage createInjectText(String text) {        ControlMessage event = new ControlMessage();        event.type = TYPE_INJECT_TEXT;        event.text = text;        return event;    }
    public static ControlMessage createInjectScrollEvent(Position position, int hScroll, int vScroll) {        ControlMessage event = new ControlMessage();        event.type = TYPE_INJECT_SCROLL_EVENT;        event.position = position;        event.hScroll = hScroll;        event.vScroll = vScroll;        return event;    }
    public static ControlMessage createInjectMouseEvent(int action, int buttons, Position position) {        ControlMessage event = new ControlMessage();        event.type = TYPE_INJECT_MOUSE_EVENT;        event.action = action;        event.buttons = buttons;        event.position = position;        return event;    }
    public static ControlMessage createInjectKeycode(int action, int keycode, int metaState) {        ControlMessage event = new ControlMessage();        event.type = TYPE_INJECT_KEYCODE;        event.action = action;        event.keycode = keycode;        event.metaState = metaState;        return event;    }
    public static ControlMessage createSetScreenPowerMode(int mode) {        ControlMessage event = new ControlMessage();        event.type = TYPE_SET_SCREEN_POWER_MODE;        event.action = mode;        return event;    }
    public static ControlMessage createSetClipboard(String text) {        ControlMessage event = new ControlMessage();        event.type = TYPE_SET_CLIPBOARD;        event.text = text;        return event;    }
    public static ControlMessage createEmpty(int type) {        ControlMessage event = new ControlMessage();        event.type = type;        return event;    }
    public static ControlMessage createInjectText(String text) {        ControlMessage msg = new ControlMessage();        msg.type = TYPE_INJECT_TEXT;        msg.text = text;        return msg;    }
    public static ControlMessage createInjectScrollEvent(Position position, int hScroll, int vScroll) {        ControlMessage msg = new ControlMessage();        msg.type = TYPE_INJECT_SCROLL_EVENT;        msg.position = position;        msg.hScroll = hScroll;        msg.vScroll = vScroll;        return msg;    }
    public static ControlMessage createInjectMouseEvent(int action, int buttons, Position position) {        ControlMessage msg = new ControlMessage();        msg.type = TYPE_INJECT_MOUSE_EVENT;        msg.action = action;        msg.buttons = buttons;        msg.position = position;        return msg;    }
    public static ControlMessage createInjectKeycode(int action, int keycode, int metaState) {        ControlMessage msg = new ControlMessage();        msg.type = TYPE_INJECT_KEYCODE;        msg.action = action;        msg.keycode = keycode;        msg.metaState = metaState;        return msg;    }
    public static ControlMessage createSetScreenPowerMode(int mode) {        ControlMessage msg = new ControlMessage();        msg.type = TYPE_SET_SCREEN_POWER_MODE;        msg.action = mode;        return msg;    }
    public static ControlMessage createSetClipboard(String text) {        ControlMessage msg = new ControlMessage();        msg.type = TYPE_SET_CLIPBOARD;        msg.text = text;        return msg;    }
    public static ControlMessage createEmpty(int type) {        ControlMessage msg = new ControlMessage();        msg.type = type;        return msg;    }
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!installer_init(&installer, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_installer;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_installer:    installer_stop(&installer);    installer_join(&installer);    installer_destroy(&installer);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
static SDL_bool event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return SDL_FALSE;            case SDL_QUIT:                LOGD("User requested to quit");                return SDL_TRUE;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return SDL_FALSE;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                    case SDL_WINDOWEVENT_EXPOSED:                    case SDL_WINDOWEVENT_SIZE_CHANGED:                        screen_render(&screen);                        break;                }                break;            case SDL_TEXTINPUT:                input_manager_process_text_input(&input_manager, &event.text);                break;            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL:                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP:                input_manager_process_mouse_button(&input_manager, &event.button);                break;            case SDL_DROPFILE:                installer_install_apk(&installer, event.drop.file);                break;        }    }    return SDL_FALSE;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_file_handler;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
static SDL_bool event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return SDL_FALSE;            case SDL_QUIT:                LOGD("User requested to quit");                return SDL_TRUE;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return SDL_FALSE;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                    case SDL_WINDOWEVENT_EXPOSED:                    case SDL_WINDOWEVENT_SIZE_CHANGED:                        screen_render(&screen);                        break;                }                break;            case SDL_TEXTINPUT:                input_manager_process_text_input(&input_manager, &event.text);                break;            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL:                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP:                input_manager_process_mouse_button(&input_manager, &event.button);                break;            case SDL_DROPFILE:                file_handler_do(&file_handler, event.drop.file);                break;        }    }    return SDL_FALSE;}
SDL_bool device_read_info(socket_t device_socket, char *device_name, struct size *size) {    unsigned char buf[DEVICE_NAME_FIELD_LENGTH + 4];    if (net_recv(device_socket, buf, sizeof(buf)) <= 0) {        LOGE("Could not retrieve device information");        return SDL_FALSE;    }    buf[DEVICE_NAME_FIELD_LENGTH - 1] = '\0'; // in case the client sends garbage    // strcpy is safe here, since name contains at least DEVICE_NAME_FIELD_LENGTH bytes    // and strlen(buf) < DEVICE_NAME_FIELD_LENGTH    strcpy(device_name, (char *) buf);    size->width = (buf[DEVICE_NAME_FIELD_LENGTH] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 1];    size->height = (buf[DEVICE_NAME_FIELD_LENGTH + 2] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 3];    return SDL_TRUE;}
SDL_bool device_read_info(socket_t device_socket, char *device_name, struct size *size) {    unsigned char buf[DEVICE_NAME_FIELD_LENGTH + 4];    int r = net_recv(device_socket, buf, sizeof(buf));    if (r < DEVICE_NAME_FIELD_LENGTH + 4) {        LOGE("Could not retrieve device information");        return SDL_FALSE;    }    buf[DEVICE_NAME_FIELD_LENGTH - 1] = '\0'; // in case the client sends garbage    // strcpy is safe here, since name contains at least DEVICE_NAME_FIELD_LENGTH bytes    // and strlen(buf) < DEVICE_NAME_FIELD_LENGTH    strcpy(device_name, (char *) buf);    size->width = (buf[DEVICE_NAME_FIELD_LENGTH] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 1];    size->height = (buf[DEVICE_NAME_FIELD_LENGTH + 2] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 3];    return SDL_TRUE;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "        resize window to optimal size (remove black borders)\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "        click on BACK\n"        "\n"        "    Ctrl+m\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+'+'\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+'-'\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click\n"        "        turn screen on\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "        click on BACK\n"        "\n"        "    Ctrl+m\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+'+'\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+'-'\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click\n"        "        turn screen on\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+'+'\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+'-'\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"bit-rate", required_argument, NULL, 'b'},        {"help",     no_argument,       NULL, 'h'},        {"max-size", required_argument, NULL, 'm'},        {"port",     required_argument, NULL, 'p'},        {"serial",   required_argument, NULL, 's'},        {"version",  no_argument,       NULL, 'v'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:hm:p:s:v", long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 's':                args->serial = optarg;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    return SDL_TRUE;}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .port = args.port,        .max_size = args.max_size,        .bit_rate = args.bit_rate,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+'+'\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+'-'\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"bit-rate",     required_argument, NULL, 'b'},        {"help",         no_argument,       NULL, 'h'},        {"max-size",     required_argument, NULL, 'm'},        {"port",         required_argument, NULL, 'p'},        {"serial",       required_argument, NULL, 's'},        {"show-touches", no_argument,       NULL, 't'},        {"version",      no_argument,       NULL, 'v'},        {NULL,           0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:hm:p:s:tv", long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = SDL_TRUE;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    return SDL_TRUE;}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .port = args.port,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        LOGI("Enable show_touches");        set_show_touches_enabled(options->serial, SDL_TRUE);    }    event_loop();    LOGD("quit...");    if (options->show_touches) {        LOGI("Disable show_touches");        set_show_touches_enabled(options->serial, SDL_FALSE);    }    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
static SDL_bool set_show_touches_enabled(const char *serial, SDL_bool enabled) {    const char *value = enabled ? "1" : "0";    const char *const adb_cmd[] = {        "shell", "settings", "put", "system", "show_touches", value    };    process_t proc = adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));    return process_check_success(proc, "show_touches");}
record_packet_new(const AVPacket *packet) {    struct record_packet *rec = SDL_malloc(sizeof(*rec));    if (!rec) {        return NULL;    }    if (av_packet_ref(&rec->packet, packet)) {        SDL_free(rec);        return NULL;    }    return rec;}
record_packet_new(const AVPacket *packet) {    struct record_packet *rec = SDL_malloc(sizeof(*rec));    if (!rec) {        return NULL;    }    // av_packet_ref() does not initialize all fields in old FFmpeg versions    // See <https://github.com/Genymobile/scrcpy/issues/707>    av_init_packet(&rec->packet);    if (av_packet_ref(&rec->packet, packet)) {        SDL_free(rec);        return NULL;    }    return rec;}
                    new EventController(device, connection).control();                } catch (IOException e) {                    e.printStackTrace();                }            }        }).start();    }
    public static void main(String... args) throws Exception {        Options options = new Options();        if (args.length > 0) {            int maximumSize = Integer.parseInt(args[0]) & ~7; // multiple of 8            options.setMaximumSize(maximumSize);        }        try {            scrcpy(options);        } catch (Throwable t) {            t.printStackTrace();            throw t;        }    }}
    private static Options createOptions(String... args) {        Options options = new Options();        if (args.length > 0) {            int maximumSize = Integer.parseInt(args[0]) & ~7; // multiple of 8            options.setMaximumSize(maximumSize);        }        return options;    }
    public static void main(String... args) throws Exception {        Options options = createOptions(args);        try {            scrcpy(options);        } catch (Throwable t) {            t.printStackTrace();            throw t;        }    }}
static inline void buffer_write16be(Uint8 *buf, Uint16 value) {    buf[0] = value >> 8;    buf[1] = value;}
static inline Uint32 buffer_read32be(Uint8 *buf) {    return (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];}
static inline void buffer_write32be(Uint8 *buf, Uint32 value) {    buf[0] = value >> 24;    buf[1] = value >> 16;    buf[2] = value >> 8;    buf[3] = value;}
static inline Uint64 buffer_read64be(Uint8 *buf) {    Uint32 msb = buffer_read32be(buf);    Uint32 lsb = buffer_read32be(&buf[4]);    return ((Uint64) msb << 32) | lsb;}
buffer_write16be(Uint8 *buf, Uint16 value) {    buf[0] = value >> 8;    buf[1] = value;}
buffer_read32be(Uint8 *buf) {    return (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];}
buffer_write32be(Uint8 *buf, Uint32 value) {    buf[0] = value >> 24;    buf[1] = value >> 16;    buf[2] = value >> 8;    buf[3] = value;}
Uint64 buffer_read64be(Uint8 *buf) {    Uint32 msb = buffer_read32be(buf);    Uint32 lsb = buffer_read32be(&buf[4]);    return ((Uint64) msb << 32) | lsb;}
process_t adb_install(const char *serial, const char *local) {#ifdef __WINDOWS__    // Windows will parse the string, so the local name must be quoted    // (see sys/win/command.c)    local = strquote(local);    if (!local) {        return PROCESS_NONE;    }#endif    const char *const adb_cmd[] = {"install", "-r", local};    process_t proc = adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));#ifdef __WINDOWS__    free((void *) local);#endif    return proc;}
process_t adb_reverse(const char *serial, const char *device_socket_name, uint16_t local_port) {    char local[4 + 5 + 1]; // tcp:PORT    char remote[108 + 14 + 1]; // localabstract:NAME    sprintf(local, "tcp:%" PRIu16, local_port);    snprintf(remote, sizeof(remote), "localabstract:%s", device_socket_name);    const char *const adb_cmd[] = {"reverse", remote, local};    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
process_t adb_forward_remove(const char *serial, uint16_t local_port) {    char local[4 + 5 + 1]; // tcp:PORT    sprintf(local, "tcp:%" PRIu16, local_port);    const char *const adb_cmd[] = {"forward", "--remove", local};    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
process_t adb_forward(const char *serial, uint16_t local_port, const char *device_socket_name) {    char local[4 + 5 + 1]; // tcp:PORT    char remote[108 + 14 + 1]; // localabstract:NAME    sprintf(local, "tcp:%" PRIu16, local_port);    snprintf(remote, sizeof(remote), "localabstract:%s", device_socket_name);    const char *const adb_cmd[] = {"forward", local, remote};    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
static inline const char *get_adb_command(void) {    if (!adb_command) {        adb_command = getenv("ADB");        if (!adb_command)            adb_command = "adb";    }    return adb_command;}
process_t adb_reverse_remove(const char *serial, const char *device_socket_name) {    char remote[108 + 14 + 1]; // localabstract:NAME    snprintf(remote, sizeof(remote), "localabstract:%s", device_socket_name);    const char *const adb_cmd[] = {"reverse", "--remove", remote};    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
process_t adb_push(const char *serial, const char *local, const char *remote) {#ifdef __WINDOWS__    // Windows will parse the string, so the paths must be quoted    // (see sys/win/command.c)    local = strquote(local);    if (!local) {        return PROCESS_NONE;    }    remote = strquote(remote);    if (!remote) {        free((void *) local);        return PROCESS_NONE;    }#endif    const char *const adb_cmd[] = {"push", local, remote};    process_t proc = adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));#ifdef __WINDOWS__    free((void *) remote);    free((void *) local);#endif    return proc;}
SDL_bool process_check_success(process_t proc, const char *name) {    if (proc == PROCESS_NONE) {        LOGE("Could not execute \"%s\"", name);        return SDL_FALSE;    }    exit_code_t exit_code;    if (!cmd_simple_wait(proc, &exit_code)) {        if (exit_code != NO_EXIT_CODE) {            LOGE("\"%s\" returned with value %" PRIexitcode, name, exit_code);        } else {            LOGE("\"%s\" exited unexpectedly", name);        }        return SDL_FALSE;    }    return SDL_TRUE;}
process_t adb_execute(const char *serial, const char *const adb_cmd[], int len) {    const char *cmd[len + 4];    int i;    process_t process;    cmd[0] = get_adb_command();    if (serial) {        cmd[1] = "-s";        cmd[2] = serial;        i = 3;    } else {        i = 1;    }    memcpy(&cmd[i], adb_cmd, len * sizeof(const char *));    cmd[len + i] = NULL;    enum process_result r = cmd_execute(cmd[0], cmd, &process);    if (r != PROCESS_SUCCESS) {        show_adb_err_msg(r);        return PROCESS_NONE;    }    return process;}
static void show_adb_err_msg(enum process_result err) {    switch (err) {        case PROCESS_ERROR_GENERIC:            LOGE("Failed to execute adb");            break;        case PROCESS_ERROR_MISSING_BINARY:            LOGE("'adb' command not found (make it accessible from your PATH "                  "or define its full path in the ADB environment variable)");            break;        case PROCESS_SUCCESS:            /* do nothing */            break;    }}
adb_install(const char *serial, const char *local) {#ifdef __WINDOWS__    // Windows will parse the string, so the local name must be quoted    // (see sys/win/command.c)    local = strquote(local);    if (!local) {        return PROCESS_NONE;    }#endif    const char *const adb_cmd[] = {"install", "-r", local};    process_t proc = adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));#ifdef __WINDOWS__    free((void *) local);#endif    return proc;}
adb_reverse(const char *serial, const char *device_socket_name,            uint16_t local_port) {    char local[4 + 5 + 1]; // tcp:PORT    char remote[108 + 14 + 1]; // localabstract:NAME    sprintf(local, "tcp:%" PRIu16, local_port);    snprintf(remote, sizeof(remote), "localabstract:%s", device_socket_name);    const char *const adb_cmd[] = {"reverse", remote, local};    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
adb_forward_remove(const char *serial, uint16_t local_port) {    char local[4 + 5 + 1]; // tcp:PORT    sprintf(local, "tcp:%" PRIu16, local_port);    const char *const adb_cmd[] = {"forward", "--remove", local};    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
adb_forward(const char *serial, uint16_t local_port,            const char *device_socket_name) {    char local[4 + 5 + 1]; // tcp:PORT    char remote[108 + 14 + 1]; // localabstract:NAME    sprintf(local, "tcp:%" PRIu16, local_port);    snprintf(remote, sizeof(remote), "localabstract:%s", device_socket_name);    const char *const adb_cmd[] = {"forward", local, remote};    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
get_adb_command(void) {    if (!adb_command) {        adb_command = getenv("ADB");        if (!adb_command)            adb_command = "adb";    }    return adb_command;}
adb_reverse_remove(const char *serial, const char *device_socket_name) {    char remote[108 + 14 + 1]; // localabstract:NAME    snprintf(remote, sizeof(remote), "localabstract:%s", device_socket_name);    const char *const adb_cmd[] = {"reverse", "--remove", remote};    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
adb_push(const char *serial, const char *local, const char *remote) {#ifdef __WINDOWS__    // Windows will parse the string, so the paths must be quoted    // (see sys/win/command.c)    local = strquote(local);    if (!local) {        return PROCESS_NONE;    }    remote = strquote(remote);    if (!remote) {        free((void *) local);        return PROCESS_NONE;    }#endif    const char *const adb_cmd[] = {"push", local, remote};    process_t proc = adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));#ifdef __WINDOWS__    free((void *) remote);    free((void *) local);#endif    return proc;}
process_check_success(process_t proc, const char *name) {    if (proc == PROCESS_NONE) {        LOGE("Could not execute \"%s\"", name);        return SDL_FALSE;    }    exit_code_t exit_code;    if (!cmd_simple_wait(proc, &exit_code)) {        if (exit_code != NO_EXIT_CODE) {            LOGE("\"%s\" returned with value %" PRIexitcode, name, exit_code);        } else {            LOGE("\"%s\" exited unexpectedly", name);        }        return SDL_FALSE;    }    return SDL_TRUE;}
adb_execute(const char *serial, const char *const adb_cmd[], int len) {    const char *cmd[len + 4];    int i;    process_t process;    cmd[0] = get_adb_command();    if (serial) {        cmd[1] = "-s";        cmd[2] = serial;        i = 3;    } else {        i = 1;    }    memcpy(&cmd[i], adb_cmd, len * sizeof(const char *));    cmd[len + i] = NULL;    enum process_result r = cmd_execute(cmd[0], cmd, &process);    if (r != PROCESS_SUCCESS) {        show_adb_err_msg(r);        return PROCESS_NONE;    }    return process;}
show_adb_err_msg(enum process_result err) {    switch (err) {        case PROCESS_ERROR_GENERIC:            LOGE("Failed to execute adb");            break;        case PROCESS_ERROR_MISSING_BINARY:            LOGE("'adb' command not found (make it accessible from your PATH "                  "or define its full path in the ADB environment variable)");            break;        case PROCESS_SUCCESS:            /* do nothing */            break;    }}
void control_event_destroy(struct control_event *event) {    if (event->type == CONTROL_EVENT_TYPE_TEXT) {        SDL_free(event->text_event.text);    }}
SDL_bool control_event_queue_is_empty(const struct control_event_queue *queue) {    return queue->head == queue->tail;}
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            buffer_write32be(&buf[2], event->keycode_event.keycode);            buffer_write32be(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (2 bytes) + string (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > TEXT_MAX_LENGTH) {                // injecting a text takes time, so limit the text length                len = TEXT_MAX_LENGTH;            }            buffer_write16be(&buf[1], (Uint16) len);            memcpy(&buf[3], event->text_event.text, len);            return 3 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            buffer_write32be(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 18;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            buffer_write32be(&buf[13], (Uint32) event->scroll_event.hscroll);            buffer_write32be(&buf[17], (Uint32) event->scroll_event.vscroll);            return 21;        case CONTROL_EVENT_TYPE_COMMAND:            buf[1] = event->command_event.action;            return 2;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
SDL_bool control_event_queue_push(struct control_event_queue *queue, const struct control_event *event) {    if (control_event_queue_is_full(queue)) {        return SDL_FALSE;    }    queue->data[queue->head] = *event;    queue->head = (queue->head + 1) % CONTROL_EVENT_QUEUE_SIZE;    return SDL_TRUE;}
SDL_bool control_event_queue_take(struct control_event_queue *queue, struct control_event *event) {    if (control_event_queue_is_empty(queue)) {        return SDL_FALSE;    }    *event = queue->data[queue->tail];    queue->tail = (queue->tail + 1) % CONTROL_EVENT_QUEUE_SIZE;    return SDL_TRUE;}
SDL_bool control_event_queue_init(struct control_event_queue *queue) {    queue->head = 0;    queue->tail = 0;    // the current implementation may not fail    return SDL_TRUE;}
void control_event_queue_destroy(struct control_event_queue *queue) {    int i = queue->tail;    while (i != queue->head) {        control_event_destroy(&queue->data[i]);        i = (i + 1) % CONTROL_EVENT_QUEUE_SIZE;    }}
static void write_position(Uint8 *buf, const struct position *position) {    buffer_write32be(&buf[0], position->point.x);    buffer_write32be(&buf[4], position->point.y);    buffer_write16be(&buf[8], position->screen_size.width);    buffer_write16be(&buf[10], position->screen_size.height);}
SDL_bool control_event_queue_is_full(const struct control_event_queue *queue) {    return (queue->head + 1) % CONTROL_EVENT_QUEUE_SIZE == queue->tail;}
control_event_destroy(struct control_event *event) {    if (event->type == CONTROL_EVENT_TYPE_TEXT) {        SDL_free(event->text_event.text);    }}
control_event_queue_is_empty(const struct control_event_queue *queue) {    return queue->head == queue->tail;}
control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            buffer_write32be(&buf[2], event->keycode_event.keycode);            buffer_write32be(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (2 bytes) + string (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > TEXT_MAX_LENGTH) {                // injecting a text takes time, so limit the text length                len = TEXT_MAX_LENGTH;            }            buffer_write16be(&buf[1], (Uint16) len);            memcpy(&buf[3], event->text_event.text, len);            return 3 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            buffer_write32be(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 18;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            buffer_write32be(&buf[13], (Uint32) event->scroll_event.hscroll);            buffer_write32be(&buf[17], (Uint32) event->scroll_event.vscroll);            return 21;        case CONTROL_EVENT_TYPE_COMMAND:            buf[1] = event->command_event.action;            return 2;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
control_event_queue_push(struct control_event_queue *queue,                         const struct control_event *event) {    if (control_event_queue_is_full(queue)) {        return SDL_FALSE;    }    queue->data[queue->head] = *event;    queue->head = (queue->head + 1) % CONTROL_EVENT_QUEUE_SIZE;    return SDL_TRUE;}
control_event_queue_take(struct control_event_queue *queue,                         struct control_event *event) {    if (control_event_queue_is_empty(queue)) {        return SDL_FALSE;    }    *event = queue->data[queue->tail];    queue->tail = (queue->tail + 1) % CONTROL_EVENT_QUEUE_SIZE;    return SDL_TRUE;}
control_event_queue_init(struct control_event_queue *queue) {    queue->head = 0;    queue->tail = 0;    // the current implementation may not fail    return SDL_TRUE;}
control_event_queue_destroy(struct control_event_queue *queue) {    int i = queue->tail;    while (i != queue->head) {        control_event_destroy(&queue->data[i]);        i = (i + 1) % CONTROL_EVENT_QUEUE_SIZE;    }}
write_position(Uint8 *buf, const struct position *position) {    buffer_write32be(&buf[0], position->point.x);    buffer_write32be(&buf[4], position->point.y);    buffer_write16be(&buf[8], position->screen_size.width);    buffer_write16be(&buf[10], position->screen_size.height);}
control_event_queue_is_full(const struct control_event_queue *queue) {    return (queue->head + 1) % CONTROL_EVENT_QUEUE_SIZE == queue->tail;}
void controller_join(struct controller *controller) {    SDL_WaitThread(controller->thread, NULL);}
void controller_stop(struct controller *controller) {    mutex_lock(controller->mutex);    controller->stopped = SDL_TRUE;    cond_signal(controller->event_cond);    mutex_unlock(controller->mutex);}
void controller_destroy(struct controller *controller) {    SDL_DestroyCond(controller->event_cond);    SDL_DestroyMutex(controller->mutex);    control_event_queue_destroy(&controller->queue);}
SDL_bool controller_push_event(struct controller *controller, const struct control_event *event) {    SDL_bool res;    mutex_lock(controller->mutex);    SDL_bool was_empty = control_event_queue_is_empty(&controller->queue);    res = control_event_queue_push(&controller->queue, event);    if (was_empty) {        cond_signal(controller->event_cond);    }    mutex_unlock(controller->mutex);    return res;}
static int run_controller(void *data) {    struct controller *controller = data;    for (;;) {        mutex_lock(controller->mutex);        while (!controller->stopped && control_event_queue_is_empty(&controller->queue)) {            cond_wait(controller->event_cond, controller->mutex);        }        if (controller->stopped) {            // stop immediately, do not process further events            mutex_unlock(controller->mutex);            break;        }        struct control_event event;        SDL_bool non_empty = control_event_queue_take(&controller->queue, &event);        SDL_assert(non_empty);        mutex_unlock(controller->mutex);        SDL_bool ok = process_event(controller, &event);        control_event_destroy(&event);        if (!ok) {            LOGD("Cannot write event to socket");            break;        }    }    return 0;}
SDL_bool controller_start(struct controller *controller) {    LOGD("Starting controller thread");    controller->thread = SDL_CreateThread(run_controller, "controller", controller);    if (!controller->thread) {        LOGC("Could not start controller thread");        return SDL_FALSE;    }    return SDL_TRUE;}
static SDL_bool process_event(struct controller *controller, const struct control_event *event) {    unsigned char serialized_event[SERIALIZED_EVENT_MAX_SIZE];    int length = control_event_serialize(event, serialized_event);    if (!length) {        return SDL_FALSE;    }    int w = net_send_all(controller->video_socket, serialized_event, length);    return w == length;}
SDL_bool controller_init(struct controller *controller, socket_t video_socket) {    if (!control_event_queue_init(&controller->queue)) {        return SDL_FALSE;    }    if (!(controller->mutex = SDL_CreateMutex())) {        return SDL_FALSE;    }    if (!(controller->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(controller->mutex);        return SDL_FALSE;    }    controller->video_socket = video_socket;    controller->stopped = SDL_FALSE;    return SDL_TRUE;}
controller_join(struct controller *controller) {    SDL_WaitThread(controller->thread, NULL);}
controller_stop(struct controller *controller) {    mutex_lock(controller->mutex);    controller->stopped = SDL_TRUE;    cond_signal(controller->event_cond);    mutex_unlock(controller->mutex);}
controller_destroy(struct controller *controller) {    SDL_DestroyCond(controller->event_cond);    SDL_DestroyMutex(controller->mutex);    control_event_queue_destroy(&controller->queue);}
controller_push_event(struct controller *controller,                      const struct control_event *event) {    SDL_bool res;    mutex_lock(controller->mutex);    SDL_bool was_empty = control_event_queue_is_empty(&controller->queue);    res = control_event_queue_push(&controller->queue, event);    if (was_empty) {        cond_signal(controller->event_cond);    }    mutex_unlock(controller->mutex);    return res;}
run_controller(void *data) {    struct controller *controller = data;    for (;;) {        mutex_lock(controller->mutex);        while (!controller->stopped                && control_event_queue_is_empty(&controller->queue)) {            cond_wait(controller->event_cond, controller->mutex);        }        if (controller->stopped) {            // stop immediately, do not process further events            mutex_unlock(controller->mutex);            break;        }        struct control_event event;        SDL_bool non_empty = control_event_queue_take(&controller->queue,                                                      &event);        SDL_assert(non_empty);        mutex_unlock(controller->mutex);        SDL_bool ok = process_event(controller, &event);        control_event_destroy(&event);        if (!ok) {            LOGD("Cannot write event to socket");            break;        }    }    return 0;}
controller_start(struct controller *controller) {    LOGD("Starting controller thread");    controller->thread = SDL_CreateThread(run_controller, "controller",                                          controller);    if (!controller->thread) {        LOGC("Could not start controller thread");        return SDL_FALSE;    }    return SDL_TRUE;}
process_event(struct controller *controller,              const struct control_event *event) {    unsigned char serialized_event[SERIALIZED_EVENT_MAX_SIZE];    int length = control_event_serialize(event, serialized_event);    if (!length) {        return SDL_FALSE;    }    int w = net_send_all(controller->video_socket, serialized_event, length);    return w == length;}
controller_init(struct controller *controller, socket_t video_socket) {    if (!control_event_queue_init(&controller->queue)) {        return SDL_FALSE;    }    if (!(controller->mutex = SDL_CreateMutex())) {        return SDL_FALSE;    }    if (!(controller->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(controller->mutex);        return SDL_FALSE;    }    controller->video_socket = video_socket;    controller->stopped = SDL_FALSE;    return SDL_TRUE;}
static SDL_bool convert_mouse_action(SDL_EventType from, enum android_motionevent_action *to) {    switch (from) {        MAP(SDL_MOUSEBUTTONDOWN, AMOTION_EVENT_ACTION_DOWN);        MAP(SDL_MOUSEBUTTONUP,   AMOTION_EVENT_ACTION_UP);        FAIL;    }}
static enum android_metastate autocomplete_metastate(enum android_metastate metastate) {    // fill dependant flags    if (metastate & (AMETA_SHIFT_LEFT_ON | AMETA_SHIFT_RIGHT_ON)) {        metastate |= AMETA_SHIFT_ON;    }    if (metastate & (AMETA_CTRL_LEFT_ON | AMETA_CTRL_RIGHT_ON)) {        metastate |= AMETA_CTRL_ON;    }    if (metastate & (AMETA_ALT_LEFT_ON | AMETA_ALT_RIGHT_ON)) {        metastate |= AMETA_ALT_ON;    }    if (metastate & (AMETA_META_LEFT_ON | AMETA_META_RIGHT_ON)) {        metastate |= AMETA_META_ON;    }    return metastate;}
SDL_bool mouse_wheel_from_sdl_to_android(const SDL_MouseWheelEvent *from,                                         struct position position,                                         struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_SCROLL;    to->scroll_event.position = position;    int mul = from->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    // SDL behavior seems inconsistent between horizontal and vertical scrolling    // so reverse the horizontal    // <https://wiki.libsdl.org/SDL_MouseWheelEvent#Remarks>    to->scroll_event.hscroll = -mul * from->x;    to->scroll_event.vscroll = mul * from->y;    return SDL_TRUE;}
static SDL_bool convert_keycode(SDL_Keycode from, enum android_keycode *to, Uint16 mod) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_HOME,         AKEYCODE_HOME);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);    }    if (mod & (KMOD_LALT | KMOD_RALT | KMOD_LGUI | KMOD_RGUI)) {        return SDL_FALSE;    }    // if ALT and META are not pressed, also handle letters and space    switch (from) {        MAP(SDLK_a,            AKEYCODE_A);        MAP(SDLK_b,            AKEYCODE_B);        MAP(SDLK_c,            AKEYCODE_C);        MAP(SDLK_d,            AKEYCODE_D);        MAP(SDLK_e,            AKEYCODE_E);        MAP(SDLK_f,            AKEYCODE_F);        MAP(SDLK_g,            AKEYCODE_G);        MAP(SDLK_h,            AKEYCODE_H);        MAP(SDLK_i,            AKEYCODE_I);        MAP(SDLK_j,            AKEYCODE_J);        MAP(SDLK_k,            AKEYCODE_K);        MAP(SDLK_l,            AKEYCODE_L);        MAP(SDLK_m,            AKEYCODE_M);        MAP(SDLK_n,            AKEYCODE_N);        MAP(SDLK_o,            AKEYCODE_O);        MAP(SDLK_p,            AKEYCODE_P);        MAP(SDLK_q,            AKEYCODE_Q);        MAP(SDLK_r,            AKEYCODE_R);        MAP(SDLK_s,            AKEYCODE_S);        MAP(SDLK_t,            AKEYCODE_T);        MAP(SDLK_u,            AKEYCODE_U);        MAP(SDLK_v,            AKEYCODE_V);        MAP(SDLK_w,            AKEYCODE_W);        MAP(SDLK_x,            AKEYCODE_X);        MAP(SDLK_y,            AKEYCODE_Y);        MAP(SDLK_z,            AKEYCODE_Z);        MAP(SDLK_SPACE,        AKEYCODE_SPACE);        FAIL;    }}
static enum android_motionevent_buttons convert_mouse_buttons(Uint32 state) {    enum android_motionevent_buttons buttons = 0;    if (state & SDL_BUTTON_LMASK) {        buttons |= AMOTION_EVENT_BUTTON_PRIMARY;    }    if (state & SDL_BUTTON_RMASK) {        buttons |= AMOTION_EVENT_BUTTON_SECONDARY;    }    if (state & SDL_BUTTON_MMASK) {        buttons |= AMOTION_EVENT_BUTTON_TERTIARY;    }    if (state & SDL_BUTTON_X1) {        buttons |= AMOTION_EVENT_BUTTON_BACK;    }    if (state & SDL_BUTTON_X2) {        buttons |= AMOTION_EVENT_BUTTON_FORWARD;    }    return buttons;}
static SDL_bool convert_keycode_action(SDL_EventType from, enum android_keyevent_action *to) {    switch (from) {        MAP(SDL_KEYDOWN, AKEY_EVENT_ACTION_DOWN);        MAP(SDL_KEYUP,   AKEY_EVENT_ACTION_UP);        FAIL;    }}
SDL_bool input_key_from_sdl_to_android(const SDL_KeyboardEvent *from,                                       struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_KEYCODE;    if (!convert_keycode_action(from->type, &to->keycode_event.action)) {        return SDL_FALSE;    }    Uint16 mod = from->keysym.mod;    if (!convert_keycode(from->keysym.sym, &to->keycode_event.keycode, mod)) {        return SDL_FALSE;    }    to->keycode_event.metastate = convert_meta_state(mod);    return SDL_TRUE;}
SDL_bool mouse_motion_from_sdl_to_android(const SDL_MouseMotionEvent *from,                                          struct size screen_size,                                          struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    to->mouse_event.action = AMOTION_EVENT_ACTION_MOVE;    to->mouse_event.buttons = convert_mouse_buttons(from->state);    to->mouse_event.position.screen_size = screen_size;    to->mouse_event.position.point.x = from->x;    to->mouse_event.position.point.y = from->y;    return SDL_TRUE;}
static enum android_metastate convert_meta_state(SDL_Keymod mod) {    enum android_metastate metastate = 0;    if (mod & KMOD_LSHIFT) {        metastate |= AMETA_SHIFT_LEFT_ON;    }    if (mod & KMOD_RSHIFT) {        metastate |= AMETA_SHIFT_RIGHT_ON;    }    if (mod & KMOD_LCTRL) {        metastate |= AMETA_CTRL_LEFT_ON;    }    if (mod & KMOD_RCTRL) {        metastate |= AMETA_CTRL_RIGHT_ON;    }    if (mod & KMOD_LALT) {        metastate |= AMETA_ALT_LEFT_ON;    }    if (mod & KMOD_RALT) {        metastate |= AMETA_ALT_RIGHT_ON;    }    if (mod & KMOD_LGUI) { // Windows key        metastate |= AMETA_META_LEFT_ON;    }    if (mod & KMOD_RGUI) { // Windows key        metastate |= AMETA_META_RIGHT_ON;    }    if (mod & KMOD_NUM) {        metastate |= AMETA_NUM_LOCK_ON;    }    if (mod & KMOD_CAPS) {        metastate |= AMETA_CAPS_LOCK_ON;    }    if (mod & KMOD_MODE) { // Alt Gr        // no mapping?    }    // fill the dependent fields    return autocomplete_metastate(metastate);}
SDL_bool mouse_button_from_sdl_to_android(const SDL_MouseButtonEvent *from,                                          struct size screen_size,                                          struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    if (!convert_mouse_action(from->type, &to->mouse_event.action)) {        return SDL_FALSE;    }    to->mouse_event.buttons = convert_mouse_buttons(SDL_BUTTON(from->button));    to->mouse_event.position.screen_size = screen_size;    to->mouse_event.position.point.x = from->x;    to->mouse_event.position.point.y = from->y;    return SDL_TRUE;}
convert_mouse_action(SDL_EventType from, enum android_motionevent_action *to) {    switch (from) {        MAP(SDL_MOUSEBUTTONDOWN, AMOTION_EVENT_ACTION_DOWN);        MAP(SDL_MOUSEBUTTONUP,   AMOTION_EVENT_ACTION_UP);        FAIL;    }}
autocomplete_metastate(enum android_metastate metastate) {    // fill dependant flags    if (metastate & (AMETA_SHIFT_LEFT_ON | AMETA_SHIFT_RIGHT_ON)) {        metastate |= AMETA_SHIFT_ON;    }    if (metastate & (AMETA_CTRL_LEFT_ON | AMETA_CTRL_RIGHT_ON)) {        metastate |= AMETA_CTRL_ON;    }    if (metastate & (AMETA_ALT_LEFT_ON | AMETA_ALT_RIGHT_ON)) {        metastate |= AMETA_ALT_ON;    }    if (metastate & (AMETA_META_LEFT_ON | AMETA_META_RIGHT_ON)) {        metastate |= AMETA_META_ON;    }    return metastate;}
mouse_wheel_from_sdl_to_android(const SDL_MouseWheelEvent *from,                                struct position position,                                struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_SCROLL;    to->scroll_event.position = position;    int mul = from->direction == SDL_MOUSEWHEEL_NORMAL ? 1 : -1;    // SDL behavior seems inconsistent between horizontal and vertical scrolling    // so reverse the horizontal    // <https://wiki.libsdl.org/SDL_MouseWheelEvent#Remarks>    to->scroll_event.hscroll = -mul * from->x;    to->scroll_event.vscroll = mul * from->y;    return SDL_TRUE;}
convert_keycode(SDL_Keycode from, enum android_keycode *to, Uint16 mod) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_HOME,         AKEYCODE_HOME);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);    }    if (mod & (KMOD_LALT | KMOD_RALT | KMOD_LGUI | KMOD_RGUI)) {        return SDL_FALSE;    }    // if ALT and META are not pressed, also handle letters and space    switch (from) {        MAP(SDLK_a,            AKEYCODE_A);        MAP(SDLK_b,            AKEYCODE_B);        MAP(SDLK_c,            AKEYCODE_C);        MAP(SDLK_d,            AKEYCODE_D);        MAP(SDLK_e,            AKEYCODE_E);        MAP(SDLK_f,            AKEYCODE_F);        MAP(SDLK_g,            AKEYCODE_G);        MAP(SDLK_h,            AKEYCODE_H);        MAP(SDLK_i,            AKEYCODE_I);        MAP(SDLK_j,            AKEYCODE_J);        MAP(SDLK_k,            AKEYCODE_K);        MAP(SDLK_l,            AKEYCODE_L);        MAP(SDLK_m,            AKEYCODE_M);        MAP(SDLK_n,            AKEYCODE_N);        MAP(SDLK_o,            AKEYCODE_O);        MAP(SDLK_p,            AKEYCODE_P);        MAP(SDLK_q,            AKEYCODE_Q);        MAP(SDLK_r,            AKEYCODE_R);        MAP(SDLK_s,            AKEYCODE_S);        MAP(SDLK_t,            AKEYCODE_T);        MAP(SDLK_u,            AKEYCODE_U);        MAP(SDLK_v,            AKEYCODE_V);        MAP(SDLK_w,            AKEYCODE_W);        MAP(SDLK_x,            AKEYCODE_X);        MAP(SDLK_y,            AKEYCODE_Y);        MAP(SDLK_z,            AKEYCODE_Z);        MAP(SDLK_SPACE,        AKEYCODE_SPACE);        FAIL;    }}
convert_mouse_buttons(Uint32 state) {    enum android_motionevent_buttons buttons = 0;    if (state & SDL_BUTTON_LMASK) {        buttons |= AMOTION_EVENT_BUTTON_PRIMARY;    }    if (state & SDL_BUTTON_RMASK) {        buttons |= AMOTION_EVENT_BUTTON_SECONDARY;    }    if (state & SDL_BUTTON_MMASK) {        buttons |= AMOTION_EVENT_BUTTON_TERTIARY;    }    if (state & SDL_BUTTON_X1) {        buttons |= AMOTION_EVENT_BUTTON_BACK;    }    if (state & SDL_BUTTON_X2) {        buttons |= AMOTION_EVENT_BUTTON_FORWARD;    }    return buttons;}
convert_keycode_action(SDL_EventType from, enum android_keyevent_action *to) {    switch (from) {        MAP(SDL_KEYDOWN, AKEY_EVENT_ACTION_DOWN);        MAP(SDL_KEYUP,   AKEY_EVENT_ACTION_UP);        FAIL;    }}
input_key_from_sdl_to_android(const SDL_KeyboardEvent *from,                              struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_KEYCODE;    if (!convert_keycode_action(from->type, &to->keycode_event.action)) {        return SDL_FALSE;    }    Uint16 mod = from->keysym.mod;    if (!convert_keycode(from->keysym.sym, &to->keycode_event.keycode, mod)) {        return SDL_FALSE;    }    to->keycode_event.metastate = convert_meta_state(mod);    return SDL_TRUE;}
mouse_motion_from_sdl_to_android(const SDL_MouseMotionEvent *from,                                 struct size screen_size,                                 struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    to->mouse_event.action = AMOTION_EVENT_ACTION_MOVE;    to->mouse_event.buttons = convert_mouse_buttons(from->state);    to->mouse_event.position.screen_size = screen_size;    to->mouse_event.position.point.x = from->x;    to->mouse_event.position.point.y = from->y;    return SDL_TRUE;}
convert_meta_state(SDL_Keymod mod) {    enum android_metastate metastate = 0;    if (mod & KMOD_LSHIFT) {        metastate |= AMETA_SHIFT_LEFT_ON;    }    if (mod & KMOD_RSHIFT) {        metastate |= AMETA_SHIFT_RIGHT_ON;    }    if (mod & KMOD_LCTRL) {        metastate |= AMETA_CTRL_LEFT_ON;    }    if (mod & KMOD_RCTRL) {        metastate |= AMETA_CTRL_RIGHT_ON;    }    if (mod & KMOD_LALT) {        metastate |= AMETA_ALT_LEFT_ON;    }    if (mod & KMOD_RALT) {        metastate |= AMETA_ALT_RIGHT_ON;    }    if (mod & KMOD_LGUI) { // Windows key        metastate |= AMETA_META_LEFT_ON;    }    if (mod & KMOD_RGUI) { // Windows key        metastate |= AMETA_META_RIGHT_ON;    }    if (mod & KMOD_NUM) {        metastate |= AMETA_NUM_LOCK_ON;    }    if (mod & KMOD_CAPS) {        metastate |= AMETA_CAPS_LOCK_ON;    }    if (mod & KMOD_MODE) { // Alt Gr        // no mapping?    }    // fill the dependent fields    return autocomplete_metastate(metastate);}
mouse_button_from_sdl_to_android(const SDL_MouseButtonEvent *from,                                 struct size screen_size,                                 struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_MOUSE;    if (!convert_mouse_action(from->type, &to->mouse_event.action)) {        return SDL_FALSE;    }    to->mouse_event.buttons = convert_mouse_buttons(SDL_BUTTON(from->button));    to->mouse_event.position.screen_size = screen_size;    to->mouse_event.position.point.x = from->x;    to->mouse_event.position.point.y = from->y;    return SDL_TRUE;}
SDL_bool decoder_open(struct decoder *decoder, AVCodec *codec) {    decoder->codec_ctx = avcodec_alloc_context3(codec);    if (!decoder->codec_ctx) {        LOGC("Could not allocate decoder context");        return SDL_FALSE;    }    if (avcodec_open2(decoder->codec_ctx, codec, NULL) < 0) {        LOGE("Could not open codec");        avcodec_free_context(&decoder->codec_ctx);        return SDL_FALSE;    }    return SDL_TRUE;}
void decoder_init(struct decoder *decoder, struct video_buffer *vb) {    decoder->video_buffer = vb;}
SDL_bool decoder_push(struct decoder *decoder, AVPacket *packet) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#ifdef SCRCPY_LAVF_HAS_NEW_ENCODING_DECODING_API    int ret;    if ((ret = avcodec_send_packet(decoder->codec_ctx, packet)) < 0) {        LOGE("Could not send video packet: %d", ret);        return SDL_FALSE;    }    ret = avcodec_receive_frame(decoder->codec_ctx,                                decoder->video_buffer->decoding_frame);    if (!ret) {        // a frame was received        push_frame(decoder);    } else if (ret != AVERROR(EAGAIN)) {        LOGE("Could not receive video frame: %d", ret);        return SDL_FALSE;    }#else    int got_picture;    int len = avcodec_decode_video2(decoder->codec_ctx,                                    decoder->video_buffer->decoding_frame,                                    &got_picture,                                    packet);    if (len < 0) {        LOGE("Could not decode video packet: %d", len);        return SDL_FALSE;    }    if (got_picture) {        push_frame(decoder);    }#endif    return SDL_TRUE;}
void decoder_interrupt(struct decoder *decoder) {    video_buffer_interrupt(decoder->video_buffer);}
void decoder_close(struct decoder *decoder) {    avcodec_close(decoder->codec_ctx);    avcodec_free_context(&decoder->codec_ctx);}
static void push_frame(struct decoder *decoder) {    SDL_bool previous_frame_consumed = video_buffer_offer_decoded_frame(decoder->video_buffer);    if (!previous_frame_consumed) {        // the previous EVENT_NEW_FRAME will consume this frame        return;    }    static SDL_Event new_frame_event = {        .type = EVENT_NEW_FRAME,    };    SDL_PushEvent(&new_frame_event);}
decoder_open(struct decoder *decoder, AVCodec *codec) {    decoder->codec_ctx = avcodec_alloc_context3(codec);    if (!decoder->codec_ctx) {        LOGC("Could not allocate decoder context");        return SDL_FALSE;    }    if (avcodec_open2(decoder->codec_ctx, codec, NULL) < 0) {        LOGE("Could not open codec");        avcodec_free_context(&decoder->codec_ctx);        return SDL_FALSE;    }    return SDL_TRUE;}
decoder_init(struct decoder *decoder, struct video_buffer *vb) {    decoder->video_buffer = vb;}
decoder_push(struct decoder *decoder, AVPacket *packet) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#ifdef SCRCPY_LAVF_HAS_NEW_ENCODING_DECODING_API    int ret;    if ((ret = avcodec_send_packet(decoder->codec_ctx, packet)) < 0) {        LOGE("Could not send video packet: %d", ret);        return SDL_FALSE;    }    ret = avcodec_receive_frame(decoder->codec_ctx,                                decoder->video_buffer->decoding_frame);    if (!ret) {        // a frame was received        push_frame(decoder);    } else if (ret != AVERROR(EAGAIN)) {        LOGE("Could not receive video frame: %d", ret);        return SDL_FALSE;    }#else    int got_picture;    int len = avcodec_decode_video2(decoder->codec_ctx,                                    decoder->video_buffer->decoding_frame,                                    &got_picture,                                    packet);    if (len < 0) {        LOGE("Could not decode video packet: %d", len);        return SDL_FALSE;    }    if (got_picture) {        push_frame(decoder);    }#endif    return SDL_TRUE;}
decoder_interrupt(struct decoder *decoder) {    video_buffer_interrupt(decoder->video_buffer);}
decoder_close(struct decoder *decoder) {    avcodec_close(decoder->codec_ctx);    avcodec_free_context(&decoder->codec_ctx);}
push_frame(struct decoder *decoder) {    SDL_bool previous_frame_consumed =            video_buffer_offer_decoded_frame(decoder->video_buffer);    if (!previous_frame_consumed) {        // the previous EVENT_NEW_FRAME will consume this frame        return;    }    static SDL_Event new_frame_event = {        .type = EVENT_NEW_FRAME,    };    SDL_PushEvent(&new_frame_event);}
SDL_bool device_read_info(socket_t device_socket, char *device_name, struct size *size) {    unsigned char buf[DEVICE_NAME_FIELD_LENGTH + 4];    int r = net_recv_all(device_socket, buf, sizeof(buf));    if (r < DEVICE_NAME_FIELD_LENGTH + 4) {        LOGE("Could not retrieve device information");        return SDL_FALSE;    }    buf[DEVICE_NAME_FIELD_LENGTH - 1] = '\0'; // in case the client sends garbage    // strcpy is safe here, since name contains at least DEVICE_NAME_FIELD_LENGTH bytes    // and strlen(buf) < DEVICE_NAME_FIELD_LENGTH    strcpy(device_name, (char *) buf);    size->width = (buf[DEVICE_NAME_FIELD_LENGTH] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 1];    size->height = (buf[DEVICE_NAME_FIELD_LENGTH + 2] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 3];    return SDL_TRUE;}
device_read_info(socket_t device_socket, char *device_name, struct size *size) {    unsigned char buf[DEVICE_NAME_FIELD_LENGTH + 4];    int r = net_recv_all(device_socket, buf, sizeof(buf));    if (r < DEVICE_NAME_FIELD_LENGTH + 4) {        LOGE("Could not retrieve device information");        return SDL_FALSE;    }    // in case the client sends garbage    buf[DEVICE_NAME_FIELD_LENGTH - 1] = '\0';    // strcpy is safe here, since name contains at least    // DEVICE_NAME_FIELD_LENGTH bytes and strlen(buf) < DEVICE_NAME_FIELD_LENGTH    strcpy(device_name, (char *) buf);    size->width = (buf[DEVICE_NAME_FIELD_LENGTH] << 8)            | buf[DEVICE_NAME_FIELD_LENGTH + 1];    size->height = (buf[DEVICE_NAME_FIELD_LENGTH + 2] << 8)            | buf[DEVICE_NAME_FIELD_LENGTH + 3];    return SDL_TRUE;}
static void request_queue_destroy(struct request_queue *queue) {    int i = queue->tail;    while (i != queue->head) {        request_free(queue->reqs[i]);        i = (i + 1) % REQUEST_QUEUE_SIZE;    }}
SDL_bool file_handler_init(struct file_handler *file_handler, const char *serial) {    if (!request_queue_init(&file_handler->queue)) {        return SDL_FALSE;    }    if (!(file_handler->mutex = SDL_CreateMutex())) {        return SDL_FALSE;    }    if (!(file_handler->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(file_handler->mutex);        return SDL_FALSE;    }    if (serial) {        file_handler->serial = SDL_strdup(serial);        if (!file_handler->serial) {            LOGW("Cannot strdup serial");            SDL_DestroyMutex(file_handler->mutex);            return SDL_FALSE;        }    } else {        file_handler->serial = NULL;    }    // lazy initialization    file_handler->initialized = SDL_FALSE;    file_handler->stopped = SDL_FALSE;    file_handler->current_process = PROCESS_NONE;    return SDL_TRUE;}
static SDL_bool request_queue_push(struct request_queue *queue, struct request *req) {    if (request_queue_is_full(queue)) {        return SDL_FALSE;    }    queue->reqs[queue->head] = req;    queue->head = (queue->head + 1) % REQUEST_QUEUE_SIZE;    return SDL_TRUE;}
void file_handler_join(struct file_handler *file_handler) {    SDL_WaitThread(file_handler->thread, NULL);}
static struct request *request_new(file_handler_action_t action, const char *file) {    struct request *req = SDL_malloc(sizeof(*req));    if (!req) {        return NULL;    }    req->action = action;    req->file = file;    return req;}
SDL_bool file_handler_start(struct file_handler *file_handler) {    LOGD("Starting file_handler thread");    file_handler->thread = SDL_CreateThread(run_file_handler, "file_handler", file_handler);    if (!file_handler->thread) {        LOGC("Could not start file_handler thread");        return SDL_FALSE;    }    return SDL_TRUE;}
void file_handler_destroy(struct file_handler *file_handler) {    SDL_DestroyCond(file_handler->event_cond);    SDL_DestroyMutex(file_handler->mutex);    request_queue_destroy(&file_handler->queue);    SDL_free((void *) file_handler->serial);}
static SDL_bool request_queue_init(struct request_queue *queue) {    queue->head = 0;    queue->tail = 0;    return SDL_TRUE;}
static int run_file_handler(void *data) {    struct file_handler *file_handler = data;    for (;;) {        mutex_lock(file_handler->mutex);        file_handler->current_process = PROCESS_NONE;        while (!file_handler->stopped && request_queue_is_empty(&file_handler->queue)) {            cond_wait(file_handler->event_cond, file_handler->mutex);        }        if (file_handler->stopped) {            // stop immediately, do not process further events            mutex_unlock(file_handler->mutex);            break;        }        struct request *req;        SDL_bool non_empty = request_queue_take(&file_handler->queue, &req);        SDL_assert(non_empty);        process_t process;        if (req->action == ACTION_INSTALL_APK) {            LOGI("Installing %s...", req->file);            process = install_apk(file_handler->serial, req->file);        } else {            LOGI("Pushing %s...", req->file);            process = push_file(file_handler->serial, req->file);        }        file_handler->current_process = process;        mutex_unlock(file_handler->mutex);        if (req->action == ACTION_INSTALL_APK) {            if (process_check_success(process, "adb install")) {                LOGI("%s successfully installed", req->file);            } else {                LOGE("Failed to install %s", req->file);            }        } else {            if (process_check_success(process, "adb push")) {                LOGI("%s successfully pushed to /sdcard/", req->file);            } else {                LOGE("Failed to push %s to /sdcard/", req->file);            }        }        request_free(req);    }    return 0;}
SDL_bool file_handler_request(struct file_handler *file_handler,                              file_handler_action_t action,                              const char *file) {    SDL_bool res;    // start file_handler if it's used for the first time    if (!file_handler->initialized) {        if (!file_handler_start(file_handler)) {            return SDL_FALSE;        }        file_handler->initialized = SDL_TRUE;    }    LOGI("Request to %s %s", action == ACTION_INSTALL_APK ? "install" : "push", file);    struct request *req = request_new(action, file);    if (!req) {        LOGE("Could not create request");        return SDL_FALSE;    }    mutex_lock(file_handler->mutex);    SDL_bool was_empty = request_queue_is_empty(&file_handler->queue);    res = request_queue_push(&file_handler->queue, req);    if (was_empty) {        cond_signal(file_handler->event_cond);    }    mutex_unlock(file_handler->mutex);    return res;}
static process_t push_file(const char *serial, const char *file) {    return adb_push(serial, file, DEVICE_SDCARD_PATH);}
void file_handler_stop(struct file_handler *file_handler) {    mutex_lock(file_handler->mutex);    file_handler->stopped = SDL_TRUE;    cond_signal(file_handler->event_cond);    if (file_handler->current_process != PROCESS_NONE) {        if (!cmd_terminate(file_handler->current_process)) {            LOGW("Cannot terminate install process");        }        cmd_simple_wait(file_handler->current_process, NULL);        file_handler->current_process = PROCESS_NONE;    }    mutex_unlock(file_handler->mutex);}
static process_t install_apk(const char *serial, const char *file) {    return adb_install(serial, file);}
static SDL_bool request_queue_is_full(const struct request_queue *queue) {    return (queue->head + 1) % REQUEST_QUEUE_SIZE == queue->tail;}
static SDL_bool request_queue_take(struct request_queue *queue, struct request **req) {    if (request_queue_is_empty(queue)) {        return SDL_FALSE;    }    // transfer ownership    *req = queue->reqs[queue->tail];    queue->tail = (queue->tail + 1) % REQUEST_QUEUE_SIZE;    return SDL_TRUE;}
static void request_free(struct request *req) {    if (!req) {        return;    }    SDL_free((void *) req->file);    SDL_free((void *) req);}
static SDL_bool request_queue_is_empty(const struct request_queue *queue) {    return queue->head == queue->tail;}
request_queue_destroy(struct request_queue *queue) {    int i = queue->tail;    while (i != queue->head) {        request_free(queue->reqs[i]);        i = (i + 1) % REQUEST_QUEUE_SIZE;    }}
file_handler_init(struct file_handler *file_handler, const char *serial) {    if (!request_queue_init(&file_handler->queue)) {        return SDL_FALSE;    }    if (!(file_handler->mutex = SDL_CreateMutex())) {        return SDL_FALSE;    }    if (!(file_handler->event_cond = SDL_CreateCond())) {        SDL_DestroyMutex(file_handler->mutex);        return SDL_FALSE;    }    if (serial) {        file_handler->serial = SDL_strdup(serial);        if (!file_handler->serial) {            LOGW("Cannot strdup serial");            SDL_DestroyMutex(file_handler->mutex);            return SDL_FALSE;        }    } else {        file_handler->serial = NULL;    }    // lazy initialization    file_handler->initialized = SDL_FALSE;    file_handler->stopped = SDL_FALSE;    file_handler->current_process = PROCESS_NONE;    return SDL_TRUE;}
request_queue_push(struct request_queue *queue, struct request *req) {    if (request_queue_is_full(queue)) {        return SDL_FALSE;    }    queue->reqs[queue->head] = req;    queue->head = (queue->head + 1) % REQUEST_QUEUE_SIZE;    return SDL_TRUE;}
file_handler_join(struct file_handler *file_handler) {    SDL_WaitThread(file_handler->thread, NULL);}
request_new(file_handler_action_t action, const char *file) {    struct request *req = SDL_malloc(sizeof(*req));    if (!req) {        return NULL;    }    req->action = action;    req->file = file;    return req;}
file_handler_start(struct file_handler *file_handler) {    LOGD("Starting file_handler thread");    file_handler->thread = SDL_CreateThread(run_file_handler, "file_handler",                                            file_handler);    if (!file_handler->thread) {        LOGC("Could not start file_handler thread");        return SDL_FALSE;    }    return SDL_TRUE;}
file_handler_destroy(struct file_handler *file_handler) {    SDL_DestroyCond(file_handler->event_cond);    SDL_DestroyMutex(file_handler->mutex);    request_queue_destroy(&file_handler->queue);    SDL_free((void *) file_handler->serial);}
request_queue_init(struct request_queue *queue) {    queue->head = 0;    queue->tail = 0;    return SDL_TRUE;}
run_file_handler(void *data) {    struct file_handler *file_handler = data;    for (;;) {        mutex_lock(file_handler->mutex);        file_handler->current_process = PROCESS_NONE;        while (!file_handler->stopped                && request_queue_is_empty(&file_handler->queue)) {            cond_wait(file_handler->event_cond, file_handler->mutex);        }        if (file_handler->stopped) {            // stop immediately, do not process further events            mutex_unlock(file_handler->mutex);            break;        }        struct request *req;        SDL_bool non_empty = request_queue_take(&file_handler->queue, &req);        SDL_assert(non_empty);        process_t process;        if (req->action == ACTION_INSTALL_APK) {            LOGI("Installing %s...", req->file);            process = install_apk(file_handler->serial, req->file);        } else {            LOGI("Pushing %s...", req->file);            process = push_file(file_handler->serial, req->file);        }        file_handler->current_process = process;        mutex_unlock(file_handler->mutex);        if (req->action == ACTION_INSTALL_APK) {            if (process_check_success(process, "adb install")) {                LOGI("%s successfully installed", req->file);            } else {                LOGE("Failed to install %s", req->file);            }        } else {            if (process_check_success(process, "adb push")) {                LOGI("%s successfully pushed to /sdcard/", req->file);            } else {                LOGE("Failed to push %s to /sdcard/", req->file);            }        }        request_free(req);    }    return 0;}
file_handler_request(struct file_handler *file_handler,                     file_handler_action_t action,                     const char *file) {    SDL_bool res;    // start file_handler if it's used for the first time    if (!file_handler->initialized) {        if (!file_handler_start(file_handler)) {            return SDL_FALSE;        }        file_handler->initialized = SDL_TRUE;    }    LOGI("Request to %s %s", action == ACTION_INSTALL_APK ? "install" : "push",                             file);    struct request *req = request_new(action, file);    if (!req) {        LOGE("Could not create request");        return SDL_FALSE;    }    mutex_lock(file_handler->mutex);    SDL_bool was_empty = request_queue_is_empty(&file_handler->queue);    res = request_queue_push(&file_handler->queue, req);    if (was_empty) {        cond_signal(file_handler->event_cond);    }    mutex_unlock(file_handler->mutex);    return res;}
push_file(const char *serial, const char *file) {    return adb_push(serial, file, DEVICE_SDCARD_PATH);}
file_handler_stop(struct file_handler *file_handler) {    mutex_lock(file_handler->mutex);    file_handler->stopped = SDL_TRUE;    cond_signal(file_handler->event_cond);    if (file_handler->current_process != PROCESS_NONE) {        if (!cmd_terminate(file_handler->current_process)) {            LOGW("Cannot terminate install process");        }        cmd_simple_wait(file_handler->current_process, NULL);        file_handler->current_process = PROCESS_NONE;    }    mutex_unlock(file_handler->mutex);}
install_apk(const char *serial, const char *file) {    return adb_install(serial, file);}
request_queue_is_full(const struct request_queue *queue) {    return (queue->head + 1) % REQUEST_QUEUE_SIZE == queue->tail;}
request_queue_take(struct request_queue *queue, struct request **req) {    if (request_queue_is_empty(queue)) {        return SDL_FALSE;    }    // transfer ownership    *req = queue->reqs[queue->tail];    queue->tail = (queue->tail + 1) % REQUEST_QUEUE_SIZE;    return SDL_TRUE;}
request_free(struct request *req) {    if (!req) {        return;    }    SDL_free((void *) req->file);    SDL_free((void *) req);}
request_queue_is_empty(const struct request_queue *queue) {    return queue->head == queue->tail;}
static void display_fps(struct fps_counter *counter) {#ifdef SKIP_FRAMES    if (counter->nr_skipped) {        LOGI("%d fps (+%d frames skipped)", counter->nr_rendered, counter->nr_skipped);    } else {#endif    LOGI("%d fps", counter->nr_rendered);#ifdef SKIP_FRAMES    }#endif}
void fps_counter_add_rendered_frame(struct fps_counter *counter) {    check_expired(counter);    ++counter->nr_rendered;}
void fps_counter_start(struct fps_counter *counter) {    counter->started = SDL_TRUE;    counter->slice_start = SDL_GetTicks();    counter->nr_rendered = 0;#ifdef SKIP_FRAMES    counter->nr_skipped = 0;#endif}
void fps_counter_init(struct fps_counter *counter) {    counter->started = SDL_FALSE;    // no need to initialize the other fields, they are meaningful only when    // started is true}
static void check_expired(struct fps_counter *counter) {    Uint32 now = SDL_GetTicks();    if (now - counter->slice_start >= 1000) {        display_fps(counter);        // add a multiple of one second        Uint32 elapsed_slices = (now - counter->slice_start) / 1000;        counter->slice_start += 1000 * elapsed_slices;        counter->nr_rendered = 0;#ifdef SKIP_FRAMES        counter->nr_skipped = 0;#endif    }}
void fps_counter_add_skipped_frame(struct fps_counter *counter) {    check_expired(counter);    ++counter->nr_skipped;}#endif
void fps_counter_stop(struct fps_counter *counter) {    counter->started = SDL_FALSE;}
display_fps(struct fps_counter *counter) {#ifdef SKIP_FRAMES    if (counter->nr_skipped) {        LOGI("%d fps (+%d frames skipped)", counter->nr_rendered,                                            counter->nr_skipped);    } else {#endif    LOGI("%d fps", counter->nr_rendered);#ifdef SKIP_FRAMES    }#endif}
fps_counter_add_rendered_frame(struct fps_counter *counter) {    check_expired(counter);    ++counter->nr_rendered;}
fps_counter_start(struct fps_counter *counter) {    counter->started = SDL_TRUE;    counter->slice_start = SDL_GetTicks();    counter->nr_rendered = 0;#ifdef SKIP_FRAMES    counter->nr_skipped = 0;#endif}
fps_counter_init(struct fps_counter *counter) {    counter->started = SDL_FALSE;    // no need to initialize the other fields, they are meaningful only when    // started is true}
check_expired(struct fps_counter *counter) {    Uint32 now = SDL_GetTicks();    if (now - counter->slice_start >= 1000) {        display_fps(counter);        // add a multiple of one second        Uint32 elapsed_slices = (now - counter->slice_start) / 1000;        counter->slice_start += 1000 * elapsed_slices;        counter->nr_rendered = 0;#ifdef SKIP_FRAMES        counter->nr_skipped = 0;#endif    }}
fps_counter_add_skipped_frame(struct fps_counter *counter) {    check_expired(counter);    ++counter->nr_skipped;}#endif
fps_counter_stop(struct fps_counter *counter) {    counter->started = SDL_FALSE;}
static void switch_fps_counter_state(struct video_buffer *vb) {    mutex_lock(vb->mutex);    if (vb->fps_counter.started) {        LOGI("FPS counter stopped");        fps_counter_stop(&vb->fps_counter);    } else {        LOGI("FPS counter started");        fps_counter_start(&vb->fps_counter);    }    mutex_unlock(vb->mutex);}
void input_manager_process_text_input(struct input_manager *input_manager,                                      const SDL_TextInputEvent *event) {    char c = event->text[0];    if (isalpha(c) || c == ' ') {        SDL_assert(event->text[1] == '\0');        // letters and space are handled as raw key event        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    control_event.text_event.text = SDL_strdup(event->text);    if (!control_event.text_event.text) {        LOGW("Cannot strdup input text");        return;    }    if (!controller_push_event(input_manager->controller, &control_event)) {        SDL_free(control_event.text_event.text);        LOGW("Cannot send text event");    }}
static void press_back_or_turn_screen_on(struct controller *controller) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_COMMAND;    control_event.command_event.action = CONTROL_EVENT_COMMAND_BACK_OR_SCREEN_ON;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot turn screen on");    }}
static void expand_notification_panel(struct controller *controller) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_COMMAND;    control_event.command_event.action = CONTROL_EVENT_COMMAND_EXPAND_NOTIFICATION_PANEL;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot expand notification panel");    }}
static inline void action_back(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_BACK, actions, "BACK");}
static struct point get_mouse_point(struct screen *screen) {    int x;    int y;    SDL_GetMouseState(&x, &y);    convert_to_renderer_coordinates(screen->renderer, &x, &y);    return (struct point) {        .x = x,        .y = y,    };}
static inline void action_power(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_POWER, actions, "POWER");}
static inline void action_home(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_HOME, actions, "HOME");}
static void send_keycode(struct controller *controller, enum android_keycode keycode, int actions, const char *name) {    // send DOWN event    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_KEYCODE;    control_event.keycode_event.keycode = keycode;    control_event.keycode_event.metastate = 0;    if (actions & ACTION_DOWN) {        control_event.keycode_event.action = AKEY_EVENT_ACTION_DOWN;        if (!controller_push_event(controller, &control_event)) {            LOGW("Cannot send %s (DOWN)", name);            return;        }    }    if (actions & ACTION_UP) {        control_event.keycode_event.action = AKEY_EVENT_ACTION_UP;        if (!controller_push_event(controller, &control_event)) {            LOGW("Cannot send %s (UP)", name);        }    }}
static void clipboard_paste(struct controller *controller) {    char *text = SDL_GetClipboardText();    if (!text) {        LOGW("Cannot get clipboard text: %s", SDL_GetError());        return;    }    if (!*text) {        // empty text        SDL_free(text);        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    control_event.text_event.text = text;    if (!controller_push_event(controller, &control_event)) {        SDL_free(text);        LOGW("Cannot send clipboard paste event");    }}
static inline void action_volume_down(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_VOLUME_DOWN, actions, "VOLUME_DOWN");}
static void convert_to_renderer_coordinates(SDL_Renderer *renderer, int *x, int *y) {    SDL_Rect viewport;    float scale_x, scale_y;    SDL_RenderGetViewport(renderer, &viewport);    SDL_RenderGetScale(renderer, &scale_x, &scale_y);    *x = (int) (*x / scale_x) - viewport.x;    *y = (int) (*y / scale_y) - viewport.y;}
static void collapse_notification_panel(struct controller *controller) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_COMMAND;    control_event.command_event.action = CONTROL_EVENT_COMMAND_COLLAPSE_NOTIFICATION_PANEL;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot collapse notification panel");    }}
static inline void action_menu(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_MENU, actions, "MENU");}
static inline void action_app_switch(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_APP_SWITCH, actions, "APP_SWITCH");}
static inline void action_volume_up(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_VOLUME_UP, actions, "VOLUME_UP");}
switch_fps_counter_state(struct video_buffer *vb) {    mutex_lock(vb->mutex);    if (vb->fps_counter.started) {        LOGI("FPS counter stopped");        fps_counter_stop(&vb->fps_counter);    } else {        LOGI("FPS counter started");        fps_counter_start(&vb->fps_counter);    }    mutex_unlock(vb->mutex);}
input_manager_process_text_input(struct input_manager *input_manager,                                 const SDL_TextInputEvent *event) {    char c = event->text[0];    if (isalpha(c) || c == ' ') {        SDL_assert(event->text[1] == '\0');        // letters and space are handled as raw key event        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    control_event.text_event.text = SDL_strdup(event->text);    if (!control_event.text_event.text) {        LOGW("Cannot strdup input text");        return;    }    if (!controller_push_event(input_manager->controller, &control_event)) {        SDL_free(control_event.text_event.text);        LOGW("Cannot send text event");    }}
press_back_or_turn_screen_on(struct controller *controller) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_COMMAND;    control_event.command_event.action =            CONTROL_EVENT_COMMAND_BACK_OR_SCREEN_ON;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot turn screen on");    }}
expand_notification_panel(struct controller *controller) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_COMMAND;    control_event.command_event.action =            CONTROL_EVENT_COMMAND_EXPAND_NOTIFICATION_PANEL;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot expand notification panel");    }}
action_back(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_BACK, actions, "BACK");}
get_mouse_point(struct screen *screen) {    int x;    int y;    SDL_GetMouseState(&x, &y);    convert_to_renderer_coordinates(screen->renderer, &x, &y);    return (struct point) {        .x = x,        .y = y,    };}
action_power(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_POWER, actions, "POWER");}
action_home(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_HOME, actions, "HOME");}
send_keycode(struct controller *controller, enum android_keycode keycode,             int actions, const char *name) {    // send DOWN event    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_KEYCODE;    control_event.keycode_event.keycode = keycode;    control_event.keycode_event.metastate = 0;    if (actions & ACTION_DOWN) {        control_event.keycode_event.action = AKEY_EVENT_ACTION_DOWN;        if (!controller_push_event(controller, &control_event)) {            LOGW("Cannot send %s (DOWN)", name);            return;        }    }    if (actions & ACTION_UP) {        control_event.keycode_event.action = AKEY_EVENT_ACTION_UP;        if (!controller_push_event(controller, &control_event)) {            LOGW("Cannot send %s (UP)", name);        }    }}
clipboard_paste(struct controller *controller) {    char *text = SDL_GetClipboardText();    if (!text) {        LOGW("Cannot get clipboard text: %s", SDL_GetError());        return;    }    if (!*text) {        // empty text        SDL_free(text);        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    control_event.text_event.text = text;    if (!controller_push_event(controller, &control_event)) {        SDL_free(text);        LOGW("Cannot send clipboard paste event");    }}
action_volume_down(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_VOLUME_DOWN, actions, "VOLUME_DOWN");}
convert_to_renderer_coordinates(SDL_Renderer *renderer, int *x, int *y) {    SDL_Rect viewport;    float scale_x, scale_y;    SDL_RenderGetViewport(renderer, &viewport);    SDL_RenderGetScale(renderer, &scale_x, &scale_y);    *x = (int) (*x / scale_x) - viewport.x;    *y = (int) (*y / scale_y) - viewport.y;}
collapse_notification_panel(struct controller *controller) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_COMMAND;    control_event.command_event.action =            CONTROL_EVENT_COMMAND_COLLAPSE_NOTIFICATION_PANEL;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot collapse notification panel");    }}
action_menu(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_MENU, actions, "MENU");}
action_app_switch(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_APP_SWITCH, actions, "APP_SWITCH");}
action_volume_up(struct controller *controller, int actions) {    send_keycode(controller, AKEYCODE_VOLUME_UP, actions, "VOLUME_UP");}
void mutex_unlock(SDL_mutex *mutex) {    if (SDL_UnlockMutex(mutex)) {        LOGC("Could not unlock mutex");        abort();    }}
void cond_signal(SDL_cond *cond) {    if (SDL_CondSignal(cond)) {        LOGC("Could not signal a condition");        abort();    }}
void cond_wait(SDL_cond *cond, SDL_mutex *mutex) {    if (SDL_CondWait(cond, mutex)) {        LOGC("Could not wait on condition");        abort();    }}
void mutex_lock(SDL_mutex *mutex) {    if (SDL_LockMutex(mutex)) {        LOGC("Could not lock mutex");        abort();    }}
mutex_unlock(SDL_mutex *mutex) {    if (SDL_UnlockMutex(mutex)) {        LOGC("Could not unlock mutex");        abort();    }}
cond_signal(SDL_cond *cond) {    if (SDL_CondSignal(cond)) {        LOGC("Could not signal a condition");        abort();    }}
cond_wait(SDL_cond *cond, SDL_mutex *mutex) {    if (SDL_CondWait(cond, mutex)) {        LOGC("Could not wait on condition");        abort();    }}
mutex_lock(SDL_mutex *mutex) {    if (SDL_LockMutex(mutex)) {        LOGC("Could not lock mutex");        abort();    }}
static SDL_bool parse_bit_rate(char *optarg, Uint32 *bit_rate) {    char *endptr;    if (*optarg == '\0') {        LOGE("Bit-rate parameter is empty");        return SDL_FALSE;    }    long value = strtol(optarg, &endptr, 0);    int mul = 1;    if (*endptr != '\0') {        if (optarg == endptr) {            LOGE("Invalid bit-rate: %s", optarg);            return SDL_FALSE;        }        if ((*endptr == 'M' || *endptr == 'm') && endptr[1] == '\0') {            mul = 1000000;        } else if ((*endptr == 'K' || *endptr == 'k') && endptr[1] == '\0') {            mul = 1000;        } else {            LOGE("Invalid bit-rate unit: %s", optarg);            return SDL_FALSE;        }    }    if (value < 0 || ((Uint32) -1) / mul < value) {        LOGE("Bitrate must be positive and less than 2^32: %s", optarg);        return SDL_FALSE;    }    *bit_rate = (Uint32) value * mul;    return SDL_TRUE;}
static SDL_bool parse_port(char *optarg, Uint16 *port) {    char *endptr;    if (*optarg == '\0') {        LOGE("Invalid port parameter is empty");        return SDL_FALSE;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid port: %s", optarg);        return SDL_FALSE;    }    if (value & ~0xffff) {        LOGE("Port out of range: %ld", value);        return SDL_FALSE;    }    *port = (Uint16) value;    return SDL_TRUE;}
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top", no_argument,       NULL, 'T'},        {"bit-rate",      required_argument, NULL, 'b'},        {"crop",          required_argument, NULL, 'c'},        {"fullscreen",    no_argument,       NULL, 'f'},        {"help",          no_argument,       NULL, 'h'},        {"max-size",      required_argument, NULL, 'm'},        {"no-window",     no_argument,       NULL, 'n'},        {"port",          required_argument, NULL, 'p'},        {"record",        required_argument, NULL, 'r'},        {"record-format", required_argument, NULL, 'f'},        {"serial",        required_argument, NULL, 's'},        {"show-touches",  no_argument,       NULL, 't'},        {"version",       no_argument,       NULL, 'v'},        {NULL,            0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:np:r:s:tTv", long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = SDL_TRUE;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return SDL_FALSE;                }                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'n':                args->no_window = SDL_TRUE;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = SDL_TRUE;                break;            case 'T':                args->always_on_top = SDL_TRUE;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    if (args->no_window && !args->record_filename) {        LOGE("-n/--no-window requires screen recording (-r/--record)");        return SDL_FALSE;    }    if (args->no_window && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -n/--no-window");        return SDL_FALSE;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return SDL_FALSE;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return SDL_FALSE;        }    }    return SDL_TRUE;}
static SDL_bool parse_max_size(char *optarg, Uint16 *max_size) {    char *endptr;    if (*optarg == '\0') {        LOGE("Max size parameter is empty");        return SDL_FALSE;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid max size: %s", optarg);        return SDL_FALSE;    }    if (value & ~0xffff) {        LOGE("Max size must be between 0 and 65535: %ld", value);        return SDL_FALSE;    }    *max_size = (Uint16) value;    return SDL_TRUE;}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .record_format = 0,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = SDL_FALSE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,        .no_window = args.no_window,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
static void print_version(void) {    fprintf(stderr, "scrcpy %s\n\n", SCRCPY_VERSION);    fprintf(stderr, "dependencies:\n");    fprintf(stderr, " - SDL %d.%d.%d\n", SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL);    fprintf(stderr, " - libavcodec %d.%d.%d\n", LIBAVCODEC_VERSION_MAJOR, LIBAVCODEC_VERSION_MINOR, LIBAVCODEC_VERSION_MICRO);    fprintf(stderr, " - libavformat %d.%d.%d\n", LIBAVFORMAT_VERSION_MAJOR, LIBAVFORMAT_VERSION_MINOR, LIBAVFORMAT_VERSION_MICRO);    fprintf(stderr, " - libavutil %d.%d.%d\n", LIBAVUTIL_VERSION_MAJOR, LIBAVUTIL_VERSION_MINOR, LIBAVUTIL_VERSION_MICRO);}
parse_bit_rate(char *optarg, Uint32 *bit_rate) {    char *endptr;    if (*optarg == '\0') {        LOGE("Bit-rate parameter is empty");        return SDL_FALSE;    }    long value = strtol(optarg, &endptr, 0);    int mul = 1;    if (*endptr != '\0') {        if (optarg == endptr) {            LOGE("Invalid bit-rate: %s", optarg);            return SDL_FALSE;        }        if ((*endptr == 'M' || *endptr == 'm') && endptr[1] == '\0') {            mul = 1000000;        } else if ((*endptr == 'K' || *endptr == 'k') && endptr[1] == '\0') {            mul = 1000;        } else {            LOGE("Invalid bit-rate unit: %s", optarg);            return SDL_FALSE;        }    }    if (value < 0 || ((Uint32) -1) / mul < value) {        LOGE("Bitrate must be positive and less than 2^32: %s", optarg);        return SDL_FALSE;    }    *bit_rate = (Uint32) value * mul;    return SDL_TRUE;}
parse_port(char *optarg, Uint16 *port) {    char *endptr;    if (*optarg == '\0') {        LOGE("Invalid port parameter is empty");        return SDL_FALSE;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid port: %s", optarg);        return SDL_FALSE;    }    if (value & ~0xffff) {        LOGE("Port out of range: %ld", value);        return SDL_FALSE;    }    *port = (Uint16) value;    return SDL_TRUE;}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top", no_argument,       NULL, 'T'},        {"bit-rate",      required_argument, NULL, 'b'},        {"crop",          required_argument, NULL, 'c'},        {"fullscreen",    no_argument,       NULL, 'f'},        {"help",          no_argument,       NULL, 'h'},        {"max-size",      required_argument, NULL, 'm'},        {"no-window",     no_argument,       NULL, 'n'},        {"port",          required_argument, NULL, 'p'},        {"record",        required_argument, NULL, 'r'},        {"record-format", required_argument, NULL, 'f'},        {"serial",        required_argument, NULL, 's'},        {"show-touches",  no_argument,       NULL, 't'},        {"version",       no_argument,       NULL, 'v'},        {NULL,            0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:np:r:s:tTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = SDL_TRUE;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return SDL_FALSE;                }                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'n':                args->no_window = SDL_TRUE;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = SDL_TRUE;                break;            case 'T':                args->always_on_top = SDL_TRUE;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    if (args->no_window && !args->record_filename) {        LOGE("-n/--no-window requires screen recording (-r/--record)");        return SDL_FALSE;    }    if (args->no_window && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -n/--no-window");        return SDL_FALSE;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return SDL_FALSE;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return SDL_FALSE;        }    }    return SDL_TRUE;}
parse_max_size(char *optarg, Uint16 *max_size) {    char *endptr;    if (*optarg == '\0') {        LOGE("Max size parameter is empty");        return SDL_FALSE;    }    long value = strtol(optarg, &endptr, 0);    if (*endptr != '\0') {        LOGE("Invalid max size: %s", optarg);        return SDL_FALSE;    }    if (value & ~0xffff) {        LOGE("Max size must be between 0 and 65535: %ld", value);        return SDL_FALSE;    }    *max_size = (Uint16) value;    return SDL_TRUE;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .record_format = 0,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = SDL_FALSE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,        .no_window = args.no_window,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
print_version(void) {    fprintf(stderr, "scrcpy %s\n\n", SCRCPY_VERSION);    fprintf(stderr, "dependencies:\n");    fprintf(stderr, " - SDL %d.%d.%d\n", SDL_MAJOR_VERSION, SDL_MINOR_VERSION,                                         SDL_PATCHLEVEL);    fprintf(stderr, " - libavcodec %d.%d.%d\n", LIBAVCODEC_VERSION_MAJOR,                                                LIBAVCODEC_VERSION_MINOR,                                                LIBAVCODEC_VERSION_MICRO);    fprintf(stderr, " - libavformat %d.%d.%d\n", LIBAVFORMAT_VERSION_MAJOR,                                                 LIBAVFORMAT_VERSION_MINOR,                                                 LIBAVFORMAT_VERSION_MICRO);    fprintf(stderr, " - libavutil %d.%d.%d\n", LIBAVUTIL_VERSION_MAJOR,                                               LIBAVUTIL_VERSION_MINOR,                                               LIBAVUTIL_VERSION_MICRO);}
socket_t net_connect(Uint32 addr, Uint16 port) {    socket_t sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        perror("socket");        return INVALID_SOCKET;    }    SOCKADDR_IN sin;    sin.sin_family = AF_INET;    sin.sin_addr.s_addr = htonl(addr);    sin.sin_port = htons(port);    if (connect(sock, (SOCKADDR *) &sin, sizeof(sin)) == SOCKET_ERROR) {        perror("connect");        return INVALID_SOCKET;    }    return sock;}
ssize_t net_send_all(socket_t socket, const void *buf, size_t len) {    ssize_t w = 0;    while (len > 0) {        w = send(socket, buf, len, 0);        if (w == -1) {            return -1;        }        len -= w;        buf = (char *) buf + w;    }    return w;}
socket_t net_listen(Uint32 addr, Uint16 port, int backlog) {    socket_t sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        perror("socket");        return INVALID_SOCKET;    }    int reuse = 1;    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (const void *) &reuse, sizeof(reuse)) == -1) {        perror("setsockopt(SO_REUSEADDR)");    }    SOCKADDR_IN sin;    sin.sin_family = AF_INET;    sin.sin_addr.s_addr = htonl(addr); // htonl() harmless on INADDR_ANY    sin.sin_port = htons(port);    if (bind(sock, (SOCKADDR *) &sin, sizeof(sin)) == SOCKET_ERROR) {        perror("bind");        return INVALID_SOCKET;    }    if (listen(sock, backlog) == SOCKET_ERROR) {        perror("listen");        return INVALID_SOCKET;    }    return sock;}
ssize_t net_recv(socket_t socket, void *buf, size_t len) {    return recv(socket, buf, len, 0);}
ssize_t net_recv_all(socket_t socket, void *buf, size_t len) {    return recv(socket, buf, len, MSG_WAITALL);}
socket_t net_accept(socket_t server_socket) {    SOCKADDR_IN csin;    socklen_t sinsize = sizeof(csin);    return accept(server_socket, (SOCKADDR *) &csin, &sinsize);}
ssize_t net_send(socket_t socket, const void *buf, size_t len) {    return send(socket, buf, len, 0);}
SDL_bool net_shutdown(socket_t socket, int how) {    return !shutdown(socket, how);}
net_connect(Uint32 addr, Uint16 port) {    socket_t sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        perror("socket");        return INVALID_SOCKET;    }    SOCKADDR_IN sin;    sin.sin_family = AF_INET;    sin.sin_addr.s_addr = htonl(addr);    sin.sin_port = htons(port);    if (connect(sock, (SOCKADDR *) &sin, sizeof(sin)) == SOCKET_ERROR) {        perror("connect");        return INVALID_SOCKET;    }    return sock;}
net_send_all(socket_t socket, const void *buf, size_t len) {    ssize_t w = 0;    while (len > 0) {        w = send(socket, buf, len, 0);        if (w == -1) {            return -1;        }        len -= w;        buf = (char *) buf + w;    }    return w;}
net_listen(Uint32 addr, Uint16 port, int backlog) {    socket_t sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        perror("socket");        return INVALID_SOCKET;    }    int reuse = 1;    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (const void *) &reuse,                   sizeof(reuse)) == -1) {        perror("setsockopt(SO_REUSEADDR)");    }    SOCKADDR_IN sin;    sin.sin_family = AF_INET;    sin.sin_addr.s_addr = htonl(addr); // htonl() harmless on INADDR_ANY    sin.sin_port = htons(port);    if (bind(sock, (SOCKADDR *) &sin, sizeof(sin)) == SOCKET_ERROR) {        perror("bind");        return INVALID_SOCKET;    }    if (listen(sock, backlog) == SOCKET_ERROR) {        perror("listen");        return INVALID_SOCKET;    }    return sock;}
net_recv(socket_t socket, void *buf, size_t len) {    return recv(socket, buf, len, 0);}
net_recv_all(socket_t socket, void *buf, size_t len) {    return recv(socket, buf, len, MSG_WAITALL);}
net_accept(socket_t server_socket) {    SOCKADDR_IN csin;    socklen_t sinsize = sizeof(csin);    return accept(server_socket, (SOCKADDR *) &csin, &sinsize);}
net_send(socket_t socket, const void *buf, size_t len) {    return send(socket, buf, len, 0);}
net_shutdown(socket_t socket, int how) {    return !shutdown(socket, how);}
SDL_bool recorder_init(struct recorder *recorder,                       const char *filename,                       enum recorder_format format,                       struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Cannot strdup filename");        return SDL_FALSE;    }    recorder->format = format;    recorder->declared_frame_size = declared_frame_size;    recorder->header_written = SDL_FALSE;    return SDL_TRUE;}
static const AVOutputFormat *find_muxer(const char *name) {#ifdef SCRCPY_LAVF_HAS_NEW_MUXER_ITERATOR_API    void *opaque = NULL;#endif    const AVOutputFormat *oformat = NULL;    do {#ifdef SCRCPY_LAVF_HAS_NEW_MUXER_ITERATOR_API        oformat = av_muxer_iterate(&opaque);#else        oformat = av_oformat_next(oformat);#endif        // until null or with name "mp4"    } while (oformat && strcmp(oformat->name, name));    return oformat;}
SDL_bool recorder_open(struct recorder *recorder, AVCodec *input_codec) {    const char *format_name = recorder_get_format_name(recorder->format);    SDL_assert(format_name);    const AVOutputFormat *format = find_muxer(format_name);    if (!format) {        LOGE("Could not find muxer");        return SDL_FALSE;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return SDL_FALSE;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) format;    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }#ifdef SCRCPY_LAVF_HAS_NEW_CODEC_PARAMS_API    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    LOGI("Recording started to %s file: %s", format_name, recorder->filename);    return SDL_TRUE;}
SDL_bool recorder_write(struct recorder *recorder, AVPacket *packet) {    if (!recorder->header_written) {        SDL_bool ok = recorder_write_header(recorder, packet);        if (!ok) {            return SDL_FALSE;        }        recorder->header_written = SDL_TRUE;    }    recorder_rescale_packet(recorder, packet);    return av_write_frame(recorder->ctx, packet) >= 0;}
void recorder_close(struct recorder *recorder) {    int ret = av_write_trailer(recorder->ctx);    if (ret < 0) {        LOGE("Failed to write trailer to %s", recorder->filename);    }    avio_close(recorder->ctx->pb);    avformat_free_context(recorder->ctx);    const char *format_name = recorder_get_format_name(recorder->format);    LOGI("Recording complete to %s file: %s", format_name, recorder->filename);}
void recorder_destroy(struct recorder *recorder) {    SDL_free(recorder->filename);}
recorder_init(struct recorder *recorder,              const char *filename,              enum recorder_format format,              struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Cannot strdup filename");        return SDL_FALSE;    }    recorder->format = format;    recorder->declared_frame_size = declared_frame_size;    recorder->header_written = SDL_FALSE;    return SDL_TRUE;}
find_muxer(const char *name) {#ifdef SCRCPY_LAVF_HAS_NEW_MUXER_ITERATOR_API    void *opaque = NULL;#endif    const AVOutputFormat *oformat = NULL;    do {#ifdef SCRCPY_LAVF_HAS_NEW_MUXER_ITERATOR_API        oformat = av_muxer_iterate(&opaque);#else        oformat = av_oformat_next(oformat);#endif        // until null or with name "mp4"    } while (oformat && strcmp(oformat->name, name));    return oformat;}
recorder_open(struct recorder *recorder, AVCodec *input_codec) {    const char *format_name = recorder_get_format_name(recorder->format);    SDL_assert(format_name);    const AVOutputFormat *format = find_muxer(format_name);    if (!format) {        LOGE("Could not find muxer");        return SDL_FALSE;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return SDL_FALSE;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) format;    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }#ifdef SCRCPY_LAVF_HAS_NEW_CODEC_PARAMS_API    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    LOGI("Recording started to %s file: %s", format_name, recorder->filename);    return SDL_TRUE;}
recorder_write(struct recorder *recorder, AVPacket *packet) {    if (!recorder->header_written) {        SDL_bool ok = recorder_write_header(recorder, packet);        if (!ok) {            return SDL_FALSE;        }        recorder->header_written = SDL_TRUE;    }    recorder_rescale_packet(recorder, packet);    return av_write_frame(recorder->ctx, packet) >= 0;}
recorder_close(struct recorder *recorder) {    int ret = av_write_trailer(recorder->ctx);    if (ret < 0) {        LOGE("Failed to write trailer to %s", recorder->filename);    }    avio_close(recorder->ctx->pb);    avformat_free_context(recorder->ctx);    const char *format_name = recorder_get_format_name(recorder->format);    LOGI("Recording complete to %s file: %s", format_name, recorder->filename);}
recorder_destroy(struct recorder *recorder) {    SDL_free(recorder->filename);}
static SDL_bool is_apk(const char *file) {    const char *ext = strrchr(file, '.');    return ext && !strcmp(ext, ".apk");}
static SDL_bool event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_STREAM_STOPPED:                LOGD("Video stream stopped");                return SDL_FALSE;            case SDL_QUIT:                LOGD("User requested to quit");                return SDL_TRUE;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &video_buffer)) {                    return SDL_FALSE;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                    case SDL_WINDOWEVENT_EXPOSED:                    case SDL_WINDOWEVENT_SIZE_CHANGED:                        screen_render(&screen);                        break;                }                break;            case SDL_TEXTINPUT:                input_manager_process_text_input(&input_manager, &event.text);                break;            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL:                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP:                input_manager_process_mouse_button(&input_manager, &event.button);                break;            case SDL_DROPFILE: {                file_handler_action_t action;                if (is_apk(event.drop.file)) {                    action = ACTION_INSTALL_APK;                } else {                    action = ACTION_PUSH_FILE;                }                file_handler_request(&file_handler, action, event.drop.file);                break;            }        }    }    return SDL_FALSE;}
static SDL_LogPriority sdl_priority_from_av_level(int level) {    switch (level) {        case AV_LOG_PANIC:        case AV_LOG_FATAL:            return SDL_LOG_PRIORITY_CRITICAL;        case AV_LOG_ERROR:            return SDL_LOG_PRIORITY_ERROR;        case AV_LOG_WARNING:            return SDL_LOG_PRIORITY_WARN;        case AV_LOG_INFO:            return SDL_LOG_PRIORITY_INFO;    }    // do not forward others, which are too verbose    return 0;}
static void wait_show_touches(process_t process) {    // reap the process, ignore the result    process_check_success(process, "show_touches");}
SDL_bool scrcpy(const struct scrcpy_options *options) {    SDL_bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    SDL_bool display = !options->no_window;    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            server_stop(&server);            ret = SDL_FALSE;            goto finally_destroy_server;        }        if (!file_handler_init(&file_handler, server.serial)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_video_buffer;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (display) {        if (!controller_init(&controller, device_socket)) {            ret = SDL_FALSE;            goto finally_stop_stream;        }        if (!controller_start(&controller)) {            ret = SDL_FALSE;            goto finally_destroy_controller;        }        if (!screen_init_rendering(&screen, device_name, frame_size, options->always_on_top)) {            ret = SDL_FALSE;            goto finally_stop_and_join_controller;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    if (display) {        controller_stop(&controller);        controller_join(&controller);    }finally_destroy_controller:    if (display) {        controller_destroy(&controller);    }finally_stop_stream:    stream_stop(&stream);    // stop the server before stream_join() to wake up the stream    server_stop(&server);    stream_join(&stream);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    if (display) {        file_handler_stop(&file_handler);        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }finally_destroy_video_buffer:    if (display) {        video_buffer_destroy(&video_buffer);    }finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
static int event_watcher(void *data, SDL_Event *event) {    if (event->type == SDL_WINDOWEVENT && event->window.event == SDL_WINDOWEVENT_RESIZED) {        // called from another thread, not very safe, but it's a workaround!        screen_render(&screen);    }    return 0;}#endif
static process_t set_show_touches_enabled(const char *serial, SDL_bool enabled) {    const char *value = enabled ? "1" : "0";    const char *const adb_cmd[] = {        "shell", "settings", "put", "system", "show_touches", value    };    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
is_apk(const char *file) {    const char *ext = strrchr(file, '.');    return ext && !strcmp(ext, ".apk");}
event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_STREAM_STOPPED:                LOGD("Video stream stopped");                return SDL_FALSE;            case SDL_QUIT:                LOGD("User requested to quit");                return SDL_TRUE;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &video_buffer)) {                    return SDL_FALSE;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                    case SDL_WINDOWEVENT_EXPOSED:                    case SDL_WINDOWEVENT_SIZE_CHANGED:                        screen_render(&screen);                        break;                }                break;            case SDL_TEXTINPUT:                input_manager_process_text_input(&input_manager, &event.text);                break;            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager,                                                   &event.motion);                break;            case SDL_MOUSEWHEEL:                input_manager_process_mouse_wheel(&input_manager,                                                  &event.wheel);                break;            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP:                input_manager_process_mouse_button(&input_manager,                                                   &event.button);                break;            case SDL_DROPFILE: {                file_handler_action_t action;                if (is_apk(event.drop.file)) {                    action = ACTION_INSTALL_APK;                } else {                    action = ACTION_PUSH_FILE;                }                file_handler_request(&file_handler, action, event.drop.file);                break;            }        }    }    return SDL_FALSE;}
sdl_priority_from_av_level(int level) {    switch (level) {        case AV_LOG_PANIC:        case AV_LOG_FATAL:            return SDL_LOG_PRIORITY_CRITICAL;        case AV_LOG_ERROR:            return SDL_LOG_PRIORITY_ERROR;        case AV_LOG_WARNING:            return SDL_LOG_PRIORITY_WARN;        case AV_LOG_INFO:            return SDL_LOG_PRIORITY_INFO;    }    // do not forward others, which are too verbose    return 0;}
wait_show_touches(process_t process) {    // reap the process, ignore the result    process_check_success(process, "show_touches");}
scrcpy(const struct scrcpy_options *options) {    SDL_bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    SDL_bool display = !options->no_window;    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            server_stop(&server);            ret = SDL_FALSE;            goto finally_destroy_server;        }        if (!file_handler_init(&file_handler, server.serial)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_video_buffer;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (display) {        if (!controller_init(&controller, device_socket)) {            ret = SDL_FALSE;            goto finally_stop_stream;        }        if (!controller_start(&controller)) {            ret = SDL_FALSE;            goto finally_destroy_controller;        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            ret = SDL_FALSE;            goto finally_stop_and_join_controller;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    if (display) {        controller_stop(&controller);        controller_join(&controller);    }finally_destroy_controller:    if (display) {        controller_destroy(&controller);    }finally_stop_stream:    stream_stop(&stream);    // stop the server before stream_join() to wake up the stream    server_stop(&server);    stream_join(&stream);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    if (display) {        file_handler_stop(&file_handler);        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }finally_destroy_video_buffer:    if (display) {        video_buffer_destroy(&video_buffer);    }finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial,                                                     SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
event_watcher(void *data, SDL_Event *event) {    if (event->type == SDL_WINDOWEVENT            && event->window.event == SDL_WINDOWEVENT_RESIZED) {        // called from another thread, not very safe, but it's a workaround!        screen_render(&screen);    }    return 0;}#endif
set_show_touches_enabled(const char *serial, SDL_bool enabled) {    const char *value = enabled ? "1" : "0";    const char *const adb_cmd[] = {        "shell", "settings", "put", "system", "show_touches", value    };    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
static SDL_bool get_preferred_display_bounds(struct size *bounds) {    SDL_Rect rect;#ifdef SCRCPY_SDL_HAS_GET_DISPLAY_USABLE_BOUNDS# define GET_DISPLAY_BOUNDS(i, r) SDL_GetDisplayUsableBounds((i), (r))#else# define GET_DISPLAY_BOUNDS(i, r) SDL_GetDisplayBounds((i), (r))#endif    if (GET_DISPLAY_BOUNDS(0, &rect)) {        LOGW("Could not get display usable bounds: %s", SDL_GetError());        return SDL_FALSE;    }    bounds->width = MAX(0, rect.w - DISPLAY_MARGINS);    bounds->height = MAX(0, rect.h - DISPLAY_MARGINS);    return SDL_TRUE;}
SDL_bool screen_init_rendering(struct screen *screen,                               const char *device_name,                               struct size frame_size,                               SDL_bool always_on_top) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    Uint32 window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height, window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1, SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width, frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    return SDL_TRUE;}
void screen_resize_to_fit(struct screen *screen) {    if (!screen->fullscreen) {        struct size optimal_size = get_optimal_window_size(screen, screen->frame_size);        SDL_SetWindowSize(screen->window, optimal_size.width, optimal_size.height);        LOGD("Resized to optimal size");    }}
static inline SDL_Texture *create_texture(SDL_Renderer *renderer, struct size frame_size) {    return SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                             frame_size.width, frame_size.height);}
static struct size get_optimal_size(struct size current_size, struct size frame_size) {    if (frame_size.width == 0 || frame_size.height == 0) {        // avoid division by 0        return current_size;    }    struct size display_size;    // 32 bits because we need to multiply two 16 bits values    Uint32 w;    Uint32 h;    if (!get_preferred_display_bounds(&display_size)) {        // cannot get display bounds, do not constraint the size        w = current_size.width;        h = current_size.height;    } else {        w = MIN(current_size.width, display_size.width);        h = MIN(current_size.height, display_size.height);    }    SDL_bool keep_width = frame_size.width * h > frame_size.height * w;    if (keep_width) {        // remove black borders on top and bottom        h = frame_size.height * w / frame_size.width;    } else {        // remove black borders on left and right (or none at all if it already fits)        w = frame_size.width * h / frame_size.height;    }    // w and h must fit into 16 bits    SDL_assert_release(w < 0x10000 && h < 0x10000);    return (struct size) {w, h};}
void screen_destroy(struct screen *screen) {    if (screen->texture) {        SDL_DestroyTexture(screen->texture);    }    if (screen->renderer) {        SDL_DestroyRenderer(screen->renderer);    }    if (screen->window) {        SDL_DestroyWindow(screen->window);    }}
static inline struct size get_optimal_window_size(const struct screen *screen, struct size frame_size) {    struct size current_size = get_window_size(screen);    return get_optimal_size(current_size, frame_size);}
void screen_init(struct screen *screen) {    *screen = (struct screen) SCREEN_INITIALIZER;}
void screen_render(struct screen *screen) {    SDL_RenderClear(screen->renderer);    SDL_RenderCopy(screen->renderer, screen->texture, NULL, NULL);    SDL_RenderPresent(screen->renderer);}
static inline struct size get_initial_optimal_size(struct size frame_size) {    return get_optimal_size(frame_size, frame_size);}
static void update_texture(struct screen *screen, const AVFrame *frame) {    SDL_UpdateYUVTexture(screen->texture, NULL,            frame->data[0], frame->linesize[0],            frame->data[1], frame->linesize[1],            frame->data[2], frame->linesize[2]);}
static void set_window_size(struct screen *screen, struct size new_size) {    // setting the window size during fullscreen is implementation defined,    // so apply the resize only after fullscreen is disabled    if (screen->fullscreen) {        // SDL_SetWindowSize will be called when fullscreen will be disabled        screen->windowed_window_size = new_size;    } else {        SDL_SetWindowSize(screen->window, new_size.width, new_size.height);    }}
SDL_bool screen_update_frame(struct screen *screen, struct video_buffer *vb) {    mutex_lock(vb->mutex);    const AVFrame *frame = video_buffer_consume_rendered_frame(vb);    struct size new_frame_size = {frame->width, frame->height};    if (!prepare_for_frame(screen, new_frame_size)) {        mutex_unlock(vb->mutex);        return SDL_FALSE;    }    update_texture(screen, frame);    mutex_unlock(vb->mutex);    screen_render(screen);    return SDL_TRUE;}
void screen_switch_fullscreen(struct screen *screen) {    if (!screen->fullscreen) {        // going to fullscreen, store the current windowed window size        screen->windowed_window_size = get_native_window_size(screen->window);    }    Uint32 new_mode = screen->fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;    if (SDL_SetWindowFullscreen(screen->window, new_mode)) {        LOGW("Could not switch fullscreen mode: %s", SDL_GetError());        return;    }    screen->fullscreen = !screen->fullscreen;    if (!screen->fullscreen) {        // fullscreen disabled, restore expected windowed window size        SDL_SetWindowSize(screen->window, screen->windowed_window_size.width, screen->windowed_window_size.height);    }    LOGD("Switched to %s mode", screen->fullscreen ? "fullscreen" : "windowed");    screen_render(screen);}
static SDL_bool prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width || screen->frame_size.height != new_frame_size.height) {        if (SDL_RenderSetLogicalSize(screen->renderer, new_frame_size.width, new_frame_size.height)) {            LOGE("Could not set renderer logical size: %s", SDL_GetError());            return SDL_FALSE;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        struct size current_size = get_window_size(screen);        struct size target_size = {            (Uint32) current_size.width * new_frame_size.width / screen->frame_size.width,            (Uint32) current_size.height * new_frame_size.height / screen->frame_size.height,        };        target_size = get_optimal_size(target_size, new_frame_size);        set_window_size(screen, target_size);        screen->frame_size = new_frame_size;        LOGD("New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = create_texture(screen->renderer, new_frame_size);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return SDL_FALSE;        }    }    return SDL_TRUE;}
void screen_show_window(struct screen *screen) {    SDL_ShowWindow(screen->window);}
static struct size get_native_window_size(SDL_Window *window) {    int width;    int height;    SDL_GetWindowSize(window, &width, &height);    struct size size;    size.width = width;    size.height = height;    return size;}
SDL_bool sdl_init_and_configure(void) {    if (SDL_Init(SDL_INIT_VIDEO)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return SDL_FALSE;    }    atexit(SDL_Quit);    // Use the best available scale quality    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "2")) {        LOGW("Could not enable bilinear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return SDL_TRUE;}
static struct size get_window_size(const struct screen *screen) {    if (screen->fullscreen) {        return screen->windowed_window_size;    }    return get_native_window_size(screen->window);}
void screen_resize_to_pixel_perfect(struct screen *screen) {    if (!screen->fullscreen) {        SDL_SetWindowSize(screen->window, screen->frame_size.width, screen->frame_size.height);        LOGD("Resized to pixel-perfect");    }}
get_preferred_display_bounds(struct size *bounds) {    SDL_Rect rect;#ifdef SCRCPY_SDL_HAS_GET_DISPLAY_USABLE_BOUNDS# define GET_DISPLAY_BOUNDS(i, r) SDL_GetDisplayUsableBounds((i), (r))#else# define GET_DISPLAY_BOUNDS(i, r) SDL_GetDisplayBounds((i), (r))#endif    if (GET_DISPLAY_BOUNDS(0, &rect)) {        LOGW("Could not get display usable bounds: %s", SDL_GetError());        return SDL_FALSE;    }    bounds->width = MAX(0, rect.w - DISPLAY_MARGINS);    bounds->height = MAX(0, rect.h - DISPLAY_MARGINS);    return SDL_TRUE;}
screen_init_rendering(struct screen *screen, const char *device_name,                      struct size frame_size, SDL_bool always_on_top) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    Uint32 window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED,                                      SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    return SDL_TRUE;}
screen_resize_to_fit(struct screen *screen) {    if (!screen->fullscreen) {        struct size optimal_size = get_optimal_window_size(screen,                                                           screen->frame_size);        SDL_SetWindowSize(screen->window, optimal_size.width,                          optimal_size.height);        LOGD("Resized to optimal size");    }}
create_texture(SDL_Renderer *renderer, struct size frame_size) {    return SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12,                             SDL_TEXTUREACCESS_STREAMING,                             frame_size.width, frame_size.height);}
get_optimal_size(struct size current_size, struct size frame_size) {    if (frame_size.width == 0 || frame_size.height == 0) {        // avoid division by 0        return current_size;    }    struct size display_size;    // 32 bits because we need to multiply two 16 bits values    Uint32 w;    Uint32 h;    if (!get_preferred_display_bounds(&display_size)) {        // cannot get display bounds, do not constraint the size        w = current_size.width;        h = current_size.height;    } else {        w = MIN(current_size.width, display_size.width);        h = MIN(current_size.height, display_size.height);    }    SDL_bool keep_width = frame_size.width * h > frame_size.height * w;    if (keep_width) {        // remove black borders on top and bottom        h = frame_size.height * w / frame_size.width;    } else {        // remove black borders on left and right (or none at all if it already        // fits)        w = frame_size.width * h / frame_size.height;    }    // w and h must fit into 16 bits    SDL_assert_release(w < 0x10000 && h < 0x10000);    return (struct size) {w, h};}
screen_destroy(struct screen *screen) {    if (screen->texture) {        SDL_DestroyTexture(screen->texture);    }    if (screen->renderer) {        SDL_DestroyRenderer(screen->renderer);    }    if (screen->window) {        SDL_DestroyWindow(screen->window);    }}
get_optimal_window_size(const struct screen *screen, struct size frame_size) {    struct size current_size = get_window_size(screen);    return get_optimal_size(current_size, frame_size);}
screen_init(struct screen *screen) {    *screen = (struct screen) SCREEN_INITIALIZER;}
screen_render(struct screen *screen) {    SDL_RenderClear(screen->renderer);    SDL_RenderCopy(screen->renderer, screen->texture, NULL, NULL);    SDL_RenderPresent(screen->renderer);}
get_initial_optimal_size(struct size frame_size) {    return get_optimal_size(frame_size, frame_size);}
update_texture(struct screen *screen, const AVFrame *frame) {    SDL_UpdateYUVTexture(screen->texture, NULL,            frame->data[0], frame->linesize[0],            frame->data[1], frame->linesize[1],            frame->data[2], frame->linesize[2]);}
set_window_size(struct screen *screen, struct size new_size) {    // setting the window size during fullscreen is implementation defined,    // so apply the resize only after fullscreen is disabled    if (screen->fullscreen) {        // SDL_SetWindowSize will be called when fullscreen will be disabled        screen->windowed_window_size = new_size;    } else {        SDL_SetWindowSize(screen->window, new_size.width, new_size.height);    }}
screen_update_frame(struct screen *screen, struct video_buffer *vb) {    mutex_lock(vb->mutex);    const AVFrame *frame = video_buffer_consume_rendered_frame(vb);    struct size new_frame_size = {frame->width, frame->height};    if (!prepare_for_frame(screen, new_frame_size)) {        mutex_unlock(vb->mutex);        return SDL_FALSE;    }    update_texture(screen, frame);    mutex_unlock(vb->mutex);    screen_render(screen);    return SDL_TRUE;}
screen_switch_fullscreen(struct screen *screen) {    if (!screen->fullscreen) {        // going to fullscreen, store the current windowed window size        screen->windowed_window_size = get_native_window_size(screen->window);    }    Uint32 new_mode = screen->fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;    if (SDL_SetWindowFullscreen(screen->window, new_mode)) {        LOGW("Could not switch fullscreen mode: %s", SDL_GetError());        return;    }    screen->fullscreen = !screen->fullscreen;    if (!screen->fullscreen) {        // fullscreen disabled, restore expected windowed window size        SDL_SetWindowSize(screen->window, screen->windowed_window_size.width,                          screen->windowed_window_size.height);    }    LOGD("Switched to %s mode", screen->fullscreen ? "fullscreen" : "windowed");    screen_render(screen);}
prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width            || screen->frame_size.height != new_frame_size.height) {        if (SDL_RenderSetLogicalSize(screen->renderer, new_frame_size.width,                                     new_frame_size.height)) {            LOGE("Could not set renderer logical size: %s", SDL_GetError());            return SDL_FALSE;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        struct size current_size = get_window_size(screen);        struct size target_size = {            (Uint32) current_size.width * new_frame_size.width                    / screen->frame_size.width,            (Uint32) current_size.height * new_frame_size.height                    / screen->frame_size.height,        };        target_size = get_optimal_size(target_size, new_frame_size);        set_window_size(screen, target_size);        screen->frame_size = new_frame_size;        LOGD("New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = create_texture(screen->renderer, new_frame_size);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return SDL_FALSE;        }    }    return SDL_TRUE;}
screen_show_window(struct screen *screen) {    SDL_ShowWindow(screen->window);}
get_native_window_size(SDL_Window *window) {    int width;    int height;    SDL_GetWindowSize(window, &width, &height);    struct size size;    size.width = width;    size.height = height;    return size;}
sdl_init_and_configure(void) {    if (SDL_Init(SDL_INIT_VIDEO)) {        LOGC("Could not initialize SDL: %s", SDL_GetError());        return SDL_FALSE;    }    atexit(SDL_Quit);    // Use the best available scale quality    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "2")) {        LOGW("Could not enable bilinear filtering");    }#ifdef SCRCPY_SDL_HAS_HINT_MOUSE_FOCUS_CLICKTHROUGH    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        LOGW("Could not enable mouse focus clickthrough");    }#endif    // Do not disable the screensaver when scrcpy is running    SDL_EnableScreenSaver();    return SDL_TRUE;}
get_window_size(const struct screen *screen) {    if (screen->fullscreen) {        return screen->windowed_window_size;    }    return get_native_window_size(screen->window);}
screen_resize_to_pixel_perfect(struct screen *screen) {    if (!screen->fullscreen) {        SDL_SetWindowSize(screen->window, screen->frame_size.width,                          screen->frame_size.height);        LOGD("Resized to pixel-perfect");    }}
socket_t server_connect_to(struct server *server) {    if (!server->tunnel_forward) {        server->device_socket = net_accept(server->server_socket);    } else {        Uint32 attempts = 100;        Uint32 delay = 100; // ms        server->device_socket = connect_to_server(server->local_port, attempts, delay);    }    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    if (!server->tunnel_forward) {        // we don't need the server socket anymore        close_socket(&server->server_socket);    }    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = SDL_FALSE;    return server->device_socket;}
void server_init(struct server *server) {    *server = (struct server) SERVER_INITIALIZER;}
static SDL_bool push_server(const char *serial) {    process_t process = adb_push(serial, get_server_path(), DEVICE_SERVER_PATH);    return process_check_success(process, "adb push");}
static socket_t listen_on_port(Uint16 port) {    return net_listen(IPV4_LOCALHOST, port, 1);}
static socket_t connect_and_read_byte(Uint16 port) {    socket_t socket = net_connect(IPV4_LOCALHOST, port);    if (socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    char byte;    // the connection may succeed even if the server behind the "adb tunnel"    // is not listening, so read one byte to detect a working connection    if (net_recv_all(socket, &byte, 1) != 1) {        // the server is not listening yet behind the adb tunnel        return INVALID_SOCKET;    }    return socket;}
static const char *get_server_path(void) {    const char *server_path = getenv("SCRCPY_SERVER_PATH");    if (!server_path) {        server_path = DEFAULT_SERVER_PATH;    }    return server_path;}
static SDL_bool disable_tunnel(struct server *server) {    if (server->tunnel_forward) {        return disable_tunnel_forward(server->serial, server->local_port);    }    return disable_tunnel_reverse(server->serial);}
static process_t execute_server(const char *serial,                                Uint16 max_size, Uint32 bit_rate,                                SDL_bool tunnel_forward, const char *crop,                                SDL_bool send_frame_meta) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        tunnel_forward ? "true" : "false",        crop ? crop : "-",        send_frame_meta ? "true" : "false",    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
static void close_socket(socket_t *socket) {    SDL_assert(*socket != INVALID_SOCKET);    net_shutdown(*socket, SHUT_RDWR);    if (!net_close(*socket)) {        LOGW("Cannot close socket");        return;    }    *socket = INVALID_SOCKET;}
void server_stop(struct server *server) {    SDL_assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Cannot terminate server");    }    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->tunnel_enabled) {        // ignore failure        disable_tunnel(server);    }}
void server_destroy(struct server *server) {    if (server->server_socket != INVALID_SOCKET) {        close_socket(&server->server_socket);    }    if (server->device_socket != INVALID_SOCKET) {        close_socket(&server->device_socket);    }    SDL_free((void *) server->serial);}
static SDL_bool disable_tunnel_forward(const char *serial, Uint16 local_port) {    process_t process = adb_forward_remove(serial, local_port);    return process_check_success(process, "adb forward --remove");}
static SDL_bool enable_tunnel(struct server *server) {    if (enable_tunnel_reverse(server->serial, server->local_port)) {        return SDL_TRUE;    }    LOGW("'adb reverse' failed, fallback to 'adb forward'");    server->tunnel_forward = SDL_TRUE;    return enable_tunnel_forward(server->serial, server->local_port);}
SDL_bool server_start(struct server *server, const char *serial,                      Uint16 local_port, Uint16 max_size, Uint32 bit_rate,                      const char *crop, SDL_bool send_frame_meta) {    server->local_port = local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return SDL_FALSE;        }    }    if (!push_server(serial)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    if (!enable_tunnel(server)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no need to        // try to connect until the server socket is listening on the device.        server->server_socket = listen_on_port(local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, local_port);            disable_tunnel(server);            SDL_free((void *) server->serial);            return SDL_FALSE;        }    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate,                                     server->tunnel_forward, crop,                                     send_frame_meta);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free((void *) server->serial);        return SDL_FALSE;    }    server->tunnel_enabled = SDL_TRUE;    return SDL_TRUE;}
static SDL_bool enable_tunnel_forward(const char *serial, Uint16 local_port) {    process_t process = adb_forward(serial, local_port, SOCKET_NAME);    return process_check_success(process, "adb forward");}
static socket_t connect_to_server(Uint16 port, Uint32 attempts, Uint32 delay) {    do {        LOGD("Remaining connection attempts: %d", (int) attempts);        socket_t socket = connect_and_read_byte(port);        if (socket != INVALID_SOCKET) {            // it worked!            return socket;        }        if (attempts) {            SDL_Delay(delay);        }    } while (--attempts > 0);    return INVALID_SOCKET;}
static SDL_bool disable_tunnel_reverse(const char *serial) {    process_t process = adb_reverse_remove(serial, SOCKET_NAME);    return process_check_success(process, "adb reverse --remove");}
static SDL_bool enable_tunnel_reverse(const char *serial, Uint16 local_port) {    process_t process = adb_reverse(serial, SOCKET_NAME, local_port);    return process_check_success(process, "adb reverse");}
server_connect_to(struct server *server) {    if (!server->tunnel_forward) {        server->device_socket = net_accept(server->server_socket);    } else {        Uint32 attempts = 100;        Uint32 delay = 100; // ms        server->device_socket = connect_to_server(server->local_port, attempts,                                                  delay);    }    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    if (!server->tunnel_forward) {        // we don't need the server socket anymore        close_socket(&server->server_socket);    }    // we don't need the adb tunnel anymore    disable_tunnel(server); // ignore failure    server->tunnel_enabled = SDL_FALSE;    return server->device_socket;}
server_init(struct server *server) {    *server = (struct server) SERVER_INITIALIZER;}
push_server(const char *serial) {    process_t process = adb_push(serial, get_server_path(), DEVICE_SERVER_PATH);    return process_check_success(process, "adb push");}
listen_on_port(Uint16 port) {    return net_listen(IPV4_LOCALHOST, port, 1);}
connect_and_read_byte(Uint16 port) {    socket_t socket = net_connect(IPV4_LOCALHOST, port);    if (socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    char byte;    // the connection may succeed even if the server behind the "adb tunnel"    // is not listening, so read one byte to detect a working connection    if (net_recv_all(socket, &byte, 1) != 1) {        // the server is not listening yet behind the adb tunnel        return INVALID_SOCKET;    }    return socket;}
get_server_path(void) {    const char *server_path = getenv("SCRCPY_SERVER_PATH");    if (!server_path) {        server_path = DEFAULT_SERVER_PATH;    }    return server_path;}
disable_tunnel(struct server *server) {    if (server->tunnel_forward) {        return disable_tunnel_forward(server->serial, server->local_port);    }    return disable_tunnel_reverse(server->serial);}
execute_server(const char *serial,               Uint16 max_size, Uint32 bit_rate,               SDL_bool tunnel_forward, const char *crop,               SDL_bool send_frame_meta) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        tunnel_forward ? "true" : "false",        crop ? crop : "-",        send_frame_meta ? "true" : "false",    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
close_socket(socket_t *socket) {    SDL_assert(*socket != INVALID_SOCKET);    net_shutdown(*socket, SHUT_RDWR);    if (!net_close(*socket)) {        LOGW("Cannot close socket");        return;    }    *socket = INVALID_SOCKET;}
server_stop(struct server *server) {    SDL_assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Cannot terminate server");    }    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->tunnel_enabled) {        // ignore failure        disable_tunnel(server);    }}
server_destroy(struct server *server) {    if (server->server_socket != INVALID_SOCKET) {        close_socket(&server->server_socket);    }    if (server->device_socket != INVALID_SOCKET) {        close_socket(&server->device_socket);    }    SDL_free((void *) server->serial);}
disable_tunnel_forward(const char *serial, Uint16 local_port) {    process_t process = adb_forward_remove(serial, local_port);    return process_check_success(process, "adb forward --remove");}
enable_tunnel(struct server *server) {    if (enable_tunnel_reverse(server->serial, server->local_port)) {        return SDL_TRUE;    }    LOGW("'adb reverse' failed, fallback to 'adb forward'");    server->tunnel_forward = SDL_TRUE;    return enable_tunnel_forward(server->serial, server->local_port);}
server_start(struct server *server, const char *serial,             Uint16 local_port, Uint16 max_size, Uint32 bit_rate,             const char *crop, SDL_bool send_frame_meta) {    server->local_port = local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return SDL_FALSE;        }    }    if (!push_server(serial)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    if (!enable_tunnel(server)) {        SDL_free((void *) server->serial);        return SDL_FALSE;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, local_port);            disable_tunnel(server);            SDL_free((void *) server->serial);            return SDL_FALSE;        }    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate,                                     server->tunnel_forward, crop,                                     send_frame_meta);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free((void *) server->serial);        return SDL_FALSE;    }    server->tunnel_enabled = SDL_TRUE;    return SDL_TRUE;}
enable_tunnel_forward(const char *serial, Uint16 local_port) {    process_t process = adb_forward(serial, local_port, SOCKET_NAME);    return process_check_success(process, "adb forward");}
connect_to_server(Uint16 port, Uint32 attempts, Uint32 delay) {    do {        LOGD("Remaining connection attempts: %d", (int) attempts);        socket_t socket = connect_and_read_byte(port);        if (socket != INVALID_SOCKET) {            // it worked!            return socket;        }        if (attempts) {            SDL_Delay(delay);        }    } while (--attempts > 0);    return INVALID_SOCKET;}
disable_tunnel_reverse(const char *serial) {    process_t process = adb_reverse_remove(serial, SOCKET_NAME);    return process_check_success(process, "adb reverse --remove");}
enable_tunnel_reverse(const char *serial, Uint16 local_port) {    process_t process = adb_reverse(serial, SOCKET_NAME, local_port);    return process_check_success(process, "adb reverse");}
wchar_t *utf8_to_wide_char(const char *utf8) {    int len = MultiByteToWideChar(CP_UTF8, 0, utf8, -1, NULL, 0);    if (!len) {        return NULL;    }    wchar_t *wide = malloc(len * sizeof(wchar_t));    if (!wide) {        return NULL;    }    MultiByteToWideChar(CP_UTF8, 0, utf8, -1, wide, len);    return wide;}
char *strquote(const char *src) {    size_t len = strlen(src);    char *quoted = malloc(len + 3);    if (!quoted) {        return NULL;    }    memcpy(&quoted[1], src, len);    quoted[0] = '"';    quoted[len + 1] = '"';    quoted[len + 2] = '\0';    return quoted;}
size_t xstrncpy(char *dest, const char *src, size_t n) {    size_t i;    for (i = 0; i < n - 1 && src[i] != '\0'; ++i)        dest[i] = src[i];    if (n)        dest[i] = '\0';    return src[i] == '\0' ? i : n;}
size_t xstrjoin(char *dst, const char *const tokens[], char sep, size_t n) {    const char *const *remaining = tokens;    const char *token = *remaining++;    size_t i = 0;    while (token) {        if (i) {            dst[i++] = sep;            if (i == n)                goto truncated;        }        size_t w = xstrncpy(dst + i, token, n - i);        if (w >= n - i)            goto truncated;        i += w;        token = *remaining++;    }    return i;truncated:    dst[n - 1] = '\0';    return n;}
utf8_to_wide_char(const char *utf8) {    int len = MultiByteToWideChar(CP_UTF8, 0, utf8, -1, NULL, 0);    if (!len) {        return NULL;    }    wchar_t *wide = malloc(len * sizeof(wchar_t));    if (!wide) {        return NULL;    }    MultiByteToWideChar(CP_UTF8, 0, utf8, -1, wide, len);    return wide;}
strquote(const char *src) {    size_t len = strlen(src);    char *quoted = malloc(len + 3);    if (!quoted) {        return NULL;    }    memcpy(&quoted[1], src, len);    quoted[0] = '"';    quoted[len + 1] = '"';    quoted[len + 2] = '\0';    return quoted;}
xstrncpy(char *dest, const char *src, size_t n) {    size_t i;    for (i = 0; i < n - 1 && src[i] != '\0'; ++i)        dest[i] = src[i];    if (n)        dest[i] = '\0';    return src[i] == '\0' ? i : n;}
xstrjoin(char *dst, const char *const tokens[], char sep, size_t n) {    const char *const *remaining = tokens;    const char *token = *remaining++;    size_t i = 0;    while (token) {        if (i) {            dst[i++] = sep;            if (i == n)                goto truncated;        }        size_t w = xstrncpy(dst + i, token, n - i);        if (w >= n - i)            goto truncated;        i += w;        token = *remaining++;    }    return i;truncated:    dst[n - 1] = '\0';    return n;}
static int run_stream(void *data) {    struct stream *stream = data;    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto end;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto finally_free_format_ctx;    }    // initialize the receiver state    stream->receiver_state.frame_meta_queue = NULL;    stream->receiver_state.remaining = 0;    // if recording is enabled, a "header" is sent between raw packets    int (*read_packet)(void *, uint8_t *, int) =            stream->recorder ? read_packet_with_meta : read_raw_packet;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, stream,                                               read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto finally_free_avio_ctx;    }    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto end;    }    if (stream->decoder && !decoder_open(stream->decoder, codec)) {        LOGE("Could not open decoder");        goto finally_close_input;    }    if (stream->recorder && !recorder_open(stream->recorder, codec)) {        LOGE("Could not open recorder");        goto finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {        if (stream->decoder && !decoder_push(stream->decoder, &packet)) {            av_packet_unref(&packet);            goto quit;        }        if (stream->recorder) {            // we retrieve the PTS in order they were received, so they will            // be assigned to the correct frame            Uint64 pts = receiver_state_take_meta(&stream->receiver_state);            packet.pts = pts;            packet.dts = pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(stream->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");quit:    if (stream->recorder) {        recorder_close(stream->recorder);    }finally_close_input:    avformat_close_input(&format_ctx);finally_free_avio_ctx:    av_free(avio_ctx->buffer);    av_free(avio_ctx);finally_free_format_ctx:    avformat_free_context(format_ctx);end:    notify_stopped();    return 0;}
static int read_raw_packet(void *opaque, uint8_t *buf, int buf_size) {    struct stream *stream = opaque;    ssize_t r = net_recv(stream->socket, buf, buf_size);    if (r == -1) {        return AVERROR(errno);    }    if (r == 0) {        return AVERROR_EOF;    }    return r;}
static Uint64 receiver_state_take_meta(struct receiver_state *state) {    struct frame_meta *frame_meta = state->frame_meta_queue; // first item    SDL_assert(frame_meta); // must not be empty    Uint64 pts = frame_meta->pts;    state->frame_meta_queue = frame_meta->next; // remove the item    frame_meta_delete(frame_meta);    return pts;}
static void frame_meta_delete(struct frame_meta *frame_meta) {    free(frame_meta);}
SDL_bool stream_start(struct stream *stream) {    LOGD("Starting stream thread");    stream->thread = SDL_CreateThread(run_stream, "stream", stream);    if (!stream->thread) {        LOGC("Could not start stream thread");        return SDL_FALSE;    }    return SDL_TRUE;}
static SDL_bool receiver_state_push_meta(struct receiver_state *state,                                         Uint64 pts) {    struct frame_meta *frame_meta = frame_meta_new(pts);    if (!frame_meta) {        return SDL_FALSE;    }    // append to the list    // (iterate to find the last item, in practice the list should be tiny)    struct frame_meta **p = &state->frame_meta_queue;    while (*p) {        p = &(*p)->next;    }    *p = frame_meta;    return SDL_TRUE;}
static int read_packet_with_meta(void *opaque, uint8_t *buf, int buf_size) {    struct stream *stream = opaque;    struct receiver_state *state = &stream->receiver_state;    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    if (!state->remaining) {#define HEADER_SIZE 12        uint8_t header[HEADER_SIZE];        ssize_t r = net_recv_all(stream->socket, header, HEADER_SIZE);        if (r == -1) {            return AVERROR(errno);        }        if (r == 0) {            return AVERROR_EOF;        }        // no partial read (net_recv_all())        SDL_assert_release(r == HEADER_SIZE);        Uint64 pts = buffer_read64be(header);        state->remaining = buffer_read32be(&header[8]);        if (pts != NO_PTS && !receiver_state_push_meta(state, pts)) {            LOGE("Could not store PTS for recording");            // we cannot save the PTS, the recording would be broken            return AVERROR(ENOMEM);        }    }    SDL_assert(state->remaining);    if (buf_size > state->remaining) {        buf_size = state->remaining;    }    ssize_t r = net_recv(stream->socket, buf, buf_size);    if (r == -1) {        return AVERROR(errno);    }    if (r == 0) {        return AVERROR_EOF;    }    SDL_assert(state->remaining >= r);    state->remaining -= r;    return r;}
void stream_init(struct stream *stream, socket_t socket,                 struct decoder *decoder, struct recorder *recorder) {    stream->socket = socket;    stream->decoder = decoder,    stream->recorder = recorder;}
static void notify_stopped(void) {    SDL_Event stop_event;    stop_event.type = EVENT_STREAM_STOPPED;    SDL_PushEvent(&stop_event);}
static struct frame_meta *frame_meta_new(Uint64 pts) {    struct frame_meta *meta = malloc(sizeof(*meta));    if (!meta) {        return meta;    }    meta->pts = pts;    meta->next = NULL;    return meta;}
void stream_stop(struct stream *stream) {    if (stream->decoder) {        decoder_interrupt(stream->decoder);    }}
void stream_join(struct stream *stream) {    SDL_WaitThread(stream->thread, NULL);}
run_stream(void *data) {    struct stream *stream = data;    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto end;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto finally_free_format_ctx;    }    // initialize the receiver state    stream->receiver_state.frame_meta_queue = NULL;    stream->receiver_state.remaining = 0;    // if recording is enabled, a "header" is sent between raw packets    int (*read_packet)(void *, uint8_t *, int) =            stream->recorder ? read_packet_with_meta : read_raw_packet;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, stream,                                               read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto finally_free_avio_ctx;    }    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto end;    }    if (stream->decoder && !decoder_open(stream->decoder, codec)) {        LOGE("Could not open decoder");        goto finally_close_input;    }    if (stream->recorder && !recorder_open(stream->recorder, codec)) {        LOGE("Could not open recorder");        goto finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {        if (stream->decoder && !decoder_push(stream->decoder, &packet)) {            av_packet_unref(&packet);            goto quit;        }        if (stream->recorder) {            // we retrieve the PTS in order they were received, so they will            // be assigned to the correct frame            Uint64 pts = receiver_state_take_meta(&stream->receiver_state);            packet.pts = pts;            packet.dts = pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(stream->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");quit:    if (stream->recorder) {        recorder_close(stream->recorder);    }finally_close_input:    avformat_close_input(&format_ctx);finally_free_avio_ctx:    av_free(avio_ctx->buffer);    av_free(avio_ctx);finally_free_format_ctx:    avformat_free_context(format_ctx);end:    notify_stopped();    return 0;}
read_raw_packet(void *opaque, uint8_t *buf, int buf_size) {    struct stream *stream = opaque;    ssize_t r = net_recv(stream->socket, buf, buf_size);    if (r == -1) {        return AVERROR(errno);    }    if (r == 0) {        return AVERROR_EOF;    }    return r;}
receiver_state_take_meta(struct receiver_state *state) {    struct frame_meta *frame_meta = state->frame_meta_queue; // first item    SDL_assert(frame_meta); // must not be empty    Uint64 pts = frame_meta->pts;    state->frame_meta_queue = frame_meta->next; // remove the item    frame_meta_delete(frame_meta);    return pts;}
frame_meta_delete(struct frame_meta *frame_meta) {    free(frame_meta);}
stream_start(struct stream *stream) {    LOGD("Starting stream thread");    stream->thread = SDL_CreateThread(run_stream, "stream", stream);    if (!stream->thread) {        LOGC("Could not start stream thread");        return SDL_FALSE;    }    return SDL_TRUE;}
receiver_state_push_meta(struct receiver_state *state, Uint64 pts) {    struct frame_meta *frame_meta = frame_meta_new(pts);    if (!frame_meta) {        return SDL_FALSE;    }    // append to the list    // (iterate to find the last item, in practice the list should be tiny)    struct frame_meta **p = &state->frame_meta_queue;    while (*p) {        p = &(*p)->next;    }    *p = frame_meta;    return SDL_TRUE;}
read_packet_with_meta(void *opaque, uint8_t *buf, int buf_size) {    struct stream *stream = opaque;    struct receiver_state *state = &stream->receiver_state;    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    if (!state->remaining) {#define HEADER_SIZE 12        uint8_t header[HEADER_SIZE];        ssize_t r = net_recv_all(stream->socket, header, HEADER_SIZE);        if (r == -1) {            return AVERROR(errno);        }        if (r == 0) {            return AVERROR_EOF;        }        // no partial read (net_recv_all())        SDL_assert_release(r == HEADER_SIZE);        Uint64 pts = buffer_read64be(header);        state->remaining = buffer_read32be(&header[8]);        if (pts != NO_PTS && !receiver_state_push_meta(state, pts)) {            LOGE("Could not store PTS for recording");            // we cannot save the PTS, the recording would be broken            return AVERROR(ENOMEM);        }    }    SDL_assert(state->remaining);    if (buf_size > state->remaining) {        buf_size = state->remaining;    }    ssize_t r = net_recv(stream->socket, buf, buf_size);    if (r == -1) {        return AVERROR(errno);    }    if (r == 0) {        return AVERROR_EOF;    }    SDL_assert(state->remaining >= r);    state->remaining -= r;    return r;}
stream_init(struct stream *stream, socket_t socket,            struct decoder *decoder, struct recorder *recorder) {    stream->socket = socket;    stream->decoder = decoder,    stream->recorder = recorder;}
notify_stopped(void) {    SDL_Event stop_event;    stop_event.type = EVENT_STREAM_STOPPED;    SDL_PushEvent(&stop_event);}
frame_meta_new(Uint64 pts) {    struct frame_meta *meta = malloc(sizeof(*meta));    if (!meta) {        return meta;    }    meta->pts = pts;    meta->next = NULL;    return meta;}
stream_stop(struct stream *stream) {    if (stream->decoder) {        decoder_interrupt(stream->decoder);    }}
stream_join(struct stream *stream) {    SDL_WaitThread(stream->thread, NULL);}
SDL_bool cmd_simple_wait(pid_t pid, int *exit_code) {    int status;    int code;    if (waitpid(pid, &status, 0) == -1 || !WIFEXITED(status)) {        // cannot wait, or exited unexpectedly, probably by a signal        code = -1;    } else {        code = WEXITSTATUS(status);    }    if (exit_code) {        *exit_code = code;    }    return !code;}
SDL_bool cmd_terminate(pid_t pid) {    if (pid <= 0) {        LOGC("Requested to kill %d, this is an error. Please report the bug.\n", (int) pid);        abort();    }    return kill(pid, SIGTERM) != -1;}
enum process_result cmd_execute(const char *path, const char *const argv[], pid_t *pid) {    int fd[2];    if (pipe(fd) == -1) {        perror("pipe");        return PROCESS_ERROR_GENERIC;    }    enum process_result ret = PROCESS_SUCCESS;    *pid = fork();    if (*pid == -1) {        perror("fork");        ret = PROCESS_ERROR_GENERIC;        goto end;    }    if (*pid > 0) {        // parent close write side        close(fd[1]);        fd[1] = -1;        // wait for EOF or receive errno from child        if (read(fd[0], &ret, sizeof(ret)) == -1) {            perror("read");            ret = PROCESS_ERROR_GENERIC;            goto end;        }    } else if (*pid == 0) {        // child close read side        close(fd[0]);        if (fcntl(fd[1], F_SETFD, FD_CLOEXEC) == 0) {            execvp(path, (char *const *)argv);            if (errno == ENOENT) {                ret = PROCESS_ERROR_MISSING_BINARY;            } else {                ret = PROCESS_ERROR_GENERIC;            }            perror("exec");        } else {            perror("fcntl");            ret = PROCESS_ERROR_GENERIC;        }        // send ret to the parent        if (write(fd[1], &ret, sizeof(ret)) == -1) {            perror("write");        }        // close write side before exiting        close(fd[1]);        _exit(1);    }end:    if (fd[0] != -1) {        close(fd[0]);    }    if (fd[1] != -1) {        close(fd[1]);    }    return ret;}
cmd_simple_wait(pid_t pid, int *exit_code) {    int status;    int code;    if (waitpid(pid, &status, 0) == -1 || !WIFEXITED(status)) {        // cannot wait, or exited unexpectedly, probably by a signal        code = -1;    } else {        code = WEXITSTATUS(status);    }    if (exit_code) {        *exit_code = code;    }    return !code;}
cmd_terminate(pid_t pid) {    if (pid <= 0) {        LOGC("Requested to kill %d, this is an error. Please report the bug.\n",             (int) pid);        abort();    }    return kill(pid, SIGTERM) != -1;}
cmd_execute(const char *path, const char *const argv[], pid_t *pid) {    int fd[2];    if (pipe(fd) == -1) {        perror("pipe");        return PROCESS_ERROR_GENERIC;    }    enum process_result ret = PROCESS_SUCCESS;    *pid = fork();    if (*pid == -1) {        perror("fork");        ret = PROCESS_ERROR_GENERIC;        goto end;    }    if (*pid > 0) {        // parent close write side        close(fd[1]);        fd[1] = -1;        // wait for EOF or receive errno from child        if (read(fd[0], &ret, sizeof(ret)) == -1) {            perror("read");            ret = PROCESS_ERROR_GENERIC;            goto end;        }    } else if (*pid == 0) {        // child close read side        close(fd[0]);        if (fcntl(fd[1], F_SETFD, FD_CLOEXEC) == 0) {            execvp(path, (char *const *)argv);            if (errno == ENOENT) {                ret = PROCESS_ERROR_MISSING_BINARY;            } else {                ret = PROCESS_ERROR_GENERIC;            }            perror("exec");        } else {            perror("fcntl");            ret = PROCESS_ERROR_GENERIC;        }        // send ret to the parent        if (write(fd[1], &ret, sizeof(ret)) == -1) {            perror("write");        }        // close write side before exiting        close(fd[1]);        _exit(1);    }end:    if (fd[0] != -1) {        close(fd[0]);    }    if (fd[1] != -1) {        close(fd[1]);    }    return ret;}
SDL_bool net_close(socket_t socket) {    return !close(socket);}
void net_cleanup(void) {    // do nothing}
SDL_bool net_init(void) {    // do nothing    return SDL_TRUE;}
net_close(socket_t socket) {    return !close(socket);}
net_cleanup(void) {    // do nothing}
net_init(void) {    // do nothing    return SDL_TRUE;}
enum process_result cmd_execute(const char *path, const char *const argv[], HANDLE *handle) {    STARTUPINFOW si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    char cmd[256];    if (build_cmd(cmd, sizeof(cmd), argv)) {        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }    wchar_t *wide = utf8_to_wide_char(cmd);    if (!wide) {        LOGC("Cannot allocate wide char string");        return PROCESS_ERROR_GENERIC;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcessW(NULL, wide, NULL, NULL, FALSE, flags, NULL, NULL, &si, &pi)) {        free(wide);        *handle = NULL;        if (GetLastError() == ERROR_FILE_NOT_FOUND) {            return PROCESS_ERROR_MISSING_BINARY;        }        return PROCESS_ERROR_GENERIC;    }    free(wide);    *handle = pi.hProcess;    return PROCESS_SUCCESS;}
SDL_bool cmd_simple_wait(HANDLE handle, DWORD *exit_code) {    DWORD code;    if (WaitForSingleObject(handle, INFINITE) != WAIT_OBJECT_0 || !GetExitCodeProcess(handle, &code)) {        // cannot wait or retrieve the exit code        code = -1; // max value, it's unsigned    }    if (exit_code) {        *exit_code = code;    }    return !code;}
SDL_bool cmd_terminate(HANDLE handle) {    return TerminateProcess(handle, 1) && CloseHandle(handle);}
static int build_cmd(char *cmd, size_t len, const char *const argv[]) {    // Windows command-line parsing is WTF:    // <http://daviddeley.com/autohotkey/parameters/parameters.htm#WINPASS>    // only make it work for this very specific program    // (don't handle escaping nor quotes)    size_t ret = xstrjoin(cmd, argv, ' ', len);    if (ret >= len) {        LOGE("Command too long (%" PRIsizet " chars)", len - 1);        return -1;    }    return 0;}
cmd_execute(const char *path, const char *const argv[], HANDLE *handle) {    STARTUPINFOW si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    char cmd[256];    if (build_cmd(cmd, sizeof(cmd), argv)) {        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }    wchar_t *wide = utf8_to_wide_char(cmd);    if (!wide) {        LOGC("Cannot allocate wide char string");        return PROCESS_ERROR_GENERIC;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcessW(NULL, wide, NULL, NULL, FALSE, flags, NULL, NULL, &si,                        &pi)) {        free(wide);        *handle = NULL;        if (GetLastError() == ERROR_FILE_NOT_FOUND) {            return PROCESS_ERROR_MISSING_BINARY;        }        return PROCESS_ERROR_GENERIC;    }    free(wide);    *handle = pi.hProcess;    return PROCESS_SUCCESS;}
cmd_simple_wait(HANDLE handle, DWORD *exit_code) {    DWORD code;    if (WaitForSingleObject(handle, INFINITE) != WAIT_OBJECT_0            || !GetExitCodeProcess(handle, &code)) {        // cannot wait or retrieve the exit code        code = -1; // max value, it's unsigned    }    if (exit_code) {        *exit_code = code;    }    return !code;}
cmd_terminate(HANDLE handle) {    return TerminateProcess(handle, 1) && CloseHandle(handle);}
build_cmd(char *cmd, size_t len, const char *const argv[]) {    // Windows command-line parsing is WTF:    // <http://daviddeley.com/autohotkey/parameters/parameters.htm#WINPASS>    // only make it work for this very specific program    // (don't handle escaping nor quotes)    size_t ret = xstrjoin(cmd, argv, ' ', len);    if (ret >= len) {        LOGE("Command too long (%" PRIsizet " chars)", len - 1);        return -1;    }    return 0;}
void net_cleanup(void) {    WSACleanup();}
SDL_bool net_init(void) {    WSADATA wsa;    int res = WSAStartup(MAKEWORD(2, 2), &wsa) < 0;    if (res < 0) {        LOGC("WSAStartup failed with error %d", res);        return SDL_FALSE;    }    return SDL_TRUE;}
SDL_bool net_close(socket_t socket) {    return !closesocket(socket);}
net_cleanup(void) {    WSACleanup();}
net_init(void) {    WSADATA wsa;    int res = WSAStartup(MAKEWORD(2, 2), &wsa) < 0;    if (res < 0) {        LOGC("WSAStartup failed with error %d", res);        return SDL_FALSE;    }    return SDL_TRUE;}
net_close(socket_t socket) {    return !closesocket(socket);}
static SDL_bool find_color(struct index *index, int len, char c, Uint32 *color) {    // there are typically very few color, so it's ok to iterate over the array    for (int i = 0; i < len; ++i) {        if (index[i].c == c) {            *color = index[i].color;            return SDL_TRUE;        }    }    *color = 0;    return SDL_FALSE;}
SDL_Surface *read_xpm(char *xpm[]) {#if SDL_ASSERT_LEVEL >= 2    // patch the XPM to change the icon color in debug mode    xpm[2] = ".	c #CC00CC";#endif    char *endptr;    // *** No error handling, assume the XPM source is valid ***    // (it's in our source repo)    // Assertions are only checked in debug    int width = strtol(xpm[0], &endptr, 10);    int height = strtol(endptr + 1, &endptr, 10);    int colors = strtol(endptr + 1, &endptr, 10);    int chars = strtol(endptr + 1, &endptr, 10);    // sanity checks    SDL_assert(0 <= width && width < 256);    SDL_assert(0 <= height && height < 256);    SDL_assert(0 <= colors && colors < 256);    SDL_assert(chars == 1); // this implementation does not support more    // init index    struct index index[colors];    for (int i = 0; i < colors; ++i) {        const char *line = xpm[1+i];        index[i].c = line[0];        SDL_assert(line[1] == '\t');        SDL_assert(line[2] == 'c');        SDL_assert(line[3] == ' ');        if (line[4] == '#') {            index[i].color = 0xff000000 | strtol(&line[5], &endptr, 0x10);            SDL_assert(*endptr == '\0');        } else {            SDL_assert(!strcmp("None", &line[4]));            index[i].color = 0;        }    }    // parse image    Uint32 *pixels = SDL_malloc(4 * width * height);    if (!pixels) {        LOGE("Could not allocate icon memory");        return NULL;    }    for (int y = 0; y < height; ++y) {        const char *line = xpm[1 + colors + y];        for (int x = 0; x < width; ++x) {            char c = line[x];            Uint32 color;            SDL_bool color_found = find_color(index, colors, c, &color);            SDL_assert(color_found);            pixels[y * width + x] = color;        }    }#if SDL_BYTEORDER == SDL_BIG_ENDIAN    Uint32 amask = 0x000000ff;    Uint32 rmask = 0x0000ff00;    Uint32 gmask = 0x00ff0000;    Uint32 bmask = 0xff000000;#else // little endian, like x86    Uint32 amask = 0xff000000;    Uint32 rmask = 0x00ff0000;    Uint32 gmask = 0x0000ff00;    Uint32 bmask = 0x000000ff;#endif    SDL_Surface *surface = SDL_CreateRGBSurfaceFrom(pixels,                                                    width, height,                                                    32, 4 * width,                                                    rmask, gmask, bmask, amask);    // make the surface own the raw pixels    surface->flags &= ~SDL_PREALLOC;    return surface;}
find_color(struct index *index, int len, char c, Uint32 *color) {    // there are typically very few color, so it's ok to iterate over the array    for (int i = 0; i < len; ++i) {        if (index[i].c == c) {            *color = index[i].color;            return SDL_TRUE;        }    }    *color = 0;    return SDL_FALSE;}
read_xpm(char *xpm[]) {#if SDL_ASSERT_LEVEL >= 2    // patch the XPM to change the icon color in debug mode    xpm[2] = ".	c #CC00CC";#endif    char *endptr;    // *** No error handling, assume the XPM source is valid ***    // (it's in our source repo)    // Assertions are only checked in debug    int width = strtol(xpm[0], &endptr, 10);    int height = strtol(endptr + 1, &endptr, 10);    int colors = strtol(endptr + 1, &endptr, 10);    int chars = strtol(endptr + 1, &endptr, 10);    // sanity checks    SDL_assert(0 <= width && width < 256);    SDL_assert(0 <= height && height < 256);    SDL_assert(0 <= colors && colors < 256);    SDL_assert(chars == 1); // this implementation does not support more    // init index    struct index index[colors];    for (int i = 0; i < colors; ++i) {        const char *line = xpm[1+i];        index[i].c = line[0];        SDL_assert(line[1] == '\t');        SDL_assert(line[2] == 'c');        SDL_assert(line[3] == ' ');        if (line[4] == '#') {            index[i].color = 0xff000000 | strtol(&line[5], &endptr, 0x10);            SDL_assert(*endptr == '\0');        } else {            SDL_assert(!strcmp("None", &line[4]));            index[i].color = 0;        }    }    // parse image    Uint32 *pixels = SDL_malloc(4 * width * height);    if (!pixels) {        LOGE("Could not allocate icon memory");        return NULL;    }    for (int y = 0; y < height; ++y) {        const char *line = xpm[1 + colors + y];        for (int x = 0; x < width; ++x) {            char c = line[x];            Uint32 color;            SDL_bool color_found = find_color(index, colors, c, &color);            SDL_assert(color_found);            pixels[y * width + x] = color;        }    }#if SDL_BYTEORDER == SDL_BIG_ENDIAN    Uint32 amask = 0x000000ff;    Uint32 rmask = 0x0000ff00;    Uint32 gmask = 0x00ff0000;    Uint32 bmask = 0xff000000;#else // little endian, like x86    Uint32 amask = 0xff000000;    Uint32 rmask = 0x00ff0000;    Uint32 gmask = 0x0000ff00;    Uint32 bmask = 0x000000ff;#endif    SDL_Surface *surface = SDL_CreateRGBSurfaceFrom(pixels,                                                    width, height,                                                    32, 4 * width,                                                    rmask, gmask, bmask, amask);    // make the surface own the raw pixels    surface->flags &= ~SDL_PREALLOC;    return surface;}
SDL_bool video_buffer_offer_decoded_frame(struct video_buffer *vb) {    mutex_lock(vb->mutex);#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then the decoder must wait for the current    // frame to be consumed    while (!vb->rendering_frame_consumed && !vb->interrupted) {        cond_wait(vb->rendering_frame_consumed_cond, vb->mutex);    }#else    if (vb->fps_counter.started && !vb->rendering_frame_consumed) {        fps_counter_add_skipped_frame(&vb->fps_counter);    }#endif    video_buffer_swap_frames(vb);    SDL_bool previous_frame_consumed = vb->rendering_frame_consumed;    vb->rendering_frame_consumed = SDL_FALSE;    mutex_unlock(vb->mutex);    return previous_frame_consumed;}
SDL_bool video_buffer_init(struct video_buffer *vb) {    if (!(vb->decoding_frame = av_frame_alloc())) {        goto error_0;    }    if (!(vb->rendering_frame = av_frame_alloc())) {        goto error_1;    }    if (!(vb->mutex = SDL_CreateMutex())) {        goto error_2;    }#ifndef SKIP_FRAMES    if (!(vb->rendering_frame_consumed_cond = SDL_CreateCond())) {        SDL_DestroyMutex(vb->mutex);        goto error_2;    }    vb->interrupted = SDL_FALSE;#endif    // there is initially no rendering frame, so consider it has already been    // consumed    vb->rendering_frame_consumed = SDL_TRUE;    fps_counter_init(&vb->fps_counter);    return SDL_TRUE;error_2:    av_frame_free(&vb->rendering_frame);error_1:    av_frame_free(&vb->decoding_frame);error_0:    return SDL_FALSE;}
void video_buffer_destroy(struct video_buffer *vb) {#ifndef SKIP_FRAMES    SDL_DestroyCond(vb->rendering_frame_consumed_cond);#endif    SDL_DestroyMutex(vb->mutex);    av_frame_free(&vb->rendering_frame);    av_frame_free(&vb->decoding_frame);}
void video_buffer_interrupt(struct video_buffer *vb) {#ifdef SKIP_FRAMES    (void) vb; // unused#else    mutex_lock(vb->mutex);    vb->interrupted = SDL_TRUE;    mutex_unlock(vb->mutex);    // wake up blocking wait    cond_signal(vb->rendering_frame_consumed_cond);#endif}
static void video_buffer_swap_frames(struct video_buffer *vb) {    AVFrame *tmp = vb->decoding_frame;    vb->decoding_frame = vb->rendering_frame;    vb->rendering_frame = tmp;}
const AVFrame *video_buffer_consume_rendered_frame(struct video_buffer *vb) {    SDL_assert(!vb->rendering_frame_consumed);    vb->rendering_frame_consumed = SDL_TRUE;    if (vb->fps_counter.started) {        fps_counter_add_rendered_frame(&vb->fps_counter);    }#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then notify the decoder the current frame is    // consumed, so that it may push a new one    cond_signal(vb->rendering_frame_consumed_cond);#endif    return vb->rendering_frame;}
video_buffer_offer_decoded_frame(struct video_buffer *vb) {    mutex_lock(vb->mutex);#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then the decoder must wait for the current    // frame to be consumed    while (!vb->rendering_frame_consumed && !vb->interrupted) {        cond_wait(vb->rendering_frame_consumed_cond, vb->mutex);    }#else    if (vb->fps_counter.started && !vb->rendering_frame_consumed) {        fps_counter_add_skipped_frame(&vb->fps_counter);    }#endif    video_buffer_swap_frames(vb);    SDL_bool previous_frame_consumed = vb->rendering_frame_consumed;    vb->rendering_frame_consumed = SDL_FALSE;    mutex_unlock(vb->mutex);    return previous_frame_consumed;}
video_buffer_init(struct video_buffer *vb) {    if (!(vb->decoding_frame = av_frame_alloc())) {        goto error_0;    }    if (!(vb->rendering_frame = av_frame_alloc())) {        goto error_1;    }    if (!(vb->mutex = SDL_CreateMutex())) {        goto error_2;    }#ifndef SKIP_FRAMES    if (!(vb->rendering_frame_consumed_cond = SDL_CreateCond())) {        SDL_DestroyMutex(vb->mutex);        goto error_2;    }    vb->interrupted = SDL_FALSE;#endif    // there is initially no rendering frame, so consider it has already been    // consumed    vb->rendering_frame_consumed = SDL_TRUE;    fps_counter_init(&vb->fps_counter);    return SDL_TRUE;error_2:    av_frame_free(&vb->rendering_frame);error_1:    av_frame_free(&vb->decoding_frame);error_0:    return SDL_FALSE;}
video_buffer_destroy(struct video_buffer *vb) {#ifndef SKIP_FRAMES    SDL_DestroyCond(vb->rendering_frame_consumed_cond);#endif    SDL_DestroyMutex(vb->mutex);    av_frame_free(&vb->rendering_frame);    av_frame_free(&vb->decoding_frame);}
video_buffer_interrupt(struct video_buffer *vb) {#ifdef SKIP_FRAMES    (void) vb; // unused#else    mutex_lock(vb->mutex);    vb->interrupted = SDL_TRUE;    mutex_unlock(vb->mutex);    // wake up blocking wait    cond_signal(vb->rendering_frame_consumed_cond);#endif}
video_buffer_swap_frames(struct video_buffer *vb) {    AVFrame *tmp = vb->decoding_frame;    vb->decoding_frame = vb->rendering_frame;    vb->rendering_frame = tmp;}
video_buffer_consume_rendered_frame(struct video_buffer *vb) {    SDL_assert(!vb->rendering_frame_consumed);    vb->rendering_frame_consumed = SDL_TRUE;    if (vb->fps_counter.started) {        fps_counter_add_rendered_frame(&vb->fps_counter);    }#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then notify the decoder the current frame is    // consumed, so that it may push a new one    cond_signal(vb->rendering_frame_consumed_cond);#endif    return vb->rendering_frame;}
int parse_args(struct args *args, int argc, char *argv[]) {    int c;    while ((c = getopt(argc, argv, "p:m:")) != -1) {        switch (c) {            case 'p': {                char *endptr;                long value = strtol(optarg, &endptr, 0);                if (*optarg == '\0' || *endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s\n", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld\n", value);                    return -1;                }                args->port = (Uint16) value;                break;            }            case 'm': {                char *endptr;                long value = strtol(optarg, &endptr, 0);                if (*optarg == '\0' || *endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid maximum size: %s\n", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Maximum size must be between 0 and 65535: %ld\n", value);                    return -1;                }                args->maximum_size = (Uint16) value;                break;            }            default:                // getopt prints the error message on stderr                return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s\n", argv[index]);        return -1;    }    return 0;}
static int parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"port",     required_argument, NULL, 'p'},        {"max-size", required_argument, NULL, 'm'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "p:m:", long_options, NULL)) != -1) {        switch (c) {            case 'p': {                char *endptr;                long value = strtol(optarg, &endptr, 0);                if (*optarg == '\0' || *endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s\n", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld\n", value);                    return -1;                }                args->port = (Uint16) value;                break;            }            case 'm': {                char *endptr;                long value = strtol(optarg, &endptr, 0);                if (*optarg == '\0' || *endptr != '\0') {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid maximum size: %s\n", optarg);                    return -1;                }                if (value & ~0xffff) {                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Maximum size must be between 0 and 65535: %ld\n", value);                    return -1;                }                args->maximum_size = (Uint16) value;                break;            }            default:                // getopt prints the error message on stderr                return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s\n", argv[index]);        return -1;    }    return 0;}
    private int injectText(String text) {        int successCount = 0;        for (char c : text.toCharArray()) {            if (!injectChar(c)) {                continue;            }            successCount++;        }        return successCount;    }
    private int injectText(String text) {        int successCount = 0;        for (char c : text.toCharArray()) {            if (!injectChar(c)) {                Ln.w("Could not inject char u+" + String.format("%04x", (int) c));                continue;            }            successCount++;        }        return successCount;    }
recorder_write(struct recorder *recorder, AVPacket *packet) {    if (!recorder->header_written) {        bool ok = recorder_write_header(recorder, packet);        if (!ok) {            return false;        }        recorder->header_written = true;    }    recorder_rescale_packet(recorder, packet);    return av_write_frame(recorder->ctx, packet) >= 0;}
recorder_write(struct recorder *recorder, AVPacket *packet) {    if (!recorder->header_written) {        if (packet->pts != AV_NOPTS_VALUE) {            LOGE("The first packet is not a config packet");            return false;        }        bool ok = recorder_write_header(recorder, packet);        if (!ok) {            return false;        }        recorder->header_written = true;        return true;    }    if (packet->pts == AV_NOPTS_VALUE) {        // ignore config packets        return true;    }    recorder_rescale_packet(recorder, packet);    return av_write_frame(recorder->ctx, packet) >= 0;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .send_frame_meta = record,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial,                                   options->push_target)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/" SERVER_FILENAME,        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        params->send_frame_meta ? "true" : "false",        params->control ? "true" : "false",    };    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/" SERVER_FILENAME,        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        "true", // always send frame meta (packet boundaries + timestamp)        params->control ? "true" : "false",    };    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
read_raw_packet(void *opaque, uint8_t *buf, int buf_size) {    struct stream *stream = opaque;    ssize_t r = net_recv(stream->socket, buf, buf_size);    if (r == -1) {        return errno ? AVERROR(errno) : AVERROR_EOF;    }    if (r == 0) {        return AVERROR_EOF;    }    return r;}
run_stream(void *data) {    struct stream *stream = data;    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto end;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto finally_free_format_ctx;    }    // initialize the receiver state    stream->receiver_state.frame_meta_queue = NULL;    stream->receiver_state.remaining = 0;    // if recording is enabled, a "header" is sent between raw packets    int (*read_packet)(void *, uint8_t *, int) =            stream->recorder ? read_packet_with_meta : read_raw_packet;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, stream,                                               read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto finally_free_avio_ctx;    }    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto end;    }    if (stream->decoder && !decoder_open(stream->decoder, codec)) {        LOGE("Could not open decoder");        goto finally_close_input;    }    if (stream->recorder && !recorder_open(stream->recorder, codec)) {        LOGE("Could not open recorder");        goto finally_close_decoder;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {        if (SDL_AtomicGet(&stream->stopped)) {            // if the stream is stopped, the socket had been shutdown, so the            // last packet is probably corrupted (but not detected as such by            // FFmpeg) and will not be decoded correctly            av_packet_unref(&packet);            goto quit;        }        if (stream->decoder && !decoder_push(stream->decoder, &packet)) {            av_packet_unref(&packet);            goto quit;        }        if (stream->recorder) {            // we retrieve the PTS in order they were received, so they will            // be assigned to the correct frame            uint64_t pts = receiver_state_take_meta(&stream->receiver_state);            packet.pts = pts;            packet.dts = pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(stream->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");quit:    if (stream->recorder) {        recorder_close(stream->recorder);    }finally_close_decoder:    if (stream->decoder) {        decoder_close(stream->decoder);    }finally_close_input:    avformat_close_input(&format_ctx);finally_free_avio_ctx:    av_free(avio_ctx->buffer);    av_free(avio_ctx);finally_free_format_ctx:    avformat_free_context(format_ctx);end:    notify_stopped();    return 0;}
receiver_state_take_meta(struct receiver_state *state) {    struct frame_meta *frame_meta = state->frame_meta_queue; // first item    SDL_assert(frame_meta); // must not be empty    uint64_t pts = frame_meta->pts;    state->frame_meta_queue = frame_meta->next; // remove the item    frame_meta_delete(frame_meta);    return pts;}
receiver_state_take_meta(struct receiver_state *state) {    struct frame_meta *frame_meta = state->frame_meta_queue; // first item    SDL_assert(frame_meta); // must not be empty    uint64_t pts = frame_meta->pts;    state->frame_meta_queue = frame_meta->next; // remove the item    frame_meta_delete(frame_meta);    return pts;}
frame_meta_delete(struct frame_meta *frame_meta) {    SDL_free(frame_meta);}
frame_meta_delete(struct frame_meta *frame_meta) {    SDL_free(frame_meta);}
frame_meta_new(uint64_t pts) {    struct frame_meta *meta = SDL_malloc(sizeof(*meta));    if (!meta) {        return meta;    }    meta->pts = pts;    meta->next = NULL;    return meta;}
read_packet_with_meta(void *opaque, uint8_t *buf, int buf_size) {    struct stream *stream = opaque;    struct receiver_state *state = &stream->receiver_state;    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    if (!state->remaining) {#define HEADER_SIZE 12        uint8_t header[HEADER_SIZE];        ssize_t r = net_recv_all(stream->socket, header, HEADER_SIZE);        if (r == -1) {            return AVERROR(errno);        }        if (r == 0) {            return AVERROR_EOF;        }        // no partial read (net_recv_all())        SDL_assert_release(r == HEADER_SIZE);        uint64_t pts = buffer_read64be(header);        state->remaining = buffer_read32be(&header[8]);        if (pts != NO_PTS && !receiver_state_push_meta(state, pts)) {            LOGE("Could not store PTS for recording");            // we could not save the PTS, the recording would be broken            return AVERROR(ENOMEM);        }    }    SDL_assert(state->remaining);    if (buf_size > state->remaining) {        buf_size = state->remaining;    }    ssize_t r = net_recv(stream->socket, buf, buf_size);    if (r == -1) {        return errno ? AVERROR(errno) : AVERROR_EOF;    }    if (r == 0) {        return AVERROR_EOF;    }    SDL_assert(state->remaining >= r);    state->remaining -= r;    return r;}
stream_init(struct stream *stream, socket_t socket,            struct decoder *decoder, struct recorder *recorder) {    stream->socket = socket;    stream->decoder = decoder,    stream->recorder = recorder;    SDL_AtomicSet(&stream->stopped, 0);}
receiver_state_push_meta(struct receiver_state *state, uint64_t pts) {    struct frame_meta *frame_meta = frame_meta_new(pts);    if (!frame_meta) {        return false;    }    // append to the list    // (iterate to find the last item, in practice the list should be tiny)    struct frame_meta **p = &state->frame_meta_queue;    while (*p) {        p = &(*p)->next;    }    *p = frame_meta;    return true;}
receiver_state_push_meta(struct receiver_state *state, uint64_t pts) {    struct frame_meta *frame_meta = frame_meta_new(pts);    if (!frame_meta) {        return false;    }    // append to the list    // (iterate to find the last item, in practice the list should be tiny)    struct frame_meta **p = &state->frame_meta_queue;    while (*p) {        p = &(*p)->next;    }    *p = frame_meta;    return true;}
receiver_state_push_meta(struct receiver_state *state, uint64_t pts) {    struct frame_meta *frame_meta = frame_meta_new(pts);    if (!frame_meta) {        return false;    }    // append to the list    // (iterate to find the last item, in practice the list should be tiny)    struct frame_meta **p = &state->frame_meta_queue;    while (*p) {        p = &(*p)->next;    }    *p = frame_meta;    return true;}
receiver_state_push_meta(struct receiver_state *state, uint64_t pts) {    struct frame_meta *frame_meta = frame_meta_new(pts);    if (!frame_meta) {        return false;    }    // append to the list    // (iterate to find the last item, in practice the list should be tiny)    struct frame_meta **p = &state->frame_meta_queue;    while (*p) {        p = &(*p)->next;    }    *p = frame_meta;    return true;}
    // A config packet must not be decoded immetiately (it contains no    // frame); instead, it must be concatenated with the future data packet.    if (stream->has_pending || is_config) {        size_t offset;        if (stream->has_pending) {            offset = stream->pending.size;            if (av_grow_packet(&stream->pending, packet->size)) {                LOGE("Could not grow packet");                return false;            }        } else {
run_stream(void *data) {    struct stream *stream = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto end;    }    stream->codec_ctx = avcodec_alloc_context3(codec);    if (!stream->codec_ctx) {        LOGC("Could not allocate codec context");        goto end;    }    if (stream->decoder && !decoder_open(stream->decoder, codec)) {        LOGE("Could not open decoder");        goto finally_free_codec_ctx;    }    if (stream->recorder && !recorder_open(stream->recorder, codec)) {        LOGE("Could not open recorder");        goto finally_close_decoder;    }    stream->parser = av_parser_init(AV_CODEC_ID_H264);    if (!stream->parser) {        LOGE("Could not initialize parser");        goto finally_close_recorder;    }    // We must only pass complete frames to av_parser_parse2()!    // It's more complicated, but this allows to reduce the latency by 1 frame!    stream->parser->flags |= PARSER_FLAG_COMPLETE_FRAMES;    for (;;) {        AVPacket packet;        bool ok = stream_recv_packet(stream, &packet);        if (!ok) {            // end of stream            break;        }        ok = stream_push_packet(stream, &packet);        av_packet_unref(&packet);        if (!ok) {            // cannot process packet (error already logged)            break;        }    }    LOGD("End of frames");    if (stream->has_pending) {        av_packet_unref(&stream->pending);    }    av_parser_close(stream->parser);finally_close_recorder:    if (stream->recorder) {        recorder_close(stream->recorder);    }finally_close_decoder:    if (stream->decoder) {        decoder_close(stream->decoder);    }finally_free_codec_ctx:    avcodec_free_context(&stream->codec_ctx);end:    notify_stopped();    return 0;}
    packet->pts = pts != NO_PTS ? pts : AV_NOPTS_VALUE;    return true;}static voidnotify_stopped(void) {    SDL_Event stop_event;
stream_recv_packet(struct stream *stream, AVPacket *packet) {    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    uint8_t header[HEADER_SIZE];    ssize_t r = net_recv_all(stream->socket, header, HEADER_SIZE);    if (r < HEADER_SIZE) {        return false;    }    uint64_t pts = buffer_read64be(header);    uint32_t len = buffer_read32be(&header[8]);    SDL_assert(len);    if (av_new_packet(packet, len)) {        LOGE("Could not allocate packet");        return false;    }    r = net_recv_all(stream->socket, packet->data, len);    if (r < len) {        av_packet_unref(packet);        return false;    }    packet->pts = pts != NO_PTS ? pts : AV_NOPTS_VALUE;    return true;}
    // It is followed by <packet_size> bytes containing the packet/frame.    uint8_t header[HEADER_SIZE];    ssize_t r = net_recv_all(stream->socket, header, HEADER_SIZE);
stream_parse(struct stream *stream, AVPacket *packet) {    uint8_t *in_data = packet->data;    int in_len = packet->size;    uint8_t *out_data = NULL;    int out_len = 0;    int r = av_parser_parse2(stream->parser, stream->codec_ctx,                             &out_data, &out_len, in_data, in_len,                             AV_NOPTS_VALUE, AV_NOPTS_VALUE, -1);    // PARSER_FLAG_COMPLETE_FRAMES is set    SDL_assert(r == in_len);    SDL_assert(out_len == in_len);    if (stream->parser->key_frame == 1) {        packet->flags |= AV_PKT_FLAG_KEY;    }    bool ok = process_frame(stream, packet);    if (!ok) {        LOGE("Could not process frame");        return false;    }    return true;}
stream_recv_packet(struct stream *stream, AVPacket *packet) {    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size
    SDL_PushEvent(&stop_event);}static boolprocess_config_packet(struct stream *stream, AVPacket *packet) {    if (stream->recorder && !recorder_write(stream->recorder, packet)) {        LOGE("Could not send config packet to recorder");        return false;    }    return true;}static boolprocess_frame(struct stream *stream, AVPacket *packet) {    if (stream->decoder && !decoder_push(stream->decoder, packet)) {        return false;    }    if (stream->recorder) {        packet->dts = packet->pts;        if (!recorder_write(stream->recorder, packet)) {            LOGE("Could not write frame to output file");            return false;        }    }    return true;}static boolstream_parse(struct stream *stream, AVPacket *packet) {    uint8_t *in_data = packet->data;    int in_len = packet->size;    uint8_t *out_data = NULL;    int out_len = 0;    int r = av_parser_parse2(stream->parser, stream->codec_ctx,                             &out_data, &out_len, in_data, in_len,                             AV_NOPTS_VALUE, AV_NOPTS_VALUE, -1);    // PARSER_FLAG_COMPLETE_FRAMES is set    SDL_assert(r == in_len);    SDL_assert(out_len == in_len);    if (stream->parser->key_frame == 1) {        packet->flags |= AV_PKT_FLAG_KEY;    }    bool ok = process_frame(stream, packet);    if (!ok) {        LOGE("Could not process frame");        return false;    }    return true;}static boolstream_push_packet(struct stream *stream, AVPacket *packet) {
stream_init(struct stream *stream, socket_t socket,            struct decoder *decoder, struct recorder *recorder) {    stream->socket = socket;    stream->decoder = decoder,    stream->recorder = recorder;    stream->has_pending = false;}
        return false;    }    uint64_t pts = buffer_read64be(header);    uint32_t len = buffer_read32be(&header[8]);    SDL_assert(len);    if (av_new_packet(packet, len)) {        LOGE("Could not allocate packet");        return false;    }    r = net_recv_all(stream->socket, packet->data, len);    if (r < len) {        av_packet_unref(packet);        return false;
process_frame(struct stream *stream, AVPacket *packet) {    if (stream->decoder && !decoder_push(stream->decoder, packet)) {        return false;    }    if (stream->recorder) {        packet->dts = packet->pts;        if (!recorder_write(stream->recorder, packet)) {            LOGE("Could not write frame to output file");            return false;        }    }    return true;}
stream_push_packet(struct stream *stream, AVPacket *packet) {    bool is_config = packet->pts == AV_NOPTS_VALUE;    // A config packet must not be decoded immetiately (it contains no    // frame); instead, it must be concatenated with the future data packet.    if (stream->has_pending || is_config) {        size_t offset;        if (stream->has_pending) {            offset = stream->pending.size;            if (av_grow_packet(&stream->pending, packet->size)) {                LOGE("Could not grow packet");                return false;            }        } else {            offset = 0;            if (av_new_packet(&stream->pending, packet->size)) {                LOGE("Could not create packet");                return false;            }            stream->has_pending = true;        }        memcpy(stream->pending.data + offset, packet->data, packet->size);        if (!is_config) {            // prepare the concat packet to send to the decoder            stream->pending.pts = packet->pts;            stream->pending.dts = packet->dts;            stream->pending.flags = packet->flags;            packet = &stream->pending;        }    }    if (is_config) {        // config packet        bool ok = process_config_packet(stream, packet);        if (!ok) {            return false;        }    } else {        // data packet        bool ok = stream_parse(stream, packet);        if (stream->has_pending) {            // the pending packet must be discarded (consumed or error)            stream->has_pending = false;            av_packet_unref(&stream->pending);        }        if (!ok) {            return false;        }    }    return true;}
process_config_packet(struct stream *stream, AVPacket *packet) {    if (stream->recorder && !recorder_write(stream->recorder, packet)) {        LOGE("Could not send config packet to recorder");        return false;    }    return true;}
    public static IBinder getBuiltInDisplay(int builtInDisplayId) {        try {            // Android Q does not have this method anymore but has a            // replacement.            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                return (IBinder) CLASS.getMethod("getBuiltInDisplay", int.class).invoke(null, builtInDisplayId);            } else {                return (IBinder) CLASS.getMethod("getPhysicalDisplayToken", long.class).invoke(null, builtInDisplayId);            }        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public static IBinder getBuiltInDisplay(int builtInDisplayId) {        try {            // the method signature has changed in Android Q            // <https://github.com/Genymobile/scrcpy/issues/586>            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                return (IBinder) CLASS.getMethod("getBuiltInDisplay", int.class).invoke(null, builtInDisplayId);            } else {                return (IBinder) CLASS.getMethod("getPhysicalDisplayToken", long.class).invoke(null, builtInDisplayId);            }        } catch (Exception e) {            throw new AssertionError(e);        }    }
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            buffer_write32be(&buf[2], event->keycode_event.keycode);            buffer_write32be(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (1 byte) + date (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > TEXT_MAX_LENGTH) {                // injecting a text takes time, so limit the text length                len = TEXT_MAX_LENGTH;            }            buffer_write16be(&buf[1], (Uint16) len);            memcpy(&buf[3], event->text_event.text, len);            return 3 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            buffer_write32be(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 14;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            buffer_write32be(&buf[9], (Uint32) event->scroll_event.hscroll);            buffer_write32be(&buf[13], (Uint32) event->scroll_event.vscroll);            return 17;        case CONTROL_EVENT_TYPE_COMMAND:            buf[1] = event->command_event.action;            return 2;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
static void write_position(Uint8 *buf, const struct position *position) {    buffer_write16be(&buf[0], position->point.x);    buffer_write16be(&buf[2], position->point.y);    buffer_write16be(&buf[4], position->screen_size.width);    buffer_write16be(&buf[6], position->screen_size.height);}
int control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            buffer_write32be(&buf[2], event->keycode_event.keycode);            buffer_write32be(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (1 byte) + date (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > TEXT_MAX_LENGTH) {                // injecting a text takes time, so limit the text length                len = TEXT_MAX_LENGTH;            }            buffer_write16be(&buf[1], (Uint16) len);            memcpy(&buf[3], event->text_event.text, len);            return 3 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            buffer_write32be(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 18;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            buffer_write32be(&buf[13], (Uint32) event->scroll_event.hscroll);            buffer_write32be(&buf[17], (Uint32) event->scroll_event.vscroll);            return 21;        case CONTROL_EVENT_TYPE_COMMAND:            buf[1] = event->command_event.action;            return 2;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
static void write_position(Uint8 *buf, const struct position *position) {    buffer_write32be(&buf[0], position->point.x);    buffer_write32be(&buf[4], position->point.y);    buffer_write16be(&buf[8], position->screen_size.width);    buffer_write16be(&buf[10], position->screen_size.height);}
static void get_mouse_point(struct screen *screen, int *x, int *y) {    SDL_GetMouseState(x, y);    convert_to_renderer_coordinates(screen->renderer, x, y);}
static void get_mouse_point(struct screen *screen, int *x, int *y) {    SDL_GetMouseState(x, y);    convert_to_renderer_coordinates(screen->renderer, x, y);}
static struct point get_mouse_point(struct screen *screen) {    int x;    int y;    SDL_GetMouseState(&x, &y);    convert_to_renderer_coordinates(screen->renderer, &x, &y);    return (struct point) {        .x = x,        .y = y,    };}
static struct point get_mouse_point(struct screen *screen) {    int x;    int y;    SDL_GetMouseState(&x, &y);    convert_to_renderer_coordinates(screen->renderer, &x, &y);
    private static Position readPosition(ByteBuffer buffer) {        int x = toUnsigned(buffer.getShort());        int y = toUnsigned(buffer.getShort());        int screenWidth = toUnsigned(buffer.getShort());        int screenHeight = toUnsigned(buffer.getShort());        return new Position(x, y, screenWidth, screenHeight);    }
    private static Position readPosition(ByteBuffer buffer) {        int x = buffer.getInt();        int y = buffer.getInt();        int screenWidth = toUnsigned(buffer.getShort());        int screenHeight = toUnsigned(buffer.getShort());        return new Position(x, y, screenWidth, screenHeight);    }
static SDL_bool convert_keycode(SDL_Keycode from, enum android_keycode *to) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_HOME,         AKEYCODE_HOME);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);        FAIL;    }}
static SDL_bool convert_keycode(SDL_Keycode from, enum android_keycode *to) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_HOME,         AKEYCODE_HOME);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);        FAIL;    }}
process_t start_server(const char *serial, Uint16 max_size, Uint32 bit_rate) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy.apk",        "app_process",        "/", // unused        "com.genymobile.scrcpy.ScrCpyServer",        max_size_string,        bit_rate_string,    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
process_t push_server(const char *serial) {    const char *apk_path = getenv("SCRCPY_APK");    if (!apk_path) {        apk_path = "scrcpy.apk";    }    return adb_push(serial, apk_path, "/data/local/tmp/scrcpy.apk");}
process_t start_server(const char *serial, Uint16 max_size, Uint32 bit_rate) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.ScrCpyServer",        max_size_string,        bit_rate_string,    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
process_t push_server(const char *serial) {    const char *server_path = getenv("SCRCPY_SERVER_JAR");    if (!server_path) {        server_path = "scrcpy-server.jar";    }    return adb_push(serial, server_path, "/data/local/tmp/scrcpy-server.jar");}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top", no_argument,       NULL, 'T'},        {"bit-rate",      required_argument, NULL, 'b'},        {"crop",          required_argument, NULL, 'c'},        {"fullscreen",    no_argument,       NULL, 'f'},        {"help",          no_argument,       NULL, 'h'},        {"max-size",      required_argument, NULL, 'm'},        {"no-display",    no_argument,       NULL, 'N'},        {"port",          required_argument, NULL, 'p'},        {"record",        required_argument, NULL, 'r'},        {"record-format", required_argument, NULL, 'f'},        {"serial",        required_argument, NULL, 's'},        {"show-touches",  no_argument,       NULL, 't'},        {"version",       no_argument,       NULL, 'v'},        {NULL,            0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:Np:r:s:tTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = SDL_TRUE;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return SDL_FALSE;                }                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'N':                args->no_display = SDL_TRUE;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = SDL_TRUE;                break;            case 'T':                args->always_on_top = SDL_TRUE;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    if (args->no_display && !args->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return SDL_FALSE;    }    if (args->no_display && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return SDL_FALSE;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return SDL_FALSE;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return SDL_FALSE;        }    }    return SDL_TRUE;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .record_format = 0,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = SDL_FALSE,        .no_display = SDL_FALSE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,        .no_display = args.no_display,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top", no_argument,       NULL, 'T'},        {"bit-rate",      required_argument, NULL, 'b'},        {"crop",          required_argument, NULL, 'c'},        {"fullscreen",    no_argument,       NULL, 'f'},        {"help",          no_argument,       NULL, 'h'},        {"max-size",      required_argument, NULL, 'm'},        {"no-control",    no_argument,       NULL, 'n'},        {"no-display",    no_argument,       NULL, 'N'},        {"port",          required_argument, NULL, 'p'},        {"record",        required_argument, NULL, 'r'},        {"record-format", required_argument, NULL, 'f'},        {"serial",        required_argument, NULL, 's'},        {"show-touches",  no_argument,       NULL, 't'},        {"version",       no_argument,       NULL, 'v'},        {NULL,            0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:tTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = SDL_TRUE;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return SDL_FALSE;                }                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'n':                args->no_control = SDL_TRUE;                break;            case 'N':                args->no_display = SDL_TRUE;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = SDL_TRUE;                break;            case 'T':                args->always_on_top = SDL_TRUE;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    if (args->no_display && !args->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return SDL_FALSE;    }    if (args->no_display && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return SDL_FALSE;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return SDL_FALSE;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return SDL_FALSE;        }    }    return SDL_TRUE;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .record_format = 0,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = SDL_FALSE,        .no_control = SDL_FALSE,        .no_display = SDL_FALSE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,        .no_control = args.no_control,        .no_display = args.no_display,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
event_loop(SDL_bool display) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    if (display) {        SDL_AddEventWatch(event_watcher, NULL);    }#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        enum event_result result = handle_event(&event);        switch (result) {            case EVENT_RESULT_STOPPED_BY_USER:                return SDL_TRUE;            case EVENT_RESULT_STOPPED_BY_EOS:                return SDL_FALSE;            case EVENT_RESULT_CONTINUE:                break;        }    }    return SDL_FALSE;}
handle_event(SDL_Event *event) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = SDL_TRUE;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return SDL_FALSE;            }            break;        case SDL_WINDOWEVENT:            switch (event->window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;            }            break;        case SDL_TEXTINPUT:            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            input_manager_process_key(&input_manager, &event->key);            break;        case SDL_MOUSEMOTION:            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            input_manager_process_mouse_button(&input_manager, &event->button);            break;        case SDL_DROPFILE: {            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
handle_event(SDL_Event *event) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = SDL_TRUE;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return SDL_FALSE;            }            break;        case SDL_WINDOWEVENT:            switch (event->window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;            }            break;        case SDL_TEXTINPUT:            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            input_manager_process_key(&input_manager, &event->key);            break;        case SDL_MOUSEMOTION:            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            input_manager_process_mouse_button(&input_manager, &event->button);            break;        case SDL_DROPFILE: {            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
event_loop(SDL_bool display) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    if (display) {        SDL_AddEventWatch(event_watcher, NULL);    }#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        enum event_result result = handle_event(&event);        switch (result) {            case EVENT_RESULT_STOPPED_BY_USER:                return SDL_TRUE;            case EVENT_RESULT_STOPPED_BY_EOS:                return SDL_FALSE;            case EVENT_RESULT_CONTINUE:                break;        }    }    return SDL_FALSE;}
scrcpy(const struct scrcpy_options *options) {    SDL_bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    SDL_bool display = !options->no_display;    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            server_stop(&server);            ret = SDL_FALSE;            goto finally_destroy_server;        }        if (!file_handler_init(&file_handler, server.serial)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_video_buffer;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (display) {        if (!controller_init(&controller, device_socket)) {            ret = SDL_FALSE;            goto finally_stop_stream;        }        if (!controller_start(&controller)) {            ret = SDL_FALSE;            goto finally_destroy_controller;        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            ret = SDL_FALSE;            goto finally_stop_and_join_controller;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    ret = event_loop(display);    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    if (display) {        controller_stop(&controller);        controller_join(&controller);    }finally_destroy_controller:    if (display) {        controller_destroy(&controller);    }finally_stop_stream:    stream_stop(&stream);    // stop the server before stream_join() to wake up the stream    server_stop(&server);    stream_join(&stream);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    if (display) {        file_handler_stop(&file_handler);        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }finally_destroy_video_buffer:    if (display) {        video_buffer_destroy(&video_buffer);    }finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial,                                                     SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
event_loop(SDL_bool display, SDL_bool control) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    if (display) {        SDL_AddEventWatch(event_watcher, NULL);    }#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        enum event_result result = handle_event(&event, control);        switch (result) {            case EVENT_RESULT_STOPPED_BY_USER:                return SDL_TRUE;            case EVENT_RESULT_STOPPED_BY_EOS:                return SDL_FALSE;            case EVENT_RESULT_CONTINUE:                break;        }    }    return SDL_FALSE;}
static enum event_resulthandle_event(SDL_Event *event, SDL_bool control) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = SDL_TRUE;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return SDL_FALSE;            }            break;        case SDL_WINDOWEVENT:            switch (event->window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;            }            break;        case SDL_TEXTINPUT:            if (!control) {                break;            }            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            // some key events do not interact with the device, so process the            // event even if control is disabled            input_manager_process_key(&input_manager, &event->key);            break;        case SDL_MOUSEMOTION:            if (!control) {                break;            }            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            if (!control) {                break;            }            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            // some mouse events do not interact with the device, so process            // the event even if control is disabled            input_manager_process_mouse_button(&input_manager, &event->button);            break;
handle_event(SDL_Event *event, SDL_bool control) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = SDL_TRUE;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return SDL_FALSE;            }            break;        case SDL_WINDOWEVENT:            switch (event->window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;            }            break;        case SDL_TEXTINPUT:            if (!control) {                break;            }            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            // some key events do not interact with the device, so process the            // event even if control is disabled            input_manager_process_key(&input_manager, &event->key);            break;        case SDL_MOUSEMOTION:            if (!control) {                break;            }            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            if (!control) {                break;            }            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            // some mouse events do not interact with the device, so process            // the event even if control is disabled            input_manager_process_mouse_button(&input_manager, &event->button);            break;        case SDL_DROPFILE: {            if (!control) {                break;            }            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
            if (!control) {                break;            }            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}static SDL_boolevent_loop(SDL_bool display, SDL_bool control) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    if (display) {        SDL_AddEventWatch(event_watcher, NULL);
scrcpy(const struct scrcpy_options *options) {    SDL_bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    SDL_bool display = !options->no_display;    SDL_bool control = !options->no_control;    input_manager.control = control;    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            server_stop(&server);            ret = SDL_FALSE;            goto finally_destroy_server;        }        if (control && !file_handler_init(&file_handler, server.serial)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_video_buffer;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (display) {        if (control) {            if (!controller_init(&controller, device_socket)) {                ret = SDL_FALSE;                goto finally_stop_stream;            }            if (!controller_start(&controller)) {                ret = SDL_FALSE;                goto finally_destroy_controller;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            ret = SDL_FALSE;            goto finally_stop_and_join_controller;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    ret = event_loop(display, control);    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    if (display && control) {        controller_stop(&controller);        controller_join(&controller);    }finally_destroy_controller:    if (display && control) {        controller_destroy(&controller);    }finally_stop_stream:    stream_stop(&stream);    // stop the server before stream_join() to wake up the stream    server_stop(&server);    stream_join(&stream);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    if (display && control) {        file_handler_stop(&file_handler);        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }finally_destroy_video_buffer:    if (display) {        video_buffer_destroy(&video_buffer);    }finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial,                                                     SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
    public static void scrcpy() throws IOException {        String deviceName = DeviceUtil.getDeviceName();        ScreenInfo initialScreenInfo = DeviceUtil.getScreenInfo();        int width = initialScreenInfo.getLogicalWidth();        int height = initialScreenInfo.getLogicalHeight();        try (DesktopConnection connection = DesktopConnection.open(deviceName, width, height)) {            try {                new ScreenStreamer(connection).streamScreen();            } catch (IOException e) {                System.err.println("Screen streaming interrupted: " + e.getMessage());                System.err.flush();            }        }    }
    public static void scrcpy() throws IOException {        String deviceName = DeviceUtil.getDeviceName();        ScreenInfo initialScreenInfo = DeviceUtil.getScreenInfo();        int width = initialScreenInfo.getLogicalWidth();        int height = initialScreenInfo.getLogicalHeight();        try (DesktopConnection connection = DesktopConnection.open(deviceName, width, height)) {            try {                new ScreenStreamer(connection).streamScreen();            } catch (IOException e) {                Ln.e("Screen streaming interrupted", e);            }        }    }
SDL_bool recorder_write(struct recorder *recorder, AVPacket *packet) {    if (!recorder->header_written) {        SDL_bool ok = recorder_write_header(recorder, packet);        if (!ok) {            return SDL_FALSE;        }        recorder->header_written = SDL_TRUE;    }    return av_write_frame(recorder->ctx, packet) >= 0;}
SDL_bool recorder_open(struct recorder *recorder, AVCodec *input_codec) {    const AVOutputFormat *mp4 = find_mp4_muxer();    if (!mp4) {        LOGE("Could not find mp4 muxer");        return SDL_FALSE;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return SDL_FALSE;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) mp4;    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }#ifdef LAVF_NEW_CODEC_API    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    ostream->time_base = (AVRational) {1, 1000000}; // timestamps in us    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    return SDL_TRUE;}
SDL_bool recorder_open(struct recorder *recorder, AVCodec *input_codec) {    const AVOutputFormat *mp4 = find_mp4_muxer();    if (!mp4) {        LOGE("Could not find mp4 muxer");        return SDL_FALSE;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return SDL_FALSE;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) mp4;    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }#ifdef LAVF_NEW_CODEC_API    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    ostream->time_base = (AVRational) {1, 1000000}; // timestamps in us    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    return SDL_TRUE;}
SDL_bool recorder_write(struct recorder *recorder, AVPacket *packet) {    if (!recorder->header_written) {        SDL_bool ok = recorder_write_header(recorder, packet);        if (!ok) {            return SDL_FALSE;        }        recorder->header_written = SDL_TRUE;    }    recorder_rescale_packet(recorder, packet);    return av_write_frame(recorder->ctx, packet) >= 0;}
}SDL_bool recorder_open(struct recorder *recorder, AVCodec *input_codec) {    const AVOutputFormat *mp4 = find_mp4_muxer();    if (!mp4) {        LOGE("Could not find mp4 muxer");        return SDL_FALSE;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return SDL_FALSE;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) mp4;    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }#ifdef LAVF_NEW_CODEC_API    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    return SDL_TRUE;}
recorder_rescale_packet(struct recorder *recorder, AVPacket *packet) {    AVStream *ostream = recorder->ctx->streams[0];    av_packet_rescale_ts(packet, SCRCPY_TIME_BASE, ostream->time_base);}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = true;    bool display = !options->no_display;    bool control = !options->no_control;    if (!sdl_init_and_configure(display)) {        ret = false;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = false;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = false;        goto finally_destroy_server;    }    input_manager.control = control;    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            server_stop(&server);            ret = false;            goto finally_destroy_server;        }        if (control && !file_handler_init(&file_handler, server.serial)) {            ret = false;            server_stop(&server);            goto finally_destroy_video_buffer;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = false;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        ret = false;        server_stop(&server);        goto finally_destroy_recorder;    }    if (display) {        if (control) {            if (!controller_init(&controller, device_socket)) {                ret = false;                goto finally_stop_stream;            }            if (!controller_start(&controller)) {                ret = false;                goto finally_destroy_controller;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            ret = false;            goto finally_stop_and_join_controller;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(display, control);    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    if (display && control) {        controller_stop(&controller);        controller_join(&controller);    }finally_destroy_controller:    if (display && control) {        controller_destroy(&controller);    }finally_stop_stream:    stream_stop(&stream);    // stop the server before stream_join() to wake up the stream    server_stop(&server);    stream_join(&stream);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    if (display && control) {        file_handler_stop(&file_handler);        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }finally_destroy_video_buffer:    if (display) {        video_buffer_destroy(&video_buffer);    }finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial,                                                     false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
handle_event(SDL_Event *event, bool control) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = true;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return false;            }            break;        case SDL_WINDOWEVENT:            switch (event->window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;            }            break;        case SDL_TEXTINPUT:            if (!control) {                break;            }            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            // some key events do not interact with the device, so process the            // event even if control is disabled            input_manager_process_key(&input_manager, &event->key);            break;        case SDL_MOUSEMOTION:            if (!control) {                break;            }            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            if (!control) {                break;            }            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            // some mouse events do not interact with the device, so process            // the event even if control is disabled            input_manager_process_mouse_button(&input_manager, &event->button);            break;        case SDL_DROPFILE: {            if (!control) {                break;            }            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = true;    bool display = !options->no_display;    bool control = !options->no_control;    if (!sdl_init_and_configure(display)) {        ret = false;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = false;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = false;        goto finally_destroy_server;    }    struct decoder *dec = NULL;    if (display) {        if (!video_buffer_init(&video_buffer)) {            server_stop(&server);            ret = false;            goto finally_destroy_server;        }        if (control && !file_handler_init(&file_handler, server.serial)) {            ret = false;            server_stop(&server);            goto finally_destroy_video_buffer;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = false;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, device_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        ret = false;        server_stop(&server);        goto finally_destroy_recorder;    }    if (display) {        if (control) {            if (!controller_init(&controller, device_socket)) {                ret = false;                goto finally_stop_stream;            }            if (!controller_start(&controller)) {                ret = false;                goto finally_destroy_controller;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            ret = false;            goto finally_stop_and_join_controller;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(display, control);    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    if (display && control) {        controller_stop(&controller);        controller_join(&controller);    }finally_destroy_controller:    if (display && control) {        controller_destroy(&controller);    }finally_stop_stream:    stream_stop(&stream);    // stop the server before stream_join() to wake up the stream    server_stop(&server);    stream_join(&stream);finally_destroy_recorder:    if (record) {        recorder_destroy(&recorder);    }finally_destroy_file_handler:    if (display && control) {        file_handler_stop(&file_handler);        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }finally_destroy_video_buffer:    if (display) {        video_buffer_destroy(&video_buffer);    }finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial,                                                     false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
handle_event(SDL_Event *event, bool control) {    switch (event->type) {        case EVENT_STREAM_STOPPED:            LOGD("Video stream stopped");            return EVENT_RESULT_STOPPED_BY_EOS;        case SDL_QUIT:            LOGD("User requested to quit");            return EVENT_RESULT_STOPPED_BY_USER;        case EVENT_NEW_FRAME:            if (!screen.has_frame) {                screen.has_frame = true;                // this is the very first frame, show the window                screen_show_window(&screen);            }            if (!screen_update_frame(&screen, &video_buffer)) {                return false;            }            break;        case SDL_WINDOWEVENT:            switch (event->window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;            }            break;        case SDL_TEXTINPUT:            if (!control) {                break;            }            input_manager_process_text_input(&input_manager, &event->text);            break;        case SDL_KEYDOWN:        case SDL_KEYUP:            // some key events do not interact with the device, so process the            // event even if control is disabled            input_manager_process_key(&input_manager, &event->key, control);            break;        case SDL_MOUSEMOTION:            if (!control) {                break;            }            input_manager_process_mouse_motion(&input_manager, &event->motion);            break;        case SDL_MOUSEWHEEL:            if (!control) {                break;            }            input_manager_process_mouse_wheel(&input_manager, &event->wheel);            break;        case SDL_MOUSEBUTTONDOWN:        case SDL_MOUSEBUTTONUP:            // some mouse events do not interact with the device, so process            // the event even if control is disabled            input_manager_process_mouse_button(&input_manager, &event->button,                                               control);            break;        case SDL_DROPFILE: {            if (!control) {                break;            }            file_handler_action_t action;            if (is_apk(event->drop.file)) {                action = ACTION_INSTALL_APK;            } else {                action = ACTION_PUSH_FILE;            }            file_handler_request(&file_handler, action, event->drop.file);            break;        }    }    return EVENT_RESULT_CONTINUE;}
convert_mouse_buttons(uint32_t state) {    enum android_motionevent_buttons buttons = 0;    if (state & SDL_BUTTON_LMASK) {        buttons |= AMOTION_EVENT_BUTTON_PRIMARY;    }    if (state & SDL_BUTTON_RMASK) {        buttons |= AMOTION_EVENT_BUTTON_SECONDARY;    }    if (state & SDL_BUTTON_MMASK) {        buttons |= AMOTION_EVENT_BUTTON_TERTIARY;    }    if (state & SDL_BUTTON_X1) {        buttons |= AMOTION_EVENT_BUTTON_BACK;    }    if (state & SDL_BUTTON_X2) {        buttons |= AMOTION_EVENT_BUTTON_FORWARD;    }    return buttons;}
convert_mouse_buttons(uint32_t state) {    enum android_motionevent_buttons buttons = 0;    if (state & SDL_BUTTON_LMASK) {        buttons |= AMOTION_EVENT_BUTTON_PRIMARY;    }    if (state & SDL_BUTTON_RMASK) {        buttons |= AMOTION_EVENT_BUTTON_SECONDARY;    }    if (state & SDL_BUTTON_MMASK) {        buttons |= AMOTION_EVENT_BUTTON_TERTIARY;    }    if (state & SDL_BUTTON_X1MASK) {        buttons |= AMOTION_EVENT_BUTTON_BACK;    }    if (state & SDL_BUTTON_X2MASK) {        buttons |= AMOTION_EVENT_BUTTON_FORWARD;    }    return buttons;}
void screen_destroy(struct screen *screen) {    if (screen->texture) {        SDL_DestroyTexture(screen->texture);    }    if (screen->renderer) {        // FIXME it may crash at exit if we destroy the renderer or the window,        // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.        // As a workaround, leak the renderer and the window (we are exiting anyway).        //SDL_DestroyRenderer(screen->renderer);    }    if (screen->window) {        //SDL_DestroyWindow(screen->window);        // at least we hide it        SDL_HideWindow(screen->window);    }}
SDL_bool sdl_init_and_configure(void) {    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        return SDL_FALSE;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }#if SDL_VERSION_ATLEAST(2, 0, 5)    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable mouse focus clickthrough");    }#endif    return SDL_TRUE;}
void screen_destroy(struct screen *screen) {    if (screen->texture) {        SDL_DestroyTexture(screen->texture);    }    if (screen->renderer) {        SDL_DestroyRenderer(screen->renderer);    }    if (screen->window) {        SDL_DestroyWindow(screen->window);    }}
SDL_bool sdl_init_and_configure(void) {    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        return SDL_FALSE;    }    atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }#if SDL_VERSION_ATLEAST(2, 0, 5)    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable mouse focus clickthrough");    }#endif    return SDL_TRUE;}
static int run_controller(void *data) {    struct controller *controller = data;    for (;;) {        mutex_lock(controller->mutex);        while (!controller->stopped && control_event_queue_is_empty(&controller->queue)) {            cond_wait(controller->event_cond, controller->mutex);        }        if (controller->stopped) {            // stop immediately, do not process further events            mutex_unlock(controller->mutex);            break;        }        struct control_event event;#ifdef BUILD_DEBUG        SDL_bool non_empty = control_event_queue_take(&controller->queue, &event);        SDL_assert(non_empty);#else        control_event_queue_take(&controller->queue, &event);#endif        mutex_unlock(controller->mutex);        SDL_bool ok = process_event(controller, &event);        control_event_destroy(&event);        if (!ok) {            LOGD("Cannot write event to socket");            break;        }    }    return 0;}
static int run_controller(void *data) {    struct controller *controller = data;    for (;;) {        mutex_lock(controller->mutex);        while (!controller->stopped && control_event_queue_is_empty(&controller->queue)) {            cond_wait(controller->event_cond, controller->mutex);        }        if (controller->stopped) {            // stop immediately, do not process further events            mutex_unlock(controller->mutex);            break;        }        struct control_event event;        SDL_bool non_empty = control_event_queue_take(&controller->queue, &event);        SDL_assert(non_empty);        mutex_unlock(controller->mutex);        SDL_bool ok = process_event(controller, &event);        control_event_destroy(&event);        if (!ok) {            LOGD("Cannot write event to socket");            break;        }    }    return 0;}SDL_bool controller_start(struct controller *controller) {    LOGD("Starting controller thread");    controller->thread = SDL_CreateThread(run_controller, "controller", controller);
static int run_file_handler(void *data) {    struct file_handler *file_handler = data;    for (;;) {        mutex_lock(file_handler->mutex);        file_handler->current_process = PROCESS_NONE;        while (!file_handler->stopped && request_queue_is_empty(&file_handler->queue)) {            cond_wait(file_handler->event_cond, file_handler->mutex);        }        if (file_handler->stopped) {            // stop immediately, do not process further events            mutex_unlock(file_handler->mutex);            break;        }        struct request *req;#ifdef BUILD_DEBUG        SDL_bool non_empty = request_queue_take(&file_handler->queue, &req);        SDL_assert(non_empty);#else        request_queue_take(&file_handler->queue, &req);#endif        process_t process;        if (req->action == ACTION_INSTALL_APK) {            LOGI("Installing %s...", req->file);            process = install_apk(file_handler->serial, req->file);        } else {            LOGI("Pushing %s...", req->file);            process = push_file(file_handler->serial, req->file);        }        file_handler->current_process = process;        mutex_unlock(file_handler->mutex);        if (req->action == ACTION_INSTALL_APK) {            if (process_check_success(process, "adb install")) {                LOGI("%s successfully installed", req->file);            } else {                LOGE("Failed to install %s", req->file);            }        } else {            if (process_check_success(process, "adb push")) {                LOGI("%s successfully pushed to /sdcard/", req->file);            } else {                LOGE("Failed to push %s to /sdcard/", req->file);            }        }        request_free(req);    }    return 0;}
static int run_file_handler(void *data) {    struct file_handler *file_handler = data;    for (;;) {        mutex_lock(file_handler->mutex);        file_handler->current_process = PROCESS_NONE;        while (!file_handler->stopped && request_queue_is_empty(&file_handler->queue)) {            cond_wait(file_handler->event_cond, file_handler->mutex);        }        if (file_handler->stopped) {            // stop immediately, do not process further events            mutex_unlock(file_handler->mutex);            break;        }        struct request *req;        SDL_bool non_empty = request_queue_take(&file_handler->queue, &req);        SDL_assert(non_empty);        process_t process;        if (req->action == ACTION_INSTALL_APK) {            LOGI("Installing %s...", req->file);            process = install_apk(file_handler->serial, req->file);        } else {            LOGI("Pushing %s...", req->file);            process = push_file(file_handler->serial, req->file);        }        file_handler->current_process = process;        mutex_unlock(file_handler->mutex);        if (req->action == ACTION_INSTALL_APK) {            if (process_check_success(process, "adb install")) {                LOGI("%s successfully installed", req->file);            } else {                LOGE("Failed to install %s", req->file);            }        } else {            if (process_check_success(process, "adb push")) {                LOGI("%s successfully pushed to /sdcard/", req->file);            } else {                LOGE("Failed to push %s to /sdcard/", req->file);            }        }        request_free(req);    }    return 0;}
push_frame(struct decoder *decoder) {    bool previous_frame_consumed =            video_buffer_offer_decoded_frame(decoder->video_buffer);    if (!previous_frame_consumed) {        // the previous EVENT_NEW_FRAME will consume this frame        return;    }    static SDL_Event new_frame_event = {        .type = EVENT_NEW_FRAME,    };    SDL_PushEvent(&new_frame_event);}
push_frame(struct decoder *decoder) {    bool previous_frame_skipped;    video_buffer_offer_decoded_frame(decoder->video_buffer,                                     &previous_frame_skipped);    if (previous_frame_skipped) {        // the previous EVENT_NEW_FRAME will consume this frame        return;    }    static SDL_Event new_frame_event = {        .type = EVENT_NEW_FRAME,    };    SDL_PushEvent(&new_frame_event);}
video_buffer_offer_decoded_frame(struct video_buffer *vb) {    mutex_lock(vb->mutex);#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then the decoder must wait for the current    // frame to be consumed    while (!vb->rendering_frame_consumed && !vb->interrupted) {        cond_wait(vb->rendering_frame_consumed_cond, vb->mutex);    }#else    if (vb->fps_counter.started && !vb->rendering_frame_consumed) {        fps_counter_add_skipped_frame(&vb->fps_counter);    }#endif    video_buffer_swap_frames(vb);    bool previous_frame_consumed = vb->rendering_frame_consumed;    vb->rendering_frame_consumed = false;    mutex_unlock(vb->mutex);    return previous_frame_consumed;}
video_buffer_offer_decoded_frame(struct video_buffer *vb) {    mutex_lock(vb->mutex);#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then the decoder must wait for the current    // frame to be consumed    while (!vb->rendering_frame_consumed && !vb->interrupted) {        cond_wait(vb->rendering_frame_consumed_cond, vb->mutex);    }#else    if (vb->fps_counter.started && !vb->rendering_frame_consumed) {        fps_counter_add_skipped_frame(&vb->fps_counter);    }#endif    video_buffer_swap_frames(vb);    bool previous_frame_consumed = vb->rendering_frame_consumed;    vb->rendering_frame_consumed = false;    mutex_unlock(vb->mutex);    return previous_frame_consumed;}
video_buffer_offer_decoded_frame(struct video_buffer *vb,                                 bool *previous_frame_skipped) {    mutex_lock(vb->mutex);#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then the decoder must wait for the current    // frame to be consumed    while (!vb->rendering_frame_consumed && !vb->interrupted) {        cond_wait(vb->rendering_frame_consumed_cond, vb->mutex);    }#else    if (vb->fps_counter.started && !vb->rendering_frame_consumed) {        fps_counter_add_skipped_frame(&vb->fps_counter);    }#endif    video_buffer_swap_frames(vb);    *previous_frame_skipped = !vb->rendering_frame_consumed;    vb->rendering_frame_consumed = false;    mutex_unlock(vb->mutex);}
video_buffer_offer_decoded_frame(struct video_buffer *vb,                                 bool *previous_frame_skipped) {    mutex_lock(vb->mutex);#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then the decoder must wait for the current    // frame to be consumed    while (!vb->rendering_frame_consumed && !vb->interrupted) {        cond_wait(vb->rendering_frame_consumed_cond, vb->mutex);    }#else    if (vb->fps_counter.started && !vb->rendering_frame_consumed) {        fps_counter_add_skipped_frame(&vb->fps_counter);    }#endif    video_buffer_swap_frames(vb);    *previous_frame_skipped = !vb->rendering_frame_consumed;    vb->rendering_frame_consumed = false;    mutex_unlock(vb->mutex);}
enum process_result cmd_execute(const char *path, const char *const argv[], HANDLE *handle) {    STARTUPINFO si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    // Windows command-line parsing is WTF:    // <http://daviddeley.com/autohotkey/parameters/parameters.htm#WINPASS>    // only make it work for this very specific program    // (don't handle escaping nor quotes)    char cmd[256];    size_t ret = xstrjoin(cmd, argv, ' ', sizeof(cmd));    if (ret >= sizeof(cmd)) {        LOGE("Command too long (%" PRIsizet " chars)", sizeof(cmd) - 1);        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, flags, NULL, NULL, &si, &pi)) {        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }    *handle = pi.hProcess;    return PROCESS_SUCCESS;}
enum process_result cmd_execute(const char *path, const char *const argv[], HANDLE *handle) {    STARTUPINFO si;    PROCESS_INFORMATION pi;    memset(&si, 0, sizeof(si));    si.cb = sizeof(si);    // Windows command-line parsing is WTF:    // <http://daviddeley.com/autohotkey/parameters/parameters.htm#WINPASS>    // only make it work for this very specific program    // (don't handle escaping nor quotes)    char cmd[256];    size_t ret = xstrjoin(cmd, argv, ' ', sizeof(cmd));    if (ret >= sizeof(cmd)) {        LOGE("Command too long (%" PRIsizet " chars)", sizeof(cmd) - 1);        *handle = NULL;        return PROCESS_ERROR_GENERIC;    }#ifdef WINDOWS_NOCONSOLE    int flags = CREATE_NO_WINDOW;#else    int flags = 0;#endif    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, flags, NULL, NULL, &si, &pi)) {        *handle = NULL;        if (GetLastError() == ERROR_FILE_NOT_FOUND) {            return PROCESS_ERROR_MISSING_BINARY;        }        return PROCESS_ERROR_GENERIC;    }    *handle = pi.hProcess;    return PROCESS_SUCCESS;}
run_stream(void *data) {    struct stream *stream = data;    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto end;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto finally_free_format_ctx;    }    // initialize the receiver state    stream->receiver_state.frame_meta_queue = NULL;    stream->receiver_state.remaining = 0;    // if recording is enabled, a "header" is sent between raw packets    int (*read_packet)(void *, uint8_t *, int) =            stream->recorder ? read_packet_with_meta : read_raw_packet;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, stream,                                               read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto finally_free_avio_ctx;    }    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto end;    }    if (stream->decoder && !decoder_open(stream->decoder, codec)) {        LOGE("Could not open decoder");        goto finally_close_input;    }    if (stream->recorder && !recorder_open(stream->recorder, codec)) {        LOGE("Could not open recorder");        goto finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {        if (stream->decoder && !decoder_push(stream->decoder, &packet)) {            av_packet_unref(&packet);            goto quit;        }        if (stream->recorder) {            // we retrieve the PTS in order they were received, so they will            // be assigned to the correct frame            uint64_t pts = receiver_state_take_meta(&stream->receiver_state);            packet.pts = pts;            packet.dts = pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(stream->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");quit:    if (stream->recorder) {        recorder_close(stream->recorder);    }finally_close_input:    avformat_close_input(&format_ctx);finally_free_avio_ctx:    av_free(avio_ctx->buffer);    av_free(avio_ctx);finally_free_format_ctx:    avformat_free_context(format_ctx);end:    notify_stopped();    return 0;}
stream_stop(struct stream *stream) {    if (stream->decoder) {        decoder_interrupt(stream->decoder);    }}
stream_init(struct stream *stream, socket_t socket,            struct decoder *decoder, struct recorder *recorder) {    stream->socket = socket;    stream->decoder = decoder,    stream->recorder = recorder;}
run_stream(void *data) {    struct stream *stream = data;    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto end;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto finally_free_format_ctx;    }    // initialize the receiver state    stream->receiver_state.frame_meta_queue = NULL;    stream->receiver_state.remaining = 0;    // if recording is enabled, a "header" is sent between raw packets    int (*read_packet)(void *, uint8_t *, int) =            stream->recorder ? read_packet_with_meta : read_raw_packet;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, stream,                                               read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto finally_free_avio_ctx;    }    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto end;    }    if (stream->decoder && !decoder_open(stream->decoder, codec)) {        LOGE("Could not open decoder");        goto finally_close_input;    }    if (stream->recorder && !recorder_open(stream->recorder, codec)) {        LOGE("Could not open recorder");        goto finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {        if (SDL_AtomicGet(&stream->stopped)) {            // if the stream is stopped, the socket had been shutdown, so the            // last packet is probably corrupted (but not detected as such by            // FFmpeg) and will not be decoded correctly            av_packet_unref(&packet);            goto quit;        }        if (stream->decoder && !decoder_push(stream->decoder, &packet)) {            av_packet_unref(&packet);            goto quit;        }        if (stream->recorder) {            // we retrieve the PTS in order they were received, so they will            // be assigned to the correct frame            uint64_t pts = receiver_state_take_meta(&stream->receiver_state);            packet.pts = pts;            packet.dts = pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(stream->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");quit:    if (stream->recorder) {        recorder_close(stream->recorder);    }finally_close_input:    avformat_close_input(&format_ctx);finally_free_avio_ctx:    av_free(avio_ctx->buffer);    av_free(avio_ctx);finally_free_format_ctx:    avformat_free_context(format_ctx);end:    notify_stopped();    return 0;}
stream_stop(struct stream *stream) {    SDL_AtomicSet(&stream->stopped, 1);    if (stream->decoder) {        decoder_interrupt(stream->decoder);    }}
stream_init(struct stream *stream, socket_t socket,            struct decoder *decoder, struct recorder *recorder) {    stream->socket = socket;    stream->decoder = decoder,    stream->recorder = recorder;    SDL_AtomicSet(&stream->stopped, 0);}
SDL_bool screen_init_rendering(struct screen *screen, const char *device_name, struct size frame_size) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height, SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1, SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width, frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    screen->texture = SDL_CreateTexture(screen->renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                                        frame_size.width, frame_size.height);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    return SDL_TRUE;}
SDL_bool screen_init_rendering(struct screen *screen, const char *device_name, struct size frame_size) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height,                                      SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1, SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width, frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        LOGE("Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    screen->texture = SDL_CreateTexture(screen->renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                                        frame_size.width, frame_size.height);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    return SDL_TRUE;}
static SDL_bool handle_new_frame(void) {    mutex_lock(frames.mutex);    AVFrame *frame = frames.rendering_frame;    frames.rendering_frame_consumed = SDL_TRUE;#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then notify the decoder the current frame is    // consumed, so that it may push a new one    cond_signal(frames.rendering_frame_consumed_cond);#endif    if (!screen_update(&screen, frame)){        return SDL_FALSE;    }    mutex_unlock(frames.mutex);    screen_render(&screen);    return SDL_TRUE;}
static SDL_bool handle_new_frame(void) {    mutex_lock(frames.mutex);    AVFrame *frame = frames.rendering_frame;    frames.rendering_frame_consumed = SDL_TRUE;#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then notify the decoder the current frame is    // consumed, so that it may push a new one    cond_signal(frames.rendering_frame_consumed_cond);#endif    if (!screen_update(&screen, frame)){        mutex_unlock(frames.mutex);        return SDL_FALSE;    }    mutex_unlock(frames.mutex);    screen_render(&screen);    return SDL_TRUE;}
    public EventController(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;        inputManager = device.getInputManager();        powerManager = device.getPowerManager();        initPointer();    }
    public EventController(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;        inputManager = device.getInputManager();        powerManager = device.getPowerManager();        initPointer();        // on start, turn screen on        turnScreenOn();    }
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, 'T'},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, 'c'},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, 'f'},        {"render-expired-frames", no_argument,       NULL,                                                 OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"version",               no_argument,       NULL, 'v'},        {NULL,                    0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return false;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = true;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return false;                }                break;            case 'n':                args->no_control = true;                break;            case 'N':                args->no_display = true;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return false;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 'S':                args->turn_screen_off = true;                break;            case 't':                args->show_touches = true;                break;            case 'T':                args->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                args->render_expired_frames = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (args->no_display && !args->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (args->no_display && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return false;        }    }    return true;}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, 'T'},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, 'c'},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, 'f'},        {"render-expired-frames", no_argument,       NULL,                                                 OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"version",               no_argument,       NULL, 'v'},        {NULL,                    0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return false;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = true;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return false;                }                break;            case 'n':                args->no_control = true;                break;            case 'N':                args->no_display = true;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return false;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 'S':                args->turn_screen_off = true;                break;            case 't':                args->show_touches = true;                break;            case 'T':                args->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                args->render_expired_frames = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (args->no_display && !args->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (args->no_display && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return false;        }    }    if (args->no_control && args->turn_screen_off) {        LOGE("Cannot request to turn screen off if control is disabled");        return false;    }    return true;}
decoder_push(struct decoder *decoder, AVPacket *packet) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#ifdef SCRCPY_LAVF_HAS_NEW_ENCODING_DECODING_API    int ret;    if ((ret = avcodec_send_packet(decoder->codec_ctx, packet)) < 0) {        LOGE("Could not send video packet: %d", ret);        return false;    }    ret = avcodec_receive_frame(decoder->codec_ctx,                                decoder->video_buffer->decoding_frame);    if (!ret) {        // a frame was received        push_frame(decoder);    } else if (ret != AVERROR(EAGAIN)) {        LOGE("Could not receive video frame: %d", ret);        return false;    }#else    int got_picture;    int len = avcodec_decode_video2(decoder->codec_ctx,                                    decoder->video_buffer->decoding_frame,                                    &got_picture,                                    packet);    if (len < 0) {        LOGE("Could not decode video packet: %d", len);        return false;    }    if (got_picture) {        push_frame(decoder);    }#endif    return true;}
decoder_open(struct decoder *decoder, AVCodec *codec) {    decoder->codec_ctx = avcodec_alloc_context3(codec);    if (!decoder->codec_ctx) {        LOGC("Could not allocate decoder context");        return false;    }    if (avcodec_open2(decoder->codec_ctx, codec, NULL) < 0) {        LOGE("Could not open codec");        avcodec_free_context(&decoder->codec_ctx);        return false;    }    return true;}
decoder_open(struct decoder *decoder, AVCodec *codec) {    decoder->codec_ctx = avcodec_alloc_context3(codec);    if (!decoder->codec_ctx) {        LOGC("Could not allocate decoder context");        return false;    }    if (avcodec_open2(decoder->codec_ctx, codec, NULL) < 0) {        LOGE("Could not open codec");        avcodec_free_context(&decoder->codec_ctx);        return false;    }    return true;}
decoder_push(struct decoder *decoder, AVPacket *packet) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#ifdef SCRCPY_LAVF_HAS_NEW_ENCODING_DECODING_API    int ret;    if ((ret = avcodec_send_packet(decoder->codec_ctx, packet)) < 0) {        LOGE("Could not send video packet: %d", ret);        return false;    }    ret = avcodec_receive_frame(decoder->codec_ctx,                                decoder->video_buffer->decoding_frame);    if (!ret) {        // a frame was received        push_frame(decoder);    } else if (ret != AVERROR(EAGAIN)) {        LOGE("Could not receive video frame: %d", ret);        return false;    }#else    int got_picture;    int len = avcodec_decode_video2(decoder->codec_ctx,                                    decoder->video_buffer->decoding_frame,                                    &got_picture,                                    packet);    if (len < 0) {        LOGE("Could not decode video packet: %d", len);        return false;    }    if (got_picture) {        push_frame(decoder);    }#endif    return true;}
decoder_push(struct decoder *decoder, const AVPacket *packet) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#ifdef SCRCPY_LAVF_HAS_NEW_ENCODING_DECODING_API    int ret;    if ((ret = avcodec_send_packet(decoder->codec_ctx, packet)) < 0) {        LOGE("Could not send video packet: %d", ret);        return false;    }    ret = avcodec_receive_frame(decoder->codec_ctx,                                decoder->video_buffer->decoding_frame);    if (!ret) {        // a frame was received        push_frame(decoder);    } else if (ret != AVERROR(EAGAIN)) {        LOGE("Could not receive video frame: %d", ret);        return false;    }#else    int got_picture;    int len = avcodec_decode_video2(decoder->codec_ctx,                                    decoder->video_buffer->decoding_frame,                                    &got_picture,                                    packet);    if (len < 0) {        LOGE("Could not decode video packet: %d", len);        return false;    }    if (got_picture) {        push_frame(decoder);    }#endif    return true;}
decoder_open(struct decoder *decoder, const AVCodec *codec) {    decoder->codec_ctx = avcodec_alloc_context3(codec);    if (!decoder->codec_ctx) {        LOGC("Could not allocate decoder context");        return false;    }    if (avcodec_open2(decoder->codec_ctx, codec, NULL) < 0) {        LOGE("Could not open codec");        avcodec_free_context(&decoder->codec_ctx);        return false;    }    return true;}
decoder_open(struct decoder *decoder, const AVCodec *codec) {    decoder->codec_ctx = avcodec_alloc_context3(codec);    if (!decoder->codec_ctx) {        LOGC("Could not allocate decoder context");        return false;    }    if (avcodec_open2(decoder->codec_ctx, codec, NULL) < 0) {        LOGE("Could not open codec");        avcodec_free_context(&decoder->codec_ctx);        return false;    }    return true;}
decoder_push(struct decoder *decoder, const AVPacket *packet) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#ifdef SCRCPY_LAVF_HAS_NEW_ENCODING_DECODING_API    int ret;    if ((ret = avcodec_send_packet(decoder->codec_ctx, packet)) < 0) {        LOGE("Could not send video packet: %d", ret);        return false;    }    ret = avcodec_receive_frame(decoder->codec_ctx,                                decoder->video_buffer->decoding_frame);    if (!ret) {        // a frame was received        push_frame(decoder);    } else if (ret != AVERROR(EAGAIN)) {        LOGE("Could not receive video frame: %d", ret);        return false;    }#else    int got_picture;    int len = avcodec_decode_video2(decoder->codec_ctx,                                    decoder->video_buffer->decoding_frame,                                    &got_picture,                                    packet);    if (len < 0) {        LOGE("Could not decode video packet: %d", len);        return false;    }    if (got_picture) {        push_frame(decoder);    }#endif    return true;}
recorder_open(struct recorder *recorder, AVCodec *input_codec) {    const char *format_name = recorder_get_format_name(recorder->format);    SDL_assert(format_name);    const AVOutputFormat *format = find_muxer(format_name);    if (!format) {        LOGE("Could not find muxer");        return false;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return false;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) format;    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return false;    }#ifdef SCRCPY_LAVF_HAS_NEW_CODEC_PARAMS_API    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return false;    }    LOGI("Recording started to %s file: %s", format_name, recorder->filename);    return true;}
recorder_write_header(struct recorder *recorder, AVPacket *packet) {    AVStream *ostream = recorder->ctx->streams[0];    uint8_t *extradata = av_malloc(packet->size * sizeof(uint8_t));    if (!extradata) {        LOGC("Cannot allocate extradata");        return false;    }    // copy the first packet to the extra data    memcpy(extradata, packet->data, packet->size);#ifdef SCRCPY_LAVF_HAS_NEW_CODEC_PARAMS_API    ostream->codecpar->extradata = extradata;    ostream->codecpar->extradata_size = packet->size;#else    ostream->codec->extradata = extradata;    ostream->codec->extradata_size = packet->size;#endif    int ret = avformat_write_header(recorder->ctx, NULL);    if (ret < 0) {        LOGE("Failed to write header to %s", recorder->filename);        SDL_free(extradata);        avio_closep(&recorder->ctx->pb);        avformat_free_context(recorder->ctx);        return false;    }    return true;}
recorder_write_header(struct recorder *recorder, AVPacket *packet) {    AVStream *ostream = recorder->ctx->streams[0];    uint8_t *extradata = av_malloc(packet->size * sizeof(uint8_t));    if (!extradata) {        LOGC("Cannot allocate extradata");        return false;    }    // copy the first packet to the extra data    memcpy(extradata, packet->data, packet->size);#ifdef SCRCPY_LAVF_HAS_NEW_CODEC_PARAMS_API    ostream->codecpar->extradata = extradata;    ostream->codecpar->extradata_size = packet->size;#else    ostream->codec->extradata = extradata;    ostream->codec->extradata_size = packet->size;#endif    int ret = avformat_write_header(recorder->ctx, NULL);    if (ret < 0) {        LOGE("Failed to write header to %s", recorder->filename);        SDL_free(extradata);        avio_closep(&recorder->ctx->pb);        avformat_free_context(recorder->ctx);        return false;    }    return true;}
recorder_open(struct recorder *recorder, AVCodec *input_codec) {    const char *format_name = recorder_get_format_name(recorder->format);    SDL_assert(format_name);    const AVOutputFormat *format = find_muxer(format_name);    if (!format) {        LOGE("Could not find muxer");        return false;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return false;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) format;    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return false;    }#ifdef SCRCPY_LAVF_HAS_NEW_CODEC_PARAMS_API    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return false;    }    LOGI("Recording started to %s file: %s", format_name, recorder->filename);    return true;}
recorder_open(struct recorder *recorder, const AVCodec *input_codec) {    const char *format_name = recorder_get_format_name(recorder->format);    SDL_assert(format_name);    const AVOutputFormat *format = find_muxer(format_name);    if (!format) {        LOGE("Could not find muxer");        return false;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return false;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) format;    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return false;    }#ifdef SCRCPY_LAVF_HAS_NEW_CODEC_PARAMS_API    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return false;    }    LOGI("Recording started to %s file: %s", format_name, recorder->filename);    return true;}
recorder_write_header(struct recorder *recorder, const AVPacket *packet) {    AVStream *ostream = recorder->ctx->streams[0];    uint8_t *extradata = av_malloc(packet->size * sizeof(uint8_t));    if (!extradata) {        LOGC("Cannot allocate extradata");        return false;    }    // copy the first packet to the extra data    memcpy(extradata, packet->data, packet->size);#ifdef SCRCPY_LAVF_HAS_NEW_CODEC_PARAMS_API    ostream->codecpar->extradata = extradata;    ostream->codecpar->extradata_size = packet->size;#else    ostream->codec->extradata = extradata;    ostream->codec->extradata_size = packet->size;#endif    int ret = avformat_write_header(recorder->ctx, NULL);    if (ret < 0) {        LOGE("Failed to write header to %s", recorder->filename);        SDL_free(extradata);        avio_closep(&recorder->ctx->pb);        avformat_free_context(recorder->ctx);        return false;    }    return true;}
recorder_write_header(struct recorder *recorder, const AVPacket *packet) {    AVStream *ostream = recorder->ctx->streams[0];    uint8_t *extradata = av_malloc(packet->size * sizeof(uint8_t));    if (!extradata) {        LOGC("Cannot allocate extradata");        return false;    }    // copy the first packet to the extra data    memcpy(extradata, packet->data, packet->size);#ifdef SCRCPY_LAVF_HAS_NEW_CODEC_PARAMS_API    ostream->codecpar->extradata = extradata;    ostream->codecpar->extradata_size = packet->size;#else    ostream->codec->extradata = extradata;    ostream->codec->extradata_size = packet->size;#endif    int ret = avformat_write_header(recorder->ctx, NULL);    if (ret < 0) {        LOGE("Failed to write header to %s", recorder->filename);        SDL_free(extradata);        avio_closep(&recorder->ctx->pb);        avformat_free_context(recorder->ctx);        return false;    }    return true;}
recorder_open(struct recorder *recorder, const AVCodec *input_codec) {    const char *format_name = recorder_get_format_name(recorder->format);    SDL_assert(format_name);    const AVOutputFormat *format = find_muxer(format_name);    if (!format) {        LOGE("Could not find muxer");        return false;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return false;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) format;    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return false;    }#ifdef SCRCPY_LAVF_HAS_NEW_CODEC_PARAMS_API    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return false;    }    LOGI("Recording started to %s file: %s", format_name, recorder->filename);    return true;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet) && !avio_ctx->eof_reached) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        av_packet_unref(&packet);    }    LOGD("End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {        if (avio_ctx->eof_reached) {            av_packet_unref(&packet);            goto run_quit;        }// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        av_packet_unref(&packet);    }    LOGD("End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
int show_screen(const char *serial, Uint16 local_port) {    int ret = 0;    const char *server_jar_path = getenv("SCRCPY_SERVER_JAR");    if (!server_jar_path) {        server_jar_path = "scrcpy-server.jar";    }    process_t push_proc = adb_push(serial, server_jar_path, "/data/local/tmp/");    if (wait_for_success(push_proc, "adb push")) {        return -1;    }    process_t reverse_tunnel_proc = adb_reverse(serial, SOCKET_NAME, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return -1;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = -1;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = -1;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_size(device_socket, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = -1;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (frames_init(&frames)) {        ret = -1;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the width and height values, the socket receives the video stream    // start the decoder    if (decoder_start(&decoder)) {        ret = -1;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = -1;        goto screen_finally_stop_decoder;    }    atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    SDL_Window *window = SDL_CreateWindow("scrcpy", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = -1;        goto screen_finally_stop_decoder;    }    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = -1;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = -1;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    SDL_Texture *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = -1;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    long ts = timestamp_ms();    int nbframes = 0;    SDL_bool texture_empty = SDL_TRUE;    SDL_bool fullscreen = SDL_FALSE;    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            goto screen_quit;        case EVENT_NEW_FRAME:            lock_mutex(frames.mutex);            AVFrame *frame = frames.rendering_frame;            frames.rendering_frame_consumed = SDL_TRUE;            if (!decoder.skip_frames) {                SDL_CondSignal(frames.rendering_frame_consumed_cond);            }            struct size current_frame_size = {frame->width, frame->height};            if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {                goto screen_quit;            }            frame_size = current_frame_size;            update_texture(frame, texture);            unlock_mutex(frames.mutex);            texture_empty = SDL_FALSE;            long now = timestamp_ms();            ++nbframes;            if (now - ts > 1000) {                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "%d fps", nbframes);                ts = now;                nbframes = 0;            }            render(renderer, texture);            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_KEYDOWN: {            SDL_bool ctrl = SDL_GetModState() & (KMOD_LCTRL | KMOD_RCTRL);            SDL_bool shift = SDL_GetModState() & (KMOD_LSHIFT | KMOD_RSHIFT);            SDL_bool repeat = event.key.repeat;            switch (event.key.keysym.sym) {            case SDLK_x:                if (!repeat && ctrl && !shift) {                    // Ctrl+x                    struct size optimal_size = get_optimal_window_size(window, frame_size);                    SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                }                break;            case SDLK_f:                if (!repeat && ctrl && !shift) {                    // Ctrl+f                    Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;                    if (!SDL_SetWindowFullscreen(window, new_mode)) {                        fullscreen = !fullscreen;                        render(renderer, texture_empty ? NULL : texture);                    } else {                        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());                    }                }                break;            }            break;        }        }    }screen_quit:    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = adb_reverse_remove(serial, SOCKET_NAME);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool read_initial_device_size(TCPsocket socket, struct size *size) {    unsigned char buf[4];    if (SDLNet_TCP_Recv(socket, buf, sizeof(buf)) <= 0) {        return SDL_FALSE;    }    size->width = (buf[0] << 8) | buf[1];    size->height = (buf[2] << 8) | buf[3];    return SDL_TRUE;}
SDL_bool read_initial_device_size(TCPsocket socket, struct size *size) {    unsigned char buf[4];    if (SDLNet_TCP_Recv(socket, buf, sizeof(buf)) <= 0) {        return SDL_FALSE;    }    size->width = (buf[0] << 8) | buf[1];    size->height = (buf[2] << 8) | buf[3];    return SDL_TRUE;}
int show_screen(const char *serial, Uint16 local_port) {    int ret = 0;    const char *server_jar_path = getenv("SCRCPY_SERVER_JAR");    if (!server_jar_path) {        server_jar_path = "scrcpy-server.jar";    }    process_t push_proc = adb_push(serial, server_jar_path, "/data/local/tmp/");    if (wait_for_success(push_proc, "adb push")) {        return -1;    }    process_t reverse_tunnel_proc = adb_reverse(serial, SOCKET_NAME, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return -1;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = -1;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = -1;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    struct size frame_size;    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = -1;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (frames_init(&frames)) {        ret = -1;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the width and height values, the socket receives the video stream    // start the decoder    if (decoder_start(&decoder)) {        ret = -1;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = -1;        goto screen_finally_stop_decoder;    }    atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    SDL_Window *window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = -1;        goto screen_finally_stop_decoder;    }    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = -1;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = -1;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    SDL_Texture *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = -1;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    long ts = timestamp_ms();    int nbframes = 0;    SDL_bool texture_empty = SDL_TRUE;    SDL_bool fullscreen = SDL_FALSE;    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {        case EVENT_DECODER_STOPPED:            SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Video decoder stopped");        case SDL_QUIT:            goto screen_quit;        case EVENT_NEW_FRAME:            lock_mutex(frames.mutex);            AVFrame *frame = frames.rendering_frame;            frames.rendering_frame_consumed = SDL_TRUE;            if (!decoder.skip_frames) {                SDL_CondSignal(frames.rendering_frame_consumed_cond);            }            struct size current_frame_size = {frame->width, frame->height};            if (!prepare_for_frame(window, renderer, &texture, frame_size, current_frame_size)) {                goto screen_quit;            }            frame_size = current_frame_size;            update_texture(frame, texture);            unlock_mutex(frames.mutex);            texture_empty = SDL_FALSE;            long now = timestamp_ms();            ++nbframes;            if (now - ts > 1000) {                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "%d fps", nbframes);                ts = now;                nbframes = 0;            }            render(renderer, texture);            break;        case SDL_WINDOWEVENT:            switch (event.window.event) {            case SDL_WINDOWEVENT_EXPOSED:            case SDL_WINDOWEVENT_SIZE_CHANGED:                render(renderer, texture_empty ? NULL : texture);                break;            }            break;        case SDL_KEYDOWN: {            SDL_bool ctrl = SDL_GetModState() & (KMOD_LCTRL | KMOD_RCTRL);            SDL_bool shift = SDL_GetModState() & (KMOD_LSHIFT | KMOD_RSHIFT);            SDL_bool repeat = event.key.repeat;            switch (event.key.keysym.sym) {            case SDLK_x:                if (!repeat && ctrl && !shift) {                    // Ctrl+x                    struct size optimal_size = get_optimal_window_size(window, frame_size);                    SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                }                break;            case SDLK_f:                if (!repeat && ctrl && !shift) {                    // Ctrl+f                    Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;                    if (!SDL_SetWindowFullscreen(window, new_mode)) {                        fullscreen = !fullscreen;                        render(renderer, texture_empty ? NULL : texture);                    } else {                        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());                    }                }                break;            }            break;        }        }    }screen_quit:    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = adb_reverse_remove(serial, SOCKET_NAME);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
// name must be at least DEVICE_NAME_FIELD_LENGTH bytesSDL_bool read_initial_device_info(TCPsocket socket, char *device_name, struct size *size) {    unsigned char buf[DEVICE_NAME_FIELD_LENGTH + 4];    if (SDLNet_TCP_Recv(socket, buf, sizeof(buf)) <= 0) {        return SDL_FALSE;    }    buf[DEVICE_NAME_FIELD_LENGTH - 1] = '\0'; // in case the client sends garbage    // scrcpy is safe here, since name contains at least DEVICE_NAME_FIELD_LENGTH bytes    // and strlen(buf) < DEVICE_NAME_FIELD_LENGTH
SDL_bool read_initial_device_info(TCPsocket socket, char *device_name, struct size *size) {    unsigned char buf[DEVICE_NAME_FIELD_LENGTH + 4];    if (SDLNet_TCP_Recv(socket, buf, sizeof(buf)) <= 0) {        return SDL_FALSE;    }    buf[DEVICE_NAME_FIELD_LENGTH - 1] = '\0'; // in case the client sends garbage    // scrcpy is safe here, since name contains at least DEVICE_NAME_FIELD_LENGTH bytes    // and strlen(buf) < DEVICE_NAME_FIELD_LENGTH    strcpy(device_name, (char *) buf);    size->width = (buf[DEVICE_NAME_FIELD_LENGTH] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 1];    size->height = (buf[DEVICE_NAME_FIELD_LENGTH + 2] << 8) | buf[DEVICE_NAME_FIELD_LENGTH + 3];    return SDL_TRUE;}
    private static void send(LocalSocket socket, int width, int height) throws IOException {        assert width < 0x10000 : "width may not be stored on 16 bits";        assert height < 0x10000 : "height may not be stored on 16 bits";        byte[] buffer = new byte[4];        buffer[0] = (byte) (width >> 8);        buffer[1] = (byte) width;        buffer[2] = (byte) (height >> 8);        buffer[3] = (byte) height;        socket.getOutputStream().write(buffer, 0, 4);    }
    public static DesktopConnection open(int width, int height) throws IOException {        LocalSocket socket = connect(SOCKET_NAME);        send(socket, width, height);        return new DesktopConnection(socket);    }
    public static DesktopConnection open(int width, int height) throws IOException {        LocalSocket socket = connect(SOCKET_NAME);        send(socket, width, height);        return new DesktopConnection(socket);    }
    private static void send(LocalSocket socket, int width, int height) throws IOException {        assert width < 0x10000 : "width may not be stored on 16 bits";        assert height < 0x10000 : "height may not be stored on 16 bits";        byte[] buffer = new byte[4];        buffer[0] = (byte) (width >> 8);        buffer[1] = (byte) width;        buffer[2] = (byte) (height >> 8);        buffer[3] = (byte) height;        socket.getOutputStream().write(buffer, 0, 4);    }
    private static void send(LocalSocket socket, String deviceName, int width, int height) throws IOException {        assert width < 0x10000 : "width may not be stored on 16 bits";        assert height < 0x10000 : "height may not be stored on 16 bits";        byte[] buffer = new byte[DEVICE_NAME_FIELD_LENGTH + 4];        byte[] deviceNameBytes = deviceName.getBytes(StandardCharsets.UTF_8);        int len = Math.min(DEVICE_NAME_FIELD_LENGTH - 1, deviceNameBytes.length);        System.arraycopy(deviceNameBytes, 0, buffer, 0, len);        // byte[] are always 0-initialized in java, no need to set '\0' explicitly        buffer[DEVICE_NAME_FIELD_LENGTH] = (byte) (width >> 8);        buffer[DEVICE_NAME_FIELD_LENGTH + 1] = (byte) width;        buffer[DEVICE_NAME_FIELD_LENGTH + 2] = (byte) (height >> 8);        buffer[DEVICE_NAME_FIELD_LENGTH + 3] = (byte) height;        socket.getOutputStream().write(buffer, 0, buffer.length);    }
    public static DesktopConnection open(String deviceName, int width, int height) throws IOException {        LocalSocket socket = connect(SOCKET_NAME);        send(socket, deviceName, width, height);        return new DesktopConnection(socket);    }
        return localSocket;    }    public static DesktopConnection open(String deviceName, int width, int height) throws IOException {        LocalSocket socket = connect(SOCKET_NAME);        send(socket, deviceName, width, height);
        socket.close();    }    private static void send(LocalSocket socket, String deviceName, int width, int height) throws IOException {        assert width < 0x10000 : "width may not be stored on 16 bits";        assert height < 0x10000 : "height may not be stored on 16 bits";        byte[] buffer = new byte[DEVICE_NAME_FIELD_LENGTH + 4];        byte[] deviceNameBytes = deviceName.getBytes(StandardCharsets.UTF_8);        int len = Math.min(DEVICE_NAME_FIELD_LENGTH - 1, deviceNameBytes.length);        System.arraycopy(deviceNameBytes, 0, buffer, 0, len);
            } catch (Exception e) {                throw new AssertionError(e);            }        }        public WindowManager getWindowManager() {            return new WindowManager(getService("window", "android.view.IWindowManager"));        }        public DisplayManager getDisplayManager() {            return new DisplayManager(getService("display", "android.hardware.display.IDisplayManager"));
    public static String getDeviceName() {        return Build.MODEL;    }
    public static void scrcpy() throws IOException {        ScreenInfo initialScreenInfo = ScreenUtil.getScreenInfo();        int width = initialScreenInfo.getLogicalWidth();        int height = initialScreenInfo.getLogicalHeight();        try (DesktopConnection connection = DesktopConnection.open(width, height)) {            try {                new ScreenStreamer(connection).streamScreen();            } catch (IOException e) {                System.err.println("Screen streaming interrupted: " + e.getMessage());                System.err.flush();            }        }    }
    public static void scrcpy() throws IOException {        String deviceName = DeviceUtil.getDeviceName();        ScreenInfo initialScreenInfo = DeviceUtil.getScreenInfo();        int width = initialScreenInfo.getLogicalWidth();        int height = initialScreenInfo.getLogicalHeight();        try (DesktopConnection connection = DesktopConnection.open(deviceName, width, height)) {            try {                new ScreenStreamer(connection).streamScreen();            } catch (IOException e) {                System.err.println("Screen streaming interrupted: " + e.getMessage());                System.err.flush();            }        }    }
    public ScreenStreamer(DesktopConnection connection) {        this.connection = connection;        ScreenUtil.registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                reset();            }        });    }
    public ScreenStreamer(DesktopConnection connection) {        this.connection = connection;        DeviceUtil.registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                reset();            }        });    }
        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    struct recorder *rec = NULL;    if (options->record_filename) {        if (!recorder_init(&recorder, options->record_filename, frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    decoder_init(&decoder, &frames, device_socket, rec);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size, options->always_on_top)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_recorder:    if (options->record_filename) {        recorder_destroy(&recorder);    }finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    struct recorder *rec = NULL;    if (options->record_filename) {        if (!recorder_init(&recorder, options->record_filename, frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    decoder_init(&decoder, &frames, device_socket, rec);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size, options->always_on_top)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_recorder:    if (options->record_filename) {        recorder_destroy(&recorder);    }finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    SDL_bool send_frame_meta = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      send_frame_meta)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    struct recorder *rec = NULL;    if (options->record_filename) {        if (!recorder_init(&recorder, options->record_filename, frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    decoder_init(&decoder, &frames, device_socket, rec);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size, options->always_on_top)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_recorder:    if (options->record_filename) {        recorder_destroy(&recorder);    }finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
av_log_callback(void *avcl, int level, const char *fmt, va_list vl) {    SDL_LogPriority priority = sdl_priority_from_av_level(level);    if (priority == 0) {        return;    }    char *local_fmt = SDL_malloc(strlen(fmt) + 10);    if (!local_fmt) {        LOGC("Cannot allocate string");        return;    }    // strcpy is safe here, the destination is large enough    strcpy(local_fmt, "[FFmpeg] ");    strcpy(local_fmt + 9, fmt);    SDL_LogMessageV(SDL_LOG_CATEGORY_VIDEO, priority, local_fmt, vl);    SDL_free(local_fmt);}
static SDL_LogPriority sdl_priority_from_av_level(int level) {    switch (level) {        case AV_LOG_PANIC:        case AV_LOG_FATAL:            return SDL_LOG_PRIORITY_CRITICAL;        case AV_LOG_ERROR:            return SDL_LOG_PRIORITY_ERROR;        case AV_LOG_WARNING:            return SDL_LOG_PRIORITY_WARN;        case AV_LOG_INFO:            return SDL_LOG_PRIORITY_INFO;    }    // do not forward others, which are too verbose    return 0;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    SDL_bool send_frame_meta = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      send_frame_meta)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    struct recorder *rec = NULL;    if (options->record_filename) {        if (!recorder_init(&recorder, options->record_filename, frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    decoder_init(&decoder, &frames, device_socket, rec);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size, options->always_on_top)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_recorder:    if (options->record_filename) {        recorder_destroy(&recorder);    }finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
    public OutputStream getOutputStream() {        return outputStream;    }
    private DesktopConnection(LocalSocket socket) throws IOException {        this.socket = socket;        inputStream = socket.getInputStream();        outputStream = socket.getOutputStream();    }
    private DesktopConnection(LocalSocket socket) throws IOException {        this.socket = socket;        inputStream = socket.getInputStream();        outputStream = socket.getOutputStream();    }
    private void send(String deviceName, int width, int height) throws IOException {        byte[] buffer = new byte[DEVICE_NAME_FIELD_LENGTH + 4];        byte[] deviceNameBytes = deviceName.getBytes(StandardCharsets.UTF_8);        int len = Math.min(DEVICE_NAME_FIELD_LENGTH - 1, deviceNameBytes.length);        System.arraycopy(deviceNameBytes, 0, buffer, 0, len);        // byte[] are always 0-initialized in java, no need to set '\0' explicitly        buffer[DEVICE_NAME_FIELD_LENGTH] = (byte) (width >> 8);        buffer[DEVICE_NAME_FIELD_LENGTH + 1] = (byte) width;        buffer[DEVICE_NAME_FIELD_LENGTH + 2] = (byte) (height >> 8);        buffer[DEVICE_NAME_FIELD_LENGTH + 3] = (byte) height;        outputStream.write(buffer, 0, buffer.length);    }
    public FileDescriptor getFd() {        return fd;    }
    private DesktopConnection(LocalSocket socket) throws IOException {        this.socket = socket;        inputStream = socket.getInputStream();        fd = socket.getFileDescriptor();    }
    public FileDescriptor getFd() {        return fd;    }
    private void send(String deviceName, int width, int height) throws IOException {        byte[] buffer = new byte[DEVICE_NAME_FIELD_LENGTH + 4];        byte[] deviceNameBytes = deviceName.getBytes(StandardCharsets.UTF_8);        int len = Math.min(DEVICE_NAME_FIELD_LENGTH - 1, deviceNameBytes.length);        System.arraycopy(deviceNameBytes, 0, buffer, 0, len);        // byte[] are always 0-initialized in java, no need to set '\0' explicitly        buffer[DEVICE_NAME_FIELD_LENGTH] = (byte) (width >> 8);        buffer[DEVICE_NAME_FIELD_LENGTH + 1] = (byte) width;        buffer[DEVICE_NAME_FIELD_LENGTH + 2] = (byte) (height >> 8);        buffer[DEVICE_NAME_FIELD_LENGTH + 3] = (byte) height;        IO.writeFully(fd, buffer, 0, buffer.length);    }
    private boolean encode(MediaCodec codec, OutputStream outputStream) throws IOException {        @SuppressWarnings("checkstyle:MagicNumber")        byte[] buf = new byte[bitRate / 8]; // may contain up to 1 second of video        boolean eof = false;        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();        while (!consumeRotationChange() && !eof) {            int outputBufferId = codec.dequeueOutputBuffer(bufferInfo, -1);            eof = (bufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;            try {                if (consumeRotationChange()) {                    // must restart encoding with new size                    break;                }                if (outputBufferId >= 0) {                    ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);                    while (outputBuffer.hasRemaining()) {                        int remaining = outputBuffer.remaining();                        int len = Math.min(buf.length, remaining);                        // the outputBuffer is probably direct (it has no underlying array), and LocalSocket does not expose channels,                        // so we must copy the data locally to write them manually to the output stream                        outputBuffer.get(buf, 0, len);                        outputStream.write(buf, 0, len);                    }                }            } finally {                if (outputBufferId >= 0) {                    codec.releaseOutputBuffer(outputBufferId, false);                }            }        }        return !eof;    }
    public void streamScreen(Device device, OutputStream outputStream) throws IOException {        MediaFormat format = createFormat(bitRate, frameRate, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                Rect contentRect = device.getScreenInfo().getContentRect();                Rect videoRect = device.getScreenInfo().getVideoSize().toRect();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, contentRect, videoRect);                codec.start();                try {                    alive = encode(codec, outputStream);                } finally {                    codec.stop();                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    private boolean encode(MediaCodec codec, OutputStream outputStream) throws IOException {        @SuppressWarnings("checkstyle:MagicNumber")        byte[] buf = new byte[bitRate / 8]; // may contain up to 1 second of video        boolean eof = false;        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();        while (!consumeRotationChange() && !eof) {            int outputBufferId = codec.dequeueOutputBuffer(bufferInfo, -1);            eof = (bufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;            try {                if (consumeRotationChange()) {                    // must restart encoding with new size                    break;                }                if (outputBufferId >= 0) {                    ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);                    while (outputBuffer.hasRemaining()) {                        int remaining = outputBuffer.remaining();                        int len = Math.min(buf.length, remaining);                        // the outputBuffer is probably direct (it has no underlying array), and LocalSocket does not expose channels,                        // so we must copy the data locally to write them manually to the output stream                        outputBuffer.get(buf, 0, len);                        outputStream.write(buf, 0, len);                    }                }            } finally {                if (outputBufferId >= 0) {                    codec.releaseOutputBuffer(outputBufferId, false);                }            }        }        return !eof;    }
    public void streamScreen(Device device, OutputStream outputStream) throws IOException {        MediaFormat format = createFormat(bitRate, frameRate, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                Rect contentRect = device.getScreenInfo().getContentRect();                Rect videoRect = device.getScreenInfo().getVideoSize().toRect();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, contentRect, videoRect);                codec.start();                try {                    alive = encode(codec, outputStream);                } finally {                    codec.stop();                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    private boolean encode(MediaCodec codec, FileDescriptor fd) throws IOException {        boolean eof = false;        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();        while (!consumeRotationChange() && !eof) {            int outputBufferId = codec.dequeueOutputBuffer(bufferInfo, -1);            eof = (bufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;            try {                if (consumeRotationChange()) {                    // must restart encoding with new size                    break;                }                if (outputBufferId >= 0) {                    ByteBuffer codecBuffer = codec.getOutputBuffer(outputBufferId);                    IO.writeFully(fd, codecBuffer);                }            } finally {                if (outputBufferId >= 0) {                    codec.releaseOutputBuffer(outputBufferId, false);                }            }        }        return !eof;    }    private static MediaCodec createCodec() throws IOException {        return MediaCodec.createEncoderByType("video/avc");    }    private static MediaFormat createFormat(int bitRate, int frameRate, int iFrameInterval) throws IOException {        MediaFormat format = new MediaFormat();        format.setString(MediaFormat.KEY_MIME, "video/avc");        format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);        format.setInteger(MediaFormat.KEY_FRAME_RATE, frameRate);
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        MediaFormat format = createFormat(bitRate, frameRate, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                Rect contentRect = device.getScreenInfo().getContentRect();                Rect videoRect = device.getScreenInfo().getVideoSize().toRect();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, contentRect, videoRect);                codec.start();                try {                    alive = encode(codec, fd);                } finally {                    codec.stop();                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    private boolean encode(MediaCodec codec, FileDescriptor fd) throws IOException {        boolean eof = false;        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();        while (!consumeRotationChange() && !eof) {            int outputBufferId = codec.dequeueOutputBuffer(bufferInfo, -1);            eof = (bufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;            try {                if (consumeRotationChange()) {                    // must restart encoding with new size                    break;                }                if (outputBufferId >= 0) {                    ByteBuffer codecBuffer = codec.getOutputBuffer(outputBufferId);                    IO.writeFully(fd, codecBuffer);                }            } finally {                if (outputBufferId >= 0) {                    codec.releaseOutputBuffer(outputBufferId, false);                }            }        }        return !eof;    }
    public void streamScreen(Device device, FileDescriptor fd) throws IOException {        MediaFormat format = createFormat(bitRate, frameRate, iFrameInterval);        device.setRotationListener(this);        boolean alive;        try {            do {                MediaCodec codec = createCodec();                IBinder display = createDisplay();                Rect contentRect = device.getScreenInfo().getContentRect();                Rect videoRect = device.getScreenInfo().getVideoSize().toRect();                setSize(format, videoRect.width(), videoRect.height());                configure(codec, format);                Surface surface = codec.createInputSurface();                setDisplaySurface(display, surface, contentRect, videoRect);                codec.start();                try {                    alive = encode(codec, fd);                } finally {                    codec.stop();                    destroyDisplay(display);                    codec.release();                    surface.release();                }            } while (alive);        } finally {            device.setRotationListener(null);        }    }
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getBitRate());            // asynchronous            startEventController(device, connection);            try {                // synchronous                screenEncoder.streamScreen(device, connection.getOutputStream());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getBitRate());            // asynchronous            startEventController(device, connection);            try {                // synchronous                screenEncoder.streamScreen(device, connection.getFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
net_listen(uint32_t addr, uint16_t port, int backlog) {    socket_t sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        perror("socket");        return INVALID_SOCKET;    }    int reuse = 1;    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (const void *) &reuse,                   sizeof(reuse)) == -1) {        perror("setsockopt(SO_REUSEADDR)");    }    SOCKADDR_IN sin;    sin.sin_family = AF_INET;    sin.sin_addr.s_addr = htonl(addr); // htonl() harmless on INADDR_ANY    sin.sin_port = htons(port);    if (bind(sock, (SOCKADDR *) &sin, sizeof(sin)) == SOCKET_ERROR) {        perror("bind");        return INVALID_SOCKET;    }    if (listen(sock, backlog) == SOCKET_ERROR) {        perror("listen");        return INVALID_SOCKET;    }    return sock;}
net_connect(uint32_t addr, uint16_t port) {    socket_t sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        perror("socket");        return INVALID_SOCKET;    }    SOCKADDR_IN sin;    sin.sin_family = AF_INET;    sin.sin_addr.s_addr = htonl(addr);    sin.sin_port = htons(port);    if (connect(sock, (SOCKADDR *) &sin, sizeof(sin)) == SOCKET_ERROR) {        perror("connect");        return INVALID_SOCKET;    }    return sock;}
net_listen(uint32_t addr, uint16_t port, int backlog) {    socket_t sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        perror("socket");        return INVALID_SOCKET;    }    int reuse = 1;    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (const void *) &reuse,                   sizeof(reuse)) == -1) {        perror("setsockopt(SO_REUSEADDR)");    }    SOCKADDR_IN sin;    sin.sin_family = AF_INET;    sin.sin_addr.s_addr = htonl(addr); // htonl() harmless on INADDR_ANY    sin.sin_port = htons(port);    if (bind(sock, (SOCKADDR *) &sin, sizeof(sin)) == SOCKET_ERROR) {        perror("bind");        close(sock);        return INVALID_SOCKET;    }    if (listen(sock, backlog) == SOCKET_ERROR) {        perror("listen");        close(sock);        return INVALID_SOCKET;    }    return sock;}
net_connect(uint32_t addr, uint16_t port) {    socket_t sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        perror("socket");        return INVALID_SOCKET;    }    SOCKADDR_IN sin;    sin.sin_family = AF_INET;    sin.sin_addr.s_addr = htonl(addr);    sin.sin_port = htons(port);    if (connect(sock, (SOCKADDR *) &sin, sizeof(sin)) == SOCKET_ERROR) {        perror("connect");        close(sock);        return INVALID_SOCKET;    }    return sock;}
    public static void fillAppInfo() {        try {            // ActivityThread activityThread = new ActivityThread();            Class<?> activityThreadClass = Class.forName("android.app.ActivityThread");            Constructor<?> activityThreadConstructor = activityThreadClass.getDeclaredConstructor();            activityThreadConstructor.setAccessible(true);            Object activityThread = activityThreadConstructor.newInstance();            // ActivityThread.sCurrentActivityThread = activityThread;            Field sCurrentActivityThreadField = activityThreadClass.getDeclaredField("sCurrentActivityThread");            sCurrentActivityThreadField.setAccessible(true);            sCurrentActivityThreadField.set(null, activityThread);            // ActivityThread.AppBindData appBindData = new ActivityThread.AppBindData();            Class<?> appBindDataClass = Class.forName("android.app.ActivityThread$AppBindData");            Constructor<?> appBindDataConstructor = appBindDataClass.getDeclaredConstructor();            appBindDataConstructor.setAccessible(true);            Object appBindData = appBindDataConstructor.newInstance();            ApplicationInfo applicationInfo = new ApplicationInfo();            applicationInfo.packageName = "com.genymobile.scrcpy";            // appBindData.appInfo = applicationInfo;            Field appInfo = appBindDataClass.getDeclaredField("appInfo");            appInfo.setAccessible(true);            appInfo.set(appBindData, applicationInfo);            // activityThread.mBoundApplication = appBindData;            Field mBoundApplicationField = activityThreadClass.getDeclaredField("mBoundApplication");            mBoundApplicationField.setAccessible(true);            mBoundApplicationField.set(activityThread, appBindData);        } catch (Throwable throwable) {            // this is a workaround, so failing is not an error            Ln.w("Could not fill app info: " + throwable.getMessage());        }    }}
    public static void fillAppInfo() {        try {            // ActivityThread activityThread = new ActivityThread();            Class<?> activityThreadClass = Class.forName("android.app.ActivityThread");            Constructor<?> activityThreadConstructor = activityThreadClass.getDeclaredConstructor();            activityThreadConstructor.setAccessible(true);            Object activityThread = activityThreadConstructor.newInstance();            // ActivityThread.sCurrentActivityThread = activityThread;            Field sCurrentActivityThreadField = activityThreadClass.getDeclaredField("sCurrentActivityThread");            sCurrentActivityThreadField.setAccessible(true);            sCurrentActivityThreadField.set(null, activityThread);            // ActivityThread.AppBindData appBindData = new ActivityThread.AppBindData();            Class<?> appBindDataClass = Class.forName("android.app.ActivityThread$AppBindData");            Constructor<?> appBindDataConstructor = appBindDataClass.getDeclaredConstructor();            appBindDataConstructor.setAccessible(true);            Object appBindData = appBindDataConstructor.newInstance();            ApplicationInfo applicationInfo = new ApplicationInfo();            applicationInfo.packageName = "com.genymobile.scrcpy";            // appBindData.appInfo = applicationInfo;            Field appInfoField = appBindDataClass.getDeclaredField("appInfo");            appInfoField.setAccessible(true);            appInfoField.set(appBindData, applicationInfo);            // activityThread.mBoundApplication = appBindData;            Field mBoundApplicationField = activityThreadClass.getDeclaredField("mBoundApplication");            mBoundApplicationField.setAccessible(true);            mBoundApplicationField.set(activityThread, appBindData);        } catch (Throwable throwable) {            // this is a workaround, so failing is not an error            Ln.w("Could not fill app info: " + throwable.getMessage());        }    }}
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top", no_argument,       NULL, 'T'},        {"bit-rate",      required_argument, NULL, 'b'},        {"crop",          required_argument, NULL, 'c'},        {"fullscreen",    no_argument,       NULL, 'f'},        {"help",          no_argument,       NULL, 'h'},        {"max-size",      required_argument, NULL, 'm'},        {"port",          required_argument, NULL, 'p'},        {"record",        required_argument, NULL, 'r'},        {"serial",        required_argument, NULL, 's'},        {"show-touches",  no_argument,       NULL, 't'},        {"version",       no_argument,       NULL, 'v'},        {NULL,            0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fhm:p:r:s:tTv", long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = SDL_TRUE;                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = SDL_TRUE;                break;            case 'T':                args->always_on_top = SDL_TRUE;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    return SDL_TRUE;}
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top", no_argument,       NULL, 'T'},        {"bit-rate",      required_argument, NULL, 'b'},        {"crop",          required_argument, NULL, 'c'},        {"fullscreen",    no_argument,       NULL, 'f'},        {"help",          no_argument,       NULL, 'h'},        {"max-size",      required_argument, NULL, 'm'},        {"port",          required_argument, NULL, 'p'},        {"record",        required_argument, NULL, 'r'},        {"serial",        required_argument, NULL, 's'},        {"show-touches",  no_argument,       NULL, 't'},        {"version",       no_argument,       NULL, 'v'},        {NULL,            0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fhm:p:r:s:tTv", long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = SDL_TRUE;                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = SDL_TRUE;                break;            case 'T':                args->always_on_top = SDL_TRUE;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    return SDL_TRUE;}
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top", no_argument,       NULL, 'T'},        {"bit-rate",      required_argument, NULL, 'b'},        {"crop",          required_argument, NULL, 'c'},        {"fullscreen",    no_argument,       NULL, 'f'},        {"help",          no_argument,       NULL, 'h'},        {"max-size",      required_argument, NULL, 'm'},        {"port",          required_argument, NULL, 'p'},        {"record",        required_argument, NULL, 'r'},        {"serial",        required_argument, NULL, 's'},        {"show-touches",  no_argument,       NULL, 't'},        {"version",       no_argument,       NULL, 'v'},        {NULL,            0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fhm:p:r:s:tTv", long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = SDL_TRUE;                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = SDL_TRUE;                break;            case 'T':                args->always_on_top = SDL_TRUE;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    return SDL_TRUE;}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = SDL_FALSE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top", no_argument,       NULL, 'T'},        {"bit-rate",      required_argument, NULL, 'b'},        {"crop",          required_argument, NULL, 'c'},        {"fullscreen",    no_argument,       NULL, 'f'},        {"help",          no_argument,       NULL, 'h'},        {"max-size",      required_argument, NULL, 'm'},        {"port",          required_argument, NULL, 'p'},        {"record",        required_argument, NULL, 'r'},        {"record-format", required_argument, NULL, 'f'},        {"serial",        required_argument, NULL, 's'},        {"show-touches",  no_argument,       NULL, 't'},        {"version",       no_argument,       NULL, 'v'},        {NULL,            0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:p:r:s:tTv", long_options, NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = SDL_TRUE;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return SDL_FALSE;                }                break;            case 'h':                args->help = SDL_TRUE;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 't':                args->show_touches = SDL_TRUE;                break;            case 'T':                args->always_on_top = SDL_TRUE;                break;            case 'v':                args->version = SDL_TRUE;                break;            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return SDL_FALSE;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return SDL_FALSE;        }    }    return SDL_TRUE;}
guess_record_format(const char *filename) {    size_t len = strlen(filename);    if (len < 4) {        return 0;    }    const char *ext = &filename[len - 4];    if (!strcmp(ext, ".mp4")) {        return RECORDER_FORMAT_MP4;    }    if (!strcmp(ext, ".mkv")) {        return RECORDER_FORMAT_MKV;    }    return 0;}
parse_record_format(const char *optarg, enum recorder_format *format) {    if (!strcmp(optarg, "mp4")) {        *format = RECORDER_FORMAT_MP4;        return SDL_TRUE;    }    if (!strcmp(optarg, "mkv")) {        *format = RECORDER_FORMAT_MKV;        return SDL_TRUE;    }    LOGE("Unsupported format: %s (expected mp4 or mkv)", optarg);    return SDL_FALSE;}
int main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .record_format = 0,        .help = SDL_FALSE,        .version = SDL_FALSE,        .show_touches = SDL_FALSE,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = SDL_FALSE,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static const AVOutputFormat *find_mp4_muxer(void) {#if LIBAVFORMAT_VERSION_INT >= AV_VERSION_INT(58, 9, 100)    void *opaque = NULL;#endif    const AVOutputFormat *oformat = NULL;    do {#if LIBAVFORMAT_VERSION_INT >= AV_VERSION_INT(58, 9, 100)        oformat = av_muxer_iterate(&opaque);#else        oformat = av_oformat_next(oformat);#endif        // until null or with name "mp4"    } while (oformat && strcmp(oformat->name, "mp4"));    return oformat;}
SDL_bool recorder_init(struct recorder *recorder, const char *filename,                       struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Cannot strdup filename");        return SDL_FALSE;    }    recorder->declared_frame_size = declared_frame_size;    recorder->header_written = SDL_FALSE;    return SDL_TRUE;}
SDL_bool recorder_init(struct recorder *recorder, const char *filename,                       struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Cannot strdup filename");        return SDL_FALSE;    }    recorder->declared_frame_size = declared_frame_size;    recorder->header_written = SDL_FALSE;    return SDL_TRUE;}
SDL_bool recorder_init(struct recorder *recorder, const char *filename,                       struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Cannot strdup filename");        return SDL_FALSE;    }    recorder->declared_frame_size = declared_frame_size;    recorder->header_written = SDL_FALSE;    return SDL_TRUE;}
SDL_bool recorder_init(struct recorder *recorder, const char *filename,                       struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Cannot strdup filename");        return SDL_FALSE;    }    recorder->declared_frame_size = declared_frame_size;    recorder->header_written = SDL_FALSE;    return SDL_TRUE;}
SDL_bool recorder_open(struct recorder *recorder, AVCodec *input_codec) {    const AVOutputFormat *mp4 = find_mp4_muxer();    if (!mp4) {        LOGE("Could not find mp4 muxer");        return SDL_FALSE;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return SDL_FALSE;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) mp4;    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }#ifdef LAVF_NEW_CODEC_API    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    return SDL_TRUE;}
static const AVOutputFormat *find_muxer(const char *name) {#if LIBAVFORMAT_VERSION_INT >= AV_VERSION_INT(58, 9, 100)    void *opaque = NULL;#endif    const AVOutputFormat *oformat = NULL;    do {#if LIBAVFORMAT_VERSION_INT >= AV_VERSION_INT(58, 9, 100)        oformat = av_muxer_iterate(&opaque);#else        oformat = av_oformat_next(oformat);#endif        // until null or with name "mp4"    } while (oformat && strcmp(oformat->name, name));    return oformat;}
SDL_bool recorder_init(struct recorder *recorder,                       const char *filename,                       enum recorder_format format,                       struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Cannot strdup filename");        return SDL_FALSE;    }    recorder->format = format;    recorder->declared_frame_size = declared_frame_size;    recorder->header_written = SDL_FALSE;    return SDL_TRUE;}
SDL_bool recorder_init(struct recorder *recorder,                       const char *filename,                       enum recorder_format format,                       struct size declared_frame_size) {    recorder->filename = SDL_strdup(filename);    if (!recorder->filename) {        LOGE("Cannot strdup filename");        return SDL_FALSE;    }    recorder->format = format;    recorder->declared_frame_size = declared_frame_size;    recorder->header_written = SDL_FALSE;
recorder_get_format_name(enum recorder_format format) {    switch (format) {        case RECORDER_FORMAT_MP4: return "mp4";        case RECORDER_FORMAT_MKV: return "matroska";        default: return NULL;    }}
static const AVOutputFormat *find_muxer(const char *name) {#if LIBAVFORMAT_VERSION_INT >= AV_VERSION_INT(58, 9, 100)    void *opaque = NULL;#endif    const AVOutputFormat *oformat = NULL;    do {#if LIBAVFORMAT_VERSION_INT >= AV_VERSION_INT(58, 9, 100)        oformat = av_muxer_iterate(&opaque);#else        oformat = av_oformat_next(oformat);#endif        // until null or with name "mp4"    } while (oformat && strcmp(oformat->name, name));    return oformat;}
SDL_bool recorder_open(struct recorder *recorder, AVCodec *input_codec) {    const char *format_name = recorder_get_format_name(recorder->format);    SDL_assert(format_name);    const AVOutputFormat *format = find_muxer(format_name);    if (!format) {        LOGE("Could not find muxer");        return SDL_FALSE;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return SDL_FALSE;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) format;    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }#ifdef LAVF_NEW_CODEC_API    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    return SDL_TRUE;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    SDL_bool send_frame_meta = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      send_frame_meta)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    struct recorder *rec = NULL;    if (options->record_filename) {        if (!recorder_init(&recorder, options->record_filename, frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    decoder_init(&decoder, &frames, device_socket, rec);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size, options->always_on_top)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_recorder:    if (options->record_filename) {        recorder_destroy(&recorder);    }finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    SDL_bool send_frame_meta = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      send_frame_meta)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!file_handler_init(&file_handler, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    struct recorder *rec = NULL;    if (options->record_filename) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            ret = SDL_FALSE;            server_stop(&server);            goto finally_destroy_file_handler;        }        rec = &recorder;    }    av_log_set_callback(av_log_callback);    decoder_init(&decoder, &frames, device_socket, rec);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_recorder;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size, options->always_on_top)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    if (options->fullscreen) {        screen_switch_fullscreen(&screen);    }    ret = event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_file_handler:    file_handler_stop(&file_handler);    file_handler_join(&file_handler);    file_handler_destroy(&file_handler);finally_destroy_recorder:    if (options->record_filename) {        recorder_destroy(&recorder);    }finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    // SDL initialization replace the signal handler for SIGTERM, so Ctrl+C is    // managed by the event loop. This blocking call blocks the event loop, so    // timeout the connection not to block indefinitely in case of SIGTERM.#define SERVER_CONNECT_TIMEOUT_MS 2000    socket_t device_socket = server_connect_to(&server, serial, SERVER_CONNECT_TIMEOUT_MS);    if (device_socket == INVALID_SOCKET) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server, serial);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server, serial);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    // SDL initialization replace the signal handler for SIGTERM, so Ctrl+C is    // managed by the event loop. This blocking call blocks the event loop, so    // timeout the connection not to block indefinitely in case of SIGTERM.#define SERVER_CONNECT_TIMEOUT_MS 2000    socket_t device_socket = server_connect_to(&server, SERVER_CONNECT_TIMEOUT_MS);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
void server_stop(struct server *server, const char *serial) {    SDL_assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Cannot terminate server");    }    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->adb_reverse_enabled) {        // ignore failure        disable_tunnel(serial);    }    if (server->server_copied_to_device) {        remove_server(serial); // ignore failure    }}
socket_t server_connect_to(struct server *server, const char *serial, Uint32 timeout_ms) {    server->device_socket = net_accept(server->server_socket);    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    // we don't need the server socket anymore    close_socket(&server->server_socket);    // the server is started, we can clean up the jar from the temporary folder    remove_server(serial); // ignore failure    server->server_copied_to_device = SDL_FALSE;    // we don't need the adb tunnel anymore    disable_tunnel(serial); // ignore failure    server->adb_reverse_enabled = SDL_FALSE;    return server->device_socket;}
void server_destroy(struct server *server) {    if (server->server_socket != INVALID_SOCKET) {        close_socket(&server->server_socket);    }    if (server->device_socket != INVALID_SOCKET) {        close_socket(&server->device_socket);    }}
SDL_bool server_start(struct server *server, const char *serial, Uint16 local_port,                      Uint16 max_size, Uint32 bit_rate) {    if (!push_server(serial)) {        return SDL_FALSE;    }    server->server_copied_to_device = SDL_TRUE;    if (!enable_tunnel(serial, local_port)) {        return SDL_FALSE;    }    // At the application level, the device part is "the server" because it    // serves video stream and control. However, at the network level, the    // client listens and the server connects to the client. That way, the    // client can listen before starting the server app, so there is no need to    // try to connect until the server socket is listening on the device.    server->server_socket = listen_on_port(local_port);    if (server->server_socket == INVALID_SOCKET) {        LOGE("Could not listen on port %" PRIu16, local_port);        disable_tunnel(serial);        return SDL_FALSE;    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate);    if (server->process == PROCESS_NONE) {        close_socket(&server->server_socket);        disable_tunnel(serial);        return SDL_FALSE;    }    server->adb_reverse_enabled = SDL_TRUE;    return SDL_TRUE;}
void server_stop(struct server *server, const char *serial) {    SDL_assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Cannot terminate server");    }    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->adb_reverse_enabled) {        // ignore failure        disable_tunnel(serial);    }    if (server->server_copied_to_device) {        remove_server(serial); // ignore failure    }}
socket_t server_connect_to(struct server *server, const char *serial, Uint32 timeout_ms) {    server->device_socket = net_accept(server->server_socket);    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    // we don't need the server socket anymore    close_socket(&server->server_socket);    // the server is started, we can clean up the jar from the temporary folder    remove_server(serial); // ignore failure    server->server_copied_to_device = SDL_FALSE;    // we don't need the adb tunnel anymore    disable_tunnel(serial); // ignore failure    server->adb_reverse_enabled = SDL_FALSE;    return server->device_socket;}
void server_stop(struct server *server) {    SDL_assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Cannot terminate server");    }    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->adb_reverse_enabled) {        // ignore failure        disable_tunnel(server->serial);    }    if (server->server_copied_to_device) {        remove_server(server->serial); // ignore failure    }}
    return SDL_TRUE;}socket_t server_connect_to(struct server *server, Uint32 timeout_ms) {    server->device_socket = net_accept(server->server_socket);    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    // we don't need the server socket anymore    close_socket(&server->server_socket);    // the server is started, we can clean up the jar from the temporary folder    remove_server(server->serial); // ignore failure    server->server_copied_to_device = SDL_FALSE;    // we don't need the adb tunnel anymore    disable_tunnel(server->serial); // ignore failure    server->adb_reverse_enabled = SDL_FALSE;
void server_destroy(struct server *server) {    if (server->server_socket != INVALID_SOCKET) {        close_socket(&server->server_socket);    }    if (server->device_socket != INVALID_SOCKET) {        close_socket(&server->device_socket);    }    SDL_free((void *) server->serial);}
SDL_bool server_start(struct server *server, const char *serial, Uint16 local_port,                      Uint16 max_size, Uint32 bit_rate) {    if (serial) {        server->serial = SDL_strdup(serial);    }    if (!push_server(serial)) {        return SDL_FALSE;    }    server->server_copied_to_device = SDL_TRUE;    if (!enable_tunnel(serial, local_port)) {        return SDL_FALSE;    }    // At the application level, the device part is "the server" because it    // serves video stream and control. However, at the network level, the    // client listens and the server connects to the client. That way, the    // client can listen before starting the server app, so there is no need to    // try to connect until the server socket is listening on the device.    server->server_socket = listen_on_port(local_port);    if (server->server_socket == INVALID_SOCKET) {        LOGE("Could not listen on port %" PRIu16, local_port);        disable_tunnel(serial);        return SDL_FALSE;    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate);    if (server->process == PROCESS_NONE) {        close_socket(&server->server_socket);        disable_tunnel(serial);        return SDL_FALSE;    }    server->adb_reverse_enabled = SDL_TRUE;    return SDL_TRUE;}
    return server->device_socket;}void server_stop(struct server *server) {    SDL_assert(server->process != PROCESS_NONE);    if (!cmd_terminate(server->process)) {        LOGW("Cannot terminate server");    }    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->adb_reverse_enabled) {        // ignore failure        disable_tunnel(server->serial);    }    if (server->server_copied_to_device) {
socket_t server_connect_to(struct server *server, Uint32 timeout_ms) {    server->device_socket = net_accept(server->server_socket);    if (server->device_socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    // we don't need the server socket anymore    close_socket(&server->server_socket);    // the server is started, we can clean up the jar from the temporary folder    remove_server(server->serial); // ignore failure    server->server_copied_to_device = SDL_FALSE;    // we don't need the adb tunnel anymore    disable_tunnel(server->serial); // ignore failure    server->adb_reverse_enabled = SDL_FALSE;    return server->device_socket;}
control_msg_serialize(const struct control_msg *msg, unsigned char *buf) {    buf[0] = msg->type;    switch (msg->type) {        case CONTROL_MSG_TYPE_INJECT_KEYCODE:            buf[1] = msg->inject_keycode.action;            buffer_write32be(&buf[2], msg->inject_keycode.keycode);            buffer_write32be(&buf[6], msg->inject_keycode.metastate);            return 10;        case CONTROL_MSG_TYPE_INJECT_TEXT: {            size_t len = write_string(msg->inject_text.text,                                      CONTROL_MSG_TEXT_MAX_LENGTH, &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_INJECT_MOUSE_EVENT:            buf[1] = msg->inject_mouse_event.action;            buffer_write32be(&buf[2], msg->inject_mouse_event.buttons);            write_position(&buf[6], &msg->inject_mouse_event.position);            return 18;        case CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT:            buf[1] = msg->inject_touch_event.action;            buffer_write64be(&buf[2], msg->inject_touch_event.pointer_id);            write_position(&buf[10], &msg->inject_touch_event.position);            uint16_t pressure =                to_fixed_point_16(msg->inject_touch_event.pressure);            buffer_write16be(&buf[22], pressure);            return 24;        case CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT:            write_position(&buf[1], &msg->inject_scroll_event.position);            buffer_write32be(&buf[13],                             (uint32_t) msg->inject_scroll_event.hscroll);            buffer_write32be(&buf[17],                             (uint32_t) msg->inject_scroll_event.vscroll);            return 21;        case CONTROL_MSG_TYPE_SET_CLIPBOARD: {            size_t len = write_string(msg->inject_text.text,                                      CONTROL_MSG_CLIPBOARD_TEXT_MAX_LENGTH,                                      &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE:            buf[1] = msg->set_screen_power_mode.mode;            return 2;        case CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_GET_CLIPBOARD:            // no additional data            return 1;        default:            LOGW("Unknown message type: %u", (unsigned) msg->type);            return 0;    }}
control_msg_serialize(const struct control_msg *msg, unsigned char *buf) {    buf[0] = msg->type;    switch (msg->type) {        case CONTROL_MSG_TYPE_INJECT_KEYCODE:            buf[1] = msg->inject_keycode.action;            buffer_write32be(&buf[2], msg->inject_keycode.keycode);            buffer_write32be(&buf[6], msg->inject_keycode.metastate);            return 10;        case CONTROL_MSG_TYPE_INJECT_TEXT: {            size_t len = write_string(msg->inject_text.text,                                      CONTROL_MSG_TEXT_MAX_LENGTH, &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT:            buf[1] = msg->inject_touch_event.action;            buffer_write64be(&buf[2], msg->inject_touch_event.pointer_id);            write_position(&buf[10], &msg->inject_touch_event.position);            uint16_t pressure =                to_fixed_point_16(msg->inject_touch_event.pressure);            buffer_write16be(&buf[22], pressure);            buffer_write32be(&buf[24], msg->inject_touch_event.buttons);            return 28;        case CONTROL_MSG_TYPE_INJECT_SCROLL_EVENT:            write_position(&buf[1], &msg->inject_scroll_event.position);            buffer_write32be(&buf[13],                             (uint32_t) msg->inject_scroll_event.hscroll);            buffer_write32be(&buf[17],                             (uint32_t) msg->inject_scroll_event.vscroll);            return 21;        case CONTROL_MSG_TYPE_SET_CLIPBOARD: {            size_t len = write_string(msg->inject_text.text,                                      CONTROL_MSG_CLIPBOARD_TEXT_MAX_LENGTH,                                      &buf[1]);            return 1 + len;        }        case CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE:            buf[1] = msg->set_screen_power_mode.mode;            return 2;        case CONTROL_MSG_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_MSG_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_COLLAPSE_NOTIFICATION_PANEL:        case CONTROL_MSG_TYPE_GET_CLIPBOARD:            // no additional data            return 1;        default:            LOGW("Unknown message type: %u", (unsigned) msg->type);            return 0;    }}
convert_touch(const SDL_TouchFingerEvent *from, struct size screen_size,              struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_touch_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = from->fingerId;    to->inject_touch_event.position.screen_size = screen_size;    // SDL touch event coordinates are normalized in the range [0; 1]    to->inject_touch_event.position.point.x = from->x * screen_size.width;    to->inject_touch_event.position.point.y = from->y * screen_size.height;    to->inject_touch_event.pressure = from->pressure;    return true;}
convert_mouse_motion(const SDL_MouseMotionEvent *from, struct size screen_size,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_MOUSE_EVENT;    to->inject_mouse_event.action = AMOTION_EVENT_ACTION_MOVE;    to->inject_mouse_event.buttons = convert_mouse_buttons(from->state);    to->inject_mouse_event.position.screen_size = screen_size;    to->inject_mouse_event.position.point.x = from->x;    to->inject_mouse_event.position.point.y = from->y;    return true;}
convert_mouse_button(const SDL_MouseButtonEvent *from, struct size screen_size,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_MOUSE_EVENT;    if (!convert_mouse_action(from->type, &to->inject_mouse_event.action)) {        return false;    }    to->inject_mouse_event.buttons =        convert_mouse_buttons(SDL_BUTTON(from->button));    to->inject_mouse_event.position.screen_size = screen_size;    to->inject_mouse_event.position.point.x = from->x;    to->inject_mouse_event.position.point.y = from->y;    return true;}
convert_mouse_action(SDL_EventType from, enum android_motionevent_action *to) {    switch (from) {        MAP(SDL_MOUSEBUTTONDOWN, AMOTION_EVENT_ACTION_DOWN);        MAP(SDL_MOUSEBUTTONUP,   AMOTION_EVENT_ACTION_UP);        FAIL;    }}
convert_touch(const SDL_TouchFingerEvent *from, struct size screen_size,              struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_touch_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = from->fingerId;    to->inject_touch_event.position.screen_size = screen_size;    // SDL touch event coordinates are normalized in the range [0; 1]    to->inject_touch_event.position.point.x = from->x * screen_size.width;    to->inject_touch_event.position.point.y = from->y * screen_size.height;    to->inject_touch_event.pressure = from->pressure;    to->inject_touch_event.buttons = 0;    return true;}
convert_mouse_motion(const SDL_MouseMotionEvent *from, struct size screen_size,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    to->inject_touch_event.action = AMOTION_EVENT_ACTION_MOVE;    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen_size;    to->inject_touch_event.position.point.x = from->x;    to->inject_touch_event.position.point.y = from->y;    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons = convert_mouse_buttons(from->state);    return true;}
convert_mouse_button(const SDL_MouseButtonEvent *from, struct size screen_size,                     struct control_msg *to) {    to->type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT;    if (!convert_mouse_action(from->type, &to->inject_touch_event.action)) {        return false;    }    to->inject_touch_event.pointer_id = POINTER_ID_MOUSE;    to->inject_touch_event.position.screen_size = screen_size;    to->inject_touch_event.position.point.x = from->x;    to->inject_touch_event.position.point.y = from->y;    to->inject_touch_event.pressure = 1.f;    to->inject_touch_event.buttons =        convert_mouse_buttons(SDL_BUTTON(from->button));    return true;}
convert_mouse_action(SDL_EventType from, enum android_motionevent_action *to) {    switch (from) {        MAP(SDL_MOUSEBUTTONDOWN, AMOTION_EVENT_ACTION_DOWN);        MAP(SDL_MOUSEBUTTONUP,   AMOTION_EVENT_ACTION_UP);        FAIL;    }}
static void test_serialize_inject_touch_event(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT,        .inject_touch_event = {            .action = AMOTION_EVENT_ACTION_DOWN,            .pointer_id = 0x1234567887654321L,            .position = {                .point = {                    .x = 100,                    .y = 200,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },            .pressure = 1.0f,        },    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 24);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT,        0x00, // AKEY_EVENT_ACTION_DOWN        0x12, 0x34, 0x56, 0x78, 0x87, 0x65, 0x43, 0x21, // pointer id        0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0xc8, // 100 200        0x04, 0x38, 0x07, 0x80, // 1080 1920        0xff, 0xff, // pressure    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_inject_mouse_event(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_INJECT_MOUSE_EVENT,        .inject_mouse_event = {            .action = AMOTION_EVENT_ACTION_DOWN,            .buttons = AMOTION_EVENT_BUTTON_PRIMARY,            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },        },    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 18);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_INJECT_MOUSE_EVENT,        0x00, // AKEY_EVENT_ACTION_DOWN        0x00, 0x00, 0x00, 0x01, // AMOTION_EVENT_BUTTON_PRIMARY        0x00, 0x00, 0x01, 0x04, 0x00, 0x00, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_inject_touch_event(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT,        .inject_touch_event = {            .action = AMOTION_EVENT_ACTION_DOWN,            .pointer_id = 0x1234567887654321L,            .position = {                .point = {                    .x = 100,                    .y = 200,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },            .pressure = 1.0f,            .buttons = AMOTION_EVENT_BUTTON_PRIMARY,        },    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 28);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT,        0x00, // AKEY_EVENT_ACTION_DOWN        0x12, 0x34, 0x56, 0x78, 0x87, 0x65, 0x43, 0x21, // pointer id        0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0xc8, // 100 200        0x04, 0x38, 0x07, 0x80, // 1080 1920        0xff, 0xff, // pressure        0x00, 0x00, 0x00, 0x01 // AMOTION_EVENT_BUTTON_PRIMARY    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_inject_touch_event(void) {    struct control_msg msg = {        .type = CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT,        .inject_touch_event = {            .action = AMOTION_EVENT_ACTION_DOWN,            .pointer_id = 0x1234567887654321L,            .position = {                .point = {                    .x = 100,                    .y = 200,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },            .pressure = 1.0f,            .buttons = AMOTION_EVENT_BUTTON_PRIMARY,        },    };    unsigned char buf[CONTROL_MSG_SERIALIZED_MAX_SIZE];    int size = control_msg_serialize(&msg, buf);    assert(size == 28);    const unsigned char expected[] = {        CONTROL_MSG_TYPE_INJECT_TOUCH_EVENT,        0x00, // AKEY_EVENT_ACTION_DOWN        0x12, 0x34, 0x56, 0x78, 0x87, 0x65, 0x43, 0x21, // pointer id        0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0xc8, // 100 200        0x04, 0x38, 0x07, 0x80, // 1080 1920        0xff, 0xff, // pressure        0x00, 0x00, 0x00, 0x01 // AMOTION_EVENT_BUTTON_PRIMARY
    public static ControlMessage createInjectTouchEvent(int action, long pointerId, Position position, float pressure) {        ControlMessage msg = new ControlMessage();        msg.type = TYPE_INJECT_TOUCH_EVENT;        msg.action = action;        msg.pointerId = pointerId;        msg.pressure = pressure;        msg.position = position;        return msg;    }
    public static ControlMessage createInjectTouchEvent(int action, long pointerId, Position position, float pressure) {        ControlMessage msg = new ControlMessage();        msg.type = TYPE_INJECT_TOUCH_EVENT;        msg.action = action;        msg.pointerId = pointerId;        msg.pressure = pressure;        msg.position = position;        return msg;    }
    public static ControlMessage createInjectMouseEvent(int action, int buttons, Position position) {        ControlMessage msg = new ControlMessage();        msg.type = TYPE_INJECT_MOUSE_EVENT;        msg.action = action;        msg.buttons = buttons;        msg.position = position;        return msg;    }
    public static ControlMessage createInjectTouchEvent(int action, long pointerId, Position position, float pressure,            int buttons) {        ControlMessage msg = new ControlMessage();        msg.type = TYPE_INJECT_TOUCH_EVENT;        msg.action = action;        msg.pointerId = pointerId;        msg.pressure = pressure;        msg.position = position;        msg.buttons = buttons;        return msg;    }
    }    public static ControlMessage createInjectScrollEvent(Position position, int hScroll, int vScroll) {        ControlMessage msg = new ControlMessage();        msg.type = TYPE_INJECT_SCROLL_EVENT;        msg.position = position;        msg.hScroll = hScroll;        msg.vScroll = vScroll;        return msg;    }
            int buttons) {        ControlMessage msg = new ControlMessage();        msg.type = TYPE_INJECT_TOUCH_EVENT;        msg.action = action;        msg.pointerId = pointerId;        msg.pressure = pressure;        msg.position = position;        msg.buttons = buttons;        return msg;
    private ControlMessage parseInjectMouseEvent() {        if (buffer.remaining() < INJECT_MOUSE_EVENT_PAYLOAD_LENGTH) {            return null;        }        int action = toUnsigned(buffer.get());        int buttons = buffer.getInt();        Position position = readPosition(buffer);        return ControlMessage.createInjectMouseEvent(action, buttons, position);    }
    public ControlMessage next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        ControlMessage msg;        switch (type) {            case ControlMessage.TYPE_INJECT_KEYCODE:                msg = parseInjectKeycode();                break;            case ControlMessage.TYPE_INJECT_TEXT:                msg = parseInjectText();                break;            case ControlMessage.TYPE_INJECT_MOUSE_EVENT:                msg = parseInjectMouseEvent();                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                msg = parseInjectTouchEvent();                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                msg = parseInjectScrollEvent();                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                msg = parseSetClipboard();                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                msg = parseSetScreenPowerMode();                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:            case ControlMessage.TYPE_GET_CLIPBOARD:                msg = ControlMessage.createEmpty(type);                break;            default:                Ln.w("Unknown event type: " + type);                msg = null;                break;        }        if (msg == null) {            // failure, reset savedPosition            buffer.position(savedPosition);        }        return msg;    }
    private ControlMessage parseInjectTouchEvent() {        if (buffer.remaining() < INJECT_TOUCH_EVENT_PAYLOAD_LENGTH) {            return null;        }        int action = toUnsigned(buffer.get());        long pointerId = buffer.getLong();        Position position = readPosition(buffer);        // 16 bits fixed-point        int pressureInt = toUnsigned(buffer.getShort());        // convert it to a float between 0 and 1 (0x1p16f is 2^16 as float)        float pressure = pressureInt == 0xffff ? 1f : (pressureInt / 0x1p16f);        return ControlMessage.createInjectTouchEvent(action, pointerId, position, pressure);    }
            return null;        }        int action = toUnsigned(buffer.get());        long pointerId = buffer.getLong();        Position position = readPosition(buffer);        // 16 bits fixed-point        int pressureInt = toUnsigned(buffer.getShort());        // convert it to a float between 0 and 1 (0x1p16f is 2^16 as float)        float pressure = pressureInt == 0xffff ? 1f : (pressureInt / 0x1p16f);        int buttons = buffer.getInt();
    public ControlMessage next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        ControlMessage msg;        switch (type) {            case ControlMessage.TYPE_INJECT_KEYCODE:                msg = parseInjectKeycode();                break;            case ControlMessage.TYPE_INJECT_TEXT:                msg = parseInjectText();                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                msg = parseInjectTouchEvent();                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                msg = parseInjectScrollEvent();                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                msg = parseSetClipboard();                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                msg = parseSetScreenPowerMode();                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:            case ControlMessage.TYPE_GET_CLIPBOARD:                msg = ControlMessage.createEmpty(type);                break;            default:                Ln.w("Unknown event type: " + type);                msg = null;                break;        }        if (msg == null) {            // failure, reset savedPosition            buffer.position(savedPosition);        }        return msg;    }    private ControlMessage parseInjectKeycode() {        if (buffer.remaining() < INJECT_KEYCODE_PAYLOAD_LENGTH) {            return null;
    private ControlMessage parseInjectTouchEvent() {        if (buffer.remaining() < INJECT_TOUCH_EVENT_PAYLOAD_LENGTH) {            return null;        }        int action = toUnsigned(buffer.get());        long pointerId = buffer.getLong();        Position position = readPosition(buffer);        // 16 bits fixed-point        int pressureInt = toUnsigned(buffer.getShort());        // convert it to a float between 0 and 1 (0x1p16f is 2^16 as float)        float pressure = pressureInt == 0xffff ? 1f : (pressureInt / 0x1p16f);        int buttons = buffer.getInt();        return ControlMessage.createInjectTouchEvent(action, pointerId, position, pressure, buttons);    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                break;            case ControlMessage.TYPE_INJECT_TEXT:                injectText(msg.getText());                break;            case ControlMessage.TYPE_INJECT_MOUSE_EVENT:                injectTouch(msg.getAction(), PointersState.POINTER_ID_MOUSE, msg.getPosition(), 1, msg.getButtons());                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), 0);                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                pressBackOrTurnScreenOn();                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                device.setClipboardText(msg.getText());                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                device.setScreenPowerMode(msg.getAction());                break;            default:                // do nothing        }    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                break;            case ControlMessage.TYPE_INJECT_TEXT:                injectText(msg.getText());                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), 0);                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                pressBackOrTurnScreenOn();                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                device.setClipboardText(msg.getText());                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                device.setScreenPowerMode(msg.getAction());                break;            default:                // do nothing        }    }    private boolean injectKeycode(int action, int keycode, int metaState) {        return injectKeyEvent(action, keycode, 0, metaState);    }
    public void testParseMouseEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_MOUSE_EVENT);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(100);        dos.writeInt(200);        dos.writeShort(1080);        dos.writeShort(1920);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_MOUSE_EVENT, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getButtons());        Assert.assertEquals(100, event.getPosition().getPoint().getX());        Assert.assertEquals(200, event.getPosition().getPoint().getY());        Assert.assertEquals(1080, event.getPosition().getScreenSize().getWidth());        Assert.assertEquals(1920, event.getPosition().getScreenSize().getHeight());    }
    public void testParseTouchEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_TOUCH_EVENT);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeLong(-42); // pointerId        dos.writeInt(100);        dos.writeInt(200);        dos.writeShort(1080);        dos.writeShort(1920);        dos.writeShort(0xffff); // pressure        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_TOUCH_EVENT, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(-42, event.getPointerId());        Assert.assertEquals(100, event.getPosition().getPoint().getX());        Assert.assertEquals(200, event.getPosition().getPoint().getY());        Assert.assertEquals(1080, event.getPosition().getScreenSize().getWidth());        Assert.assertEquals(1920, event.getPosition().getScreenSize().getHeight());        Assert.assertEquals(1f, event.getPressure(), 0f); // must be exact    }
    public void testParseTouchEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_TOUCH_EVENT);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeLong(-42); // pointerId        dos.writeInt(100);        dos.writeInt(200);        dos.writeShort(1080);        dos.writeShort(1920);        dos.writeShort(0xffff); // pressure        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_TOUCH_EVENT, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(-42, event.getPointerId());        Assert.assertEquals(100, event.getPosition().getPoint().getX());        Assert.assertEquals(200, event.getPosition().getPoint().getY());        Assert.assertEquals(1080, event.getPosition().getScreenSize().getWidth());        Assert.assertEquals(1920, event.getPosition().getScreenSize().getHeight());
    public void testParseTouchEvent() throws IOException {        ControlMessageReader reader = new ControlMessageReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlMessage.TYPE_INJECT_TOUCH_EVENT);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeLong(-42); // pointerId        dos.writeInt(100);        dos.writeInt(200);        dos.writeShort(1080);        dos.writeShort(1920);        dos.writeShort(0xffff); // pressure        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlMessage event = reader.next();        Assert.assertEquals(ControlMessage.TYPE_INJECT_TOUCH_EVENT, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(-42, event.getPointerId());        Assert.assertEquals(100, event.getPosition().getPoint().getX());        Assert.assertEquals(200, event.getPosition().getPoint().getY());        Assert.assertEquals(1080, event.getPosition().getScreenSize().getWidth());        Assert.assertEquals(1920, event.getPosition().getScreenSize().getHeight());        Assert.assertEquals(1f, event.getPressure(), 0f); // must be exact        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getButtons());    }
    public static void main(String... args) throws Exception {        Options options = createOptions(args);        try {            scrcpy(options);        } catch (Throwable t) {            t.printStackTrace();            throw t;        }    }}
    private static void startEventController(final Device device, final DesktopConnection connection) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    new EventController(device, connection).control();                } catch (IOException e) {                    e.printStackTrace();                }            }        }).start();    }
    public static void main(String... args) throws Exception {        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {            @Override            public void uncaughtException(Thread t, Throwable e) {                Ln.e("Exception on thread " + t, e);            }        });        Options options = createOptions(args);        scrcpy(options);    }}
    private static void startEventController(final Device device, final DesktopConnection connection) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    new EventController(device, connection).control();                } catch (IOException e) {                    Ln.e("Exception from event controller", e);                }            }        }).start();    }
void request_queue_destroy(struct request_queue *queue) {    int i = queue->tail;    while (i != queue->head) {        request_free(queue->reqs[i]);        i = (i + 1) % REQUEST_QUEUE_SIZE;    }}
SDL_bool request_queue_push(struct request_queue *queue, struct request *req) {    if (request_queue_is_full(queue)) {        return SDL_FALSE;    }    queue->reqs[queue->head] = req;    queue->head = (queue->head + 1) % REQUEST_QUEUE_SIZE;    return SDL_TRUE;}
SDL_bool request_queue_is_full(const struct request_queue *queue) {    return (queue->head + 1) % REQUEST_QUEUE_SIZE == queue->tail;}
SDL_bool request_queue_init(struct request_queue *queue) {    queue->head = 0;    queue->tail = 0;    return SDL_TRUE;}
SDL_bool request_queue_take(struct request_queue *queue, struct request **req) {    if (request_queue_is_empty(queue)) {        return SDL_FALSE;    }    // transfer ownership    *req = queue->reqs[queue->tail];    queue->tail = (queue->tail + 1) % REQUEST_QUEUE_SIZE;    return SDL_TRUE;}
SDL_bool request_queue_is_empty(const struct request_queue *queue) {    return queue->head == queue->tail;}
static void request_queue_destroy(struct request_queue *queue) {    int i = queue->tail;    while (i != queue->head) {        request_free(queue->reqs[i]);        i = (i + 1) % REQUEST_QUEUE_SIZE;    }}
static SDL_bool request_queue_push(struct request_queue *queue, struct request *req) {    if (request_queue_is_full(queue)) {        return SDL_FALSE;    }    queue->reqs[queue->head] = req;    queue->head = (queue->head + 1) % REQUEST_QUEUE_SIZE;    return SDL_TRUE;}
static SDL_bool request_queue_is_full(const struct request_queue *queue) {    return (queue->head + 1) % REQUEST_QUEUE_SIZE == queue->tail;}
static SDL_bool request_queue_init(struct request_queue *queue) {    queue->head = 0;    queue->tail = 0;    return SDL_TRUE;}
static SDL_bool request_queue_take(struct request_queue *queue, struct request **req) {    if (request_queue_is_empty(queue)) {        return SDL_FALSE;    }    // transfer ownership    *req = queue->reqs[queue->tail];    queue->tail = (queue->tail + 1) % REQUEST_QUEUE_SIZE;    return SDL_TRUE;}
static SDL_bool request_queue_is_empty(const struct request_queue *queue) {    return queue->head == queue->tail;}
void input_manager_process_text_input(struct input_manager *input_manager,                                      const SDL_TextInputEvent *event) {    char c = event->text[0];    if (isalpha(c) || c == ' ') {        SDL_assert(event->text[1] == '\0');        // letters and space are handled as raw key event        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    control_event.text_event.text = SDL_strdup(event->text);    if (!control_event.text_event.text) {        LOGW("Cannot strdup input text");        return;    }    if (!controller_push_event(input_manager->controller, &control_event)) {        LOGW("Cannot send text event");    }}
void input_manager_process_text_input(struct input_manager *input_manager,                                      const SDL_TextInputEvent *event) {    char c = event->text[0];    if (isalpha(c) || c == ' ') {        SDL_assert(event->text[1] == '\0');        // letters and space are handled as raw key event        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    control_event.text_event.text = SDL_strdup(event->text);    if (!control_event.text_event.text) {        LOGW("Cannot strdup input text");        return;    }    if (!controller_push_event(input_manager->controller, &control_event)) {        SDL_free(control_event.text_event.text);        LOGW("Cannot send text event");    }}
recorder_open(struct recorder *recorder, const AVCodec *input_codec) {    const char *format_name = recorder_get_format_name(recorder->format);    SDL_assert(format_name);    const AVOutputFormat *format = find_muxer(format_name);    if (!format) {        LOGE("Could not find muxer");        return false;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return false;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) format;    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return false;    }#ifdef SCRCPY_LAVF_HAS_NEW_CODEC_PARAMS_API    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return false;    }    LOGI("Recording started to %s file: %s", format_name, recorder->filename);    return true;}
recorder_open(struct recorder *recorder, const AVCodec *input_codec) {    const char *format_name = recorder_get_format_name(recorder->format);    SDL_assert(format_name);    const AVOutputFormat *format = find_muxer(format_name);    if (!format) {        LOGE("Could not find muxer");        return false;    }    recorder->ctx = avformat_alloc_context();    if (!recorder->ctx) {        LOGE("Could not allocate output context");        return false;    }    // contrary to the deprecated API (av_oformat_next()), av_muxer_iterate()    // returns (on purpose) a pointer-to-const, but AVFormatContext.oformat    // still expects a pointer-to-non-const (it has not be updated accordingly)    // <https://github.com/FFmpeg/FFmpeg/commit/0694d8702421e7aff1340038559c438b61bb30dd>    recorder->ctx->oformat = (AVOutputFormat *) format;    av_dict_set(&recorder->ctx->metadata, "comment",                "Recorded by scrcpy " SCRCPY_VERSION, 0);    AVStream *ostream = avformat_new_stream(recorder->ctx, input_codec);    if (!ostream) {        avformat_free_context(recorder->ctx);        return false;    }#ifdef SCRCPY_LAVF_HAS_NEW_CODEC_PARAMS_API    ostream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codecpar->codec_id = input_codec->id;    ostream->codecpar->format = AV_PIX_FMT_YUV420P;    ostream->codecpar->width = recorder->declared_frame_size.width;    ostream->codecpar->height = recorder->declared_frame_size.height;#else    ostream->codec->codec_type = AVMEDIA_TYPE_VIDEO;    ostream->codec->codec_id = input_codec->id;    ostream->codec->pix_fmt = AV_PIX_FMT_YUV420P;    ostream->codec->width = recorder->declared_frame_size.width;    ostream->codec->height = recorder->declared_frame_size.height;#endif    int ret = avio_open(&recorder->ctx->pb, recorder->filename,                        AVIO_FLAG_WRITE);    if (ret < 0) {        LOGE("Failed to open output file: %s", recorder->filename);        // ostream will be cleaned up during context cleaning        avformat_free_context(recorder->ctx);        return false;    }    LOGI("Recording started to %s file: %s", format_name, recorder->filename);    return true;}
    private boolean injectTouch(int action, long pointerId, Position position, float pressure, int buttons) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        int pointerIndex = pointersState.getPointerIndex(pointerId);        if (pointerIndex == -1) {            Ln.w("Too many pointers for touch event");            return false;        }        Pointer pointer = pointersState.get(pointerIndex);        pointer.setPoint(point);        pointer.setPressure(pressure);        pointer.setUp(action == MotionEvent.ACTION_UP);        int pointerCount = pointersState.update(pointerProperties, pointerCoords);        if (pointerCount == 1) {            if (action == MotionEvent.ACTION_DOWN) {                lastTouchDown = now;            }        } else {            // secondary pointers must use ACTION_POINTER_* ORed with the pointerIndex            if (action == MotionEvent.ACTION_UP) {                action = MotionEvent.ACTION_POINTER_UP | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            } else if (action == MotionEvent.ACTION_DOWN) {                action = MotionEvent.ACTION_POINTER_DOWN | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            }        }        MotionEvent event = MotionEvent.obtain(lastTouchDown, now, action, pointerCount, pointerProperties,                pointerCoords, 0, 0, 1f, 1f, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                break;            case ControlMessage.TYPE_INJECT_TEXT:                injectText(msg.getText());                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), 0);                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                pressBackOrTurnScreenOn();                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                device.setClipboardText(msg.getText());                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                device.setScreenPowerMode(msg.getAction());                break;            default:                // do nothing        }    }
    private boolean injectTouch(int action, long pointerId, Position position, float pressure, int buttons) {        long now = SystemClock.uptimeMillis();        Point point = device.getPhysicalPoint(position);        if (point == null) {            // ignore event            return false;        }        int pointerIndex = pointersState.getPointerIndex(pointerId);        if (pointerIndex == -1) {            Ln.w("Too many pointers for touch event");            return false;        }        Pointer pointer = pointersState.get(pointerIndex);        pointer.setPoint(point);        pointer.setPressure(pressure);        pointer.setUp(action == MotionEvent.ACTION_UP);        int pointerCount = pointersState.update(pointerProperties, pointerCoords);        if (pointerCount == 1) {            if (action == MotionEvent.ACTION_DOWN) {                lastTouchDown = now;            }        } else {            // secondary pointers must use ACTION_POINTER_* ORed with the pointerIndex            if (action == MotionEvent.ACTION_UP) {                action = MotionEvent.ACTION_POINTER_UP | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            } else if (action == MotionEvent.ACTION_DOWN) {                action = MotionEvent.ACTION_POINTER_DOWN | (pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);            }        }        MotionEvent event = MotionEvent.obtain(lastTouchDown, now, action, pointerCount, pointerProperties,                pointerCoords, 0, buttons, 1f, 1f, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);        return injectEvent(event);    }
    private void handleEvent() throws IOException {        ControlMessage msg = connection.receiveControlMessage();        switch (msg.getType()) {            case ControlMessage.TYPE_INJECT_KEYCODE:                injectKeycode(msg.getAction(), msg.getKeycode(), msg.getMetaState());                break;            case ControlMessage.TYPE_INJECT_TEXT:                injectText(msg.getText());                break;            case ControlMessage.TYPE_INJECT_TOUCH_EVENT:                injectTouch(msg.getAction(), msg.getPointerId(), msg.getPosition(), msg.getPressure(), msg.getButtons());                break;            case ControlMessage.TYPE_INJECT_SCROLL_EVENT:                injectScroll(msg.getPosition(), msg.getHScroll(), msg.getVScroll());                break;            case ControlMessage.TYPE_BACK_OR_SCREEN_ON:                pressBackOrTurnScreenOn();                break;            case ControlMessage.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlMessage.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlMessage.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            case ControlMessage.TYPE_SET_CLIPBOARD:                device.setClipboardText(msg.getText());                break;            case ControlMessage.TYPE_SET_SCREEN_POWER_MODE:                device.setScreenPowerMode(msg.getAction());                break;            default:                // do nothing        }    }
uint64_t buffer_read64be(const uint8_t *buf) {    uint32_t msb = buffer_read32be(buf);    uint32_t lsb = buffer_read32be(&buf[4]);    return ((uint64_t) msb << 32) | lsb;}
buffer_read64be(const uint8_t *buf) {    uint32_t msb = buffer_read32be(buf);    uint32_t lsb = buffer_read32be(&buf[4]);    return ((uint64_t) msb << 32) | lsb;}
void input_manager_process_mouse_button(struct input_manager *input_manager,                                        const SDL_MouseButtonEvent *event) {    if (event->button == SDL_BUTTON_RIGHT && event->type == SDL_MOUSEBUTTONDOWN) {        press_back_or_turn_screen_on(input_manager->controller);        return;    };    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, input_manager->screen->frame_size, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send mouse button event");        }    }}
void input_manager_process_mouse_button(struct input_manager *input_manager,                                        const SDL_MouseButtonEvent *event) {    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(input_manager->controller);            return;        }        if (event->button == SDL_BUTTON_MIDDLE) {            action_home(input_manager->controller);            return;        }    };    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, input_manager->screen->frame_size, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send mouse button event");        }    }}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "        click on BACK\n"        "\n"        "    Ctrl+m\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+'+'\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+'-'\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+m\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+'+'\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+'-'\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        LOGI("Enable show_touches");        set_show_touches_enabled(options->serial, SDL_TRUE);    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);    if (options->show_touches) {        LOGI("Disable show_touches");        set_show_touches_enabled(options->serial, SDL_FALSE);    }finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        LOGI("Enable show_touches");        set_show_touches_enabled(options->serial, SDL_TRUE);    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);    if (options->show_touches) {        LOGI("Disable show_touches");        set_show_touches_enabled(options->serial, SDL_FALSE);    }finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
static SDL_bool set_show_touches_enabled(const char *serial, SDL_bool enabled) {    const char *value = enabled ? "1" : "0";    const char *const adb_cmd[] = {        "shell", "settings", "put", "system", "show_touches", value    };    process_t proc = adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));    return process_check_success(proc, "show_touches");}
static void wait_show_touches(process_t process) {    // reap the process, ignore the result    process_check_success(process, "show_touches");}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate)) {        return SDL_FALSE;    }    process_t proc_show_touches;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
static process_t set_show_touches_enabled(const char *serial, SDL_bool enabled) {    const char *value = enabled ? "1" : "0";    const char *const adb_cmd[] = {        "shell", "settings", "put", "system", "show_touches", value    };    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
SDL_bool server_start(struct server *server, const char *serial, Uint16 local_port,                      Uint16 max_size, Uint32 bit_rate) {    if (!push_server(serial)) {        return SDL_FALSE;    }    server->server_copied_to_device = SDL_TRUE;    if (!enable_tunnel(serial, local_port)) {        return SDL_FALSE;    }    // At the application level, the device part is "the server" because it    // serves video stream and control. However, at network level, the client    // listens and the server connects to the client. That way, the client can    // listen before starting the server app, so there is no need to try to    // connect until the server socket is listening on the device.    server->server_socket = listen_on_port(local_port);    if (server->server_socket == INVALID_SOCKET) {        LOGE("Could not listen on port %" PRIu16, local_port);        disable_tunnel(serial);        return SDL_FALSE;    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate);    if (server->process == PROCESS_NONE) {        close_socket(&server->server_socket);        disable_tunnel(serial);        return SDL_FALSE;    }    server->adb_reverse_enabled = SDL_TRUE;    return SDL_TRUE;}
SDL_bool server_start(struct server *server, const char *serial, Uint16 local_port,                      Uint16 max_size, Uint32 bit_rate) {    if (!push_server(serial)) {        return SDL_FALSE;    }    server->server_copied_to_device = SDL_TRUE;    if (!enable_tunnel(serial, local_port)) {        return SDL_FALSE;    }    // At the application level, the device part is "the server" because it    // serves video stream and control. However, at the network level, the    // client listens and the server connects to the client. That way, the    // client can listen before starting the server app, so there is no need to    // try to connect until the server socket is listening on the device.    server->server_socket = listen_on_port(local_port);    if (server->server_socket == INVALID_SOCKET) {        LOGE("Could not listen on port %" PRIu16, local_port);        disable_tunnel(serial);        return SDL_FALSE;    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate);    if (server->process == PROCESS_NONE) {        close_socket(&server->server_socket);        disable_tunnel(serial);        return SDL_FALSE;    }    server->adb_reverse_enabled = SDL_TRUE;    return SDL_TRUE;}
process_t adb_install(const char *serial, const char *local) {#ifdef __WINDOWS__    // Windows will parse the string, so the local name must be quoted (see sys/win/command.c)    size_t len = strlen(local);    char quoted[len + 3];    memcpy(&quoted[1], local, len);    quoted[0] = '"';    quoted[len + 1] = '"';    quoted[len + 2] = '\0';    local = quoted;#endif    const char *const adb_cmd[] = {"install", "-r", local};    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
process_t adb_push(const char *serial, const char *local, const char *remote) {    const char *const adb_cmd[] = {"push", local, remote};    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
process_t adb_install(const char *serial, const char *local) {#ifdef __WINDOWS__    // Windows will parse the string, so the local name must be quoted    // (see sys/win/command.c)    local = strquote(local);    if (!local) {        return PROCESS_NONE;    }#endif    const char *const adb_cmd[] = {"install", "-r", local};    process_t proc = adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));#ifdef __WINDOWS__    free((void *) local);#endif    return proc;}
process_t adb_push(const char *serial, const char *local, const char *remote) {#ifdef __WINDOWS__    // Windows will parse the string, so the paths must be quoted    // (see sys/win/command.c)    local = strquote(local);    if (!local) {        return PROCESS_NONE;    }    remote = strquote(remote);    if (!remote) {        free((void *) local);        return PROCESS_NONE;    }#endif    const char *const adb_cmd[] = {"push", local, remote};    process_t proc = adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));#ifdef __WINDOWS__    free((void *) remote);    free((void *) local);#endif    return proc;}
void input_manager_process_text_input(struct input_manager *input_manager,                                      const SDL_TextInputEvent *event) {    char c = event->text[0];    if (isalpha(c) || c == ' ') {        SDL_assert(event->text[1] == '\0');        // letters and space are handled as raw key event        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    control_event.text_event.text = SDL_strdup(event->text);    if (!control_event.text_event.text) {        LOGW("Cannot strdup input text");        return;    }    if (!controller_push_event(input_manager->controller, &control_event)) {        LOGW("Cannot send text event");    }}
void input_manager_process_text_input(struct input_manager *input_manager,                                      const SDL_TextInputEvent *event) {    char c = event->text[0];    if (isalpha(c) || c == ' ') {        SDL_assert(event->text[1] == '\0');        // letters and space are handled as raw key event        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    control_event.text_event.text = SDL_strdup(event->text);    if (!control_event.text_event.text) {        LOGW("Cannot strdup input text");        return;    }    if (!controller_push_event(input_manager->controller, &control_event)) {        SDL_free(control_event.text_event.text);        LOGW("Cannot send text event");    }}
static void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return;            case SDL_QUIT:                LOGD("User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;                }                break;            case SDL_TEXTINPUT: {                input_manager_process_text_input(&input_manager, &event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL: {                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                input_manager_process_mouse_button(&input_manager, &event.button);                break;            }        }    }}
static void event_loop(void) {    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return;            case SDL_QUIT:                LOGD("User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;                }                break;            case SDL_TEXTINPUT: {                input_manager_process_text_input(&input_manager, &event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL: {                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                input_manager_process_mouse_button(&input_manager, &event.button);                break;            }        }    }}
static void event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, screen.window);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return;            case SDL_QUIT:                LOGD("User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                case SDL_WINDOWEVENT_EXPOSED:                case SDL_WINDOWEVENT_SIZE_CHANGED:                    screen_render(&screen);                    break;                }                break;            case SDL_TEXTINPUT: {                input_manager_process_text_input(&input_manager, &event.text);                break;            }            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL: {                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            }            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP: {                input_manager_process_mouse_button(&input_manager, &event.button);                break;            }        }    }}
static int event_watcher(void* data, SDL_Event* event) {    if (event->type == SDL_WINDOWEVENT && event->window.event == SDL_WINDOWEVENT_RESIZED) {        // called from another thread, not very safe, but it's a workaround!        screen_render(&screen);    }    return 0;}#endif
int parse_args(struct args *args, int argc, char *argv[]) {    int c;    while ((c = getopt(argc, argv, "p:")) != -1) {        switch (c) {        case 'p': {            char *endptr;            long int value = strtol(optarg, &endptr, 0);            if (*optarg == '\0' || *endptr != '\0') {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s\n", optarg);                return -1;            }            if (value & ~0xffff) {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld\n", value);                return -1;            }            args->port = (Uint16) value;            break;        }        default:            // getopt prints the error message on stderr            return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s\n", argv[index]);        return -1;    }    return 0;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = scrcpy(args.serial, args.port) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
int parse_args(struct args *args, int argc, char *argv[]) {    int c;    while ((c = getopt(argc, argv, "p:m:")) != -1) {        switch (c) {        case 'p': {            char *endptr;            long value = strtol(optarg, &endptr, 0);            if (*optarg == '\0' || *endptr != '\0') {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid port: %s\n", optarg);                return -1;            }            if (value & ~0xffff) {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Port out of range: %ld\n", value);                return -1;            }            args->port = (Uint16) value;            break;        }        case 'm': {            char *endptr;            long value = strtol(optarg, &endptr, 0);            if (*optarg == '\0' || *endptr != '\0') {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Invalid maximum size: %s\n", optarg);                return -1;            }            if (value & ~0xffff) {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Maximum size must be between 0 and 65535: %ld\n", value);                return -1;            }            args->maximum_size = (Uint16) value;            break;        }        default:            // getopt prints the error message on stderr            return -1;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unexpected additional argument: %s\n", argv[index]);        return -1;    }    return 0;}
int main(int argc, char *argv[]) {    int res;    struct args args = {        .serial = NULL,        .port = DEFAULT_LOCAL_PORT,    };    if (parse_args(&args, argc, argv)) {        return 1;    }    av_register_all();    if (avformat_network_init()) {        return 1;    }    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);    res = scrcpy(args.serial, args.port, args.maximum_size) ? 0 : 1;    avformat_network_deinit(); // ignore failure    return res;}
SDL_bool scrcpy(const char *serial, Uint16 local_port) {    SDL_bool ret = 0;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port) {    SDL_bool ret = 0;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 maximum_size) {    SDL_bool ret = 0;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, maximum_size);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 maximum_size) {    SDL_bool ret = 0;    process_t push_proc = push_server(serial);    if (wait_for_success(push_proc, "adb push")) {        return SDL_FALSE;    }    process_t reverse_tunnel_proc = enable_tunnel(serial, local_port);    if (wait_for_success(reverse_tunnel_proc, "adb reverse")) {        return SDL_FALSE;    }    TCPsocket server_socket = listen_on_port(local_port);    if (!server_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video socket");        goto screen_finally_adb_reverse_remove;    }    // server will connect to our socket    process_t server = start_server(serial, maximum_size);    if (server == PROCESS_NONE) {        ret = SDL_FALSE;        SDLNet_TCP_Close(server_socket);        goto screen_finally_adb_reverse_remove;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = blocking_accept(server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server_socket);    if (!device_socket) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not accept video socket: %s", SDL_GetError());        ret = SDL_FALSE;        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!read_initial_device_info(device_socket, device_name, &frame_size)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not retrieve initial screen size");        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    if (!frames_init(&frames)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_adb_reverse_remove;    }    decoder.frames = &frames;    decoder.video_socket = device_socket;    decoder.skip_frames = SDL_TRUE;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        SDLNet_TCP_Close(device_socket);        stop_server(server);        goto screen_finally_destroy_controller;    }    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_and_join_controller;    }    // FIXME it may crash in SDL_Quit in i965_dri.so    // As a workaround, do not call SDL_Quit() (we are exiting anyway).    // atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }    struct size window_size = get_initial_optimal_size(frame_size);    window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                          window_size.width, window_size.height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);    if (!window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_stop_decoder;    }    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    if (!renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_window;    }    if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);    if (!texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        ret = SDL_FALSE;        goto screen_finally_destroy_renderer;    }    SDL_RenderClear(renderer);    SDL_RenderPresent(renderer);    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    SDL_DestroyTexture(texture);screen_finally_destroy_renderer:    // FIXME it may crash at exit if we destroy the renderer or the window,    // with the exact same stack trace as <https://bugs.launchpad.net/mir/+bug/1466535>.    // As a workaround, leak the renderer and the window (we are exiting anyway).    //SDL_DestroyRenderer(renderer);screen_finally_destroy_window:    //SDL_DestroyWindow(window);screen_finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);screen_finally_destroy_controller:    controller_destroy(&controller);screen_finally_stop_decoder:    SDLNet_TCP_Close(device_socket);    // kill the server before decoder_join() to wake up the decoder    stop_server(server);    decoder_join(&decoder);screen_finally_destroy_frames:    frames_destroy(&frames);screen_finally_adb_reverse_remove:    {        process_t remove = disable_tunnel(serial);        if (remove != PROCESS_NONE) {            // ignore failure            cmd_simple_wait(remove, NULL);        }    }    return ret;}
process_t start_server(const char *serial) {    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/system/bin",        "com.genymobile.scrcpy.ScrCpyServer"    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
process_t start_server(const char *serial) {    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/system/bin",        "com.genymobile.scrcpy.ScrCpyServer"    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
process_t start_server(const char *serial, Uint16 maximum_size) {    char maximum_size_string[6];    sprintf(maximum_size_string, "%d", maximum_size);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/system/bin",        "com.genymobile.scrcpy.ScrCpyServer",        maximum_size_string,    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
process_t start_server(const char *serial, Uint16 maximum_size) {    char maximum_size_string[6];    sprintf(maximum_size_string, "%d", maximum_size);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/system/bin",        "com.genymobile.scrcpy.ScrCpyServer",        maximum_size_string,    };
    public static DesktopConnection open(Device device) throws IOException {        LocalSocket socket = connect(SOCKET_NAME);        ScreenInfo initialScreenInfo = device.getScreenInfo();        int width = initialScreenInfo.getLogicalWidth();        int height = initialScreenInfo.getLogicalHeight();        DesktopConnection connection = new DesktopConnection(socket);        connection.send(Device.getDeviceName(), width, height);        return connection;    }
    public static DesktopConnection open(Device device) throws IOException {        LocalSocket socket = connect(SOCKET_NAME);        DesktopConnection connection = new DesktopConnection(socket);        Size videoSize = device.getScreenInfo().getVideoSize();        connection.send(Device.getDeviceName(), videoSize.getWidth(), videoSize.getHeight());        return connection;    }
        });    }    public synchronized ScreenInfo getScreenInfo() {        if (screenInfo == null) {            screenInfo = readScreenInfo();        }        return screenInfo;    }    public Point getPhysicalPoint(Position position) {        ScreenInfo screenInfo = getScreenInfo();
    public Device() {        screenInfo = readScreenInfo();        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    // update screenInfo cache                    screenInfo = screenInfo.withRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        });    }
    private ScreenInfo readScreenInfo() {        return serviceManager.getDisplayManager().getScreenInfo();    }
    public Point getPhysicalPoint(Position position) {        ScreenInfo screenInfo = getScreenInfo();        int deviceWidth = screenInfo.getLogicalWidth();        int deviceHeight = screenInfo.getLogicalHeight();        int scaledX = position.getX() * deviceWidth / position.getScreenWidth();        int scaledY = position.getY() * deviceHeight / position.getScreenHeight();        return new Point(scaledX, scaledY);    }
    public Device() {        screenInfo = readScreenInfo();        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    // update screenInfo cache                    screenInfo = screenInfo.withRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        });    }
    public synchronized ScreenInfo getScreenInfo() {        if (screenInfo == null) {            screenInfo = readScreenInfo();        }        return screenInfo;    }
    private ScreenInfo computeScreenInfo(int maximumSize) {        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        int w = deviceSize.getWidth();        int h = deviceSize.getHeight();        int padding = 0;        if (maximumSize > 0) {            assert maximumSize % 8 == 0;            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;            if (major > maximumSize) {                int minorExact = minor * maximumSize / major;                // +7 to ceil the value on rounding to the next multiple of 8,                // so that any necessary black bands to keep the aspect ratio are added to the smallest dimension                minor = (minorExact + 7) & ~7;                major = maximumSize;                padding = minor - minorExact;            }            w = portrait ? minor : major;            h = portrait ? major : minor;        }        return new ScreenInfo(deviceSize, new Size(w, h), padding, rotated);    }
    public Device(Options options) {        screenInfo = computeScreenInfo(options.getMaximumSize());        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    screenInfo = screenInfo.withRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        });    }
                int minorExact = minor * maximumSize / major;                // +7 to ceil the value on rounding to the next multiple of 8,                // so that any necessary black bands to keep the aspect ratio are added to the smallest dimension                minor = (minorExact + 7) & ~7;
    public Point getPhysicalPoint(Position position) {        ScreenInfo screenInfo = getScreenInfo(); // read with synchronization        Size videoSize = screenInfo.getVideoSize();        Size clientVideoSize = position.getScreenSize();        if (!videoSize.equals(clientVideoSize)) {            // The client sends a click relative to a video with wrong dimensions,            // the device may have been rotated since the event was generated, so ignore the event            return null;        }        Size deviceSize = screenInfo.getDeviceSize();        int xPadding = screenInfo.getXPadding();        int yPadding = screenInfo.getYPadding();        int contentWidth = videoSize.getWidth() - xPadding;        int contentHeight = videoSize.getHeight() - yPadding;        Point point = position.getPoint();        int x = point.getX() - xPadding / 2;        int y = point.getY() - yPadding / 2;        if (x < 0 || x >= contentWidth || y < 0 || y >= contentHeight) {            // out of screen            return null;        }        int scaledX = x * deviceSize.getWidth() / videoSize.getWidth();        int scaledY = y * deviceSize.getHeight() / videoSize.getHeight();        return new Point(scaledX, scaledY);    }
    public Device(Options options) {        screenInfo = computeScreenInfo(options.getMaximumSize());        registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                synchronized (Device.this) {                    screenInfo = screenInfo.withRotation(rotation);                    // notify                    if (rotationListener != null) {                        rotationListener.onRotationChanged(rotation);                    }                }            }        });    }    public synchronized ScreenInfo getScreenInfo() {
        return screenInfo;    }    private ScreenInfo computeScreenInfo(int maximumSize) {        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();
    public String toString() {        return "Point{" +                "x=" + x +                ", y=" + y +                ", screenWidth=" + screenWidth +                ", screenHeight=" + screenHeight +                '}';    }}
    public int getY() {        return y;    }
    public int getY() {        return y;    }
    public int getY() {        return y;    }
    public int getX() {        return x;    }
    public int getScreenWidth() {        return screenWidth;    }
    public Position(int x, int y, int screenWidth, int screenHeight) {        this.x = x;        this.y = y;        this.screenWidth = screenWidth;        this.screenHeight = screenHeight;    }
    public Position(int x, int y, int screenWidth, int screenHeight) {        this.x = x;        this.y = y;        this.screenWidth = screenWidth;        this.screenHeight = screenHeight;    }
    public int getScreenHeight() {        return screenHeight;    }
    public Position(int x, int y, int screenWidth, int screenHeight) {        this.x = x;        this.y = y;        this.screenWidth = screenWidth;        this.screenHeight = screenHeight;    }
    public Position(int x, int y, int screenWidth, int screenHeight) {        this.x = x;        this.y = y;        this.screenWidth = screenWidth;        this.screenHeight = screenHeight;    }
    public String toString() {        return "Position{" +                "point=" + point +                ", screenSize=" + screenSize +                '}';    }
    public Size getScreenSize() {        return screenSize;    }
    public Size getScreenSize() {        return screenSize;    }
    public boolean equals(Object o) {        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Position position = (Position) o;        return Objects.equals(point, position.point) &&                Objects.equals(screenSize, position.screenSize);    }
    public Point getPoint() {        return point;    }
    @Override    public boolean equals(Object o) {        if (this == o) return true;
    public Position(int x, int y, int screenWidth, int screenHeight) {        this(new Point(x, y), new Size(screenWidth, screenHeight));    }
    public int hashCode() {        return Objects.hash(point, screenSize);    }
        if (o == null || getClass() != o.getClass()) return false;        Position position = (Position) o;        return Objects.equals(point, position.point) &&                Objects.equals(screenSize, position.screenSize);
    public Position(Point point, Size screenSize) {        this.point = point;        this.screenSize = screenSize;    }
    public Point getPoint() {        return point;    }
    public static void main(String... args) throws Exception {        try {            scrcpy();        } catch (Throwable t) {            t.printStackTrace();            throw t;        }    }}
    private static void scrcpy() throws IOException {        final Device device = new Device();        try (DesktopConnection connection = DesktopConnection.open(device)) {            final ScreenStreamer streamer = new ScreenStreamer(connection);            device.setRotationListener(new Device.RotationListener() {                @Override                public void onRotationChanged(int rotation) {                    streamer.reset();                }            });            // asynchronous            startEventController(device, connection);            try {                // synchronous                streamer.streamScreen();            } catch (IOException e) {                Ln.e("Screen streaming interrupted", e);            }        }    }
    private static void scrcpy() throws IOException {        final Device device = new Device();        try (DesktopConnection connection = DesktopConnection.open(device)) {            final ScreenStreamer streamer = new ScreenStreamer(connection);            device.setRotationListener(new Device.RotationListener() {                @Override                public void onRotationChanged(int rotation) {                    streamer.reset();                }            });            // asynchronous            startEventController(device, connection);            try {                // synchronous                streamer.streamScreen();            } catch (IOException e) {                Ln.e("Screen streaming interrupted", e);            }        }    }
    public static void main(String... args) throws Exception {        Options options = new Options();        if (args.length > 0) {            int maximumSize = Integer.parseInt(args[0]) & ~7; // multiple of 8            options.setMaximumSize(maximumSize);        }        try {            scrcpy(options);        } catch (Throwable t) {            t.printStackTrace();            throw t;        }    }}
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        try (DesktopConnection connection = DesktopConnection.open(device)) {            final ScreenStreamer streamer = new ScreenStreamer(device, connection);            device.setRotationListener(new Device.RotationListener() {                @Override                public void onRotationChanged(int rotation) {                    streamer.reset();                }            });            // asynchronous            startEventController(device, connection);            try {                // synchronous                streamer.streamScreen();            } catch (IOException e) {                Ln.e("Screen streaming interrupted", e);            }        }    }
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        try (DesktopConnection connection = DesktopConnection.open(device)) {            final ScreenStreamer streamer = new ScreenStreamer(device, connection);            device.setRotationListener(new Device.RotationListener() {                @Override                public void onRotationChanged(int rotation) {                    streamer.reset();                }            });            // asynchronous            startEventController(device, connection);            try {                // synchronous                streamer.streamScreen();            } catch (IOException e) {                Ln.e("Screen streaming interrupted", e);            }        }    }
    public ScreenInfo withRotation(int rotation) {        return new ScreenInfo(width, height, rotation);    }
    public ScreenInfo withRotation(int rotation) {        return new ScreenInfo(width, height, rotation);    }
    public ScreenInfo withRotation(int rotation) {        return new ScreenInfo(width, height, rotation);    }
    public ScreenInfo withRotation(int rotation) {        return new ScreenInfo(width, height, rotation);    }
    public ScreenInfo(int width, int height, int rotation) {        this.width = width;        this.height = height;        this.rotation = rotation;    }
    public ScreenInfo(int width, int height, int rotation) {        this.width = width;        this.height = height;        this.rotation = rotation;    }
    public int getLogicalWidth() {        return (rotation & 1) == 0 ? width : height;    }
    public int getLogicalWidth() {        return (rotation & 1) == 0 ? width : height;    }
    public int getLogicalHeight() {        return (rotation & 1) == 0 ? height : width;    }}
    public ScreenInfo withRotation(int rotation) {        boolean newRotated = (rotation & 1) != 0;        if (rotated == newRotated) {            return this;        }        return new ScreenInfo(deviceSize.rotate(), videoSize.rotate(), padding, newRotated);    }}
    public int getYPadding() {        return videoSize.getHeight() < videoSize.getWidth() ? padding : 0;    }
    public Size getVideoSize() {        return videoSize;    }
    public int getXPadding() {        return videoSize.getWidth() < videoSize.getHeight() ? padding : 0;    }
    public ScreenInfo(Size deviceSize, Size videoSize, int padding, boolean rotated) {        this.deviceSize = deviceSize;        this.videoSize = videoSize;        this.padding = padding;        this.rotated = rotated;
    public ScreenInfo(Size deviceSize, Size videoSize, int padding, boolean rotated) {        this.deviceSize = deviceSize;        this.videoSize = videoSize;        this.padding = padding;        this.rotated = rotated;    }
    }    public Size getVideoSize() {        return videoSize;
    public Size getDeviceSize() {        return deviceSize;    }
    }    public int getXPadding() {        return videoSize.getWidth() < videoSize.getHeight() ? padding : 0;
    public ScreenStreamer(DesktopConnection connection) {        this.connection = connection;    }
    public ScreenStreamer(DesktopConnection connection) {        this.connection = connection;    }
    private synchronized ScreenStreamerSession newScreenStreamerSession() {        currentStreamer = new ScreenStreamerSession(connection);        return currentStreamer;    }
    public ScreenStreamer(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;
    public ScreenStreamer(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;    }
    private synchronized ScreenStreamerSession newScreenStreamerSession() {        currentStreamer = new ScreenStreamerSession(device, connection);        return currentStreamer;    }
    public ScreenStreamerSession(DesktopConnection connection) {        this.connection = connection;    }
    private static Process startScreenRecord() throws IOException {        Process process = new ProcessBuilder("screenrecord", "--output-format=h264", "-").start();        process.getOutputStream().close();        return process;    }
    public ScreenStreamerSession(DesktopConnection connection) {        this.connection = connection;    }
    private boolean streamScreenOnce() throws IOException {        Ln.d("Recording...");        Process process = startScreenRecord();        setCurrentProcess(process);        InputStream inputStream = process.getInputStream();        int r;        while ((r = inputStream.read(buffer)) != -1 && !stopped.get()) {            connection.sendVideoStream(buffer, r);        }        return r != -1;    }
    private static Process startScreenRecord() throws IOException {        Process process = new ProcessBuilder("screenrecord", "--output-format=h264", "-").start();        process.getOutputStream().close();        return process;    }
    private final AtomicBoolean stopped = new AtomicBoolean();    private final byte[] buffer = new byte[0x10000];    public ScreenStreamerSession(Device device, DesktopConnection connection) {
        // let the thread stop itself without breaking the video stream        stopped.set(true);        killCurrentProcess();    }    private static Process startScreenRecord(Size videoSize) throws IOException {
    public ScreenStreamerSession(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;    }
    private boolean streamScreenOnce() throws IOException {        Ln.d("Recording...");        Size videoSize = device.getScreenInfo().getVideoSize();        Process process = startScreenRecord(videoSize);        setCurrentProcess(process);        InputStream inputStream = process.getInputStream();        int r;        while ((r = inputStream.read(buffer)) != -1 && !stopped.get()) {            connection.sendVideoStream(buffer, r);        }        return r != -1;    }
    private static Process startScreenRecord(Size videoSize) throws IOException {        List<String> command = new ArrayList<>();        command.add("screenrecord");        command.add("--output-format=h264");        if (videoSize != null) {            command.add("--size=" + videoSize.getWidth() + "x" + videoSize.getHeight());        }        command.add("-");        Process process = new ProcessBuilder(command).start();        process.getOutputStream().close();        return process;    }
    public ScreenInfo getScreenInfo() {        try {            Object displayInfo = manager.getClass().getMethod("getDisplayInfo", int.class).invoke(manager, 0);            Class<?> cls = displayInfo.getClass();            // width and height do not depend on the rotation            int width = (Integer) cls.getMethod("getNaturalWidth").invoke(displayInfo);            int height = (Integer) cls.getMethod("getNaturalHeight").invoke(displayInfo);            int rotation = cls.getDeclaredField("rotation").getInt(displayInfo);            return new ScreenInfo(width, height, rotation);        } catch (Exception e) {            throw new AssertionError(e);        }    }}
    public ScreenInfo getScreenInfo() {        try {            Object displayInfo = manager.getClass().getMethod("getDisplayInfo", int.class).invoke(manager, 0);            Class<?> cls = displayInfo.getClass();            // width and height do not depend on the rotation            int width = (Integer) cls.getMethod("getNaturalWidth").invoke(displayInfo);            int height = (Integer) cls.getMethod("getNaturalHeight").invoke(displayInfo);            int rotation = cls.getDeclaredField("rotation").getInt(displayInfo);            return new ScreenInfo(width, height, rotation);        } catch (Exception e) {            throw new AssertionError(e);        }    }}
    public DisplayInfo getDisplayInfo() {        try {            Object displayInfo = manager.getClass().getMethod("getDisplayInfo", int.class).invoke(manager, 0);            Class<?> cls = displayInfo.getClass();            // width and height already take the rotation into account            int width = cls.getDeclaredField("logicalWidth").getInt(displayInfo);            int height = cls.getDeclaredField("logicalHeight").getInt(displayInfo);            int rotation = cls.getDeclaredField("rotation").getInt(displayInfo);            return new DisplayInfo(new Size(width, height), rotation);        } catch (Exception e) {            throw new AssertionError(e);        }    }
    public DisplayInfo getDisplayInfo() {        try {            Object displayInfo = manager.getClass().getMethod("getDisplayInfo", int.class).invoke(manager, 0);            Class<?> cls = displayInfo.getClass();            // width and height already take the rotation into account            int width = cls.getDeclaredField("logicalWidth").getInt(displayInfo);            int height = cls.getDeclaredField("logicalHeight").getInt(displayInfo);            int rotation = cls.getDeclaredField("rotation").getInt(displayInfo);            return new DisplayInfo(new Size(width, height), rotation);        } catch (Exception e) {            throw new AssertionError(e);        }    }}
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"bit-rate", required_argument, NULL, 'b'},        {"help",     no_argument,       NULL, 'h'},        {"max-size", required_argument, NULL, 'm'},        {"port",     required_argument, NULL, 'p'},        {"version",  no_argument,       NULL, 'v'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:hm:p:v", long_options, NULL)) != -1) {        switch (c) {            case 'b': {                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            }            case 'h': {                args->help = SDL_TRUE;                break;            }            case 'm': {                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            }            case 'p': {                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            }            case 'v': {                args->version = SDL_TRUE;                break;            }            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    int index = optind;    if (index < argc) {        args->serial = argv[index++];    }    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    return SDL_TRUE;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options] [serial]\n"        "\n"        "    serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "        resize window to optimal size (remove black borders)\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "        click on BACK\n"        "\n"        "    Ctrl+m\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+'+'\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+'-'\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click\n"        "        turn screen on\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static SDL_bool parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"bit-rate", required_argument, NULL, 'b'},        {"help",     no_argument,       NULL, 'h'},        {"max-size", required_argument, NULL, 'm'},        {"port",     required_argument, NULL, 'p'},        {"serial",   required_argument, NULL, 's'},        {"version",  no_argument,       NULL, 'v'},        {NULL,       0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:hm:p:s:v", long_options, NULL)) != -1) {        switch (c) {            case 'b': {                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return SDL_FALSE;                }                break;            }            case 'h': {                args->help = SDL_TRUE;                break;            }            case 'm': {                if (!parse_max_size(optarg, &args->max_size)) {                    return SDL_FALSE;                }                break;            }            case 'p': {                if (!parse_port(optarg, &args->port)) {                    return SDL_FALSE;                }                break;            }            case 's': {                args->serial = optarg;                break;            }            case 'v': {                args->version = SDL_TRUE;                break;            }            default:                // getopt prints the error message on stderr                return SDL_FALSE;        }    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return SDL_FALSE;    }    return SDL_TRUE;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "        resize window to optimal size (remove black borders)\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "        click on BACK\n"        "\n"        "    Ctrl+m\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+'+'\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+'-'\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click\n"        "        turn screen on\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static int read_packet_with_meta(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    struct receiver_state *state = &decoder->receiver_state;    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    if (!state->remaining) {#define HEADER_SIZE 12        uint8_t header[HEADER_SIZE];        ssize_t ret = net_recv_all(decoder->video_socket, header, HEADER_SIZE);        if (ret <= 0) {            return ret;        }        // no partial read (net_recv_all())        SDL_assert_release(ret == HEADER_SIZE);        uint64_t pts = buffer_read64be(header);        state->remaining = buffer_read32be(&header[8]);        if (!receiver_state_push_meta(state, pts)) {            LOGE("Could not store PTS for recording");            // we cannot save the PTS, the recording would be broken            return -1;        }    }    SDL_assert(state->remaining);    if (buf_size > state->remaining)        buf_size = state->remaining;    ssize_t ret = net_recv(decoder->video_socket, buf, buf_size);    if (ret <= 0) {        return ret;    }    SDL_assert(state->remaining >= ret);    state->remaining -= ret;    return ret;}
static int read_packet_with_meta(void *opaque, uint8_t *buf, int buf_size) {    struct decoder *decoder = opaque;    struct receiver_state *state = &decoder->receiver_state;    // The video stream contains raw packets, without time information. When we    // record, we retrieve the timestamps separately, from a "meta" header    // added by the server before each raw packet.    //    // The "meta" header length is 12 bytes:    // [. . . . . . . .|. . . .]. . . . . . . . . . . . . . . ...    //  <-------------> <-----> <-----------------------------...    //        PTS        packet        raw packet    //                    size    //    // It is followed by <packet_size> bytes containing the packet/frame.    if (!state->remaining) {#define HEADER_SIZE 12        uint8_t header[HEADER_SIZE];        ssize_t ret = net_recv_all(decoder->video_socket, header, HEADER_SIZE);        if (ret <= 0) {            return ret;        }        // no partial read (net_recv_all())        SDL_assert_release(ret == HEADER_SIZE);        uint64_t pts = buffer_read64be(header);        state->remaining = buffer_read32be(&header[8]);        if (pts != NO_PTS && !receiver_state_push_meta(state, pts)) {            LOGE("Could not store PTS for recording");            // we cannot save the PTS, the recording would be broken            return -1;        }    }    SDL_assert(state->remaining);    if (buf_size > state->remaining)        buf_size = state->remaining;    ssize_t ret = net_recv(decoder->video_socket, buf, buf_size);    if (ret <= 0) {        return ret;    }    SDL_assert(state->remaining >= ret);    state->remaining -= ret;    return ret;}
    private void writeFrameMeta(FileDescriptor fd, MediaCodec.BufferInfo bufferInfo, int packetSize) throws IOException {        headerBuffer.clear();        long pts;        if ((bufferInfo.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {            pts = 0; // non-media data packet        } else {            if (ptsOrigin == 0) {                ptsOrigin = bufferInfo.presentationTimeUs;            }            pts = bufferInfo.presentationTimeUs - ptsOrigin;        }        headerBuffer.putLong(pts);        headerBuffer.putInt(packetSize);        headerBuffer.flip();        IO.writeFully(fd, headerBuffer);    }
    private void writeFrameMeta(FileDescriptor fd, MediaCodec.BufferInfo bufferInfo, int packetSize) throws IOException {        headerBuffer.clear();        long pts;        if ((bufferInfo.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {            pts = NO_PTS; // non-media data packet        } else {            if (ptsOrigin == 0) {                ptsOrigin = bufferInfo.presentationTimeUs;            }            pts = bufferInfo.presentationTimeUs - ptsOrigin;        }        headerBuffer.putLong(pts);        headerBuffer.putInt(packetSize);        headerBuffer.flip();        IO.writeFully(fd, headerBuffer);    }
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        // Ctrl+x: optimal size        if (keycode == SDLK_x && !shift) {            struct size optimal_size = get_optimal_window_size(window, frame_size);            SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);            return;        }        // Ctrl+g: pixel-perfect (ratio 1:1)        if (keycode == SDLK_g && !shift) {            SDL_SetWindowSize(window, frame_size.width, frame_size.height);            return;        }        // Ctrl+f: switch fullscreen        if (keycode == SDLK_f && !shift) {            Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;            if (!SDL_SetWindowFullscreen(window, new_mode)) {                fullscreen = !fullscreen;                render(renderer, texture_empty ? NULL : texture);            } else {                SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());            }            return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        // Ctrl+x: optimal size        if (keycode == SDLK_x && !shift) {            struct size optimal_size = get_optimal_window_size(window, frame_size);            SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);            return;        }        // Ctrl+g: pixel-perfect (ratio 1:1)        if (keycode == SDLK_g && !shift) {            SDL_SetWindowSize(window, frame_size.width, frame_size.height);            return;        }        // Ctrl+f: switch fullscreen        if (keycode == SDLK_f && !shift) {            Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;            if (!SDL_SetWindowFullscreen(window, new_mode)) {                fullscreen = !fullscreen;                render(renderer, texture_empty ? NULL : texture);            } else {                SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());            }            return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        // Ctrl+x: optimal size        if (keycode == SDLK_x && !shift) {            struct size optimal_size = get_optimal_window_size(window, frame_size);            SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);            return;        }        // Ctrl+g: pixel-perfect (ratio 1:1)        if (keycode == SDLK_g && !shift) {            SDL_SetWindowSize(window, frame_size.width, frame_size.height);            return;        }        // Ctrl+f: switch fullscreen        if (keycode == SDLK_f && !shift) {            Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;            if (!SDL_SetWindowFullscreen(window, new_mode)) {                fullscreen = !fullscreen;                render(renderer, texture_empty ? NULL : texture);            } else {                SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());            }            return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
static inline SDL_bool prepare_for_frame(SDL_Window *window, SDL_Renderer *renderer, SDL_Texture **texture,                                         struct size old_frame_size, struct size frame_size) {    (void) window; // might be used to resize the window automatically    if (old_frame_size.width != frame_size.width || old_frame_size.height != frame_size.height) {        if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {            SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());            return SDL_FALSE;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(*texture);        struct size current_size = get_window_size(window);        struct size target_size = {            (Uint32) current_size.width * frame_size.width / old_frame_size.width,            (Uint32) current_size.height * frame_size.height / old_frame_size.height,        };        target_size = get_optimal_size(target_size, frame_size);        SDL_SetWindowSize(window, target_size.width, target_size.height);        SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "New texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);        *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);        if (!*texture) {            SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());            return SDL_FALSE;        }    }    return SDL_TRUE;}
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        // Ctrl+x: optimal size        if (keycode == SDLK_x && !shift) {            if (!fullscreen) {                struct size optimal_size = get_optimal_window_size(window, frame_size);                SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);            }            return;        }        // Ctrl+g: pixel-perfect (ratio 1:1)        if (keycode == SDLK_g && !shift) {            if (!fullscreen) {                SDL_SetWindowSize(window, frame_size.width, frame_size.height);            }            return;        }        // Ctrl+f: switch fullscreen        if (keycode == SDLK_f && !shift) {            if (!switch_fullscreen()) {                SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());            }            return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
static SDL_bool switch_fullscreen(void) {    if (!fullscreen) {        // going to fullscreen, store the current windowed window size        windowed_window_size = get_window_size(window);    }    Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;    if (SDL_SetWindowFullscreen(window, new_mode)) {        return SDL_FALSE;    }    fullscreen = !fullscreen;    if (!fullscreen) {        // fullscreen disabled, restore expected windowed window size        SDL_SetWindowSize(window, windowed_window_size.width, windowed_window_size.height);    }    render(renderer, texture_empty ? NULL : texture);    return SDL_TRUE;}
static void set_window_size(SDL_Window *window, struct size new_size) {    // setting the window size during fullscreen is implementation defined,    // so apply the resize only after fullscreen is disabled    if (fullscreen) {        // SDL_SetWindowSize will be called when fullscreen will be disabled        windowed_window_size = new_size;    } else {        SDL_SetWindowSize(window, new_size.width, new_size.height);    }}
static SDL_bool prepare_for_frame(SDL_Window *window, SDL_Renderer *renderer, SDL_Texture **texture,                                  struct size old_frame_size, struct size frame_size) {    if (old_frame_size.width != frame_size.width || old_frame_size.height != frame_size.height) {        if (SDL_RenderSetLogicalSize(renderer, frame_size.width, frame_size.height)) {            SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());            return SDL_FALSE;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(*texture);        struct size current_size = get_window_size(window);        struct size target_size = {            (Uint32) current_size.width * frame_size.width / old_frame_size.width,            (Uint32) current_size.height * frame_size.height / old_frame_size.height,        };        target_size = get_optimal_size(target_size, frame_size);        set_window_size(window, target_size);        SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "New texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);        *texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, frame_size.width, frame_size.height);        if (!*texture) {            SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());            return SDL_FALSE;        }    }    return SDL_TRUE;}
display_fps(struct fps_counter *counter) {    if (counter->nr_skipped) {        LOGI("%d fps (+%d frames skipped)", counter->nr_rendered,                                            counter->nr_skipped);    } else {        LOGI("%d fps", counter->nr_rendered);    }}
display_fps(struct fps_counter *counter) {    if (counter->nr_skipped) {        LOGI("%d fps (+%d frames skipped)", counter->nr_rendered,                                            counter->nr_skipped);    } else {        LOGI("%d fps", counter->nr_rendered);    }}
fps_counter_add_skipped_frame(struct fps_counter *counter) {    check_expired(counter);    ++counter->nr_skipped;}
fps_counter_init(struct fps_counter *counter) {    counter->started = false;    // no need to initialize the other fields, they are meaningful only when    // started is true}
fps_counter_stop(struct fps_counter *counter) {    counter->started = false;}
fps_counter_stop(struct fps_counter *counter) {    counter->started = false;}
fps_counter_stop(struct fps_counter *counter) {    counter->started = false;}
fps_counter_start(struct fps_counter *counter) {    counter->started = true;    counter->slice_start = SDL_GetTicks();    counter->nr_rendered = 0;    counter->nr_skipped = 0;}
fps_counter_start(struct fps_counter *counter) {    counter->started = true;    counter->slice_start = SDL_GetTicks();    counter->nr_rendered = 0;    counter->nr_skipped = 0;}
fps_counter_start(struct fps_counter *counter) {    counter->started = true;    counter->slice_start = SDL_GetTicks();    counter->nr_rendered = 0;    counter->nr_skipped = 0;}
fps_counter_add_rendered_frame(struct fps_counter *counter) {    check_expired(counter);    ++counter->nr_rendered;}
check_expired(struct fps_counter *counter) {    uint32_t now = SDL_GetTicks();    if (now - counter->slice_start >= 1000) {        display_fps(counter);        // add a multiple of one second        uint32_t elapsed_slices = (now - counter->slice_start) / 1000;        counter->slice_start += 1000 * elapsed_slices;        counter->nr_rendered = 0;        counter->nr_skipped = 0;    }}
check_expired(struct fps_counter *counter) {    uint32_t now = SDL_GetTicks();    if (now - counter->slice_start >= 1000) {        display_fps(counter);        // add a multiple of one second        uint32_t elapsed_slices = (now - counter->slice_start) / 1000;        counter->slice_start += 1000 * elapsed_slices;        counter->nr_rendered = 0;        counter->nr_skipped = 0;    }}
display_fps(struct fps_counter *counter) {    unsigned rendered_per_second =        counter->nr_rendered * 1000 / FPS_COUNTER_INTERVAL_MS;    if (counter->nr_skipped) {        LOGI("%u fps (+%u frames skipped)", rendered_per_second,                                            counter->nr_skipped);    } else {        LOGI("%u fps", rendered_per_second);    }}
fps_counter_is_started(struct fps_counter *counter) {    return SDL_AtomicGet(&counter->started);}
fps_counter_add_skipped_frame(struct fps_counter *counter) {    if (!SDL_AtomicGet(&counter->started)) {        return;    }    mutex_lock(counter->mutex);    uint32_t now = SDL_GetTicks();    check_interval_expired(counter, now);    ++counter->nr_skipped;    mutex_unlock(counter->mutex);}
fps_counter_init(struct fps_counter *counter) {    counter->mutex = SDL_CreateMutex();    if (!counter->mutex) {        return false;    }    counter->state_cond = SDL_CreateCond();    if (!counter->state_cond) {        SDL_DestroyMutex(counter->mutex);        return false;    }    counter->thread = NULL;    SDL_AtomicSet(&counter->started, 0);    // no need to initialize the other fields, they are unused until started    return true;}
fps_counter_stop(struct fps_counter *counter) {    SDL_AtomicSet(&counter->started, 0);    cond_signal(counter->state_cond);}
fps_counter_join(struct fps_counter *counter) {    if (counter->thread) {        SDL_WaitThread(counter->thread, NULL);    }}
fps_counter_interrupt(struct fps_counter *counter) {    if (!counter->thread) {        return;    }    mutex_lock(counter->mutex);    counter->interrupted = true;    mutex_unlock(counter->mutex);    // wake up blocking wait    cond_signal(counter->state_cond);}
fps_counter_start(struct fps_counter *counter) {    mutex_lock(counter->mutex);    counter->next_timestamp = SDL_GetTicks() + FPS_COUNTER_INTERVAL_MS;    counter->nr_rendered = 0;    counter->nr_skipped = 0;    mutex_unlock(counter->mutex);    SDL_AtomicSet(&counter->started, 1);    cond_signal(counter->state_cond);    // counter->thread is always accessed from the same thread, no need to lock    if (!counter->thread) {        counter->thread =            SDL_CreateThread(run_fps_counter, "fps counter", counter);        if (!counter->thread) {            LOGE("Could not start FPS counter thread");            return false;        }    }    return true;}
run_fps_counter(void *data) {    struct fps_counter *counter = data;    mutex_lock(counter->mutex);    while (!counter->interrupted) {        while (!counter->interrupted && !SDL_AtomicGet(&counter->started)) {            cond_wait(counter->state_cond, counter->mutex);        }        while (!counter->interrupted && SDL_AtomicGet(&counter->started)) {            uint32_t now = SDL_GetTicks();            check_interval_expired(counter, now);            SDL_assert(counter->next_timestamp > now);            uint32_t remaining = counter->next_timestamp - now;            // ignore the reason (timeout or signaled), we just loop anyway            cond_wait_timeout(counter->state_cond, counter->mutex, remaining);        }    }    mutex_unlock(counter->mutex);    return 0;}
check_interval_expired(struct fps_counter *counter, uint32_t now) {    if (now < counter->next_timestamp) {        return;    }    display_fps(counter);    counter->nr_rendered = 0;    counter->nr_skipped = 0;    // add a multiple of the interval    uint32_t elapsed_slices =        (now - counter->next_timestamp) / FPS_COUNTER_INTERVAL_MS + 1;    counter->next_timestamp += FPS_COUNTER_INTERVAL_MS * elapsed_slices;}
fps_counter_add_rendered_frame(struct fps_counter *counter) {    if (!SDL_AtomicGet(&counter->started)) {        return;    }    mutex_lock(counter->mutex);    uint32_t now = SDL_GetTicks();    check_interval_expired(counter, now);    ++counter->nr_rendered;    mutex_unlock(counter->mutex);}
static voiddisplay_fps(struct fps_counter *counter) {    unsigned rendered_per_second =        counter->nr_rendered * 1000 / FPS_COUNTER_INTERVAL_MS;    if (counter->nr_skipped) {        LOGI("%u fps (+%u frames skipped)", rendered_per_second,                                            counter->nr_skipped);    } else {        LOGI("%u fps", rendered_per_second);    }}
fps_counter_destroy(struct fps_counter *counter) {    SDL_DestroyCond(counter->state_cond);    SDL_DestroyMutex(counter->mutex);}
switch_fps_counter_state(struct video_buffer *vb) {    mutex_lock(vb->mutex);    if (vb->fps_counter.started) {        LOGI("FPS counter stopped");        fps_counter_stop(&vb->fps_counter);    } else {        LOGI("FPS counter started");        fps_counter_start(&vb->fps_counter);    }    mutex_unlock(vb->mutex);}
switch_fps_counter_state(struct video_buffer *vb) {    mutex_lock(vb->mutex);    if (vb->fps_counter.started) {        LOGI("FPS counter stopped");        fps_counter_stop(&vb->fps_counter);    } else {        LOGI("FPS counter started");        fps_counter_start(&vb->fps_counter);    }    mutex_unlock(vb->mutex);}
switch_fps_counter_state(struct fps_counter *fps_counter) {    // the started state can only be written from the current thread, so there    // is no ToCToU issue    if (fps_counter_is_started(fps_counter)) {        fps_counter_stop(fps_counter);        LOGI("FPS counter stopped");    } else {        if (fps_counter_start(fps_counter)) {            LOGI("FPS counter started");        } else {            LOGE("FPS counter starting failed");        }
switch_fps_counter_state(struct fps_counter *fps_counter) {    // the started state can only be written from the current thread, so there    // is no ToCToU issue    if (fps_counter_is_started(fps_counter)) {        fps_counter_stop(fps_counter);        LOGI("FPS counter stopped");    } else {        if (fps_counter_start(fps_counter)) {            LOGI("FPS counter started");        } else {            LOGE("FPS counter starting failed");        }    }}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .send_frame_meta = record,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!video_buffer_init(&video_buffer, options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Cannot request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .send_frame_meta = record,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Cannot request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
video_buffer_offer_decoded_frame(struct video_buffer *vb,                                 bool *previous_frame_skipped) {    mutex_lock(vb->mutex);    if (vb->render_expired_frames) {        // wait for the current (expired) frame to be consumed        while (!vb->rendering_frame_consumed && !vb->interrupted) {            cond_wait(vb->rendering_frame_consumed_cond, vb->mutex);        }    } else {        if (vb->fps_counter.started && !vb->rendering_frame_consumed) {            fps_counter_add_skipped_frame(&vb->fps_counter);        }    }    video_buffer_swap_frames(vb);    *previous_frame_skipped = !vb->rendering_frame_consumed;    vb->rendering_frame_consumed = false;    mutex_unlock(vb->mutex);}
video_buffer_init(struct video_buffer *vb, bool render_expired_frames) {    if (!(vb->decoding_frame = av_frame_alloc())) {        goto error_0;    }    if (!(vb->rendering_frame = av_frame_alloc())) {        goto error_1;    }    if (!(vb->mutex = SDL_CreateMutex())) {        goto error_2;    }    vb->render_expired_frames = render_expired_frames;    if (render_expired_frames) {        if (!(vb->rendering_frame_consumed_cond = SDL_CreateCond())) {            SDL_DestroyMutex(vb->mutex);            goto error_2;        }        // interrupted is not used if expired frames are not rendered        // since offering a frame will never block        vb->interrupted = false;    }    // there is initially no rendering frame, so consider it has already been    // consumed    vb->rendering_frame_consumed = true;    fps_counter_init(&vb->fps_counter);    return true;error_2:    av_frame_free(&vb->rendering_frame);error_1:    av_frame_free(&vb->decoding_frame);error_0:    return false;}
video_buffer_init(struct video_buffer *vb, bool render_expired_frames) {    if (!(vb->decoding_frame = av_frame_alloc())) {        goto error_0;    }    if (!(vb->rendering_frame = av_frame_alloc())) {        goto error_1;    }    if (!(vb->mutex = SDL_CreateMutex())) {        goto error_2;    }    vb->render_expired_frames = render_expired_frames;    if (render_expired_frames) {        if (!(vb->rendering_frame_consumed_cond = SDL_CreateCond())) {            SDL_DestroyMutex(vb->mutex);            goto error_2;        }        // interrupted is not used if expired frames are not rendered        // since offering a frame will never block        vb->interrupted = false;    }    // there is initially no rendering frame, so consider it has already been    // consumed    vb->rendering_frame_consumed = true;    fps_counter_init(&vb->fps_counter);    return true;error_2:    av_frame_free(&vb->rendering_frame);error_1:    av_frame_free(&vb->decoding_frame);error_0:    return false;}
video_buffer_consume_rendered_frame(struct video_buffer *vb) {    SDL_assert(!vb->rendering_frame_consumed);    vb->rendering_frame_consumed = true;    if (vb->fps_counter.started) {        fps_counter_add_rendered_frame(&vb->fps_counter);    }    if (vb->render_expired_frames) {        // unblock video_buffer_offer_decoded_frame()        cond_signal(vb->rendering_frame_consumed_cond);    }    return vb->rendering_frame;}
video_buffer_offer_decoded_frame(struct video_buffer *vb,                                 bool *previous_frame_skipped) {    mutex_lock(vb->mutex);    if (vb->render_expired_frames) {        // wait for the current (expired) frame to be consumed        while (!vb->rendering_frame_consumed && !vb->interrupted) {            cond_wait(vb->rendering_frame_consumed_cond, vb->mutex);        }    } else if (!vb->rendering_frame_consumed) {        fps_counter_add_skipped_frame(vb->fps_counter);    }    video_buffer_swap_frames(vb);    *previous_frame_skipped = !vb->rendering_frame_consumed;    vb->rendering_frame_consumed = false;    mutex_unlock(vb->mutex);}
video_buffer_init(struct video_buffer *vb, struct fps_counter *fps_counter,                  bool render_expired_frames) {    vb->fps_counter = fps_counter;    if (!(vb->decoding_frame = av_frame_alloc())) {        goto error_0;    }    if (!(vb->rendering_frame = av_frame_alloc())) {        goto error_1;    }    if (!(vb->mutex = SDL_CreateMutex())) {        goto error_2;    }    vb->render_expired_frames = render_expired_frames;    if (render_expired_frames) {        if (!(vb->rendering_frame_consumed_cond = SDL_CreateCond())) {            SDL_DestroyMutex(vb->mutex);            goto error_2;        }        // interrupted is not used if expired frames are not rendered        // since offering a frame will never block        vb->interrupted = false;    }    // there is initially no rendering frame, so consider it has already been    // consumed    vb->rendering_frame_consumed = true;    return true;error_2:    av_frame_free(&vb->rendering_frame);error_1:    av_frame_free(&vb->decoding_frame);error_0:    return false;
video_buffer_init(struct video_buffer *vb, struct fps_counter *fps_counter,                  bool render_expired_frames) {    vb->fps_counter = fps_counter;    if (!(vb->decoding_frame = av_frame_alloc())) {        goto error_0;    }    if (!(vb->rendering_frame = av_frame_alloc())) {        goto error_1;    }    if (!(vb->mutex = SDL_CreateMutex())) {        goto error_2;    }    vb->render_expired_frames = render_expired_frames;    if (render_expired_frames) {        if (!(vb->rendering_frame_consumed_cond = SDL_CreateCond())) {            SDL_DestroyMutex(vb->mutex);            goto error_2;        }        // interrupted is not used if expired frames are not rendered        // since offering a frame will never block        vb->interrupted = false;    }    // there is initially no rendering frame, so consider it has already been    // consumed    vb->rendering_frame_consumed = true;    return true;error_2:    av_frame_free(&vb->rendering_frame);error_1:    av_frame_free(&vb->decoding_frame);error_0:    return false;}
video_buffer_consume_rendered_frame(struct video_buffer *vb) {    SDL_assert(!vb->rendering_frame_consumed);    vb->rendering_frame_consumed = true;    fps_counter_add_rendered_frame(vb->fps_counter);    if (vb->render_expired_frames) {        // unblock video_buffer_offer_decoded_frame()        cond_signal(vb->rendering_frame_consumed_cond);    }    return vb->rendering_frame;}
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        // Ctrl+x: optimal size        if (keycode == SDLK_x && !shift) {            if (!fullscreen) {                struct size optimal_size = get_optimal_window_size(window, frame_size);                SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);            }            return;        }        // Ctrl+g: pixel-perfect (ratio 1:1)        if (keycode == SDLK_g && !shift) {            if (!fullscreen) {                SDL_SetWindowSize(window, frame_size.width, frame_size.height);            }            return;        }        // Ctrl+f: switch fullscreen        if (keycode == SDLK_f && !shift) {            if (!switch_fullscreen()) {                SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());            }            return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        // Ctrl+x: optimal size        if (keycode == SDLK_x && !shift) {            if (!fullscreen) {                struct size optimal_size = get_optimal_window_size(window, frame_size);                SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Resized to optimal size");            }            return;        }        // Ctrl+g: pixel-perfect (ratio 1:1)        if (keycode == SDLK_g && !shift) {            if (!fullscreen) {                SDL_SetWindowSize(window, frame_size.width, frame_size.height);                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Resized to pixel-perfect");            }            return;        }        // Ctrl+f: switch fullscreen        if (keycode == SDLK_f && !shift) {            if (switch_fullscreen()) {                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Switched to %s mode", fullscreen ? "fullscreen" : "windowed");            } else {                SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());            }            return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
size_tcontrol_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            buffer_write32be(&buf[2], event->keycode_event.keycode);            buffer_write32be(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (2 bytes) + string (non nul-terminated)            // injecting a text takes time, so limit the text length            size_t len = utf8_truncation_index(event->text_event.text,                                               CONTROL_EVENT_TEXT_MAX_LENGTH);            buffer_write16be(&buf[1], (uint16_t) len);            memcpy(&buf[3], event->text_event.text, len);            return 3 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            buffer_write32be(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 18;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            buffer_write32be(&buf[13], (uint32_t) event->scroll_event.hscroll);            buffer_write32be(&buf[17], (uint32_t) event->scroll_event.vscroll);            return 21;        case CONTROL_EVENT_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_EVENT_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_EVENT_TYPE_COLLAPSE_NOTIFICATION_PANEL:            // no additional data            return 1;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            buffer_write32be(&buf[2], event->keycode_event.keycode);            buffer_write32be(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (2 bytes) + string (non nul-terminated)            // injecting a text takes time, so limit the text length            size_t len = utf8_truncation_index(event->text_event.text,                                               CONTROL_EVENT_TEXT_MAX_LENGTH);            buffer_write16be(&buf[1], (uint16_t) len);            memcpy(&buf[3], event->text_event.text, len);            return 3 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            buffer_write32be(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 18;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            buffer_write32be(&buf[13], (uint32_t) event->scroll_event.hscroll);            buffer_write32be(&buf[17], (uint32_t) event->scroll_event.vscroll);            return 21;        case CONTROL_EVENT_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_EVENT_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_EVENT_TYPE_COLLAPSE_NOTIFICATION_PANEL:            // no additional data            return 1;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
write_string(const char *utf8, size_t max_len, unsigned char *buf) {    size_t len = utf8_truncation_index(utf8, max_len);    buffer_write16be(buf, (uint16_t) len);    memcpy(&buf[2], utf8, len);    return 2 + len;}
control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            buffer_write32be(&buf[2], event->keycode_event.keycode);            buffer_write32be(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            size_t len = write_string(event->text_event.text,                                      CONTROL_EVENT_TEXT_MAX_LENGTH, &buf[1]);            return 1 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            buffer_write32be(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 18;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            buffer_write32be(&buf[13], (uint32_t) event->scroll_event.hscroll);            buffer_write32be(&buf[17], (uint32_t) event->scroll_event.vscroll);            return 21;        case CONTROL_EVENT_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_EVENT_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_EVENT_TYPE_COLLAPSE_NOTIFICATION_PANEL:            // no additional data            return 1;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet) && !avio_ctx->eof_reached) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        av_packet_unref(&packet);    }    LOGD("End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet) && !avio_ctx->eof_reached) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 37, 0)        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        av_packet_unref(&packet);    }    LOGD("End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
connect_and_read_byte(uint16_t port) {    socket_t socket = net_connect(IPV4_LOCALHOST, port);    if (socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    char byte;    // the connection may succeed even if the server behind the "adb tunnel"    // is not listening, so read one byte to detect a working connection    if (net_recv(socket, &byte, 1) != 1) {        // the server is not listening yet behind the adb tunnel        return INVALID_SOCKET;    }    return socket;}
connect_and_read_byte(uint16_t port) {    socket_t socket = net_connect(IPV4_LOCALHOST, port);    if (socket == INVALID_SOCKET) {        return INVALID_SOCKET;    }    char byte;    // the connection may succeed even if the server behind the "adb tunnel"    // is not listening, so read one byte to detect a working connection    if (net_recv(socket, &byte, 1) != 1) {        // the server is not listening yet behind the adb tunnel        net_close(socket);        return INVALID_SOCKET;    }    return socket;}
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        // Ctrl+x: optimal size        if (keycode == SDLK_x && !shift) {            struct size optimal_size = get_optimal_window_size(window, frame_size);            SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);            return;        }        // Ctrl+f: switch fullscreen        if (keycode == SDLK_f && !shift) {            Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;            if (!SDL_SetWindowFullscreen(window, new_mode)) {                fullscreen = !fullscreen;                render(renderer, texture_empty ? NULL : texture);            } else {                SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());            }            return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        // Ctrl+x: optimal size        if (keycode == SDLK_x && !shift) {            struct size optimal_size = get_optimal_window_size(window, frame_size);            SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);            return;        }        // Ctrl+g: pixel-perfect (ratio 1:1)        if (keycode == SDLK_g && !shift) {            SDL_SetWindowSize(window, frame_size.width, frame_size.height);            return;        }        // Ctrl+f: switch fullscreen        if (keycode == SDLK_f && !shift) {            Uint32 new_mode = fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP;            if (!SDL_SetWindowFullscreen(window, new_mode)) {                fullscreen = !fullscreen;                render(renderer, texture_empty ? NULL : texture);            } else {                SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not switch fullscreen mode: %s", SDL_GetError());            }            return;        }        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
    private DesktopConnection(LocalSocket videoSocket, LocalSocket controlSocket) throws IOException {        this.videoSocket = videoSocket;        this.controlSocket = controlSocket;        controlInputStream = controlSocket.getInputStream();        videoFd = videoSocket.getFileDescriptor();    }
    private DesktopConnection(LocalSocket videoSocket, LocalSocket controlSocket) throws IOException {        this.videoSocket = videoSocket;        this.controlSocket = controlSocket;        controlInputStream = controlSocket.getInputStream();        videoFd = videoSocket.getFileDescriptor();    }
    private DesktopConnection(LocalSocket videoSocket, LocalSocket controlSocket) throws IOException {        this.videoSocket = videoSocket;        this.controlSocket = controlSocket;        controlInputStream = controlSocket.getInputStream();        controlOutputStream = controlSocket.getOutputStream();        videoFd = videoSocket.getFileDescriptor();    }
    public void sendDeviceEvent(DeviceEvent event) throws IOException {        writer.writeTo(event, controlOutputStream);    }}
        this.connection = connection;        initPointer();    }    private void initPointer() {        MotionEvent.PointerProperties props = pointerProperties[0];        props.id = 0;
    public EventController(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;        initPointer();    }
    private boolean injectChar(char c) {        String decomposed = KeyComposition.decompose(c);        char[] chars = decomposed != null ? decomposed.toCharArray() : new char[] {c};        KeyEvent[] events = charMap.getEvents(chars);        if (events == null) {            return false;        }        for (KeyEvent event : events) {            if (!injectEvent(event)) {                return false;            }        }        return true;    }
    public EventSender getSender() {        return sender;    }
    public EventController(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;        initPointer();        sender = new EventSender(connection);    }
    private boolean injectChar(char c) {        String decomposed = KeyComposition.decompose(c);        char[] chars = decomposed != null ? decomposed.toCharArray() : new char[]{c};        KeyEvent[] events = charMap.getEvents(chars);        if (events == null) {            return false;        }        for (KeyEvent event : events) {            if (!injectEvent(event)) {                return false;            }        }        return true;    }
            Ln.e("Cannot unlink server", e);        }    }    public static void main(String... args) throws Exception {        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {            @Override            public void uncaughtException(Thread t, Throwable e) {                Ln.e("Exception on thread " + t, e);            }        });        unlinkSelf();        Options options = createOptions(args);        scrcpy(options);
    private static void startEventController(final Device device, final DesktopConnection connection) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    new EventController(device, connection).control();                } catch (IOException e) {                    // this is expected on close                    Ln.d("Event controller stopped");                }            }        }).start();    }
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate());            // asynchronous            startEventController(device, connection);            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    private static void startEventController(final Device device, final DesktopConnection connection) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    new EventController(device, connection).control();                } catch (IOException e) {                    // this is expected on close                    Ln.d("Event controller stopped");                }            }        }).start();    }
    private static void startEventSender(final EventSender sender) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    sender.loop();                } catch (IOException | InterruptedException e) {                    // this is expected on close                    Ln.d("Event sender stopped");                }            }        }).start();    }
    private static void startEventController(final EventController controller) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    controller.control();                } catch (IOException e) {                    // this is expected on close                    Ln.d("Event controller stopped");                }            }        }).start();    }
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate());            EventController controller = new EventController(device, connection);            // asynchronous            startEventController(controller);            startEventSender(controller.getSender());            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
        }    }    private static void startEventController(final EventController controller) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    controller.control();                } catch (IOException e) {                    // this is expected on close                    Ln.d("Event controller stopped");                }            }
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .send_frame_meta = record,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!video_buffer_init(&video_buffer)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            if (!controller_start(&controller)) {                goto end;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .send_frame_meta = record,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!video_buffer_init(&video_buffer)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            if (!controller_start(&controller)) {                goto end;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        params->send_frame_meta ? "true" : "false",    };    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        params->send_frame_meta ? "true" : "false",        params->control ? "true" : "false",    };    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate());            Controller controller = new Controller(device, connection);            // asynchronous            startController(controller);            startDeviceMessageSender(controller.getSender());            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    private static Options createOptions(String... args) {        if (args.length != 5) {            throw new IllegalArgumentException("Expecting 5 parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[0]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[1]);        options.setBitRate(bitRate);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[2]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[3]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[4]);        options.setSendFrameMeta(sendFrameMeta);        return options;    }
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        boolean tunnelForward = options.isTunnelForward();        try (DesktopConnection connection = DesktopConnection.open(device, tunnelForward)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getSendFrameMeta(), options.getBitRate());            if (options.getControl()) {                Controller controller = new Controller(device, connection);                // asynchronous                startController(controller);                startDeviceMessageSender(controller.getSender());            }            try {                // synchronous                screenEncoder.streamScreen(device, connection.getVideoFd());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    private static Options createOptions(String... args) {        if (args.length != 6) {            throw new IllegalArgumentException("Expecting 5 parameters");        }        Options options = new Options();        int maxSize = Integer.parseInt(args[0]) & ~7; // multiple of 8        options.setMaxSize(maxSize);        int bitRate = Integer.parseInt(args[1]);        options.setBitRate(bitRate);        // use "adb forward" instead of "adb tunnel"? (so the server must listen)        boolean tunnelForward = Boolean.parseBoolean(args[2]);        options.setTunnelForward(tunnelForward);        Rect crop = parseCrop(args[3]);        options.setCrop(crop);        boolean sendFrameMeta = Boolean.parseBoolean(args[4]);        options.setSendFrameMeta(sendFrameMeta);        boolean control = Boolean.parseBoolean(args[5]);        options.setControl(control);        return options;    }
void input_manager_process_mouse_button(struct input_manager *input_manager,                                        const SDL_MouseButtonEvent *event) {    if (event->button == SDL_BUTTON_RIGHT && event->type == SDL_MOUSEBUTTONDOWN) {        turn_screen_on(input_manager->controller);        return;    };    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, input_manager->screen->frame_size, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send mouse button event");        }    }}
static void turn_screen_on(struct controller *controller) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_COMMAND;    control_event.command_event.action = CONTROL_EVENT_COMMAND_SCREEN_ON;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot turn screen on");    }}
static void turn_screen_on(struct controller *controller) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_COMMAND;    control_event.command_event.action = CONTROL_EVENT_COMMAND_SCREEN_ON;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot turn screen on");    }}
void input_manager_process_mouse_button(struct input_manager *input_manager,                                        const SDL_MouseButtonEvent *event) {    if (event->button == SDL_BUTTON_RIGHT && event->type == SDL_MOUSEBUTTONDOWN) {        press_back_or_turn_screen_on(input_manager->controller);        return;    };    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, input_manager->screen->frame_size, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send mouse button event");        }    }}
// turn the screen on if it was off, press BACK otherwisestatic void press_back_or_turn_screen_on(struct controller *controller) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_COMMAND;    control_event.command_event.action = CONTROL_EVENT_COMMAND_BACK_OR_SCREEN_ON;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot turn screen on");    }}
static void press_back_or_turn_screen_on(struct controller *controller) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_COMMAND;    control_event.command_event.action = CONTROL_EVENT_COMMAND_BACK_OR_SCREEN_ON;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot turn screen on");    }}
            case ControlEvent.TYPE_SCROLL:                injectScroll(controlEvent.getPosition(), controlEvent.getHScroll(), controlEvent.getVScroll());                break;            case ControlEvent.TYPE_COMMAND:                executeCommand(controlEvent.getAction());                break;            default:                // do nothing        }    }
    private boolean executeCommand(int action) {        switch (action) {            case ControlEvent.COMMAND_SCREEN_ON:                return turnScreenOn();            default:                Ln.w("Unsupported command: " + action);        }        return false;    }}
    private boolean pressBackOrTurnScreenOn() {        int keycode = device.isScreenOn() ? KeyEvent.KEYCODE_BACK : KeyEvent.KEYCODE_POWER;        return injectKeycode(keycode);    }
    private boolean executeCommand(int action) {        switch (action) {            case ControlEvent.COMMAND_BACK_OR_SCREEN_ON:                return pressBackOrTurnScreenOn();            default:                Ln.w("Unsupported command: " + action);        }        return false;    }}
static const char *get_server_path(void) {    const char *server_path = getenv("SCRCPY_SERVER_JAR");    if (!server_path) {        server_path = DEFAULT_SERVER_JAR;    }    return server_path;}
static const char *get_server_path(void) {    const char *server_path = getenv("SCRCPY_SERVER_PATH");    if (!server_path) {        server_path = DEFAULT_SERVER_PATH;    }    return server_path;}
    public static void writeFully(FileDescriptor fd, ByteBuffer from) throws IOException {        while (from.hasRemaining()) {            try {                Os.write(fd, from);            } catch (ErrnoException e) {                if (e.errno != OsConstants.EINTR) {                    throw new IOException(e);                }            }        }    }
    public static void writeFully(FileDescriptor fd, ByteBuffer from) throws IOException {        // ByteBuffer position is not updated as expected by Os.write() on old Android versions, so        // count the remaining bytes manually.        // See <https://github.com/Genymobile/scrcpy/issues/291>.        int remaining = from.remaining();        while (remaining > 0) {            try {                int w = Os.write(fd, from);                if (BuildConfig.DEBUG && w < 0) {                    // w should not be negative, since an exception is thrown on error                    throw new AssertionError("Os.write() returned a negative value (" + w + ")");                }                remaining -= w;            } catch (ErrnoException e) {                if (e.errno != OsConstants.EINTR) {                    throw new IOException(e);                }            }        }    }
SDL_bool process_check_success(process_t proc, const char *name) {    if (proc == PROCESS_NONE) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not execute \"%s\"", name);        return SDL_FALSE;    }    exit_code_t exit_code;    if (!cmd_simple_wait(proc, &exit_code)) {        if (exit_code != NO_EXIT_CODE) {            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "\"%s\" returned with value %" PRIexitcode, name, exit_code);        } else {            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "\"%s\" exited unexpectedly", name);        }        return SDL_FALSE;    }    return SDL_TRUE;}
SDL_bool process_check_success(process_t proc, const char *name) {    if (proc == PROCESS_NONE) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not execute \"%s\"", name);        return SDL_FALSE;    }    exit_code_t exit_code;    if (!cmd_simple_wait(proc, &exit_code)) {        if (exit_code != NO_EXIT_CODE) {            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "\"%s\" returned with value %" PRIexitcode, name, exit_code);        } else {            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "\"%s\" exited unexpectedly", name);        }        return SDL_FALSE;    }    return SDL_TRUE;}
SDL_bool controller_start(struct controller *controller) {    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Starting controller thread");    controller->thread = SDL_CreateThread(run_controller, "controller", controller);    if (!controller->thread) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not start controller thread");        return SDL_FALSE;    }    return SDL_TRUE;}
SDL_bool controller_start(struct controller *controller) {    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Starting controller thread");    controller->thread = SDL_CreateThread(run_controller, "controller", controller);    if (!controller->thread) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not start controller thread");        return SDL_FALSE;    }    return SDL_TRUE;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    int ret = 0;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "H.264 decoder not found");        return -1;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        SDL_LogCritical(SDL_LOG_CATEGORY_VIDEO, "Could not allocate decoder context");        return -1;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Could not open H.264 codec");        ret = -1;        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        SDL_LogCritical(SDL_LOG_CATEGORY_VIDEO, "Could not allocate format context");        ret = -1;        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        SDL_LogCritical(SDL_LOG_CATEGORY_VIDEO, "Could not allocate buffer");        ret = -1;        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        SDL_LogCritical(SDL_LOG_CATEGORY_VIDEO, "Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        ret = -1;        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    //const char *url = "tcp://127.0.0.1:1234";    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Could not open video stream");        ret = -1;        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet) && !avio_ctx->eof_reached) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57, 37, 0)        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#else        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Could not send video packet: %d", ret);            goto run_quit;        }        if ((ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame)) < 0) {            SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Could not receive video frame: %d", ret);            goto run_quit;        }        push_frame(decoder);#endif    }    SDL_LogDebug(SDL_LOG_CATEGORY_VIDEO, "End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    SDL_PushEvent(&(SDL_Event) {.type = EVENT_DECODER_STOPPED});    return ret;}
SDL_bool decoder_start(struct decoder *decoder) {    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Starting decoder thread");    decoder->thread = SDL_CreateThread(run_decoder, "video_decoder", decoder);    if (!decoder->thread) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not start decoder thread");        return SDL_FALSE;    }    return SDL_TRUE;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    int ret = 0;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "H.264 decoder not found");        return -1;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not allocate decoder context");        return -1;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open H.264 codec");        ret = -1;        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not allocate format context");        ret = -1;        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not allocate buffer");        ret = -1;        goto run_finally_free_format_ctx;    }    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder, read_packet, NULL, NULL);    if (!avio_ctx) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        ret = -1;        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    //const char *url = "tcp://127.0.0.1:1234";    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not open video stream");        ret = -1;        goto run_finally_free_avio_ctx;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet) && !avio_ctx->eof_reached) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57, 37, 0)        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->frames->decoding_frame, &got_picture, &packet);            if (len < 0) {                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not decode video packet: %d", len);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#else        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not send video packet: %d", ret);            goto run_quit;        }        if ((ret = avcodec_receive_frame(codec_ctx, decoder->frames->decoding_frame)) < 0) {            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not receive video frame: %d", ret);            goto run_quit;        }        push_frame(decoder);#endif    }    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "End of frames");run_quit:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_freep(&avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    SDL_PushEvent(&(SDL_Event) {.type = EVENT_DECODER_STOPPED});    return ret;}
SDL_bool decoder_start(struct decoder *decoder) {    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Starting decoder thread");    decoder->thread = SDL_CreateThread(run_decoder, "video_decoder", decoder);    if (!decoder->thread) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not start decoder thread");        return SDL_FALSE;    }    return SDL_TRUE;}
SDL_bool frames_offer_decoded_frame(struct frames *frames) {    mutex_lock(frames->mutex);#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then the decoder must wait for the current    // frame to be consumed    while (!frames->rendering_frame_consumed && !frames->stopped) {        cond_wait(frames->rendering_frame_consumed_cond, frames->mutex);    }#else    if (!frames->rendering_frame_consumed) {        SDL_LogDebug(SDL_LOG_CATEGORY_RENDER, "Skip frame");    }#endif    frames_swap(frames);    SDL_bool previous_frame_consumed = frames->rendering_frame_consumed;    frames->rendering_frame_consumed = SDL_FALSE;    mutex_unlock(frames->mutex);    return previous_frame_consumed;}
SDL_bool frames_offer_decoded_frame(struct frames *frames) {    mutex_lock(frames->mutex);#ifndef SKIP_FRAMES    // if SKIP_FRAMES is disabled, then the decoder must wait for the current    // frame to be consumed    while (!frames->rendering_frame_consumed && !frames->stopped) {        cond_wait(frames->rendering_frame_consumed_cond, frames->mutex);    }#else    if (!frames->rendering_frame_consumed) {        SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Skip frame");    }#endif    frames_swap(frames);    SDL_bool previous_frame_consumed = frames->rendering_frame_consumed;    frames->rendering_frame_consumed = SDL_FALSE;    mutex_unlock(frames->mutex);    return previous_frame_consumed;}
void cond_wait(SDL_cond *cond, SDL_mutex *mutex) {    if (SDL_CondWait(cond, mutex)) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not wait on condition");        abort();    }}
void mutex_lock(SDL_mutex *mutex) {    if (SDL_LockMutex(mutex)) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not lock mutex");        abort();    }}
void mutex_unlock(SDL_mutex *mutex) {    if (SDL_UnlockMutex(mutex)) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not unlock mutex");        abort();    }}
void cond_signal(SDL_cond *cond) {    if (SDL_CondSignal(cond)) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not signal a condition");        abort();    }}
void cond_wait(SDL_cond *cond, SDL_mutex *mutex) {    if (SDL_CondWait(cond, mutex)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not wait on condition");        abort();    }}
void mutex_lock(SDL_mutex *mutex) {    if (SDL_LockMutex(mutex)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not lock mutex");        abort();    }}
void mutex_unlock(SDL_mutex *mutex) {    if (SDL_UnlockMutex(mutex)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not unlock mutex");        abort();    }}
void cond_signal(SDL_cond *cond) {    if (SDL_CondSignal(cond)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not signal a condition");        abort();    }}
TCPsocket server_socket_accept(TCPsocket server_socket, Uint32 timeout_ms) {    SDLNet_SocketSet set = SDLNet_AllocSocketSet(1);    if (!set) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not allocate socket set");        return NULL;    }    if (SDLNet_TCP_AddSocket(set, server_socket) == -1) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not add socket to set");        SDLNet_FreeSocketSet(set);        return NULL;    }    if (SDLNet_CheckSockets(set, timeout_ms) != 1) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "No connection to accept");        SDLNet_FreeSocketSet(set);        return NULL;    }    SDLNet_FreeSocketSet(set);    return SDLNet_TCP_Accept(server_socket);}
TCPsocket server_socket_accept(TCPsocket server_socket, Uint32 timeout_ms) {    SDLNet_SocketSet set = SDLNet_AllocSocketSet(1);    if (!set) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not allocate socket set");        return NULL;    }    if (SDLNet_TCP_AddSocket(set, server_socket) == -1) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not add socket to set");        SDLNet_FreeSocketSet(set);        return NULL;    }    if (SDLNet_CheckSockets(set, timeout_ms) != 1) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "No connection to accept");        SDLNet_FreeSocketSet(set);        return NULL;    }    SDLNet_FreeSocketSet(set);    return SDLNet_TCP_Accept(server_socket);}
static SDL_bool get_preferred_display_bounds(struct size *bounds) {    SDL_Rect rect;#if SDL_VERSION_ATLEAST(2, 0, 5)# define GET_DISPLAY_BOUNDS(i, r) SDL_GetDisplayUsableBounds((i), (r))#else# define GET_DISPLAY_BOUNDS(i, r) SDL_GetDisplayBounds((i), (r))#endif    if (GET_DISPLAY_BOUNDS(0, &rect)) {        SDL_LogWarn(SDL_LOG_CATEGORY_SYSTEM, "Could not get display usable bounds: %s", SDL_GetError());        return SDL_FALSE;    }    bounds->width = MAX(0, rect.w - DISPLAY_MARGINS);    bounds->height = MAX(0, rect.h - DISPLAY_MARGINS);    return SDL_TRUE;}
SDL_bool screen_init_rendering(struct screen *screen, const char *device_name, struct size frame_size) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height, SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE);    if (!screen->window) {        SDL_LogCritical(SDL_LOG_CATEGORY_SYSTEM, "Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1, SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    screen->texture = SDL_CreateTexture(screen->renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                                        frame_size.width, frame_size.height);    if (!screen->texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    screen_render(screen);    return SDL_TRUE;}
SDL_bool sdl_init_and_configure(void) {    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        return SDL_FALSE;    }    atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable bilinear filtering");    }#if SDL_VERSION_ATLEAST(2, 0, 5)    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO, "Could not enable mouse focus clickthrough");    }#endif    return SDL_TRUE;}
static SDL_bool prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width || screen->frame_size.height != new_frame_size.height) {        if (SDL_RenderSetLogicalSize(screen->renderer, new_frame_size.width, new_frame_size.height)) {            SDL_LogError(SDL_LOG_CATEGORY_RENDER, "Could not set renderer logical size: %s", SDL_GetError());            return SDL_FALSE;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        struct size current_size = get_window_size(screen);        struct size target_size = {            (Uint32) current_size.width * new_frame_size.width / screen->frame_size.width,            (Uint32) current_size.height * new_frame_size.height / screen->frame_size.height,        };        target_size = get_optimal_size(target_size, new_frame_size);        set_window_size(screen, target_size);        screen->frame_size = new_frame_size;        SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = SDL_CreateTexture(screen->renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                                            new_frame_size.width, new_frame_size.height);        if (!screen->texture) {            SDL_LogCritical(SDL_LOG_CATEGORY_RENDER, "Could not create texture: %s", SDL_GetError());            return SDL_FALSE;        }    }    return SDL_TRUE;}
static SDL_bool get_preferred_display_bounds(struct size *bounds) {    SDL_Rect rect;#if SDL_VERSION_ATLEAST(2, 0, 5)# define GET_DISPLAY_BOUNDS(i, r) SDL_GetDisplayUsableBounds((i), (r))#else# define GET_DISPLAY_BOUNDS(i, r) SDL_GetDisplayBounds((i), (r))#endif    if (GET_DISPLAY_BOUNDS(0, &rect)) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not get display usable bounds: %s", SDL_GetError());        return SDL_FALSE;    }    bounds->width = MAX(0, rect.w - DISPLAY_MARGINS);    bounds->height = MAX(0, rect.h - DISPLAY_MARGINS);    return SDL_TRUE;}
SDL_bool screen_init_rendering(struct screen *screen, const char *device_name, struct size frame_size) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height, SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE);    if (!screen->window) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not create window: %s", SDL_GetError());        return SDL_FALSE;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1, SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width, frame_size.height)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (!icon) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not load icon: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    SDL_SetWindowIcon(screen->window, icon);    SDL_FreeSurface(icon);    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width, frame_size.height);    screen->texture = SDL_CreateTexture(screen->renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                                        frame_size.width, frame_size.height);    if (!screen->texture) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return SDL_FALSE;    }    screen_render(screen);    return SDL_TRUE;}
SDL_bool sdl_init_and_configure(void) {    if (SDL_Init(SDL_INIT_VIDEO)) {        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());        return SDL_FALSE;    }    atexit(SDL_Quit);    // Bilinear resizing    if (!SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not enable bilinear filtering");    }#if SDL_VERSION_ATLEAST(2, 0, 5)    // Handle a click to gain focus as any other click    if (!SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, "1")) {        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Could not enable mouse focus clickthrough");    }#endif    return SDL_TRUE;}
static SDL_bool prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width || screen->frame_size.height != new_frame_size.height) {        if (SDL_RenderSetLogicalSize(screen->renderer, new_frame_size.width, new_frame_size.height)) {            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not set renderer logical size: %s", SDL_GetError());            return SDL_FALSE;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        struct size current_size = get_window_size(screen);        struct size target_size = {            (Uint32) current_size.width * new_frame_size.width / screen->frame_size.width,            (Uint32) current_size.height * new_frame_size.height / screen->frame_size.height,        };        target_size = get_optimal_size(target_size, new_frame_size);        set_window_size(screen, target_size);        screen->frame_size = new_frame_size;        SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = SDL_CreateTexture(screen->renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING,                                            new_frame_size.width, new_frame_size.height);        if (!screen->texture) {            SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, "Could not create texture: %s", SDL_GetError());            return SDL_FALSE;        }    }    return SDL_TRUE;}
static void terminate_server(process_t server) {    if (!cmd_terminate(server)) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not terminate server: %s", strerror(errno));    }}
static void terminate_server(process_t server) {    if (!cmd_terminate(server)) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not terminate server: %s", strerror(errno));    }}
SDL_Surface *read_xpm(char *xpm[]) {#if SDL_ASSERT_LEVEL >= 2    // patch the XPM to change the icon color in debug mode    xpm[2] = ".	c #CC00CC";#endif    char *endptr;    // *** No error handling, assume the XPM source is valid ***    // (it's in our source repo)    // Assertions are only checked in debug    Uint32 width = strtol(xpm[0], &endptr, 10);    Uint32 height = strtol(endptr + 1, &endptr, 10);    Uint32 colors = strtol(endptr + 1, &endptr, 10);    Uint32 chars = strtol(endptr + 1, &endptr, 10);    // sanity checks    SDL_assert(width < 256);    SDL_assert(height < 256);    SDL_assert(colors < 256);    SDL_assert(chars == 1); // this implementation does not support more    // init index    struct index index[colors];    for (int i = 0; i < colors; ++i) {        const char *line = xpm[1+i];        index[i].c = line[0];        SDL_assert(line[1] == '\t');        SDL_assert(line[2] == 'c');        SDL_assert(line[3] == ' ');        if (line[4] == '#') {            index[i].color = 0xff000000 | strtol(&line[5], &endptr, 0x10);            SDL_assert(*endptr == '\0');        } else {            SDL_assert(!strcmp("None", &line[4]));            index[i].color = 0;        }    }    // parse image    Uint32 *pixels = SDL_malloc(4 * width * height);    if (!pixels) {        SDL_LogError(SDL_LOG_CATEGORY_SYSTEM, "Could not allocate icon memory");        return NULL;    }    for (int y = 0; y < height; ++y) {        const char *line = xpm[1 + colors + y];        for (int x = 0; x < width; ++x) {            char c = line[x];            Uint32 color;            SDL_bool color_found = find_color(index, colors, c, &color);            SDL_assert(color_found);            pixels[y * width + x] = color;        }    }#if SDL_BYTEORDER == SDL_BIG_ENDIAN    Uint32 amask = 0x000000ff;    Uint32 rmask = 0x0000ff00;    Uint32 gmask = 0x00ff0000;    Uint32 bmask = 0xff000000;#else // little endian, like x86    Uint32 amask = 0xff000000;    Uint32 rmask = 0x00ff0000;    Uint32 gmask = 0x0000ff00;    Uint32 bmask = 0x000000ff;#endif    SDL_Surface *surface = SDL_CreateRGBSurfaceFrom(pixels,                                                    width, height,                                                    32, 4 * width,                                                    rmask, gmask, bmask, amask);    // make the surface own the raw pixels    surface->flags &= ~SDL_PREALLOC;    return surface;}
SDL_Surface *read_xpm(char *xpm[]) {#if SDL_ASSERT_LEVEL >= 2    // patch the XPM to change the icon color in debug mode    xpm[2] = ".	c #CC00CC";#endif    char *endptr;    // *** No error handling, assume the XPM source is valid ***    // (it's in our source repo)    // Assertions are only checked in debug    Uint32 width = strtol(xpm[0], &endptr, 10);    Uint32 height = strtol(endptr + 1, &endptr, 10);    Uint32 colors = strtol(endptr + 1, &endptr, 10);    Uint32 chars = strtol(endptr + 1, &endptr, 10);    // sanity checks    SDL_assert(width < 256);    SDL_assert(height < 256);    SDL_assert(colors < 256);    SDL_assert(chars == 1); // this implementation does not support more    // init index    struct index index[colors];    for (int i = 0; i < colors; ++i) {        const char *line = xpm[1+i];        index[i].c = line[0];        SDL_assert(line[1] == '\t');        SDL_assert(line[2] == 'c');        SDL_assert(line[3] == ' ');        if (line[4] == '#') {            index[i].color = 0xff000000 | strtol(&line[5], &endptr, 0x10);            SDL_assert(*endptr == '\0');        } else {            SDL_assert(!strcmp("None", &line[4]));            index[i].color = 0;        }    }    // parse image    Uint32 *pixels = SDL_malloc(4 * width * height);    if (!pixels) {        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not allocate icon memory");        return NULL;    }    for (int y = 0; y < height; ++y) {        const char *line = xpm[1 + colors + y];        for (int x = 0; x < width; ++x) {            char c = line[x];            Uint32 color;            SDL_bool color_found = find_color(index, colors, c, &color);            SDL_assert(color_found);            pixels[y * width + x] = color;        }    }#if SDL_BYTEORDER == SDL_BIG_ENDIAN    Uint32 amask = 0x000000ff;    Uint32 rmask = 0x0000ff00;    Uint32 gmask = 0x00ff0000;    Uint32 bmask = 0xff000000;#else // little endian, like x86    Uint32 amask = 0xff000000;    Uint32 rmask = 0x00ff0000;    Uint32 gmask = 0x0000ff00;    Uint32 bmask = 0x000000ff;#endif    SDL_Surface *surface = SDL_CreateRGBSurfaceFrom(pixels,                                                    width, height,                                                    32, 4 * width,                                                    rmask, gmask, bmask, amask);    // make the surface own the raw pixels    surface->flags &= ~SDL_PREALLOC;    return surface;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    // initialize the receiver state    decoder->receiver_state.frame_meta_queue = NULL;    decoder->receiver_state.remaining = 0;    // if recording is enabled, a "header" is sent between raw packets    int (*read_packet)(void *, uint8_t *, int) =            decoder->recorder ? read_packet_with_meta : read_raw_packet;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder,                                               read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#ifdef SCRCPY_LAVF_HAS_NEW_ENCODING_DECODING_API        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->video_buffer->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        while (packet.size > 0) {            int got_picture;            int len = avcodec_decode_video2(codec_ctx, decoder->video_buffer->decoding_frame, &got_picture, &packet);            if (len < 0) {                LOGE("Could not decode video packet: %d", len);                av_packet_unref(&packet);                goto run_quit;            }            if (got_picture) {                push_frame(decoder);            }            packet.size -= len;            packet.data += len;        }#endif        if (decoder->recorder) {            // we retrieve the PTS in order they were received, so they will            // be assigned to the correct frame            uint64_t pts = receiver_state_take_meta(&decoder->receiver_state);            packet.pts = pts;            packet.dts = pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(decoder->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto run_quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_free(avio_ctx->buffer);    av_free(avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
static int run_decoder(void *data) {    struct decoder *decoder = data;    AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_H264);    if (!codec) {        LOGE("H.264 decoder not found");        goto run_end;    }    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);    if (!codec_ctx) {        LOGC("Could not allocate decoder context");        goto run_end;    }    if (avcodec_open2(codec_ctx, codec, NULL) < 0) {        LOGE("Could not open H.264 codec");        goto run_finally_free_codec_ctx;    }    AVFormatContext *format_ctx = avformat_alloc_context();    if (!format_ctx) {        LOGC("Could not allocate format context");        goto run_finally_close_codec;    }    unsigned char *buffer = av_malloc(BUFSIZE);    if (!buffer) {        LOGC("Could not allocate buffer");        goto run_finally_free_format_ctx;    }    // initialize the receiver state    decoder->receiver_state.frame_meta_queue = NULL;    decoder->receiver_state.remaining = 0;    // if recording is enabled, a "header" is sent between raw packets    int (*read_packet)(void *, uint8_t *, int) =            decoder->recorder ? read_packet_with_meta : read_raw_packet;    AVIOContext *avio_ctx = avio_alloc_context(buffer, BUFSIZE, 0, decoder,                                               read_packet, NULL, NULL);    if (!avio_ctx) {        LOGC("Could not allocate avio context");        // avformat_open_input takes ownership of 'buffer'        // so only free the buffer before avformat_open_input()        av_free(buffer);        goto run_finally_free_format_ctx;    }    format_ctx->pb = avio_ctx;    if (avformat_open_input(&format_ctx, NULL, NULL, NULL) < 0) {        LOGE("Could not open video stream");        goto run_finally_free_avio_ctx;    }    if (decoder->recorder &&            !recorder_open(decoder->recorder, codec)) {        LOGE("Could not open recorder");        goto run_finally_close_input;    }    AVPacket packet;    av_init_packet(&packet);    packet.data = NULL;    packet.size = 0;    while (!av_read_frame(format_ctx, &packet)) {// the new decoding/encoding API has been introduced by:// <http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=7fc329e2dd6226dfecaa4a1d7adf353bf2773726>#ifdef SCRCPY_LAVF_HAS_NEW_ENCODING_DECODING_API        int ret;        if ((ret = avcodec_send_packet(codec_ctx, &packet)) < 0) {            LOGE("Could not send video packet: %d", ret);            goto run_quit;        }        ret = avcodec_receive_frame(codec_ctx, decoder->video_buffer->decoding_frame);        if (!ret) {            // a frame was received            push_frame(decoder);        } else if (ret != AVERROR(EAGAIN)) {            LOGE("Could not receive video frame: %d", ret);            av_packet_unref(&packet);            goto run_quit;        }#else        int got_picture;        int len = avcodec_decode_video2(codec_ctx, decoder->video_buffer->decoding_frame, &got_picture, &packet);        if (len < 0) {            LOGE("Could not decode video packet: %d", len);            av_packet_unref(&packet);            goto run_quit;        }        if (got_picture) {            push_frame(decoder);        }#endif        if (decoder->recorder) {            // we retrieve the PTS in order they were received, so they will            // be assigned to the correct frame            uint64_t pts = receiver_state_take_meta(&decoder->receiver_state);            packet.pts = pts;            packet.dts = pts;            // no need to rescale with av_packet_rescale_ts(), the timestamps            // are in microseconds both in input and output            if (!recorder_write(decoder->recorder, &packet)) {                LOGE("Could not write frame to output file");                av_packet_unref(&packet);                goto run_quit;            }        }        av_packet_unref(&packet);        if (avio_ctx->eof_reached) {            break;        }    }    LOGD("End of frames");run_quit:    if (decoder->recorder) {        recorder_close(decoder->recorder);    }run_finally_close_input:    avformat_close_input(&format_ctx);run_finally_free_avio_ctx:    av_free(avio_ctx->buffer);    av_free(avio_ctx);run_finally_free_format_ctx:    avformat_free_context(format_ctx);run_finally_close_codec:    avcodec_close(codec_ctx);run_finally_free_codec_ctx:    avcodec_free_context(&codec_ctx);    notify_stopped();run_end:    return 0;}
    public EventController(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;        initPointer();        // on start, turn screen on        turnScreenOn();    }
    public void control() throws IOException {        while (true) {            handleEvent();        }    }
    public EventController(Device device, DesktopConnection connection) {        this.device = device;        this.connection = connection;        initPointer();    }    private void initPointer() {        MotionEvent.PointerProperties props = pointerProperties[0];        props.id = 0;
    public void control() throws IOException {        // on start, turn screen on        turnScreenOn();        while (true) {            handleEvent();        }    }
recorder_write_header(struct recorder *recorder, AVPacket *packet) {    AVStream *ostream = recorder->ctx->streams[0];    uint8_t *extradata = SDL_malloc(packet->size * sizeof(uint8_t));    if (!extradata) {        LOGC("Cannot allocate extradata");        return SDL_FALSE;    }    // copy the first packet to the extra data    memcpy(extradata, packet->data, packet->size);#ifdef LAVF_NEW_CODEC_API    ostream->codecpar->extradata = extradata;    ostream->codecpar->extradata_size = packet->size;#else    ostream->codec->extradata = extradata;    ostream->codec->extradata_size = packet->size;#endif    int ret = avformat_write_header(recorder->ctx, NULL);    if (ret < 0) {        LOGE("Failed to write header to %s", recorder->filename);        SDL_free(extradata);        avio_closep(&recorder->ctx->pb);        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    return SDL_TRUE;}
recorder_write_header(struct recorder *recorder, AVPacket *packet) {    AVStream *ostream = recorder->ctx->streams[0];    uint8_t *extradata = av_malloc(packet->size * sizeof(uint8_t));    if (!extradata) {        LOGC("Cannot allocate extradata");        return SDL_FALSE;    }    // copy the first packet to the extra data    memcpy(extradata, packet->data, packet->size);#ifdef LAVF_NEW_CODEC_API    ostream->codecpar->extradata = extradata;    ostream->codecpar->extradata_size = packet->size;#else    ostream->codec->extradata = extradata;    ostream->codec->extradata_size = packet->size;#endif    int ret = avformat_write_header(recorder->ctx, NULL);    if (ret < 0) {        LOGE("Failed to write header to %s", recorder->filename);        SDL_free(extradata);        avio_closep(&recorder->ctx->pb);        avformat_free_context(recorder->ctx);        return SDL_FALSE;    }    return SDL_TRUE;}
    public EventController(DesktopConnection connection) {        this.connection = connection;        inputManager = DeviceUtil.getInputManager();        initPointer();    }
    public EventController(DesktopConnection connection) {        this.connection = connection;        inputManager = Device.getInstance().getInputManager();        initPointer();    }
    private static void scrcpy() throws IOException {        String deviceName = DeviceUtil.getDeviceName();        ScreenInfo initialScreenInfo = DeviceUtil.getScreenInfo();        int width = initialScreenInfo.getLogicalWidth();        int height = initialScreenInfo.getLogicalHeight();        try (DesktopConnection connection = DesktopConnection.open(deviceName, width, height)) {            try {                // asynchronous                startEventController(connection);                // synchronous                new ScreenStreamer(connection).streamScreen();            } catch (IOException e) {                Ln.e("Screen streaming interrupted", e);            }        }    }
    private static void scrcpy() throws IOException {        String deviceName = Device.getDeviceName();        ScreenInfo initialScreenInfo = Device.getInstance().getScreenInfo();        int width = initialScreenInfo.getLogicalWidth();        int height = initialScreenInfo.getLogicalHeight();        try (DesktopConnection connection = DesktopConnection.open(deviceName, width, height)) {            final ScreenStreamer streamer = new ScreenStreamer(connection);            Device.getInstance().setRotationListener(new Device.RotationListener() {                @Override                public void onRotationChanged(int rotation) {                    streamer.reset();                }            });            // asynchronous            startEventController(connection);            try {                // synchronous                streamer.streamScreen();            } catch (IOException e) {                Ln.e("Screen streaming interrupted", e);            }        }    }
    public ScreenStreamer(DesktopConnection connection) {        this.connection = connection;        DeviceUtil.registerRotationWatcher(new IRotationWatcher.Stub() {            @Override            public void onRotationChanged(int rotation) throws RemoteException {                reset();            }        });    }
    private synchronized ScreenStreamerSession newScreenStreamerSession() {        currentStreamer = new ScreenStreamerSession(connection);        return currentStreamer;    }    public void streamScreen() throws IOException {        while (true) {            try {                ScreenStreamerSession screenStreamer = newScreenStreamerSession();
process_t adb_install(const char *serial, const char *local) {    const char *const adb_cmd[] = {"install", "-r", local};    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
process_t adb_install(const char *serial, const char *local) {#ifdef __WINDOWS__    // Windows will parse the string, so the local name must be quoted (see sys/win/command.c)    size_t len = strlen(local);    char quoted[len + 3];    memcpy(&quoted[1], local, len);    quoted[0] = '"';    quoted[len + 1] = '"';    quoted[len + 2] = '\0';    local = quoted;#endif    const char *const adb_cmd[] = {"install", "-r", local};    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
SDL_bool input_key_from_sdl_to_android(const SDL_KeyboardEvent *from,                                       struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_KEYCODE;    if (!convert_keycode_action(from->type, &to->keycode_event.action)) {        return SDL_FALSE;    }    if (!convert_keycode(from->keysym.sym, &to->keycode_event.keycode)) {        return SDL_FALSE;    }    to->keycode_event.metastate = convert_meta_state(from->keysym.mod);    return SDL_TRUE;}
static SDL_bool convert_keycode(SDL_Keycode from, enum android_keycode *to) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_HOME,         AKEYCODE_HOME);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);        FAIL;    }}
static SDL_bool convert_keycode(SDL_Keycode from, enum android_keycode *to) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_HOME,         AKEYCODE_HOME);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);        FAIL;    }}
SDL_bool input_key_from_sdl_to_android(const SDL_KeyboardEvent *from,                                       struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_KEYCODE;    if (!convert_keycode_action(from->type, &to->keycode_event.action)) {        return SDL_FALSE;    }    Uint16 mod = from->keysym.mod;    if (!convert_keycode(from->keysym.sym, &to->keycode_event.keycode, mod)) {        return SDL_FALSE;    }    to->keycode_event.metastate = convert_meta_state(mod);    return SDL_TRUE;}
static SDL_bool convert_keycode(SDL_Keycode from, enum android_keycode *to, Uint16 mod) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_HOME,         AKEYCODE_HOME);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);    }    if (mod & (KMOD_LALT | KMOD_RALT | KMOD_LGUI | KMOD_RGUI)) {        return SDL_FALSE;    }
static SDL_bool convert_keycode(SDL_Keycode from, enum android_keycode *to, Uint16 mod) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_HOME,         AKEYCODE_HOME);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);    }    if (mod & (KMOD_LALT | KMOD_RALT | KMOD_LGUI | KMOD_RGUI)) {        return SDL_FALSE;    }    // if ALT and META are not pressed, also handle letters and space    switch (from) {        MAP(SDLK_a,            AKEYCODE_A);        MAP(SDLK_b,            AKEYCODE_B);        MAP(SDLK_c,            AKEYCODE_C);        MAP(SDLK_d,            AKEYCODE_D);        MAP(SDLK_e,            AKEYCODE_E);        MAP(SDLK_f,            AKEYCODE_F);        MAP(SDLK_g,            AKEYCODE_G);        MAP(SDLK_h,            AKEYCODE_H);        MAP(SDLK_i,            AKEYCODE_I);        MAP(SDLK_j,            AKEYCODE_J);        MAP(SDLK_k,            AKEYCODE_K);        MAP(SDLK_l,            AKEYCODE_L);        MAP(SDLK_m,            AKEYCODE_M);        MAP(SDLK_n,            AKEYCODE_N);        MAP(SDLK_o,            AKEYCODE_O);        MAP(SDLK_p,            AKEYCODE_P);        MAP(SDLK_q,            AKEYCODE_Q);        MAP(SDLK_r,            AKEYCODE_R);        MAP(SDLK_s,            AKEYCODE_S);        MAP(SDLK_t,            AKEYCODE_T);        MAP(SDLK_u,            AKEYCODE_U);        MAP(SDLK_v,            AKEYCODE_V);        MAP(SDLK_w,            AKEYCODE_W);        MAP(SDLK_x,            AKEYCODE_X);        MAP(SDLK_y,            AKEYCODE_Y);        MAP(SDLK_z,            AKEYCODE_Z);        MAP(SDLK_SPACE,        AKEYCODE_SPACE);        FAIL;    }}
void input_manager_process_text_input(struct input_manager *input_manager,                                      const SDL_TextInputEvent *event) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    control_event.text_event.text = SDL_strdup(event->text);    if (!control_event.text_event.text) {        LOGW("Cannot strdup input text");        return;    }    if (!controller_push_event(input_manager->controller, &control_event)) {        LOGW("Cannot send text event");    }}
void input_manager_process_text_input(struct input_manager *input_manager,                                      const SDL_TextInputEvent *event) {    char c = event->text[0];    if (isalpha(c) || c == ' ') {        SDL_assert(event->text[1] == '\0');        // letters and space are handled as raw key event        return;    }    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_TEXT;    control_event.text_event.text = SDL_strdup(event->text);    if (!control_event.text_event.text) {        LOGW("Cannot strdup input text");        return;    }    if (!controller_push_event(input_manager->controller, &control_event)) {        LOGW("Cannot send text event");    }}
process_msg(struct receiver *receiver, struct device_msg *msg) {    switch (msg->type) {        case DEVICE_MSG_TYPE_CLIPBOARD:            SDL_SetClipboardText(msg->clipboard.text);            break;    }}
process_msg(struct receiver *receiver, struct device_msg *msg) {    switch (msg->type) {        case DEVICE_MSG_TYPE_CLIPBOARD:            LOGI("Device clipboard copied");            SDL_SetClipboardText(msg->clipboard.text);            break;    }}
    public void setClipboardText(String text) {        serviceManager.getClipboardManager().setText(text);    }
    public void setClipboardText(String text) {        serviceManager.getClipboardManager().setText(text);        Ln.i("Device clipboard set");    }
void input_manager_process_mouse_button(struct input_manager *input_manager,                                        const SDL_MouseButtonEvent *event) {    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(input_manager->controller);            return;        }        if (event->button == SDL_BUTTON_MIDDLE) {            action_home(input_manager->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            SDL_bool outside_device_screen =                    event->x < 0 || event->x >= input_manager->screen->frame_size.width ||                    event->y < 0 || event->y >= input_manager->screen->frame_size.height;            if (outside_device_screen) {                screen_resize_to_fit(input_manager->screen);                return;            }            // otherwise, send the click event to the device        }    };    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, input_manager->screen->frame_size, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send mouse button event");        }    }}
void input_manager_process_mouse_button(struct input_manager *input_manager,                                        const SDL_MouseButtonEvent *event) {    if (event->type == SDL_MOUSEBUTTONDOWN) {        if (event->button == SDL_BUTTON_RIGHT) {            press_back_or_turn_screen_on(input_manager->controller);            return;        }        if (event->button == SDL_BUTTON_MIDDLE) {            action_home(input_manager->controller, ACTION_DOWN | ACTION_UP);            return;        }        // double-click on black borders resize to fit the device screen        if (event->button == SDL_BUTTON_LEFT && event->clicks == 2) {            SDL_bool outside_device_screen =                    event->x < 0 || event->x >= input_manager->screen->frame_size.width ||                    event->y < 0 || event->y >= input_manager->screen->frame_size.height;            if (outside_device_screen) {                screen_resize_to_fit(input_manager->screen);                return;            }            // otherwise, send the click event to the device        }    }    struct control_event control_event;    if (mouse_button_from_sdl_to_android(event, input_manager->screen->frame_size, &control_event)) {        if (!controller_push_event(input_manager->controller, &control_event)) {            LOGW("Cannot send mouse button event");        }    }}
control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            buffer_write32be(&buf[2], event->keycode_event.keycode);            buffer_write32be(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (2 bytes) + string (non nul-terminated)            size_t len = strlen(event->text_event.text);            if (len > CONTROL_EVENT_TEXT_MAX_LENGTH) {                // injecting a text takes time, so limit the text length                len = CONTROL_EVENT_TEXT_MAX_LENGTH;            }            buffer_write16be(&buf[1], (uint16_t) len);            memcpy(&buf[3], event->text_event.text, len);            return 3 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            buffer_write32be(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 18;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            buffer_write32be(&buf[13], (uint32_t) event->scroll_event.hscroll);            buffer_write32be(&buf[17], (uint32_t) event->scroll_event.vscroll);            return 21;        case CONTROL_EVENT_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_EVENT_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_EVENT_TYPE_COLLAPSE_NOTIFICATION_PANEL:            // no additional data            return 1;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            buffer_write32be(&buf[2], event->keycode_event.keycode);            buffer_write32be(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            // write length (2 bytes) + string (non nul-terminated)            // injecting a text takes time, so limit the text length            size_t len = utf8_truncation_index(event->text_event.text,                                               CONTROL_EVENT_TEXT_MAX_LENGTH);            buffer_write16be(&buf[1], (uint16_t) len);            memcpy(&buf[3], event->text_event.text, len);            return 3 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            buffer_write32be(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 18;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            buffer_write32be(&buf[13], (uint32_t) event->scroll_event.hscroll);            buffer_write32be(&buf[17], (uint32_t) event->scroll_event.vscroll);            return 21;        case CONTROL_EVENT_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_EVENT_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_EVENT_TYPE_COLLAPSE_NOTIFICATION_PANEL:            // no additional data            return 1;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            buffer_write32be(&buf[2], event->keycode_event.keycode);            buffer_write32be(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            size_t len = write_string(event->text_event.text,                                      CONTROL_EVENT_TEXT_MAX_LENGTH, &buf[1]);            return 1 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            buffer_write32be(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 18;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            buffer_write32be(&buf[13], (uint32_t) event->scroll_event.hscroll);            buffer_write32be(&buf[17], (uint32_t) event->scroll_event.vscroll);            return 21;        case CONTROL_EVENT_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_EVENT_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_EVENT_TYPE_COLLAPSE_NOTIFICATION_PANEL:            // no additional data            return 1;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
control_event_serialize(const struct control_event *event, unsigned char *buf) {    buf[0] = event->type;    switch (event->type) {        case CONTROL_EVENT_TYPE_KEYCODE:            buf[1] = event->keycode_event.action;            buffer_write32be(&buf[2], event->keycode_event.keycode);            buffer_write32be(&buf[6], event->keycode_event.metastate);            return 10;        case CONTROL_EVENT_TYPE_TEXT: {            size_t len = write_string(event->text_event.text,                                      CONTROL_EVENT_TEXT_MAX_LENGTH, &buf[1]);            return 1 + len;        }        case CONTROL_EVENT_TYPE_MOUSE:            buf[1] = event->mouse_event.action;            buffer_write32be(&buf[2], event->mouse_event.buttons);            write_position(&buf[6], &event->mouse_event.position);            return 18;        case CONTROL_EVENT_TYPE_SCROLL:            write_position(&buf[1], &event->scroll_event.position);            buffer_write32be(&buf[13], (uint32_t) event->scroll_event.hscroll);            buffer_write32be(&buf[17], (uint32_t) event->scroll_event.vscroll);            return 21;        case CONTROL_EVENT_TYPE_BACK_OR_SCREEN_ON:        case CONTROL_EVENT_TYPE_EXPAND_NOTIFICATION_PANEL:        case CONTROL_EVENT_TYPE_COLLAPSE_NOTIFICATION_PANEL:        case CONTROL_EVENT_TYPE_GET_CLIPBOARD:            // no additional data            return 1;        default:            LOGW("Unknown event type: %u", (unsigned) event->type);            return 0;    }}
    SDL_GetMouseState(&x, &y);    convert_to_renderer_coordinates(screen->renderer, &x, &y);    return (struct point) {        .x = x,        .y = y,    };}static const int ACTION_DOWN = 1;static const int ACTION_UP = 1 << 1;static voidsend_keycode(struct controller *controller, enum android_keycode keycode,             int actions, const char *name) {    // send DOWN event    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_KEYCODE;    control_event.keycode_event.keycode = keycode;    control_event.keycode_event.metastate = 0;    if (actions & ACTION_DOWN) {        control_event.keycode_event.action = AKEY_EVENT_ACTION_DOWN;        if (!controller_push_event(controller, &control_event)) {            LOGW("Cannot send %s (DOWN)", name);            return;        }    }    if (actions & ACTION_UP) {        control_event.keycode_event.action = AKEY_EVENT_ACTION_UP;        if (!controller_push_event(controller, &control_event)) {            LOGW("Cannot send %s (UP)", name);        }    }
request_device_clipboard(struct controller *controller) {    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_GET_CLIPBOARD;    if (!controller_push_event(controller, &control_event)) {        LOGW("Cannot get device clipboard");    }}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+c\n"        "        copy device clipboard to computer\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
            .text = "hello, world!",        },    };    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 16);    const unsigned char expected[] = {        0x01, // CONTROL_EVENT_TYPE_TEXT        0x00, 0x0d, // text length        'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', // text    };    assert(!memcmp(buf, expected, sizeof(expected)));}static void test_serialize_long_text_event(void) {    struct control_event event;    event.type = CONTROL_EVENT_TYPE_TEXT;    char text[CONTROL_EVENT_TEXT_MAX_LENGTH + 1];    memset(text, 'a', sizeof(text));    text[CONTROL_EVENT_TEXT_MAX_LENGTH] = '\0';    event.text_event.text = text;    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 3 + CONTROL_EVENT_TEXT_MAX_LENGTH);    unsigned char expected[3 + CONTROL_EVENT_TEXT_MAX_LENGTH];    expected[0] = 0x01; // CONTROL_EVENT_TYPE_KEYCODE    expected[1] = 0x01;    expected[2] = 0x2c; // text length (16 bits)    memset(&expected[3], 'a', CONTROL_EVENT_TEXT_MAX_LENGTH);    assert(!memcmp(buf, expected, sizeof(expected)));}static void test_serialize_mouse_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_MOUSE,        .mouse_event = {            .action = AMOTION_EVENT_ACTION_DOWN,            .buttons = AMOTION_EVENT_BUTTON_PRIMARY,            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },        },    };    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 18);    const unsigned char expected[] = {        0x02, // CONTROL_EVENT_TYPE_MOUSE        0x00, // AKEY_EVENT_ACTION_DOWN        0x00, 0x00, 0x00, 0x01, // AMOTION_EVENT_BUTTON_PRIMARY        0x00, 0x00, 0x01, 0x04, 0x00, 0x00, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920    };    assert(!memcmp(buf, expected, sizeof(expected)));}static void test_serialize_scroll_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_SCROLL,        .scroll_event = {            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },            .hscroll = 1,            .vscroll = -1,        },    };    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 21);    const unsigned char expected[] = {        0x03, // CONTROL_EVENT_TYPE_SCROLL        0x00, 0x00, 0x01, 0x04, 0x00, 0x00, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920        0x00, 0x00, 0x00, 0x01, // 1        0xFF, 0xFF, 0xFF, 0xFF, // -1    };    assert(!memcmp(buf, expected, sizeof(expected)));}static void test_serialize_back_or_screen_on_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_BACK_OR_SCREEN_ON,    };    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 1);    const unsigned char expected[] = {        0x04, // CONTROL_EVENT_TYPE_BACK_OR_SCREEN_ON    };    assert(!memcmp(buf, expected, sizeof(expected)));}static void test_serialize_expand_notification_panel_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_EXPAND_NOTIFICATION_PANEL,    };
int main(void) {    test_serialize_keycode_event();    test_serialize_text_event();    test_serialize_long_text_event();    test_serialize_mouse_event();    test_serialize_scroll_event();    test_serialize_back_or_screen_on_event();    test_serialize_expand_notification_panel_event();    test_serialize_collapse_notification_panel_event();    return 0;}
static void test_serialize_get_clipboard_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_GET_CLIPBOARD,    };    unsigned char buf[CONTROL_EVENT_SERIALIZED_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 1);    const unsigned char expected[] = {        0x07, // CONTROL_EVENT_TYPE_GET_CLIPBOARD    };    assert(!memcmp(buf, expected, sizeof(expected)));}
int main(void) {    test_serialize_keycode_event();    test_serialize_text_event();    test_serialize_long_text_event();    test_serialize_mouse_event();    test_serialize_scroll_event();    test_serialize_back_or_screen_on_event();    test_serialize_expand_notification_panel_event();    test_serialize_collapse_notification_panel_event();    test_serialize_get_clipboard_event();    return 0;}
    public ControlEvent next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        ControlEvent controlEvent;        switch (type) {            case ControlEvent.TYPE_KEYCODE:                controlEvent = parseKeycodeControlEvent();                break;            case ControlEvent.TYPE_TEXT:                controlEvent = parseTextControlEvent();                break;            case ControlEvent.TYPE_MOUSE:                controlEvent = parseMouseControlEvent();                break;            case ControlEvent.TYPE_SCROLL:                controlEvent = parseScrollControlEvent();                break;            case ControlEvent.TYPE_BACK_OR_SCREEN_ON:            case ControlEvent.TYPE_EXPAND_NOTIFICATION_PANEL:            case ControlEvent.TYPE_COLLAPSE_NOTIFICATION_PANEL:                controlEvent = ControlEvent.createSimpleControlEvent(type);                break;            default:                Ln.w("Unknown event type: " + type);                controlEvent = null;                break;        }        if (controlEvent == null) {            // failure, reset savedPosition            buffer.position(savedPosition);        }        return controlEvent;    }
    public ControlEvent next() {        if (!buffer.hasRemaining()) {            return null;        }        int savedPosition = buffer.position();        int type = buffer.get();        ControlEvent controlEvent;        switch (type) {            case ControlEvent.TYPE_KEYCODE:                controlEvent = parseKeycodeControlEvent();                break;            case ControlEvent.TYPE_TEXT:                controlEvent = parseTextControlEvent();                break;            case ControlEvent.TYPE_MOUSE:                controlEvent = parseMouseControlEvent();                break;            case ControlEvent.TYPE_SCROLL:                controlEvent = parseScrollControlEvent();                break;            case ControlEvent.TYPE_BACK_OR_SCREEN_ON:            case ControlEvent.TYPE_EXPAND_NOTIFICATION_PANEL:            case ControlEvent.TYPE_COLLAPSE_NOTIFICATION_PANEL:            case ControlEvent.TYPE_GET_CLIPBOARD:                controlEvent = ControlEvent.createSimpleControlEvent(type);                break;            default:                Ln.w("Unknown event type: " + type);                controlEvent = null;                break;        }        if (controlEvent == null) {            // failure, reset savedPosition            buffer.position(savedPosition);        }        return controlEvent;    }
        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        Rect contentRect = new Rect(0, 0, deviceSize.getWidth(), deviceSize.getHeight());        if (crop != null) {            if (rotated) {                // the crop (provided by the user) is expressed in the natural orientation                crop = flipRect(crop);            }            if (!contentRect.intersect(crop)) {                // intersect() changes contentRect so that it is intersected with crop                Ln.w("Crop rectangle (" + formatCrop(crop) + ") does not intersect device screen (" + formatCrop(deviceSize.toRect()) + ")");                contentRect = new Rect(); // empty            }        }        Size videoSize = computeVideoSize(contentRect.width(), contentRect.height(), maxSize);        return new ScreenInfo(contentRect, videoSize, rotated);    }    private static String formatCrop(Rect rect) {        return rect.width() + ":" + rect.height() + ":" + rect.left + ":" + rect.top;    }    @SuppressWarnings("checkstyle:MagicNumber")    private static Size computeVideoSize(int w, int h, int maxSize) {        // Compute the video size and the padding of the content inside this video.        // Principle:        // - scale down the great side of the screen to maxSize (if necessary);        // - scale down the other side so that the aspect ratio is preserved;        // - round this value to the nearest multiple of 8 (H.264 only accepts multiples of 8)        w &= ~7; // in case it's not a multiple of 8        h &= ~7;        if (maxSize > 0) {            if (BuildConfig.DEBUG && maxSize % 8 != 0) {                throw new AssertionError("Max size must be a multiple of 8");            }            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;
    public String getClipboardText() {        CharSequence s = serviceManager.getClipboardManager().getText();        if (s == null) {            return null;        }        return s.toString();    }
    private void handleEvent() throws IOException {        ControlEvent controlEvent = connection.receiveControlEvent();        switch (controlEvent.getType()) {            case ControlEvent.TYPE_KEYCODE:                injectKeycode(controlEvent.getAction(), controlEvent.getKeycode(), controlEvent.getMetaState());                break;            case ControlEvent.TYPE_TEXT:                injectText(controlEvent.getText());                break;            case ControlEvent.TYPE_MOUSE:                injectMouse(controlEvent.getAction(), controlEvent.getButtons(), controlEvent.getPosition());                break;            case ControlEvent.TYPE_SCROLL:                injectScroll(controlEvent.getPosition(), controlEvent.getHScroll(), controlEvent.getVScroll());                break;            case ControlEvent.TYPE_BACK_OR_SCREEN_ON:                pressBackOrTurnScreenOn();                break;            case ControlEvent.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlEvent.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            default:                // do nothing        }    }
    private void handleEvent() throws IOException {        ControlEvent controlEvent = connection.receiveControlEvent();        switch (controlEvent.getType()) {            case ControlEvent.TYPE_KEYCODE:                injectKeycode(controlEvent.getAction(), controlEvent.getKeycode(), controlEvent.getMetaState());                break;            case ControlEvent.TYPE_TEXT:                injectText(controlEvent.getText());                break;            case ControlEvent.TYPE_MOUSE:                injectMouse(controlEvent.getAction(), controlEvent.getButtons(), controlEvent.getPosition());                break;            case ControlEvent.TYPE_SCROLL:                injectScroll(controlEvent.getPosition(), controlEvent.getHScroll(), controlEvent.getVScroll());                break;            case ControlEvent.TYPE_BACK_OR_SCREEN_ON:                pressBackOrTurnScreenOn();                break;            case ControlEvent.TYPE_EXPAND_NOTIFICATION_PANEL:                device.expandNotificationPanel();                break;            case ControlEvent.TYPE_COLLAPSE_NOTIFICATION_PANEL:                device.collapsePanels();                break;            case ControlEvent.TYPE_GET_CLIPBOARD:                String clipboardText = device.getClipboardText();                sender.pushClipboardText(clipboardText);                break;            default:                // do nothing        }    }
        return statusBarManager;    }}
    public ClipboardManager getClipboardManager() {        if (clipboardManager == null) {            clipboardManager = new ClipboardManager(getService("clipboard", "android.content.IClipboard"));        }        return clipboardManager;    }}
        dos.write(text);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_TEXT, event.getType());        Assert.assertEquals(new String(text, StandardCharsets.US_ASCII), event.getText());    }    @Test    public void testParseMouseEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_KEYCODE);        dos.writeByte(MotionEvent.ACTION_DOWN);        dos.writeInt(MotionEvent.BUTTON_PRIMARY);        dos.writeInt(KeyEvent.META_CTRL_ON);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_KEYCODE, event.getType());        Assert.assertEquals(MotionEvent.ACTION_DOWN, event.getAction());        Assert.assertEquals(MotionEvent.BUTTON_PRIMARY, event.getKeycode());        Assert.assertEquals(KeyEvent.META_CTRL_ON, event.getMetaState());
    public void testParseGetClipboardEvent() throws IOException {        ControlEventReader reader = new ControlEventReader();        ByteArrayOutputStream bos = new ByteArrayOutputStream();        DataOutputStream dos = new DataOutputStream(bos);        dos.writeByte(ControlEvent.TYPE_GET_CLIPBOARD);        byte[] packet = bos.toByteArray();        reader.readFrom(new ByteArrayInputStream(packet));        ControlEvent event = reader.next();        Assert.assertEquals(ControlEvent.TYPE_GET_CLIPBOARD, event.getType());    }
    private Method getSetPrimaryClipMethod() {        if (setPrimaryClipMethod == null) {            try {                setPrimaryClipMethod = manager.getClass().getMethod("setPrimaryClip", ClipData.class, String.class);            } catch (NoSuchMethodException e) {                Ln.e("Could not find method", e);            }        }        return setPrimaryClipMethod;    }
    private Method getGetPrimaryClipMethod() {        if (getPrimaryClipMethod == null) {            try {                getPrimaryClipMethod = manager.getClass().getMethod("getPrimaryClip", String.class);            } catch (NoSuchMethodException e) {                Ln.e("Could not find method", e);            }        }        return getPrimaryClipMethod;    }
    private Method getGetPrimaryClipMethod() {        if (getPrimaryClipMethod == null) {            try {                getPrimaryClipMethod = manager.getClass().getMethod("getPrimaryClip", String.class);            } catch (NoSuchMethodException e) {                Ln.e("Could not find method", e);            }        }        return getPrimaryClipMethod;    }
    public void setText(CharSequence text) {        Method method = getSetPrimaryClipMethod();        if (method == null) {            return;        }        ClipData clipData = ClipData.newPlainText(null, text);        try {            method.invoke(manager, clipData, PACKAGE_NAME);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);        }    }}
    public void setText(CharSequence text) {        Method method = getSetPrimaryClipMethod();        if (method == null) {            return;        }        ClipData clipData = ClipData.newPlainText(null, text);        try {            method.invoke(manager, clipData, PACKAGE_NAME);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);        }    }}
    public CharSequence getText() {        Method method = getGetPrimaryClipMethod();        if (method == null) {            return null;        }        try {            ClipData clipData = (ClipData) method.invoke(manager, PACKAGE_NAME);            if (clipData == null || clipData.getItemCount() == 0) {                return null;            }            return clipData.getItemAt(0).getText();        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);            return null;        }    }
    private Method getSetPrimaryClipMethod() {        if (setPrimaryClipMethod == null) {            try {                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                    setPrimaryClipMethod = manager.getClass().getMethod("setPrimaryClip", ClipData.class, String.class);                } else {                    setPrimaryClipMethod = manager.getClass().getMethod("setPrimaryClip", ClipData.class,                            String.class, int.class);                }            } catch (NoSuchMethodException e) {                Ln.e("Could not find method", e);            }        }        return setPrimaryClipMethod;    }
    private Method getGetPrimaryClipMethod() {        if (getPrimaryClipMethod == null) {            try {                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {                    getPrimaryClipMethod = manager.getClass().getMethod("getPrimaryClip", String.class);                } else {                    getPrimaryClipMethod = manager.getClass().getMethod("getPrimaryClip", String.class, int.class);                }            } catch (NoSuchMethodException e) {                Ln.e("Could not find method", e);            }        }        return getPrimaryClipMethod;    }
    private static void setPrimaryClip(Method method, IInterface manager, ClipData clipData) throws InvocationTargetException,            IllegalAccessException {        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {            method.invoke(manager, clipData, PACKAGE_NAME);        } else {            method.invoke(manager, clipData, PACKAGE_NAME, USER_ID);        }    }
    public void setText(CharSequence text) {        Method method = getSetPrimaryClipMethod();        if (method == null) {            return;        }        ClipData clipData = ClipData.newPlainText(null, text);        try {            setPrimaryClip(method, manager, clipData);        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);        }    }}
    private static ClipData getPrimaryClip(Method method, IInterface manager) throws InvocationTargetException,            IllegalAccessException {        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {            return (ClipData) method.invoke(manager, PACKAGE_NAME);        }        return (ClipData) method.invoke(manager, PACKAGE_NAME, USER_ID);    }
    public CharSequence getText() {        Method method = getGetPrimaryClipMethod();        if (method == null) {            return null;        }        try {            ClipData clipData = getPrimaryClip(method, manager);            if (clipData == null || clipData.getItemCount() == 0) {                return null;            }            return clipData.getItemAt(0).getText();        } catch (InvocationTargetException | IllegalAccessException e) {            Ln.e("Could not invoke " + method.getName(), e);            return null;        }    }
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = server_connect_to(&server);    if (!device_socket) {        server_stop(&server, serial);        return SDL_FALSE;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server, serial);        return SDL_FALSE;    }    if (!frames_init(&frames)) {        server_stop(&server, serial);        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    decoder.frames = &frames;    decoder.video_socket = device_socket;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server, serial);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    // kill the server before decoder_join() to wake up the decoder    server_stop(&server, serial);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    // to reduce startup time, we could be tempted to init other stuff before blocking here    // but we should not block after SDL_Init since it handles the signals (Ctrl+C) in its    // event loop: blocking could lead to deadlock    TCPsocket device_socket = server_connect_to(&server, serial);    if (!device_socket) {        server_stop(&server, serial);        return SDL_FALSE;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server, serial);        return SDL_FALSE;    }    if (!frames_init(&frames)) {        server_stop(&server, serial);        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    decoder.frames = &frames;    decoder.video_socket = device_socket;    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server, serial);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    // kill the server before decoder_join() to wake up the decoder    server_stop(&server, serial);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);    return ret;}
TCPsocket server_connect_to(struct server *server) {    SDL_assert(server->server_socket);    server->device_socket = server_socket_accept(server->server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server->server_socket);    server->server_socket = NULL;    return server->device_socket;}
TCPsocket server_connect_to(struct server *server) {    SDL_assert(server->server_socket);    server->device_socket = server_socket_accept(server->server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server->server_socket);    server->server_socket = NULL;    return server->device_socket;}
TCPsocket server_connect_to(struct server *server, const char *serial) {    SDL_assert(server->server_socket);    server->device_socket = server_socket_accept(server->server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server->server_socket);    server->server_socket = NULL;    // we don't need the adb tunnel anymore
TCPsocket server_connect_to(struct server *server, const char *serial) {    SDL_assert(server->server_socket);    server->device_socket = server_socket_accept(server->server_socket);    // we don't need the server socket anymore    SDLNet_TCP_Close(server->server_socket);    server->server_socket = NULL;    // we don't need the adb tunnel anymore    disable_tunnel(serial); // ignore failure    server->adb_reverse_enabled = SDL_FALSE;    return server->device_socket;}
#ifdef __WINDOWS__  typedef int socklen_t;#else# include <sys/types.h># include <sys/socket.h># include <netinet/in.h># include <arpa/inet.h># include <unistd.h># define SOCKET_ERROR -1  typedef struct sockaddr_in SOCKADDR_IN;  typedef struct sockaddr SOCKADDR;  typedef struct in_addr IN_ADDR;#endifsocket_t net_listen(Uint32 addr, Uint16 port, int backlog) {
SDL_bool net_shutdown(socket_t socket, int how) {    return !shutdown(socket, how);}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    // SDL initialization replace the signal handler for SIGTERM, so Ctrl+C is    // managed by the event loop. This blocking call blocks the event loop, so    // timeout the connection not to block indefinitely in case of SIGTERM.#define SERVER_CONNECT_TIMEOUT_MS 2000    socket_t device_socket = server_connect_to(&server, serial, SERVER_CONNECT_TIMEOUT_MS);    if (device_socket == INVALID_SOCKET) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server, serial);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // kill the server before decoder_join() to wake up the decoder    server_stop(&server, serial);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
SDL_bool scrcpy(const char *serial, Uint16 local_port, Uint16 max_size, Uint32 bit_rate) {    if (!server_start(&server, serial, local_port, max_size, bit_rate)) {        return SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    // SDL initialization replace the signal handler for SIGTERM, so Ctrl+C is    // managed by the event loop. This blocking call blocks the event loop, so    // timeout the connection not to block indefinitely in case of SIGTERM.#define SERVER_CONNECT_TIMEOUT_MS 2000    socket_t device_socket = server_connect_to(&server, serial, SERVER_CONNECT_TIMEOUT_MS);    if (device_socket == INVALID_SOCKET) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server, serial);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server, serial);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server, serial);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    server_destroy(&server);    return ret;}
void server_stop(struct server *server, const char *serial) {    SDL_assert(server->process != PROCESS_NONE);    terminate_server(server->process);    if (server->adb_reverse_enabled) {        // ignore failure        disable_tunnel(serial);    }}
static void terminate_server(process_t server) {    if (!cmd_terminate(server)) {        LOGE("Could not terminate server: %s", strerror(errno));    }}
void server_stop(struct server *server, const char *serial) {    SDL_assert(server->process != PROCESS_NONE);    if (server->device_socket != INVALID_SOCKET) {        // shutdown the socket to finish the device process gracefully        net_shutdown(server->device_socket, SHUT_RDWR);    }    LOGD("Waiting the server to complete execution on the device...");    cmd_simple_wait(server->process, NULL); // ignore exit code    LOGD("Server terminated");    if (server->adb_reverse_enabled) {        // ignore failure        disable_tunnel(serial);    }}
static socket_t listen_on_port(Uint16 port) {#define IPV4_LOCALHOST 0x7F000001    return net_listen(IPV4_LOCALHOST, port, 1);}
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        try (DesktopConnection connection = DesktopConnection.open(device)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getBitRate());            // asynchronous            startEventController(device, connection);            try {                // synchronous                screenEncoder.streamScreen(device, connection.getOutputStream());            } catch (IOException e) {                Ln.w("Screen streaming stopped");            }        }    }
    private static void startEventController(final Device device, final DesktopConnection connection) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    new EventController(device, connection).control();                } catch (IOException e) {                    Ln.w("Event controller stopped");                }            }        }).start();    }
    private static void scrcpy(Options options) throws IOException {        final Device device = new Device(options);        try (DesktopConnection connection = DesktopConnection.open(device)) {            ScreenEncoder screenEncoder = new ScreenEncoder(options.getBitRate());            // asynchronous            startEventController(device, connection);            try {                // synchronous                screenEncoder.streamScreen(device, connection.getOutputStream());            } catch (IOException e) {                // this is expected on close                Ln.d("Screen streaming stopped");            }        }    }
    private static void startEventController(final Device device, final DesktopConnection connection) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    new EventController(device, connection).control();                } catch (IOException e) {                    // this is expected on close                    Ln.d("Event controller stopped");                }            }        }).start();    }
static SDL_bool convert_keycode(SDL_Keycode from, enum android_keycode *to) {    switch (from) {        MAP(SDLK_LCTRL,        AKEYCODE_CTRL_LEFT);        MAP(SDLK_LSHIFT,       AKEYCODE_SHIFT_LEFT);        MAP(SDLK_LALT,         AKEYCODE_ALT_LEFT);        MAP(SDLK_LGUI,         AKEYCODE_META_LEFT);        MAP(SDLK_RCTRL,        AKEYCODE_CTRL_RIGHT);        MAP(SDLK_RSHIFT,       AKEYCODE_SHIFT_RIGHT);        MAP(SDLK_RALT,         AKEYCODE_ALT_RIGHT);        MAP(SDLK_RGUI,         AKEYCODE_META_RIGHT);        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_SPACE,        AKEYCODE_SPACE);        MAP(SDLK_F1,           AKEYCODE_F1);        MAP(SDLK_F2,           AKEYCODE_F2);        MAP(SDLK_F3,           AKEYCODE_F3);        MAP(SDLK_F4,           AKEYCODE_F4);        MAP(SDLK_F5,           AKEYCODE_F5);        MAP(SDLK_F6,           AKEYCODE_F6);        MAP(SDLK_F7,           AKEYCODE_F7);        MAP(SDLK_F8,           AKEYCODE_F8);        MAP(SDLK_F9,           AKEYCODE_F9);        MAP(SDLK_F10,          AKEYCODE_F10);        MAP(SDLK_F11,          AKEYCODE_F11);        MAP(SDLK_F12,          AKEYCODE_F12);        MAP(SDLK_PRINTSCREEN,  AKEYCODE_SYSRQ);        MAP(SDLK_SCROLLLOCK,   AKEYCODE_SCROLL_LOCK);        MAP(SDLK_PAUSE,        AKEYCODE_BREAK);        MAP(SDLK_INSERT,       AKEYCODE_INSERT);        MAP(SDLK_HOME,         AKEYCODE_HOME);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);        MAP(SDLK_NUMLOCKCLEAR, AKEYCODE_NUM_LOCK);        MAP(SDLK_KP_DIVIDE,    AKEYCODE_NUMPAD_DIVIDE);        MAP(SDLK_KP_MULTIPLY,  AKEYCODE_NUMPAD_MULTIPLY);        MAP(SDLK_KP_MINUS,     AKEYCODE_NUMPAD_SUBTRACT);        MAP(SDLK_KP_PLUS,      AKEYCODE_NUMPAD_ADD);        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_KP_1,         AKEYCODE_NUMPAD_1);        MAP(SDLK_KP_2,         AKEYCODE_NUMPAD_2);        MAP(SDLK_KP_3,         AKEYCODE_NUMPAD_3);        MAP(SDLK_KP_4,         AKEYCODE_NUMPAD_4);        MAP(SDLK_KP_5,         AKEYCODE_NUMPAD_5);        MAP(SDLK_KP_6,         AKEYCODE_NUMPAD_6);        MAP(SDLK_KP_7,         AKEYCODE_NUMPAD_7);        MAP(SDLK_KP_8,         AKEYCODE_NUMPAD_8);        MAP(SDLK_KP_9,         AKEYCODE_NUMPAD_9);        MAP(SDLK_KP_0,         AKEYCODE_NUMPAD_0);        MAP(SDLK_KP_PERIOD,    AKEYCODE_NUMPAD_DOT);        FAIL;    }}
static SDL_bool convert_keycode(SDL_Keycode from, enum android_keycode *to) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_HOME,         AKEYCODE_HOME);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);        FAIL;    }}static SDL_bool convert_mouse_action(SDL_EventType from, enum android_motionevent_action *to) {    switch (from) {        MAP(SDL_MOUSEBUTTONDOWN, AMOTION_EVENT_ACTION_DOWN);        MAP(SDL_MOUSEBUTTONUP,   AMOTION_EVENT_ACTION_UP);        FAIL;    }}static enum android_motionevent_buttons convert_mouse_buttons(Uint32 state) {    enum android_motionevent_buttons buttons = 0;    if (state & SDL_BUTTON_LMASK) {        buttons |= AMOTION_EVENT_BUTTON_PRIMARY;    }    if (state & SDL_BUTTON_RMASK) {        buttons |= AMOTION_EVENT_BUTTON_SECONDARY;    }    if (state & SDL_BUTTON_MMASK) {        buttons |= AMOTION_EVENT_BUTTON_TERTIARY;    }    if (state & SDL_BUTTON_X1) {        buttons |= AMOTION_EVENT_BUTTON_BACK;    }    if (state & SDL_BUTTON_X2) {        buttons |= AMOTION_EVENT_BUTTON_FORWARD;    }    return buttons;}SDL_bool input_key_from_sdl_to_android(SDL_KeyboardEvent *from, struct control_event *to) {    to->type = CONTROL_EVENT_TYPE_KEYCODE;    if (!convert_keycode_action(from->type, &to->keycode_event.action)) {        return SDL_FALSE;    }    if (!convert_keycode(from->keysym.sym, &to->keycode_event.keycode)) {        return SDL_FALSE;    }    to->keycode_event.metastate = convert_meta_state(from->keysym.mod);    return SDL_TRUE;
static void close_socket(socket_t *socket) {    SDL_assert(*socket != INVALID_SOCKET);    if (!net_close(*socket)) {        LOGW("Cannot close socket");        return;    }    *socket = INVALID_SOCKET;}
static void close_socket(socket_t *socket) {    SDL_assert(*socket != INVALID_SOCKET);    net_shutdown(*socket, SHUT_RDWR);    if (!net_close(*socket)) {        LOGW("Cannot close socket");        return;    }    *socket = INVALID_SOCKET;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -s, --serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Home\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        turn screen on\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .record_format = 0,        .help = false,        .version = false,        .show_touches = false,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = false,        .no_control = false,        .no_display = false,        .turn_screen_off = false,        .render_expired_frames = false,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,        .control = !args.no_control,        .display = !args.no_display,        .turn_screen_off = args.turn_screen_off,        .render_expired_frames = args.render_expired_frames,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    Ctrl+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+c\n"        "        copy device clipboard to computer\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, 'T'},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, 'c'},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, 'f'},        {"render-expired-frames", no_argument,       NULL,                                                 OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"version",               no_argument,       NULL, 'v'},        {NULL,                    0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return false;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = true;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return false;                }                break;            case 'n':                args->no_control = true;                break;            case 'N':                args->no_display = true;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return false;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 'S':                args->turn_screen_off = true;                break;            case 't':                args->show_touches = true;                break;            case 'T':                args->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                args->render_expired_frames = true;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (args->no_display && !args->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (args->no_display && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return false;        }    }    if (args->no_control && args->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
main(int argc, char *argv[]) {#ifdef __WINDOWS__    // disable buffering, we want logs immediately    // even line buffering (setvbuf() with mode _IOLBF) is not sufficient    setbuf(stdout, NULL);    setbuf(stderr, NULL);#endif    struct args args = {        .serial = NULL,        .crop = NULL,        .record_filename = NULL,        .window_title = NULL,        .record_format = 0,        .help = false,        .version = false,        .show_touches = false,        .port = DEFAULT_LOCAL_PORT,        .max_size = DEFAULT_MAX_SIZE,        .bit_rate = DEFAULT_BIT_RATE,        .always_on_top = false,        .no_control = false,        .no_display = false,        .turn_screen_off = false,        .render_expired_frames = false,    };    if (!parse_args(&args, argc, argv)) {        return 1;    }    if (args.help) {        usage(argv[0]);        return 0;    }    if (args.version) {        print_version();        return 0;    }#ifdef SCRCPY_LAVF_REQUIRES_REGISTER_ALL    av_register_all();#endif    if (avformat_network_init()) {        return 1;    }#ifdef BUILD_DEBUG    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);#endif    struct scrcpy_options options = {        .serial = args.serial,        .crop = args.crop,        .port = args.port,        .record_filename = args.record_filename,        .window_title = args.window_title,        .record_format = args.record_format,        .max_size = args.max_size,        .bit_rate = args.bit_rate,        .show_touches = args.show_touches,        .fullscreen = args.fullscreen,        .always_on_top = args.always_on_top,        .control = !args.no_control,        .display = !args.no_display,        .turn_screen_off = args.turn_screen_off,        .render_expired_frames = args.render_expired_frames,    };    int res = scrcpy(&options) ? 0 : 1;    avformat_network_deinit(); // ignore failure#if defined (__WINDOWS__) && ! defined (WINDOWS_NOCONSOLE)    if (res != 0) {        fprintf(stderr, "Press any key to continue...\n");        getchar();    }#endif    return res;}
static void usage(const char *arg0) {    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "Shortcuts:\n"        "\n"        "    Ctrl+f\n"        "        switch fullscreen mode\n"        "\n"        "    Ctrl+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    Ctrl+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    Ctrl+b\n"        "    Ctrl+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    Ctrl+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    Ctrl+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    Ctrl+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    Ctrl+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    Ctrl+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    Ctrl+n\n"        "       expand notification panel\n"        "\n"        "    Ctrl+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    Ctrl+c\n"        "        copy device clipboard to computer\n"        "\n"        "    Ctrl+v\n"        "        paste computer clipboard to device\n"        "\n"        "    Ctrl+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    Ctrl+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
parse_args(struct args *args, int argc, char *argv[]) {    static const struct option long_options[] = {        {"always-on-top",         no_argument,       NULL, 'T'},        {"bit-rate",              required_argument, NULL, 'b'},        {"crop",                  required_argument, NULL, 'c'},        {"fullscreen",            no_argument,       NULL, 'f'},        {"help",                  no_argument,       NULL, 'h'},        {"max-size",              required_argument, NULL, 'm'},        {"no-control",            no_argument,       NULL, 'n'},        {"no-display",            no_argument,       NULL, 'N'},        {"port",                  required_argument, NULL, 'p'},        {"record",                required_argument, NULL, 'r'},        {"record-format",         required_argument, NULL, 'f'},        {"render-expired-frames", no_argument,       NULL,                                                 OPT_RENDER_EXPIRED_FRAMES},        {"serial",                required_argument, NULL, 's'},        {"show-touches",          no_argument,       NULL, 't'},        {"turn-screen-off",       no_argument,       NULL, 'S'},        {"version",               no_argument,       NULL, 'v'},        {"window-title",          required_argument, NULL,                                                 OPT_WINDOW_TITLE},        {NULL,                    0,                 NULL, 0  },    };    int c;    while ((c = getopt_long(argc, argv, "b:c:fF:hm:nNp:r:s:StTv", long_options,                            NULL)) != -1) {        switch (c) {            case 'b':                if (!parse_bit_rate(optarg, &args->bit_rate)) {                    return false;                }                break;            case 'c':                args->crop = optarg;                break;            case 'f':                args->fullscreen = true;                break;            case 'F':                if (!parse_record_format(optarg, &args->record_format)) {                    return false;                }                break;            case 'h':                args->help = true;                break;            case 'm':                if (!parse_max_size(optarg, &args->max_size)) {                    return false;                }                break;            case 'n':                args->no_control = true;                break;            case 'N':                args->no_display = true;                break;            case 'p':                if (!parse_port(optarg, &args->port)) {                    return false;                }                break;            case 'r':                args->record_filename = optarg;                break;            case 's':                args->serial = optarg;                break;            case 'S':                args->turn_screen_off = true;                break;            case 't':                args->show_touches = true;                break;            case 'T':                args->always_on_top = true;                break;            case 'v':                args->version = true;                break;            case OPT_RENDER_EXPIRED_FRAMES:                args->render_expired_frames = true;                break;            case OPT_WINDOW_TITLE:                args->window_title = optarg;                break;            default:                // getopt prints the error message on stderr                return false;        }    }    if (args->no_display && !args->record_filename) {        LOGE("-N/--no-display requires screen recording (-r/--record)");        return false;    }    if (args->no_display && args->fullscreen) {        LOGE("-f/--fullscreen-window is incompatible with -N/--no-display");        return false;    }    int index = optind;    if (index < argc) {        LOGE("Unexpected additional argument: %s", argv[index]);        return false;    }    if (args->record_format && !args->record_filename) {        LOGE("Record format specified without recording");        return false;    }    if (args->record_filename && !args->record_format) {        args->record_format = guess_record_format(args->record_filename);        if (!args->record_format) {            LOGE("No format specified for \"%s\" (try with -F mkv)",                 args->record_filename);            return false;        }    }    if (args->no_control && args->turn_screen_off) {        LOGE("Could not request to turn screen off if control is disabled");        return false;    }    return true;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .send_frame_meta = record,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .send_frame_meta = record,        .control = options->control,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool fps_counter_initialized = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!fps_counter_init(&fps_counter)) {            goto end;        }        fps_counter_initialized = true;        if (!video_buffer_init(&video_buffer, &fps_counter,                               options->render_expired_frames)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            controller_initialized = true;            if (!controller_start(&controller)) {                goto end;            }            controller_started = true;        }        const char *window_title =            options->window_title ? options->window_title : device_name;        if (!screen_init_rendering(&screen, window_title, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->turn_screen_off) {            struct control_msg msg;            msg.type = CONTROL_MSG_TYPE_SET_SCREEN_POWER_MODE;            msg.set_screen_power_mode.mode = SCREEN_POWER_MODE_OFF;            if (!controller_push_msg(&controller, &msg)) {                LOGW("Could not request 'set screen power mode'");            }        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    if (fps_counter_initialized) {        fps_counter_interrupt(&fps_counter);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (fps_counter_initialized) {        fps_counter_join(&fps_counter);        fps_counter_destroy(&fps_counter);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
screen_init_rendering(struct screen *screen, const char *device_name,                      struct size frame_size, bool always_on_top) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED,                                      SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    return true;}
screen_init_rendering(struct screen *screen, const char *device_name,                      struct size frame_size, bool always_on_top) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    screen->window = SDL_CreateWindow(device_name, SDL_WINDOWPOS_UNDEFINED,                                      SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    return true;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    screen->window = SDL_CreateWindow(window_title, SDL_WINDOWPOS_UNDEFINED,                                      SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    return true;}
screen_init_rendering(struct screen *screen, const char *window_title,                      struct size frame_size, bool always_on_top) {    screen->frame_size = frame_size;    struct size window_size = get_initial_optimal_size(frame_size);    uint32_t window_flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE;#ifdef HIDPI_SUPPORT    window_flags |= SDL_WINDOW_ALLOW_HIGHDPI;#endif    if (always_on_top) {#ifdef SCRCPY_SDL_HAS_WINDOW_ALWAYS_ON_TOP        window_flags |= SDL_WINDOW_ALWAYS_ON_TOP;#else        LOGW("The 'always on top' flag is not available "             "(compile with SDL >= 2.0.5 to enable it)");#endif    }    screen->window = SDL_CreateWindow(window_title, SDL_WINDOWPOS_UNDEFINED,                                      SDL_WINDOWPOS_UNDEFINED,                                      window_size.width, window_size.height,                                      window_flags);    if (!screen->window) {        LOGC("Could not create window: %s", SDL_GetError());        return false;    }    screen->renderer = SDL_CreateRenderer(screen->window, -1,                                          SDL_RENDERER_ACCELERATED);    if (!screen->renderer) {        LOGC("Could not create renderer: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    if (SDL_RenderSetLogicalSize(screen->renderer, frame_size.width,                                 frame_size.height)) {        LOGE("Could not set renderer logical size: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    SDL_Surface *icon = read_xpm(icon_xpm);    if (icon) {        SDL_SetWindowIcon(screen->window, icon);        SDL_FreeSurface(icon);    } else {        LOGW("Could not load icon");    }    LOGI("Initial texture: %" PRIu16 "x%" PRIu16, frame_size.width,                                                  frame_size.height);    screen->texture = create_texture(screen->renderer, frame_size);    if (!screen->texture) {        LOGC("Could not create texture: %s", SDL_GetError());        screen_destroy(screen);        return false;    }    return true;}
static struct point get_mouse_point(struct screen *screen) {    int x;    int y;    SDL_GetMouseState(&x, &y);    convert_to_renderer_coordinates(screen->renderer, &x, &y);    SDL_assert_release(x >= 0 && x < 0x10000 && y >= 0 && y < 0x10000);    return (struct point) {        .x = (Uint16) x,        .y = (Uint16) y,    };}
static struct point get_mouse_point(struct screen *screen) {    int x;    int y;    SDL_GetMouseState(&x, &y);    convert_to_renderer_coordinates(screen->renderer, &x, &y);    SDL_assert_release(x >= 0 && x < 0x10000 && y >= 0 && y < 0x10000);    return (struct point) {        .x = (Uint16) x,        .y = (Uint16) y,    };}
static void get_mouse_point(struct screen *screen, int *x, int *y) {    SDL_GetMouseState(x, y);    convert_to_renderer_coordinates(screen->renderer, x, y);}static const int ACTION_DOWN = 1;static const int ACTION_UP = 1 << 1;static void send_keycode(struct controller *controller, enum android_keycode keycode, int actions, const char *name) {    // send DOWN event    struct control_event control_event;    control_event.type = CONTROL_EVENT_TYPE_KEYCODE;
static void get_mouse_point(struct screen *screen, int *x, int *y) {    SDL_GetMouseState(x, y);    convert_to_renderer_coordinates(screen->renderer, x, y);}
        } else {            LOGE("\"%s\" exited unexpectedly", name);        }        return SDL_FALSE;    }    return SDL_TRUE;}
process_t adb_install(const char *serial, const char *local) {    const char *const adb_cmd[] = {"install", "-r", local};    return adb_execute(serial, adb_cmd, ARRAY_LEN(adb_cmd));}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
static void event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return;            case SDL_QUIT:                LOGD("User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                    case SDL_WINDOWEVENT_EXPOSED:                    case SDL_WINDOWEVENT_SIZE_CHANGED:                        screen_render(&screen);                        break;                }                break;            case SDL_TEXTINPUT:                input_manager_process_text_input(&input_manager, &event.text);                break;            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL:                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP:                input_manager_process_mouse_button(&input_manager, &event.button);                break;        }    }}
SDL_bool scrcpy(const struct scrcpy_options *options) {    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate)) {        return SDL_FALSE;    }    process_t proc_show_touches = PROCESS_NONE;    SDL_bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_TRUE);        show_touches_waited = SDL_FALSE;    }    SDL_bool ret = SDL_TRUE;    if (!SDL_SetHint(SDL_HINT_NO_SIGNAL_HANDLERS, "1")) {        LOGW("Cannot request to keep default signal handlers");    }    if (!sdl_init_and_configure()) {        ret = SDL_FALSE;        goto finally_destroy_server;    }    socket_t device_socket = server_connect_to(&server);    if (device_socket == INVALID_SOCKET) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not change    // therefore, we transmit the screen size before the video stream, to be able    // to init the window immediately    if (!device_read_info(device_socket, device_name, &frame_size)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!frames_init(&frames)) {        server_stop(&server);        ret = SDL_FALSE;        goto finally_destroy_server;    }    if (!installer_init(&installer, server.serial)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_frames;    }    decoder_init(&decoder, &frames, device_socket);    // now we consumed the header values, the socket receives the video stream    // start the decoder    if (!decoder_start(&decoder)) {        ret = SDL_FALSE;        server_stop(&server);        goto finally_destroy_installer;    }    if (!controller_init(&controller, device_socket)) {        ret = SDL_FALSE;        goto finally_stop_decoder;    }    if (!controller_start(&controller)) {        ret = SDL_FALSE;        goto finally_destroy_controller;    }    if (!screen_init_rendering(&screen, device_name, frame_size)) {        ret = SDL_FALSE;        goto finally_stop_and_join_controller;    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = SDL_TRUE;    }    event_loop();    LOGD("quit...");    screen_destroy(&screen);finally_stop_and_join_controller:    controller_stop(&controller);    controller_join(&controller);finally_destroy_controller:    controller_destroy(&controller);finally_stop_decoder:    decoder_stop(&decoder);    // stop the server before decoder_join() to wake up the decoder    server_stop(&server);    decoder_join(&decoder);finally_destroy_installer:    installer_stop(&installer);    installer_join(&installer);    installer_destroy(&installer);finally_destroy_frames:    frames_destroy(&frames);finally_destroy_server:    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, SDL_FALSE);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
static void event_loop(void) {#ifdef CONTINUOUS_RESIZING_WORKAROUND    SDL_AddEventWatch(event_watcher, NULL);#endif    SDL_Event event;    while (SDL_WaitEvent(&event)) {        switch (event.type) {            case EVENT_DECODER_STOPPED:                LOGD("Video decoder stopped");                return;            case SDL_QUIT:                LOGD("User requested to quit");                return;            case EVENT_NEW_FRAME:                if (!screen.has_frame) {                    screen.has_frame = SDL_TRUE;                    // this is the very first frame, show the window                    screen_show_window(&screen);                }                if (!screen_update_frame(&screen, &frames)) {                    return;                }                break;            case SDL_WINDOWEVENT:                switch (event.window.event) {                    case SDL_WINDOWEVENT_EXPOSED:                    case SDL_WINDOWEVENT_SIZE_CHANGED:                        screen_render(&screen);                        break;                }                break;            case SDL_TEXTINPUT:                input_manager_process_text_input(&input_manager, &event.text);                break;            case SDL_KEYDOWN:            case SDL_KEYUP:                input_manager_process_key(&input_manager, &event.key);                break;            case SDL_MOUSEMOTION:                input_manager_process_mouse_motion(&input_manager, &event.motion);                break;            case SDL_MOUSEWHEEL:                input_manager_process_mouse_wheel(&input_manager, &event.wheel);                break;            case SDL_MOUSEBUTTONDOWN:            case SDL_MOUSEBUTTONUP:                input_manager_process_mouse_button(&input_manager, &event.button);                break;            case SDL_DROPFILE:                installer_install_apk(&installer, event.drop.file);                break;        }    }}
    private boolean encode(MediaCodec codec, FileDescriptor fd) throws IOException {        boolean eof = false;        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();        while (!consumeRotationChange() && !eof) {            int outputBufferId = codec.dequeueOutputBuffer(bufferInfo, -1);            eof = (bufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;            try {                if (consumeRotationChange()) {                    // must restart encoding with new size                    break;                }                if (outputBufferId >= 0) {                    ByteBuffer codecBuffer = codec.getOutputBuffer(outputBufferId);                    if (sendFrameMeta) {                        writeFrameMeta(fd, bufferInfo, codecBuffer.remaining());                    }                    IO.writeFully(fd, codecBuffer);                }            } finally {                if (outputBufferId >= 0) {                    codec.releaseOutputBuffer(outputBufferId, false);                }            }        }        return !eof;    }
    private boolean encode(MediaCodec codec, FileDescriptor fd) throws IOException {        boolean eof = false;        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();        while (!consumeRotationChange() && !eof) {            int outputBufferId = codec.dequeueOutputBuffer(bufferInfo, -1);            eof = (bufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;            try {                if (consumeRotationChange()) {                    // must restart encoding with new size                    break;                }                if (outputBufferId >= 0) {                    ByteBuffer codecBuffer = codec.getOutputBuffer(outputBufferId);                    if (sendFrameMeta) {                        writeFrameMeta(fd, bufferInfo, codecBuffer.remaining());                    }                    IO.writeFully(fd, codecBuffer);                }            } finally {                if (outputBufferId >= 0) {                    codec.releaseOutputBuffer(outputBufferId, false);                }            }        }        return !eof;    }    private void writeFrameMeta(FileDescriptor fd, MediaCodec.BufferInfo bufferInfo, int packetSize) throws IOException {
static void usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (only supported on\n"        "        devices with Android >= 10).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is -1 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void usage(const char *arg0) {#ifdef __APPLE__# define CTRL_OR_CMD "Cmd"#else# define CTRL_OR_CMD "Ctrl"#endif    fprintf(stderr,        "Usage: %s [options]\n"        "\n"        "Options:\n"        "\n"        "    -b, --bit-rate value\n"        "        Encode the video at the given bit-rate, expressed in bits/s.\n"        "        Unit suffixes are supported: 'K' (x1000) and 'M' (x1000000).\n"        "        Default is %d.\n"        "\n"        "    -c, --crop width:height:x:y\n"        "        Crop the device screen on the server.\n"        "        The values are expressed in the device natural orientation\n"        "        (typically, portrait for a phone, landscape for a tablet).\n"        "        Any --max-size value is computed on the cropped size.\n"        "\n"        "    -f, --fullscreen\n"        "        Start in fullscreen.\n"        "\n"        "    -F, --record-format format\n"        "        Force recording format (either mp4 or mkv).\n"        "\n"        "    -h, --help\n"        "        Print this help.\n"        "\n"        "    --max-fps value\n"        "        Limit the frame rate of screen capture (only supported on\n"        "        devices with Android >= 10).\n"        "\n"        "    -m, --max-size value\n"        "        Limit both the width and height of the video to value. The\n"        "        other dimension is computed so that the device aspect-ratio\n"        "        is preserved.\n"        "        Default is %d%s.\n"        "\n"        "    -n, --no-control\n"        "        Disable device control (mirror the device in read-only).\n"        "\n"        "    -N, --no-display\n"        "        Do not display device (only when screen recording is\n"        "        enabled).\n"        "\n"        "    -p, --port port\n"        "        Set the TCP port the client listens on.\n"        "        Default is %d.\n"        "\n"        "    --prefer-text\n"        "        Inject alpha characters and space as text events instead of\n"        "        key events.\n"        "        This avoids issues when combining multiple keys to enter a\n"        "        special character, but breaks the expected behavior of alpha\n"        "        keys in games (typically WASD).\n"        "\n"        "    --push-target path\n"        "        Set the target directory for pushing files to the device by\n"        "        drag & drop. It is passed as-is to \"adb push\".\n"        "        Default is \"/sdcard/\".\n"        "\n"        "    -r, --record file.mp4\n"        "        Record screen to file.\n"        "        The format is determined by the -F/--record-format option if\n"        "        set, or by the file extension (.mp4 or .mkv).\n"        "\n"        "    --render-expired-frames\n"        "        By default, to minimize latency, scrcpy always renders the\n"        "        last available decoded frame, and drops any previous ones.\n"        "        This flag forces to render all frames, at a cost of a\n"        "        possible increased latency.\n"        "\n"        "    -s, --serial serial\n"        "        The device serial number. Mandatory only if several devices\n"        "        are connected to adb.\n"        "\n"        "    -S, --turn-screen-off\n"        "        Turn the device screen off immediately.\n"        "\n"        "    -t, --show-touches\n"        "        Enable \"show touches\" on start, disable on quit.\n"        "        It only shows physical touches (not clicks from scrcpy).\n"        "\n"        "    -T, --always-on-top\n"        "        Make scrcpy window always on top (above other windows).\n"        "\n"        "    -v, --version\n"        "        Print the version of scrcpy.\n"        "\n"        "    --window-borderless\n"        "        Disable window decorations (display borderless window).\n"        "\n"        "    --window-title text\n"        "        Set a custom window title.\n"        "\n"        "    --window-x value\n"        "        Set the initial window horizontal position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-y value\n"        "        Set the initial window vertical position.\n"        "        Default is -1 (automatic).\n"        "\n"        "    --window-width value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "    --window-height value\n"        "        Set the initial window width.\n"        "        Default is 0 (automatic).\n"        "\n"        "Shortcuts:\n"        "\n"        "    " CTRL_OR_CMD "+f\n"        "        switch fullscreen mode\n"        "\n"        "    " CTRL_OR_CMD "+g\n"        "        resize window to 1:1 (pixel-perfect)\n"        "\n"        "    " CTRL_OR_CMD "+x\n"        "    Double-click on black borders\n"        "        resize window to remove black borders\n"        "\n"        "    Ctrl+h\n"        "    Middle-click\n"        "        click on HOME\n"        "\n"        "    " CTRL_OR_CMD "+b\n"        "    " CTRL_OR_CMD "+Backspace\n"        "    Right-click (when screen is on)\n"        "        click on BACK\n"        "\n"        "    " CTRL_OR_CMD "+s\n"        "        click on APP_SWITCH\n"        "\n"        "    Ctrl+m\n"        "        click on MENU\n"        "\n"        "    " CTRL_OR_CMD "+Up\n"        "        click on VOLUME_UP\n"        "\n"        "    " CTRL_OR_CMD "+Down\n"        "        click on VOLUME_DOWN\n"        "\n"        "    " CTRL_OR_CMD "+p\n"        "        click on POWER (turn screen on/off)\n"        "\n"        "    Right-click (when screen is off)\n"        "        power on\n"        "\n"        "    " CTRL_OR_CMD "+o\n"        "        turn device screen off (keep mirroring)\n"        "\n"        "    " CTRL_OR_CMD "+n\n"        "       expand notification panel\n"        "\n"        "    " CTRL_OR_CMD "+Shift+n\n"        "       collapse notification panel\n"        "\n"        "    " CTRL_OR_CMD "+c\n"        "        copy device clipboard to computer\n"        "\n"        "    " CTRL_OR_CMD "+v\n"        "        paste computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+Shift+v\n"        "        copy computer clipboard to device\n"        "\n"        "    " CTRL_OR_CMD "+i\n"        "        enable/disable FPS counter (print frames/second in logs)\n"        "\n"        "    Drag & drop APK file\n"        "        install APK from computer\n"        "\n",        arg0,        DEFAULT_BIT_RATE,        DEFAULT_MAX_SIZE, DEFAULT_MAX_SIZE ? "" : " (unlimited)",        DEFAULT_LOCAL_PORT);}
static void test_serialize_mouse_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_MOUSE,        .mouse_event = {            .action = AMOTION_EVENT_ACTION_DOWN,            .buttons = AMOTION_EVENT_BUTTON_PRIMARY,            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 14);    const unsigned char expected[] = {        0x02, // CONTROL_EVENT_TYPE_MOUSE        0x00, // AKEY_EVENT_ACTION_DOWN        0x00, 0x00, 0x00, 0x01, // AMOTION_EVENT_BUTTON_PRIMARY        0x01, 0x04, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_scroll_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_SCROLL,        .scroll_event = {            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },            .hscroll = 1,            .vscroll = -1,        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 17);    const unsigned char expected[] = {        0x03, // CONTROL_EVENT_TYPE_SCROLL        0x01, 0x04, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920        0x00, 0x00, 0x00, 0x01, // 1        0xFF, 0xFF, 0xFF, 0xFF, // -1    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_mouse_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_MOUSE,        .mouse_event = {            .action = AMOTION_EVENT_ACTION_DOWN,            .buttons = AMOTION_EVENT_BUTTON_PRIMARY,            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 18);    const unsigned char expected[] = {        0x02, // CONTROL_EVENT_TYPE_MOUSE        0x00, // AKEY_EVENT_ACTION_DOWN        0x00, 0x00, 0x00, 0x01, // AMOTION_EVENT_BUTTON_PRIMARY        0x00, 0x00, 0x01, 0x04, 0x00, 0x00, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920    };    assert(!memcmp(buf, expected, sizeof(expected)));}
static void test_serialize_scroll_event(void) {    struct control_event event = {        .type = CONTROL_EVENT_TYPE_SCROLL,        .scroll_event = {            .position = {                .point = {                    .x = 260,                    .y = 1026,                },                .screen_size = {                    .width = 1080,                    .height = 1920,                },            },            .hscroll = 1,            .vscroll = -1,        },    };    unsigned char buf[SERIALIZED_EVENT_MAX_SIZE];    int size = control_event_serialize(&event, buf);    assert(size == 21);    const unsigned char expected[] = {        0x03, // CONTROL_EVENT_TYPE_SCROLL        0x00, 0x00, 0x01, 0x04, 0x00, 0x00, 0x04, 0x02, // 260 1026        0x04, 0x38, 0x07, 0x80, // 1080 1920        0x00, 0x00, 0x00, 0x01, // 1        0xFF, 0xFF, 0xFF, 0xFF, // -1    };    assert(!memcmp(buf, expected, sizeof(expected)));}
request_new(file_handler_action_t action, const char *file) {    struct request *req = SDL_malloc(sizeof(*req));    if (!req) {        return NULL;    }    req->action = action;    req->file = file;    return req;}
request_free(struct request *req) {    if (!req) {        return;    }    SDL_free((void *) req->file);    SDL_free(req);}
file_handler_request(struct file_handler *file_handler,                     file_handler_action_t action,                     const char *file) {    bool res;    // start file_handler if it's used for the first time    if (!file_handler->initialized) {        if (!file_handler_start(file_handler)) {            return false;        }        file_handler->initialized = true;    }    LOGI("Request to %s %s", action == ACTION_INSTALL_APK ? "install" : "push",                             file);    struct request *req = request_new(action, file);    if (!req) {        LOGE("Could not create request");        return false;    }    mutex_lock(file_handler->mutex);    bool was_empty = request_queue_is_empty(&file_handler->queue);    res = request_queue_push(&file_handler->queue, req);    if (was_empty) {        cond_signal(file_handler->event_cond);    }    mutex_unlock(file_handler->mutex);    return res;}
file_handler_request(struct file_handler *file_handler,                     file_handler_action_t action,                     const char *file) {    bool res;    // start file_handler if it's used for the first time    if (!file_handler->initialized) {        if (!file_handler_start(file_handler)) {            return false;        }        file_handler->initialized = true;    }    LOGI("Request to %s %s", action == ACTION_INSTALL_APK ? "install" : "push",                             file);    struct request *req = request_new(action, file);    if (!req) {        LOGE("Could not create request");        return false;    }    mutex_lock(file_handler->mutex);    bool was_empty = request_queue_is_empty(&file_handler->queue);    res = request_queue_push(&file_handler->queue, req);    if (was_empty) {        cond_signal(file_handler->event_cond);    }    mutex_unlock(file_handler->mutex);    return res;}
request_new(file_handler_action_t action, const char *file) {    struct request *req = SDL_malloc(sizeof(*req));    if (!req) {        return NULL;    }    req->action = action;    req->file = file;    return req;}
request_new(file_handler_action_t action, char *file) {    struct request *req = SDL_malloc(sizeof(*req));    if (!req) {        return NULL;    }    req->action = action;    req->file = file;    return req;}
request_free(struct request *req) {    if (!req) {        return;    }    SDL_free(req->file);    SDL_free(req);}
file_handler_request(struct file_handler *file_handler,                     file_handler_action_t action,                     char *file) {    bool res;    // start file_handler if it's used for the first time    if (!file_handler->initialized) {        if (!file_handler_start(file_handler)) {            return false;        }        file_handler->initialized = true;    }    LOGI("Request to %s %s", action == ACTION_INSTALL_APK ? "install" : "push",                             file);    struct request *req = request_new(action, file);    if (!req) {        LOGE("Could not create request");        return false;    }    mutex_lock(file_handler->mutex);    bool was_empty = request_queue_is_empty(&file_handler->queue);    res = request_queue_push(&file_handler->queue, req);    if (was_empty) {        cond_signal(file_handler->event_cond);    }    mutex_unlock(file_handler->mutex);    return res;}
file_handler_request(struct file_handler *file_handler,                     file_handler_action_t action,                     char *file) {    bool res;    // start file_handler if it's used for the first time    if (!file_handler->initialized) {        if (!file_handler_start(file_handler)) {            return false;        }        file_handler->initialized = true;    }    LOGI("Request to %s %s", action == ACTION_INSTALL_APK ? "install" : "push",                             file);    struct request *req = request_new(action, file);    if (!req) {        LOGE("Could not create request");        return false;    }    mutex_lock(file_handler->mutex);    bool was_empty = request_queue_is_empty(&file_handler->queue);    res = request_queue_push(&file_handler->queue, req);    if (was_empty) {        cond_signal(file_handler->event_cond);    }    mutex_unlock(file_handler->mutex);    return res;}
request_new(file_handler_action_t action, char *file) {    struct request *req = SDL_malloc(sizeof(*req));    if (!req) {        return NULL;    }    req->action = action;    req->file = file;    return req;}
prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width            || screen->frame_size.height != new_frame_size.height) {        if (SDL_RenderSetLogicalSize(screen->renderer, new_frame_size.width,                                     new_frame_size.height)) {            LOGE("Could not set renderer logical size: %s", SDL_GetError());            return false;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        struct size current_size = get_window_size(screen);        struct size target_size = {            (uint32_t) current_size.width * new_frame_size.width                    / screen->frame_size.width,            (uint32_t) current_size.height * new_frame_size.height                    / screen->frame_size.height,        };        target_size = get_optimal_size(target_size, new_frame_size);        set_window_size(screen, target_size);        screen->frame_size = new_frame_size;        LOGD("New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = create_texture(screen->renderer, new_frame_size);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return false;        }    }    return true;}
prepare_for_frame(struct screen *screen, struct size new_frame_size) {    if (screen->frame_size.width != new_frame_size.width            || screen->frame_size.height != new_frame_size.height) {        if (SDL_RenderSetLogicalSize(screen->renderer, new_frame_size.width,                                     new_frame_size.height)) {            LOGE("Could not set renderer logical size: %s", SDL_GetError());            return false;        }        // frame dimension changed, destroy texture        SDL_DestroyTexture(screen->texture);        struct size current_size = get_window_size(screen);        struct size target_size = {            (uint32_t) current_size.width * new_frame_size.width                    / screen->frame_size.width,            (uint32_t) current_size.height * new_frame_size.height                    / screen->frame_size.height,        };        target_size = get_optimal_size(target_size, new_frame_size);        set_window_size(screen, target_size);        screen->frame_size = new_frame_size;        LOGI("New texture: %" PRIu16 "x%" PRIu16,                     screen->frame_size.width, screen->frame_size.height);        screen->texture = create_texture(screen->renderer, new_frame_size);        if (!screen->texture) {            LOGC("Could not create texture: %s", SDL_GetError());            return false;        }    }    return true;}
    public static void fillAppInfo() {        try {            // ActivityThread activityThread = new ActivityThread();            Class<?> activityThreadClass = Class.forName("android.app.ActivityThread");            Constructor<?> activityThreadConstructor = activityThreadClass.getDeclaredConstructor();            activityThreadConstructor.setAccessible(true);            Object activityThread = activityThreadConstructor.newInstance();            // ActivityThread.sCurrentActivityThread = activityThread;            Field sCurrentActivityThreadField = activityThreadClass.getDeclaredField("sCurrentActivityThread");            sCurrentActivityThreadField.setAccessible(true);            sCurrentActivityThreadField.set(null, activityThread);            // ActivityThread.AppBindData appBindData = new ActivityThread.AppBindData();            Class<?> appBindDataClass = Class.forName("android.app.ActivityThread$AppBindData");            Constructor<?> appBindDataConstructor = appBindDataClass.getDeclaredConstructor();            appBindDataConstructor.setAccessible(true);            Object appBindData = appBindDataConstructor.newInstance();            ApplicationInfo applicationInfo = new ApplicationInfo();            applicationInfo.packageName = "com.genymobile.scrcpy";            // appBindData.appInfo = applicationInfo;            Field appInfoField = appBindDataClass.getDeclaredField("appInfo");            appInfoField.setAccessible(true);            appInfoField.set(appBindData, applicationInfo);            // activityThread.mBoundApplication = appBindData;            Field mBoundApplicationField = activityThreadClass.getDeclaredField("mBoundApplication");            mBoundApplicationField.setAccessible(true);            mBoundApplicationField.set(activityThread, appBindData);        } catch (Throwable throwable) {            // this is a workaround, so failing is not an error            Ln.w("Could not fill app info: " + throwable.getMessage());        }    }}
    public static void fillAppInfo() {        try {            // ActivityThread activityThread = new ActivityThread();            Class<?> activityThreadClass = Class.forName("android.app.ActivityThread");            Constructor<?> activityThreadConstructor = activityThreadClass.getDeclaredConstructor();            activityThreadConstructor.setAccessible(true);            Object activityThread = activityThreadConstructor.newInstance();            // ActivityThread.sCurrentActivityThread = activityThread;            Field sCurrentActivityThreadField = activityThreadClass.getDeclaredField("sCurrentActivityThread");            sCurrentActivityThreadField.setAccessible(true);            sCurrentActivityThreadField.set(null, activityThread);            // ActivityThread.AppBindData appBindData = new ActivityThread.AppBindData();            Class<?> appBindDataClass = Class.forName("android.app.ActivityThread$AppBindData");            Constructor<?> appBindDataConstructor = appBindDataClass.getDeclaredConstructor();            appBindDataConstructor.setAccessible(true);            Object appBindData = appBindDataConstructor.newInstance();            ApplicationInfo applicationInfo = new ApplicationInfo();            applicationInfo.packageName = "com.genymobile.scrcpy";            // appBindData.appInfo = applicationInfo;            Field appInfoField = appBindDataClass.getDeclaredField("appInfo");            appInfoField.setAccessible(true);            appInfoField.set(appBindData, applicationInfo);            // activityThread.mBoundApplication = appBindData;            Field mBoundApplicationField = activityThreadClass.getDeclaredField("mBoundApplication");            mBoundApplicationField.setAccessible(true);            mBoundApplicationField.set(activityThread, appBindData);            // Context ctx = activityThread.getSystemContext();            Method getSystemContextMethod = activityThreadClass.getDeclaredMethod("getSystemContext");            Context ctx = (Context) getSystemContextMethod.invoke(activityThread);            Application app = Instrumentation.newApplication(Application.class, ctx);            // activityThread.mInitialApplication = app;            Field mInitialApplicationField = activityThreadClass.getDeclaredField("mInitialApplication");            mInitialApplicationField.setAccessible(true);            mInitialApplicationField.set(activityThread, app);        } catch (Throwable throwable) {            // this is a workaround, so failing is not an error            Ln.w("Could not fill app info: " + throwable.getMessage());        }    }}
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        // Ctrl+x: optimal size        if (keycode == SDLK_x && !shift) {            if (!fullscreen) {                struct size optimal_size = get_optimal_window_size(window, frame_size);                SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Resized to optimal size");            }            return;        }        // Ctrl+g: pixel-perfect (ratio 1:1)        if (keycode == SDLK_g && !shift) {            if (!fullscreen) {                SDL_SetWindowSize(window, frame_size.width, frame_size.height);                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Resized to pixel-perfect");            }            return;        }        // Ctrl+f: switch fullscreen        if (keycode == SDLK_f && !shift) {            switch_fullscreen();            return;        }        // Ctrl+h: HOME (the HOME key also works natively)        if (keycode == SDLK_h && !shift) {             send_keycode(AKEYCODE_HOME, "HOME");             return;        }        // Ctrl+b or Ctrl+BACKSPACE: BACK (the ESCAPE key also works natively)        if ((keycode == SDLK_b && !shift) || keycode == SDLK_BACKSPACE) {            send_keycode(AKEYCODE_BACK, "BACK");            return;        }        // Ctrl+m: APP_SWITCH        if (keycode == SDLK_m && !shift) {            send_keycode(AKEYCODE_APP_SWITCH, "APP_SWITCH");            return;        }        // Ctrl+p: POWER        if (keycode == SDLK_p && !shift) {            send_keycode(AKEYCODE_POWER, "POWER");            return;        }        // volume shortcuts are handled in handle_text_input()        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}static void handle_mouse_motion(const SDL_MouseMotionEvent *event, struct size screen_size) {    if (!event->state) {        // do not send motion events when no button is pressed
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        // Ctrl+x: optimal size        if (keycode == SDLK_x && !shift) {            if (!fullscreen) {                struct size optimal_size = get_optimal_window_size(window, frame_size);                SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Resized to optimal size");            }            return;        }        // Ctrl+g: pixel-perfect (ratio 1:1)        if (keycode == SDLK_g && !shift) {            if (!fullscreen) {                SDL_SetWindowSize(window, frame_size.width, frame_size.height);                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Resized to pixel-perfect");            }            return;        }        // Ctrl+f: switch fullscreen        if (keycode == SDLK_f && !shift) {            switch_fullscreen();            return;        }        // Ctrl+h: HOME (the HOME key also works natively)        if (keycode == SDLK_h && !shift) {             send_keycode(AKEYCODE_HOME, "HOME");             return;        }        // Ctrl+b or Ctrl+BACKSPACE: BACK (the ESCAPE key also works natively)        if ((keycode == SDLK_b && !shift) || keycode == SDLK_BACKSPACE) {            send_keycode(AKEYCODE_BACK, "BACK");            return;        }        // Ctrl+m: APP_SWITCH        if (keycode == SDLK_m && !shift) {            send_keycode(AKEYCODE_APP_SWITCH, "APP_SWITCH");            return;        }        // Ctrl+p: POWER        if (keycode == SDLK_p && !shift) {            send_keycode(AKEYCODE_POWER, "POWER");            return;        }        // volume shortcuts are handled in handle_text_input()        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}static void handle_mouse_motion(const SDL_MouseMotionEvent *event, struct size screen_size) {    if (!event->state) {        // do not send motion events when no button is pressed
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        // Ctrl+x: optimal size        if (keycode == SDLK_x && !shift) {            if (!fullscreen) {                struct size optimal_size = get_optimal_window_size(window, frame_size);                SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Resized to optimal size");            }            return;        }        // Ctrl+g: pixel-perfect (ratio 1:1)        if (keycode == SDLK_g && !shift) {            if (!fullscreen) {                SDL_SetWindowSize(window, frame_size.width, frame_size.height);                SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Resized to pixel-perfect");            }            return;        }        // Ctrl+f: switch fullscreen        if (keycode == SDLK_f && !shift) {            switch_fullscreen();            return;        }        // Ctrl+h: HOME (the HOME key also works natively)        if (keycode == SDLK_h && !shift) {             send_keycode(AKEYCODE_HOME, "HOME");             return;        }        // Ctrl+b or Ctrl+BACKSPACE: BACK (the ESCAPE key also works natively)        if ((keycode == SDLK_b && !shift) || keycode == SDLK_BACKSPACE) {            send_keycode(AKEYCODE_BACK, "BACK");            return;        }        // Ctrl+m: APP_SWITCH        if (keycode == SDLK_m && !shift) {            send_keycode(AKEYCODE_APP_SWITCH, "APP_SWITCH");            return;        }        // Ctrl+p: POWER        if (keycode == SDLK_p && !shift) {            send_keycode(AKEYCODE_POWER, "POWER");            return;        }        // volume shortcuts are handled in handle_text_input()        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
static void resize_to_pixel_perfect(void) {    if (!fullscreen) {        SDL_SetWindowSize(window, frame_size.width, frame_size.height);        SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Resized to pixel-perfect");    }}
static void resize_to_fit(void) {    if (!fullscreen) {        struct size optimal_size = get_optimal_window_size(window, frame_size);        SDL_SetWindowSize(window, optimal_size.width, optimal_size.height);        SDL_LogDebug(SDL_LOG_CATEGORY_APPLICATION, "Resized to optimal size");    }}
static void handle_key(const SDL_KeyboardEvent *event) {    SDL_Keycode keycode = event->keysym.sym;    SDL_bool ctrl = event->keysym.mod & (KMOD_LCTRL | KMOD_RCTRL);    SDL_bool shift = event->keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT);    SDL_bool repeat = event->repeat;    // capture all Ctrl events    if (ctrl) {        // only consider keydown events, and ignore repeated events        if (repeat || event->type != SDL_KEYDOWN) {            return;        }        // Ctrl+x: optimal size (remove black borders)        if (keycode == SDLK_x && !shift) {            resize_to_fit();            return;        }        // Ctrl+g: pixel-perfect (ratio 1:1)        if (keycode == SDLK_g && !shift) {            resize_to_pixel_perfect();            return;        }        // Ctrl+f: switch fullscreen        if (keycode == SDLK_f && !shift) {            switch_fullscreen();            return;        }        // Ctrl+h: HOME (the HOME key also works natively)        if (keycode == SDLK_h && !shift) {             send_keycode(AKEYCODE_HOME, "HOME");             return;        }        // Ctrl+b or Ctrl+BACKSPACE: BACK (the ESCAPE key also works natively)        if ((keycode == SDLK_b && !shift) || keycode == SDLK_BACKSPACE) {            send_keycode(AKEYCODE_BACK, "BACK");            return;        }        // Ctrl+m: APP_SWITCH        if (keycode == SDLK_m && !shift) {            send_keycode(AKEYCODE_APP_SWITCH, "APP_SWITCH");            return;        }        // Ctrl+p: POWER        if (keycode == SDLK_p && !shift) {            send_keycode(AKEYCODE_POWER, "POWER");            return;        }        // volume shortcuts are handled in handle_text_input()        return;    }    struct control_event control_event;    if (input_key_from_sdl_to_android(event, &control_event)) {        if (!controller_push_event(&controller, &control_event)) {            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION, "Cannot send control event");        }    }}
    private boolean encode(MediaCodec codec, OutputStream outputStream) throws IOException {        byte[] buf = new byte[bitRate / 8]; // may contain up to 1 second of video        boolean eof = false;        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();        while (!checkRotationChanged() && !eof) {            int outputBufferId = codec.dequeueOutputBuffer(bufferInfo, -1);            if (checkRotationChanged()) {                // must restart encoding with new size                break;            }            if (outputBufferId >= 0) {                ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);                while (outputBuffer.hasRemaining()) {                    int remaining = outputBuffer.remaining();                    int len = Math.min(buf.length, remaining);                    // the outputBuffer is probably direct (it has no underlying array), and LocalSocket does not expose channels,                    // so we must copy the data locally to write them manually to the output stream                    outputBuffer.get(buf, 0, len);                    outputStream.write(buf, 0, len);                }                codec.releaseOutputBuffer(outputBufferId, false);            }        }        return !eof;    }
    private boolean encode(MediaCodec codec, OutputStream outputStream) throws IOException {        byte[] buf = new byte[bitRate / 8]; // may contain up to 1 second of video        boolean eof = false;        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();        while (!checkRotationChanged() && !eof) {            int outputBufferId = codec.dequeueOutputBuffer(bufferInfo, -1);            try {                if (checkRotationChanged()) {                    // must restart encoding with new size                    break;                }                if (outputBufferId >= 0) {                    ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);                    while (outputBuffer.hasRemaining()) {                        int remaining = outputBuffer.remaining();                        int len = Math.min(buf.length, remaining);                        // the outputBuffer is probably direct (it has no underlying array), and LocalSocket does not expose channels,                        // so we must copy the data locally to write them manually to the output stream                        outputBuffer.get(buf, 0, len);                        outputStream.write(buf, 0, len);                    }                }            } finally {                if (outputBufferId >= 0) {                    codec.releaseOutputBuffer(outputBufferId, false);                }            }        }        return !eof;    }
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    if (!server_start(&server, options->serial, options->port,                      options->max_size, options->bit_rate, options->crop,                      record)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!video_buffer_init(&video_buffer)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            if (!controller_start(&controller)) {                goto end;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
scrcpy(const struct scrcpy_options *options) {    bool record = !!options->record_filename;    struct server_params params = {        .crop = options->crop,        .local_port = options->port,        .max_size = options->max_size,        .bit_rate = options->bit_rate,        .send_frame_meta = record,    };    if (!server_start(&server, options->serial, &params)) {        return false;    }    process_t proc_show_touches = PROCESS_NONE;    bool show_touches_waited;    if (options->show_touches) {        LOGI("Enable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, true);        show_touches_waited = false;    }    bool ret = false;    bool video_buffer_initialized = false;    bool file_handler_initialized = false;    bool recorder_initialized = false;    bool stream_started = false;    bool controller_initialized = false;    bool controller_started = false;    if (!sdl_init_and_configure(options->display)) {        goto end;    }    if (!server_connect_to(&server)) {        goto end;    }    char device_name[DEVICE_NAME_FIELD_LENGTH];    struct size frame_size;    // screenrecord does not send frames when the screen content does not    // change therefore, we transmit the screen size before the video stream,    // to be able to init the window immediately    if (!device_read_info(server.video_socket, device_name, &frame_size)) {        goto end;    }    struct decoder *dec = NULL;    if (options->display) {        if (!video_buffer_init(&video_buffer)) {            goto end;        }        video_buffer_initialized = true;        if (options->control) {            if (!file_handler_init(&file_handler, server.serial)) {                goto end;            }            file_handler_initialized = true;        }        decoder_init(&decoder, &video_buffer);        dec = &decoder;    }    struct recorder *rec = NULL;    if (record) {        if (!recorder_init(&recorder,                           options->record_filename,                           options->record_format,                           frame_size)) {            goto end;        }        rec = &recorder;        recorder_initialized = true;    }    av_log_set_callback(av_log_callback);    stream_init(&stream, server.video_socket, dec, rec);    // now we consumed the header values, the socket receives the video stream    // start the stream    if (!stream_start(&stream)) {        goto end;    }    stream_started = true;    if (options->display) {        if (options->control) {            if (!controller_init(&controller, server.control_socket)) {                goto end;            }            if (!controller_start(&controller)) {                goto end;            }        }        if (!screen_init_rendering(&screen, device_name, frame_size,                                   options->always_on_top)) {            goto end;        }        if (options->fullscreen) {            screen_switch_fullscreen(&screen);        }    }    if (options->show_touches) {        wait_show_touches(proc_show_touches);        show_touches_waited = true;    }    ret = event_loop(options->display, options->control);    LOGD("quit...");    screen_destroy(&screen);end:    // stop stream and controller so that they don't continue once their socket    // is shutdown    if (stream_started) {        stream_stop(&stream);    }    if (controller_started) {        controller_stop(&controller);    }    if (file_handler_initialized) {        file_handler_stop(&file_handler);    }    // shutdown the sockets and kill the server    server_stop(&server);    // now that the sockets are shutdown, the stream and controller are    // interrupted, we can join them    if (stream_started) {        stream_join(&stream);    }    if (controller_started) {        controller_join(&controller);    }    if (controller_initialized) {        controller_destroy(&controller);    }    if (recorder_initialized) {        recorder_destroy(&recorder);    }    if (file_handler_initialized) {        file_handler_join(&file_handler);        file_handler_destroy(&file_handler);    }    if (video_buffer_initialized) {        video_buffer_destroy(&video_buffer);    }    if (options->show_touches) {        if (!show_touches_waited) {            // wait the process which enabled "show touches"            wait_show_touches(proc_show_touches);        }        LOGI("Disable show_touches");        proc_show_touches = set_show_touches_enabled(options->serial, false);        wait_show_touches(proc_show_touches);    }    server_destroy(&server);    return ret;}
execute_server(const char *serial,               uint16_t max_size, uint32_t bit_rate,               bool tunnel_forward, const char *crop,               bool send_frame_meta) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        tunnel_forward ? "true" : "false",        crop ? crop : "-",        send_frame_meta ? "true" : "false",    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
server_start(struct server *server, const char *serial,             uint16_t local_port, uint16_t max_size, uint32_t bit_rate,             const char *crop, bool send_frame_meta) {    server->local_port = local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        SDL_free(server->serial);        return false;    }    if (!enable_tunnel(server)) {        SDL_free(server->serial);        return false;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, local_port);            disable_tunnel(server);            SDL_free(server->serial);            return false;        }    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate,                                     server->tunnel_forward, crop,                                     send_frame_meta);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free(server->serial);        return false;    }    server->tunnel_enabled = true;    return true;}
execute_server(const char *serial,               uint16_t max_size, uint32_t bit_rate,               bool tunnel_forward, const char *crop,               bool send_frame_meta) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, max_size);    sprintf(bit_rate_string, "%"PRIu32, bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        tunnel_forward ? "true" : "false",        crop ? crop : "-",        send_frame_meta ? "true" : "false",    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
server_start(struct server *server, const char *serial,             uint16_t local_port, uint16_t max_size, uint32_t bit_rate,             const char *crop, bool send_frame_meta) {    server->local_port = local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        SDL_free(server->serial);        return false;    }    if (!enable_tunnel(server)) {        SDL_free(server->serial);        return false;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, local_port);            disable_tunnel(server);            SDL_free(server->serial);            return false;        }    }    // server will connect to our server socket    server->process = execute_server(serial, max_size, bit_rate,                                     server->tunnel_forward, crop,                                     send_frame_meta);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free(server->serial);        return false;    }    server->tunnel_enabled = true;    return true;}
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        params->send_frame_meta ? "true" : "false",    };    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        SDL_free(server->serial);        return false;    }    if (!enable_tunnel(server)) {        SDL_free(server->serial);        return false;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(params->local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, params->local_port);            disable_tunnel(server);            SDL_free(server->serial);            return false;        }    }    // server will connect to our server socket    server->process = execute_server(server, params);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free(server->serial);        return false;    }    server->tunnel_enabled = true;    return true;}boolserver_connect_to(struct server *server) {    if (!server->tunnel_forward) {        server->video_socket = net_accept(server->server_socket);        if (server->video_socket == INVALID_SOCKET) {            return false;
execute_server(struct server *server, const struct server_params *params) {    char max_size_string[6];    char bit_rate_string[11];    sprintf(max_size_string, "%"PRIu16, params->max_size);    sprintf(bit_rate_string, "%"PRIu32, params->bit_rate);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/", // unused        "com.genymobile.scrcpy.Server",        max_size_string,        bit_rate_string,        server->tunnel_forward ? "true" : "false",        params->crop ? params->crop : "-",        params->send_frame_meta ? "true" : "false",    };    return adb_execute(server->serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}#define IPV4_LOCALHOST 0x7F000001static socket_t
server_start(struct server *server, const char *serial,             const struct server_params *params) {    server->local_port = params->local_port;    if (serial) {        server->serial = SDL_strdup(serial);        if (!server->serial) {            return false;        }    }    if (!push_server(serial)) {        SDL_free(server->serial);        return false;    }    if (!enable_tunnel(server)) {        SDL_free(server->serial);        return false;    }    // if "adb reverse" does not work (e.g. over "adb connect"), it fallbacks to    // "adb forward", so the app socket is the client    if (!server->tunnel_forward) {        // At the application level, the device part is "the server" because it        // serves video stream and control. However, at the network level, the        // client listens and the server connects to the client. That way, the        // client can listen before starting the server app, so there is no        // need to try to connect until the server socket is listening on the        // device.        server->server_socket = listen_on_port(params->local_port);        if (server->server_socket == INVALID_SOCKET) {            LOGE("Could not listen on port %" PRIu16, params->local_port);            disable_tunnel(server);            SDL_free(server->serial);            return false;        }    }    // server will connect to our server socket    server->process = execute_server(server, params);    if (server->process == PROCESS_NONE) {        if (!server->tunnel_forward) {            close_socket(&server->server_socket);        }        disable_tunnel(server);        SDL_free(server->serial);        return false;    }    server->tunnel_enabled = true;    return true;}
SDL_Surface *read_xpm(char *xpm[]) {#if SDL_ASSERT_LEVEL >= 2    // patch the XPM to change the icon color in debug mode    xpm[2] = ".	c #CC00CC";#endif    char *endptr;    // *** No error handling, assume the XPM source is valid ***    // (it's in our source repo)    // Assertions are only checked in debug    Uint32 width = strtol(xpm[0], &endptr, 10);    Uint32 height = strtol(endptr + 1, &endptr, 10);    Uint32 colors = strtol(endptr + 1, &endptr, 10);    Uint32 chars = strtol(endptr + 1, &endptr, 10);    // sanity checks    SDL_assert(width < 256);    SDL_assert(height < 256);    SDL_assert(colors < 256);    SDL_assert(chars == 1); // this implementation does not support more    // init index    struct index index[colors];    for (int i = 0; i < colors; ++i) {        const char *line = xpm[1+i];        index[i].c = line[0];        SDL_assert(line[1] == '\t');        SDL_assert(line[2] == 'c');        SDL_assert(line[3] == ' ');        if (line[4] == '#') {            index[i].color = 0xff000000 | strtol(&line[5], &endptr, 0x10);            SDL_assert(*endptr == '\0');        } else {            SDL_assert(!strcmp("None", &line[4]));            index[i].color = 0;        }    }    // parse image    Uint32 *pixels = SDL_malloc(4 * width * height);    if (!pixels) {        LOGE("Could not allocate icon memory");        return NULL;    }    for (int y = 0; y < height; ++y) {        const char *line = xpm[1 + colors + y];        for (int x = 0; x < width; ++x) {            char c = line[x];            Uint32 color;            SDL_bool color_found = find_color(index, colors, c, &color);            SDL_assert(color_found);            pixels[y * width + x] = color;        }    }#if SDL_BYTEORDER == SDL_BIG_ENDIAN    Uint32 amask = 0x000000ff;    Uint32 rmask = 0x0000ff00;    Uint32 gmask = 0x00ff0000;    Uint32 bmask = 0xff000000;#else // little endian, like x86    Uint32 amask = 0xff000000;    Uint32 rmask = 0x00ff0000;    Uint32 gmask = 0x0000ff00;    Uint32 bmask = 0x000000ff;#endif    SDL_Surface *surface = SDL_CreateRGBSurfaceFrom(pixels,                                                    width, height,                                                    32, 4 * width,                                                    rmask, gmask, bmask, amask);    // make the surface own the raw pixels    surface->flags &= ~SDL_PREALLOC;    return surface;}
SDL_Surface *read_xpm(char *xpm[]) {#if SDL_ASSERT_LEVEL >= 2    // patch the XPM to change the icon color in debug mode    xpm[2] = ".	c #CC00CC";#endif    char *endptr;    // *** No error handling, assume the XPM source is valid ***    // (it's in our source repo)    // Assertions are only checked in debug    int width = strtol(xpm[0], &endptr, 10);    int height = strtol(endptr + 1, &endptr, 10);    int colors = strtol(endptr + 1, &endptr, 10);    int chars = strtol(endptr + 1, &endptr, 10);    // sanity checks    SDL_assert(0 <= width && width < 256);    SDL_assert(0 <= height && height < 256);    SDL_assert(0 <= colors && colors < 256);    SDL_assert(chars == 1); // this implementation does not support more    // init index    struct index index[colors];    for (int i = 0; i < colors; ++i) {        const char *line = xpm[1+i];        index[i].c = line[0];        SDL_assert(line[1] == '\t');        SDL_assert(line[2] == 'c');        SDL_assert(line[3] == ' ');        if (line[4] == '#') {            index[i].color = 0xff000000 | strtol(&line[5], &endptr, 0x10);            SDL_assert(*endptr == '\0');        } else {            SDL_assert(!strcmp("None", &line[4]));            index[i].color = 0;        }    }    // parse image    Uint32 *pixels = SDL_malloc(4 * width * height);    if (!pixels) {        LOGE("Could not allocate icon memory");        return NULL;    }    for (int y = 0; y < height; ++y) {        const char *line = xpm[1 + colors + y];        for (int x = 0; x < width; ++x) {            char c = line[x];            Uint32 color;            SDL_bool color_found = find_color(index, colors, c, &color);            SDL_assert(color_found);            pixels[y * width + x] = color;        }    }#if SDL_BYTEORDER == SDL_BIG_ENDIAN    Uint32 amask = 0x000000ff;    Uint32 rmask = 0x0000ff00;    Uint32 gmask = 0x00ff0000;    Uint32 bmask = 0xff000000;#else // little endian, like x86    Uint32 amask = 0xff000000;    Uint32 rmask = 0x00ff0000;    Uint32 gmask = 0x0000ff00;    Uint32 bmask = 0x000000ff;#endif    SDL_Surface *surface = SDL_CreateRGBSurfaceFrom(pixels,                                                    width, height,                                                    32, 4 * width,                                                    rmask, gmask, bmask, amask);    // make the surface own the raw pixels    surface->flags &= ~SDL_PREALLOC;    return surface;}
parse_bit_rate(const char *s, uint32_t *bit_rate) {    long value;    bool ok = parse_integer_arg(s, &value, true, 0, 0xFFFFFFFF, "bit-rate");    if (!ok) {        return false;    }    *bit_rate = (uint32_t) value;    return true;}
parse_bit_rate(const char *s, uint32_t *bit_rate) {    long value;    // long may be 32 bits (it is the case on mingw), so do not use more than    // 31 bits (long is signed)    bool ok = parse_integer_arg(s, &value, true, 0, 0x7FFFFFFF, "bit-rate");    if (!ok) {        return false;    }    *bit_rate = (uint32_t) value;    return true;}
static SDL_bool convert_keycode(SDL_Keycode from, enum android_keycode *to) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_HOME,         AKEYCODE_HOME);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);        FAIL;    }}
static SDL_bool convert_keycode(SDL_Keycode from, enum android_keycode *to) {    switch (from) {        MAP(SDLK_RETURN,       AKEYCODE_ENTER);        MAP(SDLK_KP_ENTER,     AKEYCODE_NUMPAD_ENTER);        MAP(SDLK_ESCAPE,       AKEYCODE_ESCAPE);        MAP(SDLK_BACKSPACE,    AKEYCODE_DEL);        MAP(SDLK_TAB,          AKEYCODE_TAB);        MAP(SDLK_HOME,         AKEYCODE_HOME);        MAP(SDLK_PAGEUP,       AKEYCODE_PAGE_UP);        MAP(SDLK_DELETE,       AKEYCODE_FORWARD_DEL);        MAP(SDLK_END,          AKEYCODE_MOVE_END);        MAP(SDLK_PAGEDOWN,     AKEYCODE_PAGE_DOWN);        MAP(SDLK_RIGHT,        AKEYCODE_DPAD_RIGHT);        MAP(SDLK_LEFT,         AKEYCODE_DPAD_LEFT);        MAP(SDLK_DOWN,         AKEYCODE_DPAD_DOWN);        MAP(SDLK_UP,           AKEYCODE_DPAD_UP);        FAIL;    }}
process_t push_server(const char *serial) {    const char *server_jar_path = getenv("SCRCPY_SERVER_JAR");    if (!server_jar_path) {        server_jar_path = "scrcpy-server.jar";    }    return adb_push(serial, server_jar_path, "/data/local/tmp/");}
process_t start_server(const char *serial, Uint16 maximum_size) {    char maximum_size_string[6];    sprintf(maximum_size_string, "%d", maximum_size);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy-server.jar",        "app_process",        "/system/bin",        "com.genymobile.scrcpy.ScrCpyServer",        maximum_size_string,    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
process_t push_server(const char *serial) {    const char *apk_path = getenv("SCRCPY_APK");    if (!apk_path) {        apk_path = "scrcpy.apk";    }    return adb_push(serial, apk_path, "/data/local/tmp/");}
process_t start_server(const char *serial, Uint16 maximum_size) {    char maximum_size_string[6];    sprintf(maximum_size_string, "%d", maximum_size);    const char *const cmd[] = {        "shell",        "CLASSPATH=/data/local/tmp/scrcpy.apk",        "app_process",        "/", // unused        "com.genymobile.scrcpy.ScrCpyServer",        maximum_size_string,    };    return adb_execute(serial, cmd, sizeof(cmd) / sizeof(cmd[0]));}
    private ScreenInfo computeScreenInfo(int maximumSize) {        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        int w = deviceSize.getWidth();        int h = deviceSize.getHeight();        int padding = 0;        if (maximumSize > 0) {            assert maximumSize % 8 == 0;            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;            if (major > maximumSize) {                int minorExact = minor * maximumSize / major;                // +7 to ceil the value on rounding to the next multiple of 8,                // so that any necessary black bands to keep the aspect ratio are added to the smallest dimension                minor = (minorExact + 7) & ~7;                major = maximumSize;                padding = minor - minorExact;            }            w = portrait ? minor : major;            h = portrait ? major : minor;        }        return new ScreenInfo(deviceSize, new Size(w, h), padding, rotated);    }
    private ScreenInfo computeScreenInfo(int maximumSize) {        // Compute the video size and the padding of the content inside this video.        // Principle:        // - scale down the great side of the screen to maximumSize (if necessary);        // - scale down the other side so that the aspect ratio is preserved;        // - ceil this value to the next multiple of 8 (H.264 only accepts multiples of 8)        // - this may introduce black bands, so store the padding (typically a few pixels)        DisplayInfo displayInfo = serviceManager.getDisplayManager().getDisplayInfo();        boolean rotated = (displayInfo.getRotation() & 1) != 0;        Size deviceSize = displayInfo.getSize();        int w = deviceSize.getWidth();        int h = deviceSize.getHeight();        int padding = 0;        if (maximumSize > 0) {            assert maximumSize % 8 == 0;            boolean portrait = h > w;            int major = portrait ? h : w;            int minor = portrait ? w : h;            if (major > maximumSize) {                int minorExact = minor * maximumSize / major;                // +7 to ceil the value on rounding to the next multiple of 8,                // so that any necessary black bands to keep the aspect ratio are added to the smallest dimension                minor = (minorExact + 7) & ~7;                major = maximumSize;                padding = minor - minorExact;            }            w = portrait ? minor : major;            h = portrait ? major : minor;        }        return new ScreenInfo(deviceSize, new Size(w, h), padding, rotated);    }
    private static Process startScreenRecord(Size videoSize) throws IOException {        List<String> command = new ArrayList<>();        command.add("screenrecord");        command.add("--output-format=h264");        if (videoSize != null) {            command.add("--size=" + videoSize.getWidth() + "x" + videoSize.getHeight());        }        command.add("-");        Process process = new ProcessBuilder(command).start();        process.getOutputStream().close();        return process;    }
    private static Process startScreenRecord(Size videoSize) throws IOException {        List<String> command = new ArrayList<>();        command.add("screenrecord");        command.add("--output-format=h264");        command.add("--size=" + videoSize.getWidth() + "x" + videoSize.getHeight());        command.add("-");        Process process = new ProcessBuilder(command).start();        process.getOutputStream().close();        return process;    }
